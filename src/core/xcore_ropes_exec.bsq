namespace Core;

namespace CCharBufferOps {
    function s_create_empty(): CCharBuffer = ccharbuffer_create_empty;
    function s_create_1(c1: CChar): CCharBuffer = ccharbuffer_create_1;
    function s_create_2(c1: CChar, c2: CChar): CCharBuffer = ccharbuffer_create_2;
    function s_create_3(c1: CChar, c2: CChar, c3: CChar): CCharBuffer = ccharbuffer_create_3;
    function s_create_4(c1: CChar, c2: CChar, c3: CChar, c4: CChar): CCharBuffer = ccharbuffer_create_4;
    function s_create_5(c1: CChar, c2: CChar, c3: CChar, c4: CChar, c5: CChar): CCharBuffer = ccharbuffer_create_5;
    function s_create_6(c1: CChar, c2: CChar, c3: CChar, c4: CChar, c5: CChar, c6: CChar): CCharBuffer = ccharbuffer_create_6;
    function s_create_7(c1: CChar, c2: CChar, c3: CChar, c4: CChar, c5: CChar, c6: CChar, c7: CChar): CCharBuffer = ccharbuffer_create_7;
    function s_create_8(c1: CChar, c2: CChar, c3: CChar, c4: CChar, c5: CChar, c6: CChar, c7: CChar, c8: CChar): CCharBuffer = ccharbuffer_create_8;
}

__internal entity CCharBuffer {
}

#if CPP_CORE
namespace CRopeOps {
    function s_crope_create(buf: CCharBuffer): CRope {
        return XCore::s_createDirect<Rope, CRope>(Rope::createLeaf(buf));
    }

    datatype Rope of 
        BBLeaf { }
        | Leaf{ buffer: CCharBuffer }
        | Node { weight: Nat, l: Rope, r: Rope }
    & {
        function createLeaf(buf: CCharBuffer): Leaf {
            return Leaf{ buf };
        }

        function createNode(w: Nat, l: Rope, r: Rope): Node {
            return Node{ w, l, r };
        }

        %%
        %% TODO: need an append method
        %%

    }
} %% namespace CRopeOps

namespace UnicodeRopeOps {

} %% namespace UnicodeRopeOps
#else
#endif %% CPP_CORE