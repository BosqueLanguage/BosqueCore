namespace Core;

__internal entity UnicodeCharBuffer {
    method size(): Nat {
        return UnicodeCharBufferOps::size(this);
    }
}

namespace UnicodeCharBufferOps {
    function size(ub: UnicodeCharBuffer): Nat = unicodecharbuffer_size;
    function getMaxSize(): Nat = unicodecharbuffer_maxsize;
    function equal(ub1: UnicodeCharBuffer, ub2: UnicodeCharBuffer): Bool = unicodecharbuffer_equal;
    function mergeUnicodeBuffers(ub1: UnicodeCharBuffer, ub2: UnicodeCharBuffer): UnicodeCharBuffer = unicodecharbuffer_merge;
    function remainder(ub: UnicodeCharBuffer, split: Nat): UnicodeCharBuffer = unicodecharbuffer_remainder;

    function mergeUnicodeBuffers2(ub1: UnicodeCharBuffer, ub2: UnicodeCharBuffer): (|UnicodeCharBuffer, UnicodeCharBuffer|) {
        let ub1size = getMaxSize() - ub1.size();
        
        let nub1 = mergeUnicodeBuffers(ub1, ub2);
        let nub2 = remainder(ub2, ub1size);

        return (|nub1, nub2|);
    }

    function s_create_empty(): UnicodeCharBuffer = unicodecharbuffer_create_empty;
    function s_create_1(c1: UnicodeChar): UnicodeCharBuffer = unicodecharbuffer_create_1;
    function s_create_2(c1: UnicodeChar, c2: UnicodeChar): UnicodeCharBuffer = unicodecharbuffer_create_2;
    function s_create_3(c1: UnicodeChar, c2: UnicodeChar, c3: UnicodeChar): UnicodeCharBuffer = unicodecharbuffer_create_3;
    function s_create_4(c1: UnicodeChar, c2: UnicodeChar, c3: UnicodeChar, c4: UnicodeChar): UnicodeCharBuffer = unicodecharbuffer_create_4;
    function s_create_5(c1: UnicodeChar, c2: UnicodeChar, c3: UnicodeChar, c4: UnicodeChar, c5: UnicodeChar): UnicodeCharBuffer = unicodecharbuffer_create_5;
    function s_create_6(c1: UnicodeChar, c2: UnicodeChar, c3: UnicodeChar, c4: UnicodeChar, c5: UnicodeChar, c6: UnicodeChar): UnicodeCharBuffer = unicodecharbuffer_create_6;
    function s_create_7(c1: UnicodeChar, c2: UnicodeChar, c3: UnicodeChar, c4: UnicodeChar, c5: UnicodeChar, c6: UnicodeChar, c7: UnicodeChar): UnicodeCharBuffer = unicodecharbuffer_create_7;
    function s_create_8(c1: UnicodeChar, c2: UnicodeChar, c3: UnicodeChar, c4: UnicodeChar, c5: UnicodeChar, c6: UnicodeChar, c7: UnicodeChar, c8: UnicodeChar): UnicodeCharBuffer = unicodecharbuffer_create_8;
}

#if CPP_CORE
namespace UnicodeRopeOps {
    function s_unicoderope_create(buf: UnicodeCharBuffer): UnicodeRope {        
        return XCore::s_createDirect<Rope, UnicodeRope>(Rope::createLeaf(buf));       
    }

    function s_unicoderope_append(r: UnicodeRope, buf: UnicodeCharBuffer): UnicodeRope {
        return XCore::s_createDirect<Rope, UnicodeRope>(append(r.value, buf));
    }

    function s_unicoderope_empty(ur: UnicodeRope): Bool {
        return ur.value?<BBLeaf>;
    }

    function s_unicoderope_concat2(ur1: UnicodeRope, ur2: UnicodeRope): UnicodeRope {
        if(s_unicoderope_empty(ur1)) {
            return ur2;
        }
        elif(s_unicoderope_empty(ur2)) {
            return ur1;
        }
        else {
            return XCore::s_createDirect<Rope, UnicodeRope>(concat(ur1.value, ur2.value));
        }
    }

    function s_unicoderope_equal(ur1: UnicodeRope, ur2: UnicodeRope): Bool {
        return equal(ur1.value, ur2.value);
    }

    enum Color {
        Red,
        Black,
        BB,
        NB
    }

    function blacken(c: Color): Color {
        assert c !== Color#BB;

        switch(c) {
            | Color#Black => { return Color#BB; }
            | Color#Red => { return Color#Black; }
            | _         => { return Color#Red; }
        }
    }

    function redden(c: Color): Color {
        assert c !== Color#NB;

        switch(c) {
            | Color#BB      => { return Color#Black; }
            | Color#Black => { return Color#Red; }
            | _           => { return Color#NB; }
        }
    }

    recursive function checkRBChildColorInvariant(t: Rope): Bool {
        if(t)@@!<Node> {
            return true;
        }

        if(t.c === Color#Red) {
            let islred = if(t.l)@<Node> then $_.c === Color#Red  else false;
            let isrred = if(t.r)@<Node> then $_.c === Color#Red  else false;

            return !(islred || isrred);
        }
        
        return checkRBChildColorInvariant[recursive](t.l) && checkRBChildColorInvariant[recursive](t.r);
    }

    recursive function checkRBPathLengthInvariant(t: Rope): Int {
        if(t)@@!<Node> {
            return 0i;
        }

        let lc = checkRBPathLengthInvariant[recursive](t.l);
        if(lc == -1i) {
            return -1i;
        }

        let rc = checkRBPathLengthInvariant[recursive](t.r);
        if(rc == -1i) {
            return -1i;
        }

        if(lc != rc) {
            return -1i; %% we have a black height mismatch return sentinel value
        }

        return if(t.c === Color#Black) then lc + 1i else lc;
    }

    function checkRBInvariants(t: Rope): Bool {
       return checkRBChildColorInvariant(t) && checkRBPathLengthInvariant(t) >= 0i;
    }

    %% Case where we have a double red violation on LL side -- tleft = Node{Red, _, Node{Red, _ a, b}, c}
    function balanceHelper_RR_LL(c: Color, tleft: Rope, tright: Rope): Option<Node> {
        if(c !== Color#Black && c !== Color#BB) {
            return none;
        }

        if (tleft)@@!<Node> {
            return none;
        }

        let lleft = tleft.l;
        if(lleft)@@!<Node> {
            return none;
        }

        if(tleft.c !== Color#Red || lleft.c !== Color#Red) {
            return none;
        }

        let nl = Rope::createNode(Color#Black, lleft.l, lleft.r);
        let nr = Rope::createNode(Color#Black, tleft.r, tright);
        return some(Rope::createNode(redden(c), nl, nr));
    }

    %% Case where we have a double red violation on LR side -- tleft = Node{Red, _, a, Node{Red, _, b, c}}
    function balanceHelper_RR_LR(c: Color, tleft: Rope, tright: Rope): Option<Node> {
        if(c !== Color#Black && c !== Color#BB) {
            return none;
        }

        if (tleft)@@!<Node> {
            return none;
        }

        let lright = tleft.r;
        if(lright)@@!<Node> {
            return none;
        }

        if(tleft.c !== Color#Red || lright.c !== Color#Red) {
            return none;
        }

        let nl = Rope::createNode(Color#Black, tleft.l, lright.l);
        let nr = Rope::createNode(Color#Black, lright.r, tright);
        return some(Rope::createNode(redden(c), nl, nr));
    }

    %% Case where we have a double red violation on RL side -- tright = Node{Red, _, Node{Red, _, b, c}, d}
    function balanceHelper_RR_RL(c: Color, tleft: Rope, tright: Rope): Option<Node> {
        if(c !== Color#Black && c !== Color#BB) {
            return none;
        }

        if (tright)@@!<Node> {
            return none;
        }

        let rleft = tright.l;
        if(rleft)@@!<Node> {
            return none;
        }

        if(tright.c !== Color#Red || rleft.c !== Color#Red) {
            return none;
        }

        let nl = Rope::createNode(Color#Black, tleft, rleft.l);
        let nr = Rope::createNode(Color#Black, rleft.r, tright.r);
        return some(Rope::createNode(redden(c), nl, nr));
    }

    %% Case where we have a double red violation on RR side -- tright = Node{Red, _, b, Node{Red, _, c, d}}
    function balanceHelper_RR_RR(c: Color, tleft: Rope, tright: Rope): Option<Node> {
        if(c !== Color#Black && c !== Color#BB) {
            return none;
        }

        if (tright)@@!<Node> {
            return none;
        }

        let rright = tright.r;
        if(rright)@@!<Node> {
            return none;
        }

        if(tright.c !== Color#Red || rright.c !== Color#Red) {
            return none;
        }

        let nl = Rope::createNode(Color#Black, tleft, tright.l);
        let nr = Rope::createNode(Color#Black, rright.l, rright.r);
        return some(Rope::createNode(redden(c), nl, nr));
    }
    
    %% Case where we have negative blacks on L side -- tleft = Node{NB, _, Node{Black, _, a, b}, Node{Black, _, c, d}}
    recursive function balanceHelper_DB_L(c: Color, tleft: Rope, tright: Rope): Option<Node> {
        if(c !== Color#BB) {
            return none;
        }

        if (tleft)@@!<Node> {
            return none;
        }

        if(tleft.c !== Color#NB) {
            return none;
        }

        let lleft = tleft.l;
        if(lleft)@@!<Node> {
            return none;
        }

        let lright = tleft.r;
        if(lright)@@!<Node> {
            return none;
        }

        if(lleft.c !== Color#Black || lright.c !== Color#Black) {
            return none;
        }

        let nl = balance[recursive](Color#Black, Rope::createNode(Color#Red, lleft.l, lleft.r), lright.l);
        let nr = Rope::createNode(Color#Black, lright.r, tright);
        return some(Rope::createNode(Color#Black, nl, nr));
    }

    %% Case where we have negative blacks on R side -- tright = Node{NB, _, Node{Black, _, b, c}, Node{Black, _, d, e}}}
    recursive function balanceHelper_DB_R(c: Color, tleft: Rope, tright: Rope): Option<Node> {
        if(c !== Color#BB) {
            return none;
        }

        if (tright)@@!<Node> {
            return none;
        }

        if(tright.c !== Color#NB) {
            return none;
        }

        let rleft = tright.l;
        if(rleft)@@!<Node> {
            return none;
        }

        let rright = tright.r;
        if(rright)@@!<Node> {
            return none;
        }

        if(rleft.c !== Color#Black || rright.c !== Color#Black) {
            return none;
        }

        let nl = Rope::createNode(Color#Black, tleft, rleft.l);
        let nr = balance[recursive](Color#Black, rleft.r, Rope::createNode(Color#Red, rright.l, rright.r));
        return some(Rope::createNode(Color#Black, nl, nr));
    }

    recursive function balance(c: Color, tleft: Rope, tright: Rope): Rope {
        let doubleRedLL = balanceHelper_RR_LL(c, tleft, tright);
        if(doubleRedLL)@!none {
            return $doubleRedLL;
        }

        let doubleRedLR = balanceHelper_RR_LR(c, tleft, tright);
        if(doubleRedLR)@!none {
            return $doubleRedLR;
        }

        let doubleRedRL = balanceHelper_RR_RL(c, tleft, tright);
        if(doubleRedRL)@!none {
            return $doubleRedRL;
        }

        let doubleRedRR = balanceHelper_RR_RR(c, tleft, tright);
        if(doubleRedRR)@!none {
            return $doubleRedRR;
        }

        let negBlackL = balanceHelper_DB_L(c, tleft, tright);
        if(negBlackL)@!none {
            return $negBlackL;
        }

        let negBlackR = balanceHelper_DB_R(c, tleft, tright);
        if(negBlackR)@!none {
            return $negBlackR;
        }

        return Rope::createNode(c, tleft, tright);
    }

    %% We keep track of the closest buffer (current nodes parents left child) for merging
    recursive function append_helper(t: Rope, l: Rope, v: UnicodeCharBuffer): Rope {
        match(t)@ {
            | Leaf => { 
                %% Merge all of v into t.buf
                if($t.buf.size() + v.size() <= UnicodeCharBufferOps::getMaxSize()) {
                    let merge = UnicodeCharBufferOps::mergeUnicodeBuffers($t.buf, v);
                    return Rope::createLeaf(merge);
                }

                %% Merge chars from v into t.buf until t.buf is full
                if($t.buf.size() < UnicodeCharBufferOps::getMaxSize()) {

                    %%
                    %% TODO: once multi assignment is supported for emission lets one line this
                    %%

                    let tmp = UnicodeCharBufferOps::mergeUnicodeBuffers2($t.buf, v);
                    let cb1 = tmp.0;
                    let cb2 = tmp.1;
                    return balance(Color#Red, Rope::createLeaf(cb1), Rope::createLeaf(cb2)); 
                }

                return balance(Color#Red, $t, Rope::createLeaf(v)); 
            }
            | Node => { 
                let nr = append_helper[recursive]($t.r, $t.l, v);
                return balance($t.c, $t.l, nr); 
            }
        }
    }

    function append(t: Rope, v: UnicodeCharBuffer): Rope {
        var tt: Rope;
        match(t)@ {
            | BBLeaf => { 
                tt = Rope::createLeaf(v); 
            }
            | Leaf => {
                tt = append_helper(t, t, v);
            }
            | Node => {
                tt = append_helper(t, $t.l, v);
            }
        }
        
        let nt = tt@<Node>;    
        let ntt = if(nt.c === Color#Red) 
            then Rope::createNode(Color#Black, nt.l, nt.r) 
            else nt;
    
        return ntt;
        
    }

    function concat(l: Rope, r: Rope): Rope {
        let nn = Rope::createNode(Color#Red, l, r);
        let tt = balance(nn.c, nn.l, nn.r);

        if(tt)@<Node> {
            let nt = if($tt.c === Color#Red) 
                then Rope::createNode(Color#Black, $tt.l, $tt.r) 
                else $tt;
            return nt;
        }
        else {
            return tt;
        }
    }    

    function equal(r1: Rope, r2: Rope): Bool {
        if(r1?<Leaf> && r2?<Leaf>) {
            let nr1 = r1@<Leaf>;
            let nr2 = r2@<Leaf>;

            return UnicodeCharBufferOps::equal(nr1.buf, nr2.buf);
        }

        if(r1?<Node> && r2?<Node>) {
            let nr1 = r1@<Node>;
            let nr2 = r2@<Node>;

            if(nr1.w != nr2.w) {
                return false;
            }

            return equal(nr1.l, nr2.l) && equal(nr1.r, nr2.r);
        }
    
        return false;
    }

    %%
    %% TODO: lexicographic less comparison! (see crope)
    %%

    datatype Rope of 
        | BBLeaf { }
        | Leaf { buf: UnicodeCharBuffer }
        | Node { c: Color, w: Nat, l: Rope, r: Rope }
    & {
        function createEmpty(): BBLeaf {
            return BBLeaf{ };
        }

        function createLeaf(buf: UnicodeCharBuffer): Leaf {
            return Leaf{ buf };
        }

        %% Weight is determined by the number of characters present in left sub-tree
        function createNode(c: Color, l: Rope, r: Rope): Node {
            return Node{ c, Rope::getCharacterCount(l), l, r };
        }

        function getCharacterCount(rope: Rope): Nat {
            match(rope)@ {
                | Leaf => {
                    return $rope.buf.size();
                }
                | Node => {
                    return Rope::getCharacterCount($rope.l) + Rope::getCharacterCount($rope.r);
                }
            }
        }
    }
} %% namespace UnicodeRopeOps
#else
#endif %% CPP_CORE