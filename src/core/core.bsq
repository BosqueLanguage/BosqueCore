%%The core namespace implements the primitive types used in the Bosque language
declare namespace Core;

%** Special type for indicating a value can be used as a key in a collection. **%
__internal __universal concept KeyType {
    function equal<T: unique KeyType>(a: T, b: T): Bool = special_method;
    function less<T: unique KeyType>(a: T, b: T): Bool = special_method;
}

%** Special type for representing values that can be compared with (<, >, ==, !=, <=, and >=) currently the numeric types and typedecls on them (later other with user def operators) **%
__internal __universal concept Comparable {
}

%** Special type for representing values that can be operated on with (-+, +, -) with standard unit-results currently the numeric types and typedecls on them (later other with user def operators) **%
__internal __universal concept LinearArithmetic {
}

%** Special type for representing numeric values **%
__internal __universal concept Numeric provides Comparable, LinearArithmetic {
}

%** Type for indicating that a datatype is a Validator. **%
__internal __universal concept RegexValidator {
    function accepts<T: unique RegexValidator>(s: String): Bool = special_method;
}

%** Type for indicating that a datatype is a Validator. **%
__internal __universal concept CRegexValidator {
    function accepts<T: unique CRegexValidator>(s: CString): Bool = special_method;
}

%** Type for indicating that a datatype is a Validator. **%
__internal __universal concept PathValidator {
}

%** Type for representing the option value. **%
__internal concept Option<T> {
}

%** Type for representing the none option value. **%
__internal entity None {
}

%** Type for representing the some option value. **%
__internal entity Some<T> provides Option<T> {
}

%** Primitive boolean value. **%
__internal __typedeclable entity Bool provides KeyType {
}

%** Primitive natural number value. **%
__internal __typedeclable entity Nat provides Numeric, KeyType {
}

%** Primitive integer value. **%
__internal __typedeclable entity Int provides Numeric, KeyType {
}

%** Primitive big-integer value. **%
__internal __typedeclable entity BigNat provides Numeric, KeyType {
}

%** Primitive big-integer value. **%
__internal __typedeclable entity BigInt provides Numeric, KeyType {
}

%** Primitive rational value. **%
__internal __typedeclable entity Rational provides Numeric {
}

%** Primitive float value. **%
__internal __typedeclable entity Float provides Numeric {
}

%** Primitive float decimal value. **%
__internal __typedeclable entity Decimal provides Numeric {
}

%** Primitive decimal degree value. **%
__internal __typedeclable entity DecimalDegree provides Numeric {
}

%** Primitive latitude/longitude value. **%
__internal __typedeclable entity LatLongCoordinate {
}

%** Primitive complex number value. **%
__internal __typedeclable entity Complex provides Numeric {
}

%** Primitive string value. **%
__internal __typedeclable entity String provides KeyType {
}

%** Primitive safe string value. **%
__internal __typedeclable entity StringOf<T: unique RegexValidator> provides KeyType {
    private function s_into(s: String): StringOf<T> = special_inject;
    %*
    function coerce(s: String): StringOf<T> {
        assert RegexValidator::accepts<T>(s);
        return StringOf<T>::s_into(s);
    }
    *%
}

%** Primitive string value. **%
__internal __typedeclable entity CString provides KeyType {
}

%** Primitive safe string value. **%
__internal __typedeclable entity CStringOf<T: unique CRegexValidator> provides KeyType {
    private function s_into(s: CString): CStringOf<T> = special_inject;
    %*
    function coerce(s: CString): CStringOf<T> {
        assert CRegexValidator::accepts<T>(s);
        return CStringOf<T>::s_into(s);
    }
    *%
}

%** Primitive unicode regex value. **%
__internal entity UnicodeRegex {
    __safe internal function s_accepts(re: UnicodeRegex, s: String): Bool = regex_accepts;
    %*
    method accepts(s: String): Bool {
        return UnicodeRegex::s_accepts(this, s);
    }
    *%
}

%** Primitive unicode regex value. **%
__internal entity CRegex {
    __safe internal function s_accepts(re: CRegex, s: CString): Bool = cregex_accepts;
    %*
    method accepts(s: CString): Bool {
        return CRegex::s_accepts(this, s);
    }
    *%
}

%** Primitive unicode regex value. **%
__internal entity PathRegex {
}

%** Primitive template string value. **%
__internal __typedeclable entity TemplateString {
}

%** Primitive string value. **%
__internal __typedeclable entity TemplateCString {
}

%** Result type. **%
__internal concept Result<T, E> {
    __internal entity Ok provides Result<T, E> {
    }

    __internal entity Err provides Result<T, E> {
    }

%*
    method isOk(): Bool {
        return this@<Result<T, E>::Ok>;
    }

    method isErr(): Bool {
        return this@<Result<T, E>::Err>;
    }

    method value(): T {
        return this@<Result<T, E>::Ok>.getv();
    }

    method error(): E {
        return this@<Result<T, E>::Err>.gete();
    }

    method convert<U, V>(): Result<U, V> {
        if(this?<Result<T, E>::Ok>) {
            return Result<U, V>::Ok{this.value()@<U>};
        }
        else {
            return Result<U, V>::Err{this.error()@<V>};
        }
    }
*%
}

namespace Interpolate {
    %** Special declaration of string interpolation function. **%
    function string(): String = special_method;

    %** Special declaration of string interpolation function. **%
    function cstring(): CString = special_method;
}

#if CHECK_LIBS
internal function s_blockingfailure<T>(): T = s_blockingfailure;

internal function s_reshavoc<T>(): T = s_reshavoc;
#endif

%** All collections provide this concept so we can expand them with spread operators. **%
__internal __universal concept Expandoable<T> {
}

__assume_safe internal function s_safeAs<T, U>(v: T): U = special_function;

