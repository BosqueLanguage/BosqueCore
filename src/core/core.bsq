%%The core namespace implements the primitive types used in the Bosque language
declare namespace Core;

%** Special type for indicating a value can be used as a key in a collection. **%
namespace KeyComparator {
    function equal<T: keytype>(a: T, b: T): Bool = special_method;
    function less<T: keytype>(a: T, b: T): Bool = special_method;
}

%** Type for indicating that a datatype is a Validator. **%
namespace Validator {
    function acceptsRe<T: revalidator>(s: String): Bool = special_method;
    function acceptsCRe<T: crevalidator>(s: CString): Bool = special_method;
}

%** Type for representing the option value. **%
__internal concept Option<T> {
}

%** Type for representing the none option value. **%
__internal entity None {
}

%** Type for representing the some option value. **%
__internal entity Some<T> provides Option<T> {
}

%** Primitive boolean value. **%
__internal __typedeclable __keycomparable entity Bool {
}

%** Primitive natural number value. **%
__internal __typedeclable __keycomparable __numeric entity Nat {
}

%** Primitive integer value. **%
__internal __typedeclable __keycomparable __numeric entity Int {
}

%** Primitive big-integer value. **%
__internal __typedeclable __keycomparable __numeric entity BigNat {
}

%** Primitive big-integer value. **%
__internal __typedeclable __keycomparable __numeric entity BigInt {
}

%** Primitive rational value. **%
__internal __typedeclable __numeric entity Rational {
}

%** Primitive float value. **%
__internal __typedeclable __numeric entity Float {
}

%** Primitive float decimal value. **%
__internal __typedeclable __numeric entity Decimal {
}

%** Primitive decimal degree value. **%
__internal __typedeclable __numeric entity DecimalDegree {
}

%** Primitive latitude/longitude value. **%
__internal __typedeclable entity LatLongCoordinate {
}

%** Primitive complex number value. **%
__internal __typedeclable __numeric entity Complex {
}

%** Primitive string value. **%
__internal __typedeclable __keycomparable entity String {
}

%** Primitive safe string value. **%
__internal __typedeclable __keycomparable entity StringOf<T: revalidator> {
    private function s_into(s: String): StringOf<T> = special_inject;
    %*
    function coerce(s: String): StringOf<T> {
        assert RegexValidator::accepts<T>(s);
        return StringOf<T>::s_into(s);
    }
    *%
}

%** Primitive string value. **%
__internal __typedeclable __keycomparable entity CString {
}

%** Primitive safe string value. **%
__internal __typedeclable __keycomparable entity CStringOf<T: crevalidator> {
    private function s_into(s: CString): CStringOf<T> = special_inject;
    %*
    function coerce(s: CString): CStringOf<T> {
        assert CRegexValidator::accepts<T>(s);
        return CStringOf<T>::s_into(s);
    }
    *%
}

%** Primitive unicode regex value. **%
__internal entity UnicodeRegex {
    __safe internal function s_accepts(re: UnicodeRegex, s: String): Bool = regex_accepts;
    %*
    method accepts(s: String): Bool {
        return UnicodeRegex::s_accepts(this, s);
    }
    *%
}

%** Primitive unicode regex value. **%
__internal entity CRegex {
    __safe internal function s_accepts(re: CRegex, s: CString): Bool = cregex_accepts;
    %*
    method accepts(s: CString): Bool {
        return CRegex::s_accepts(this, s);
    }
    *%
}

%** Primitive unicode regex value. **%
__internal entity PathRegex {
}

%** Primitive template string value. **%
__internal __typedeclable entity TemplateString {
}

%** Primitive string value. **%
__internal __typedeclable entity TemplateCString {
}

%** Result type. **%
__internal concept Result<T, E> {
    __internal entity Ok provides Result<T, E> {
    }

    __internal entity Err provides Result<T, E> {
    }

%*
    method isOk(): Bool {
        return this@<Result<T, E>::Ok>;
    }

    method isErr(): Bool {
        return this@<Result<T, E>::Err>;
    }

    method value(): T {
        return this@<Result<T, E>::Ok>.getv();
    }

    method error(): E {
        return this@<Result<T, E>::Err>.gete();
    }

    method convert<U, V>(): Result<U, V> {
        if(this?<Result<T, E>::Ok>) {
            return Result<U, V>::Ok{this.value()@<U>};
        }
        else {
            return Result<U, V>::Err{this.error()@<V>};
        }
    }
*%
}

namespace Interpolate {
    %** Special declaration of string interpolation function. **%
    function string(): String = special_method;

    %** Special declaration of string interpolation function. **%
    function cstring(): CString = special_method;
}

namespace XCore {
#if CHECK_LIBS
    internal function s_blockingfailure<T>(): T = s_blockingfailure;

    internal function s_reshavoc<T>(): T = s_reshavoc;
#endif

    __assume_safe internal function s_safeAs<T, U>(v: T): U = special_function;
}


