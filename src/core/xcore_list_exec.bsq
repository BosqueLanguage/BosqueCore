namespace Core;

#if STRIPPED_CORE
#else
#if EXEC_LIBS
namespace ListOps {
    function s_list_empty<T>(l: List<T>): Bool {
        return l.value?<BBLeaf<T>>;
    } 

    function s_list_size<T>(l: List<T>): Nat {
        return size<T>(l.value);
    }

    function s_list_front<T>(l: List<T>): T {
        return front<T>(l.value);
    }

    function s_list_back<T>(l: List<T>): T {
        return back<T>(l.value);
    }

    function s_list_get<T>(l: List<T>, idx: Nat): T {
        return get<T>(l.value, idx);
    }

    function s_list_set_front<T>(l: List<T>, v: T): List<T> {
        return XCore::s_createDirect<Tree<T>, List<T>>(setFront<T>(l.value, v));
    }

    function s_list_set_back<T>(l: List<T>, v: T): List<T> {
        return XCore::s_createDirect<Tree<T>, List<T>>(setBack<T>(l.value, v));
    }

    function s_list_set<T>(l: List<T>, idx: Nat, v: T): List<T> {
        return XCore::s_createDirect<Tree<T>, List<T>>(set<T>(l.value, idx, v));
    }

    function s_list_push_front<T>(l: List<T>, v: T): List<T> {
        return XCore::s_createDirect<Tree<T>, List<T>>(pushFront<T>(l.value, v));
    }

    function s_list_push_back<T>(l: List<T>, v: T): List<T> {
        return XCore::s_createDirect<Tree<T>, List<T>>(pushBack<T>(l.value, v));
    }

    function s_list_insert<T>(l: List<T>, idx: Nat, v: T): List<T> {
        return XCore::s_createDirect<Tree<T>, List<T>>(insert<T>(l.value, idx, v));
    }

    function s_list_create_empty<T>(): List<T> {
        return XCore::s_createDirect<Tree<T>, List<T>>(Tree<T>::emptyTree);
    }

    function s_list_create_1<T>(v1: T): List<T> {
        return XCore::s_createDirect<Tree<T>, List<T>>(Tree<T>::create1(v1));
    }

    function s_list_create_2<T>(v1: T, v2: T): List<T> {
        return XCore::s_createDirect<Tree<T>, List<T>>(Tree<T>::create2(v1, v2));
    }

    function s_list_create_3<T>(v1: T, v2: T, v3: T): List<T> {
        return XCore::s_createDirect<Tree<T>, List<T>>(Tree<T>::create3(v1, v2, v3));
    }

    function s_list_create_4<T>(v1: T, v2: T, v3: T, v4: T): List<T> {
        return XCore::s_createDirect<Tree<T>, List<T>>(Tree<T>::create4(v1, v2, v3, v4));
    }

    recursive? function s_list_allof<T>(l: List<T>, p: recursive? pred(T) -> Bool): Bool {
        return Tree<T>::allof[recursive?](l.value, p);
    }

    recursive? function s_list_noneof<T>(l: List<T>, p: recursive? pred(T) -> Bool): Bool {
        return Tree<T>::noneof[recursive?](l.value, p);
    }

    recursive? function s_list_someof<T>(l: List<T>, p: recursive? pred(T) -> Bool): Bool {
        return Tree<T>::someof[recursive?](l.value, p);
    }

    recursive? function s_list_map<T, U>(l: List<T>, f: recursive? fn(T) -> U): List<U> {
        return XCore::s_createDirect<Tree<U>, List<U>>(Tree<T>::map[recursive?]<U>(l.value, f));
    }

    enum Color {
        Red,
        Black,
        BB,
        NB
    }

    function computeColor<T>(t: Tree<T>): Color {
        match(t)@ {
            BBLeaf<T> => { return Color#Black; }
            | Leaf<T> => { return Color#Black; }
            | Node<T> => { return $t.c; }
        }
    }

    recursive function checkRBChildColorInvariant<T>(t: Tree<T>): Bool {
        if(t)@@!<Node<T>> {
            return true;
        }

        if(t.c === Color#Red) {
            let islred = if(t.l)@<Node<T>> then $_.c === Color#Red  else false;
            let isrred = if(t.r)@<Node<T>> then $_.c === Color#Red  else false;

            return \/(islred, isrred);
        }
        
        return checkRBChildColorInvariant[recursive]<T>(t.l) && checkRBChildColorInvariant[recursive]<T>(t.r);
    }

    recursive function checkRBPathLengthInvariant<T>(t: Tree<T>): Int {
        if(t)@@!<Node<T>> {
            return 0i;
        }

        let lc = checkRBPathLengthInvariant[recursive]<T>(t.l);
        if(lc == -1i) {
            return -1i;
        }

        let rc = checkRBPathLengthInvariant[recursive]<T>(t.r);
        if(rc == -1i) {
            return -1i;
        }

        if(lc != rc) {
            return -1i; %% we have a black height mismatch return sentinel value
        }

        return if(t.c === Color#Black) then lc + 1i else lc;
    }

    function checkRBInvariants<T>(t: Tree<T>): Bool {
       return checkRBChildColorInvariant<T>(t) && checkRBPathLengthInvariant<T>(t) >= 0i;
    }

    function blacken(c: Color): Color {
        assert c !== Color#BB;

        switch(c) {
            Color#Black => { return Color#BB; }
            | Color#Red => { return Color#Black; }
            | _         => { return Color#Red; }
        }
    }

    function redden(c: Color): Color {
        assert c !== Color#NB;

        switch(c) {
            Color#BB      => { return Color#Black; }
            | Color#Black => { return Color#Red; }
            | _           => { return Color#NB; }
        }
    }

    %% Case where we have a double red violation on LL side -- tleft = Node{Red, _, Node{Red, _ a, b}, c}
    function balanceHelper_RR_LL<T>(c: Color, tleft: Tree<T>, tright: Tree<T>): Option<Node<T>> {
        if(/\(c !== Color#Black, c !== Color#BB)) {
            return none;
        }

        if (tleft)@@!<Node<T>> {
            return none;
        }

        let lleft = tleft.l;
        if(lleft)@@!<Node<T>> {
            return none;
        }
            
        if(\/(tleft.c !== Color#Red, lleft.c !== Color#Red)) {
            return none;
        }

        let nl = Tree<T>::createNode(Color#Black, lleft.l, lleft.r);
        let nr = Tree<T>::createNode(Color#Black, tleft.r, tright);
        return some(Tree<T>::createNode(redden(c), nl, nr));
    }

    %% Case where we have a double red violation on LR side -- tleft = Node{Red, _, a, Node{Red, _, b, c}}
    function balanceHelper_RR_LR<T>(c: Color, tleft: Tree<T>, tright: Tree<T>): Option<Node<T>> {
        if(/\(c !== Color#Black, c !== Color#BB)) {
            return none;
        }

        if (tleft)@@!<Node<T>> {
            return none;
        }

        let lright = tleft.r;
        if(lright)@@!<Node<T>> {
            return none;
        }
            
        if(\/(tleft.c !== Color#Red, lright.c !== Color#Red)) {
            return none;
        }

        let nl = Tree<T>::createNode(Color#Black, tleft.l, lright.l);
        let nr = Tree<T>::createNode(Color#Black, lright.r, tright);
        return some(Tree<T>::createNode(redden(c), nl, nr));
    }

    %% Case where we have a double red violation on RL side -- tright = Node{Red, _, Node{Red, _, b, c}, d}
    function balanceHelper_RR_RL<T>(c: Color, tleft: Tree<T>, tright: Tree<T>): Option<Node<T>> {
        if(/\(c !== Color#Black, c !== Color#BB)) {
            return none;
        }

        if (tright)@@!<Node<T>> {
            return none;
        }

        let rleft = tright.l;
        if(rleft)@@!<Node<T>> {
            return none;
        }
            
        if(\/(tright.c !== Color#Red, rleft.c !== Color#Red)) {
            return none;
        }

        let nl = Tree<T>::createNode(Color#Black, tleft, rleft.l);
        let nr = Tree<T>::createNode(Color#Black, rleft.r, tright.r);
        return some(Tree<T>::createNode(redden(c), nl, nr));
    }

    %% Case where we have a double red violation on RR side -- tright = Node{Red, _, b, Node{Red, _, c, d}}
    function balanceHelper_RR_RR<T>(c: Color, tleft: Tree<T>, tright: Tree<T>): Option<Node<T>> {
        if(/\(c !== Color#Black, c !== Color#BB)) {
            return none;
        }

        if (tright)@@!<Node<T>> {
            return none;
        }

        let rright = tright.r;
        if(rright)@@!<Node<T>> {
            return none;
        }
            
        if(\/(tright.c !== Color#Red, rright.c !== Color#Red)) {
            return none;
        }

        let nl = Tree<T>::createNode(Color#Black, tleft, tright.l);
        let nr = Tree<T>::createNode(Color#Black, rright.l, rright.r);
        return some(Tree<T>::createNode(redden(c), nl, nr));
    }
    
    %% Case where we have negative blacks on L side -- tleft = Node{NB, _, Node{Black, _, a, b}, Node{Black, _, c, d}}
    recursive function balanceHelper_DB_L<T>(c: Color, tleft: Tree<T>, tright: Tree<T>): Option<Node<T>> {
        if(c !== Color#BB) {
            return none;
        }

        if (tleft)@@!<Node<T>> {
            return none;
        }

        if(tleft.c !== Color#NB) {
            return none;
        }

        let lleft = tleft.l;
        if(lleft)@@!<Node<T>> {
            return none;
        }

        let lright = tleft.r;
        if(lright)@@!<Node<T>> {
            return none;
        }

        if(\/(lleft.c !== Color#Black, lright.c !== Color#Black)) {
            return none;
        }

        let nl = balance[recursive]<T>(Color#Black, Tree<T>::createNode(Color#Red, lleft.l, lleft.r), lright.l);
        let nr = Tree<T>::createNode(Color#Black, lright.r, tright);
        return some(Tree<T>::createNode(Color#Black, nl, nr));
    }

    %% Case where we have negative blacks on R side -- tright = Node{NB, _, Node{Black, _, b, c}, Node{Black, _, d, e}}}
    recursive function balanceHelper_DB_R<T>(c: Color, tleft: Tree<T>, tright: Tree<T>): Option<Node<T>> {
        if(c !== Color#BB) {
            return none;
        }

        if (tright)@@!<Node<T>> {
            return none;
        }

        if(tright.c !== Color#NB) {
            return none;
        }

        let rleft = tright.l;
        if(rleft)@@!<Node<T>> {
            return none;
        }

        let rright = tright.r;
        if(rright)@@!<Node<T>> {
            return none;
        }

        if(\/(rleft.c !== Color#Black, rright.c !== Color#Black)) {
            return none;
        }

        let nl = Tree<T>::createNode(Color#Black, tleft, rleft.l);
        let nr = balance[recursive]<T>(Color#Black, rleft.r, Tree<T>::createNode(Color#Red, rright.l, rright.r));
        return some(Tree<T>::createNode(Color#Black, nl, nr));
    }

    recursive function balance<T>(c: Color, tleft: Tree<T>, tright: Tree<T>): Tree<T> {
        let doubleRedLL = balanceHelper_RR_LL<T>(c, tleft, tright);
        if(doubleRedLL)@!none {
            return $doubleRedLL;
        }

        let doubleRedLR = balanceHelper_RR_LR<T>(c, tleft, tright);
        if(doubleRedLR)@!none {
            return $doubleRedLR;
        }

        let doubleRedRL = balanceHelper_RR_RL<T>(c, tleft, tright);
        if(doubleRedRL)@!none {
            return $doubleRedRL;
        }

        let doubleRedRR = balanceHelper_RR_RR<T>(c, tleft, tright);
        if(doubleRedRR)@!none {
            return $doubleRedRR;
        }

        let negBlackL = balanceHelper_DB_L<T>(c, tleft, tright);
        if(negBlackL)@!none {
            return $negBlackL;
        }

        let negBlackR = balanceHelper_DB_R<T>(c, tleft, tright);
        if(negBlackR)@!none {
            return $negBlackR;
        }

        return Tree<T>::createNode(c, tleft, tright);
    }

    function bubble<T>(c: Color, tleft: Tree<T>, tright: Tree<T>): Tree<T> {
        if(/\(tleft?<Node<T>>, tright?<Node<T>>)) {
            let tl = tleft@<Node<T>>;
            let tr = tright@<Node<T>>;

            if(tl.c === Color#BB || tr.c === Color#BB) {
                let nl = Tree<T>::createNode(redden(tl.c), tl.l, tl.r);
                let nr = Tree<T>::createNode(redden(tr.c), tr.l, tr.r);
                return balance<T>(blacken(tl.c), nl, nr);
            }
        }
        
        return Tree<T>::createNode(c, tleft, tright);
    }

    function size<T>(t: Tree<T>): Nat {
        match(t)@ {
            BBLeaf<T> => { return 0n; }
            | Leaf<T> => { return 1n; }
            | Node<T> => { return $t.count; }
        }
    }

    recursive function front<T>(t: Tree<T>): T {
        if(t)@<Leaf<T>> {
            return $t.v;
        }
        else {
            let nn = XCore::s_safeas<Tree<T>, Node<T>>(t);
            return front[recursive]<T>(nn.l);
        }
    }

    recursive function back<T>(t: Tree<T>): T {
        if(t)@<Leaf<T>> {
            return $t.v;
        }
        else {
            let nn = XCore::s_safeas<Tree<T>, Node<T>>(t);
            return back[recursive]<T>(nn.r);
        }
    }

    recursive function get<T>(t: Tree<T>, idx: Nat): T {
        if(t)@<Leaf<T>> {
            return $t.v;
        }
        else {
            let nn = XCore::s_safeas<Tree<T>, Node<T>>(t);

            let count = size<T>(nn.l);
            if(idx < count) {
                return get[recursive]<T>(nn.l, idx);
            }
            else {
                return get[recursive]<T>(nn.r, idx - count);
            }
        }
    }

    recursive function setFront<T>(t: Tree<T>, v: T): Tree<T> {
        if(t)@<Leaf<T>> {
            return Tree<T>::createLeaf(v);
        }
        else {
            let nn = XCore::s_safeas<Tree<T>, Node<T>>(t);
            return Tree<T>::createNode(nn.c, setFront[recursive]<T>(nn.l, v), nn.r);
        }
    }

    recursive function setBack<T>(t: Tree<T>, v: T): Tree<T> {
        if(t)@<Leaf<T>> {
            return Tree<T>::createLeaf(v);
        }
        else {
            let nn = XCore::s_safeas<Tree<T>, Node<T>>(t);
            return Tree<T>::createNode(nn.c, nn.l, setBack[recursive]<T>(nn.r, v));
        }
    }

    recursive function set<T>(t: Tree<T>, idx: Nat, v: T): Tree<T> {
        if(t)@<Leaf<T>> {
            return Tree<T>::createLeaf(v);
        }
        else {
            let nn = XCore::s_safeas<Tree<T>, Node<T>>(t);

            let count = size<T>(nn.l);
            if(idx < count) {
                return Tree<T>::createNode(nn.c, set[recursive]<T>(nn.l, idx, v), nn.r);
            }
            else {
                return Tree<T>::createNode(nn.c, nn.l, set[recursive]<T>(nn.r, idx - count, v));
            }
        }
    }

    recursive function pushBack_helper<T>(t: Tree<T>, v: T): Tree<T> {
        match(t)@ {
            BBLeaf<T> => { return Tree<T>::createLeaf(v); }
            | Leaf<T> => { return balance<T>(Color#Black, $t, Tree<T>::createLeaf(v)); }
            | Node<T> => { 
                let nr = pushBack_helper[recursive]<T>($t.r, v);
                return balance<T>(Color#Black, $t.l, nr); 
            }
        }
    }

    function pushBack<T>(t: Tree<T>, v: T): Tree<T> {
        let tt = pushBack_helper<T>(t, v); 
        if (tt)@!<Node<T>> {
            return tt;
        }
        else {
            return Tree<T>::createNode(Color#Black, $tt.l, $tt.r);
        }
    }

    recursive function pushFront_helper<T>(t: Tree<T>, v: T): Tree<T> {
        match(t)@ {
            BBLeaf<T> => { return Tree<T>::createLeaf(v); }
            | Leaf<T> => { return balance<T>(Color#Black, Tree<T>::createLeaf(v), $t); }
            | Node<T> => { 
                let nr = pushFront_helper[recursive]<T>($t.l, v);
                return balance<T>(Color#Black, nr, $t.r); 
            }
        }
    }

    function pushFront<T>(t: Tree<T>, v: T): Tree<T> {
        let tt = pushFront_helper<T>(t, v); 
        if (tt)@!<Node<T>> {
            return tt;
        }
        else {
            return Tree<T>::createNode(Color#Black, $tt.l, $tt.r);
        }
    }

    recursive function insert_helper<T>(t: Tree<T>, idx: Nat, v: T): Tree<T> {
        match(t)@ {
            BBLeaf<T> => { 
                return Tree<T>::createLeaf(v); 
            }
            | Leaf<T> => { 
                if(idx == 0n) {
                    return Tree<T>::createNode(Color#Black, Tree<T>::createLeaf(v), $t);
                }
                else {
                    return Tree<T>::createNode(Color#Black, $t, Tree<T>::createLeaf(v));
                }
            }
            | Node<T> => { 
                let count = size<T>($t.l);
                if(idx < count) {
                    let nr = insert_helper[recursive]<T>($t.l, idx, v);
                    return balance<T>(Color#Black, nr, $t.r); 
                }
                else {
                    let nr = insert_helper[recursive]<T>($t.r, idx - count, v);
                    return balance<T>(Color#Black, $t.l, nr); 
                }
            }
        }
    }

    function insert<T>(t: Tree<T>, idx: Nat, v: T): Tree<T> {
        let tt = insert_helper<T>(t, idx, v); 
        if (tt)@!<Node<T>> {
            return tt;
        }
        else {
            return Tree<T>::createNode(Color#Black, $tt.l, $tt.r);
        }
    }

    datatype Tree<T> of 
        BBLeaf {}
        | Leaf { v: T }
        | Node { c: Color, count: Nat, l: Tree<T>, r: Tree<T> }
    & {
        const emptyTree: Tree<T> = BBLeaf<T>{};

        function createLeaf(v: T): Leaf<T> {
            return Leaf<T>{v};
        }

        function createNode(c: Color, l: Tree<T>, r: Tree<T>): Node<T> {
            return Node<T>{c, size<T>(l) + size<T>(r), l, r};
        }

        function create1(v1: T): Tree<T> {
            return Tree<T>::createLeaf(v1);
        }

        function create2(v1: T, v2: T): Tree<T> {
            return Tree<T>::createNode(Color#Black, Tree<T>::createLeaf(v1), Tree<T>::createLeaf(v2));
        }

        function create3(v1: T, v2: T, v3: T): Tree<T> {
            return Tree<T>::createNode(Color#Black, Tree<T>::createLeaf(v1), Tree<T>::create2(v2, v3));
        }

        function create4(v1: T, v2: T, v3: T, v4: T): Tree<T> {
            return Tree<T>::createNode(Color#Black, Tree<T>::create2(v1, v2), Tree<T>::create2(v3, v4));
        }

        recursive? function allof(t: Tree<T>, p: recursive? pred(T) -> Bool): Bool {
            match(t)@ {
                Leaf<T> => { return p[recursive?]($t.v); }
                | Node<T> => { 
                    let nl = Tree<T>::allof[recursive?]($t.l, p);
                    if(!nl) { 
                        return false; 
                    }
                    else {
                        let nr = Tree<T>::allof[recursive?]($t.r, p);
                        return nr;
                    }
                }
            }
        }

        recursive? function noneof(t: Tree<T>, p: recursive? pred(T) -> Bool): Bool {
            match(t)@ {
                Leaf<T> => { return !p[recursive?]($t.v); }
                | Node<T> => { 
                    let nl = Tree<T>::noneof[recursive?]($t.l, p);
                    if(!nl) { 
                        return false; 
                    }
                    else {
                        let nr = Tree<T>::noneof[recursive?]($t.r, p);
                        return nr;
                    }
                }
            }
        }

        recursive? function someof(t: Tree<T>, p: recursive? pred(T) -> Bool): Bool {
            match(t)@ {
                Leaf<T> => { return p[recursive?]($t.v); }
                | Node<T> => { 
                    let nl = Tree<T>::someof[recursive?]($t.l, p);
                    if(nl) { 
                        return true; 
                    }
                    else {
                        let nr = Tree<T>::someof[recursive?]($t.r, p);
                        return nr;
                    }
                }
            }
        }

        recursive? function map<U>(t: Tree<T>, f: recursive? fn(T) -> U): Tree<U> {
            match(t)@ {
                Leaf<T> => { return Leaf<U>{f[recursive?]($t.v)}; }
                | Node<T> => { 
                    let nl = Tree<T>::map[recursive?]<U>($t.l, f);
                    let nr = Tree<T>::map[recursive?]<U>($t.r, f);
                    return Node<U>{$t.c, $t.count, nl, nr};
                }
            }
        }
    }
}
#else
#endif %% EXEC_LIBS
#endif %% STRIPPED_CORE
