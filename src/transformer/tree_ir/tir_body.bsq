namespace TreeIR;

concept Expression provides APIType {
    field tag: ExpressionTag;
    field sinfo: SourceInfo;

    field etype: TypeKey;
}

datatype LiteralExpression provides Expression
of
LiteralNoneExpression { }
| LiteralNothingExpression { }
| LiteralBoolExpression { value: Bool }
| LiteralIntegralExpression { value: String }
| LiteralRationalExpression { value: String }
| LiteralFloatPointExpression { value: String }
| LiteralStringExpression { value: String }
| LiteralRegexExpression { value: BSQRegex }
| LiteralASCIIStringExpression { value: String }
| LiteralTypedStringExpression { oftype: TypeKey, value: String }
| LiteralASCIITypedStringExpression { oftype: TypeKey, value: String }
| LiteralTemplateStringExpression { value: String }
| LiteralASCIITemplateStringExpression { value: String }
| LiteralTypedPrimitiveDirectExpression { value: Expression, constype: TypeKey;, basetype: TypeKey }
| LiteralTypedPrimitiveConstructorExpression { value: Expression, constype: TypeKey;, basetype: TypeKey }
;

entity AccessEnvValueExpression provides Expression {
    field keyname: String;
    field valtype: TypeKey;
    field restype: TypeKey;
    field orNoneMode: Bool;
}

entity AccessNamespaceConstantExpression provides Expression {
    field ns: String;
    field cname: String;
}

entity AccessConstMemberFieldExpression provides Expression {
    field tkey: TypeKey;
    field cname: String;
}

entity AccessVariableExpression provides Expression {
    field name: String;
}

entity AccessCapturedVariableExpression provides Expression {
    field name: String;
}

entity AccessScratchSingleValueExpression provides Expression {
    field sidx: Nat;
}

entity AccessScratchIndexExpression provides Expression {
    field index: Nat;
    field sidx: Nat;
}

datatype LoadSingleExpression provides Expression using {
    tkey: TypeKey,
    exp: Expression
} of
LoadIndexExpression { index: Nat }
| LoadPropertyExpression { property: String }
| LoadFieldExpression { field: FieldKey }
| LoadFieldVirtualExpression { field: FieldKey }
;

datatype ConstructorExpression provides Expression using {
    oftype: TypeKey,
    args: List<Expression>
} of
ConstructorPrimaryDirectExpression { }
| ConstructorPrimaryCheckExpression { }
| ConstructorTupleExpression { }
| ConstructorRecordExpression { }
| ConstructorListExpression { }
| ConstructorMapExpression { }
;

entity CodePackInvokeExpression provides Expression {
    field cpack: CodePack;
    field args: List<Expression>;
}

datatype ConstructorOfExpression provides Expression using {
    oftype: TypeKey,
    arg: Expression
} of
ResultOkConstructorExpression { }
| ResultErrConstructorExpression { }
| SomethingConstructorExpression { }
| TypedeclDirectExpression { }
| TypedeclConstructorExpression { }
;

datatype CallFunctionExpression provides Expression using {
    fkey: InvokeKey, 
    args: List<Expression>
} of
CallNamespaceFunctionExpression { ns: String, fname: String }
| CallNamespaceOperatorExpression { ns: String, oname: String }
| CallStaticFunctionExpression { tkey: TypeKey, fname: String }
;

datatype LogicActionExpression provides Expression using {
    args: List<Expression>
} of
LogicActionAndExpression { }
| LogicActionOrExpression { }
;

datatype UnaryExpression provides Expression using {
    exp: Expression
} of
PrefixNotExpression { }
| PrefixNegateExpression { optype: TypeKey }
;

datatype BinOpExpression provides Expression using {
    optype: TypeKey,
    lhs: Expression,
    rhs: Expression
} of
BinAddExpression { }
| BinSubExpression { }
| BinMultExpression { }
| BinDivExpression { }
;

entity BinKeyEqBothUniqueExpression provides Expression {
    field optype: TypeKey; //both must be the same unique key type
    field lhs: Expression;
    field rhs: Expression;
}

entity BinKeyEqOneUniqueExpression provides Expression {
    field oftype: TypeKey; //the unique key type
    field uarg: Expression; //the value that has the unique type

    field gtype: TypeKey; //The type of the non-unique value
    field garg: Expression; //The arg that has the non-unique type
}

entity BinKeyEqGeneralExpression provides Expression {
    field lhstype: TypeKey;
    field lhs: Expression;

    field rhstype: TypeKey;
    field rhs: Expression;
}

entity BinKeyNeqBothUniqueExpression provides Expression {
    field optype: TypeKey; //both must be the same unique key type
    field lhs: Expression;
    field rhs: Expression;
}

entity BinKeyNeqOneUniqueExpression provides Expression {
    field oftype: TypeKey; //the unique key type
    field uarg: Expression; //the value that has the unique type

    field gtype: TypeKey; //The type of the non-unique value
    field garg: Expression; //The arg that has the non-unique type
}

entity BinKeyNeqGeneralExpression provides Expression {
    field lhstype: TypeKey;
    field lhs: Expression;

    field rhstype: TypeKey;
    field rhs: Expression;
}

entity BinKeyUniqueLessExpression provides Expression {
    field optype: TypeKey;
    field lhs: Expression;
    field rhs: Expression;
}

entity BinKeyGeneralLessExpression provides Expression {
    field optype: TypeKey;
    field lhs: Expression;
    field rhs: Expression;
}

datatype NumericBinCmpExpression provides Expression using {
    optype: TypeKey,
    lhs: Expression,
    rhs: Expression
} of
NumericEqExpression { }
| NumericNeqExpression { }
| NumericLessExpression { }
| NumericLessEqExpression { }
| NumericGreaterExpression { }
| NumericGreaterEqExpression { }
;

datatype BinLogicExpression provides Expression using {
    lhs: Expression,
    rhs: Expression
} of
BinLogicAndExpression { }
| BinLogicOrExpression { }
| BinLogicImpliesExpression { }
;

entity MapEntryConstructorExpression provides Expression {
    field ktype: TypeKey;
    field vtype: TypeKey;
    field oftype: TypeKey;

    field kexp: Expression;
    field vexp: Expression;
}

entity IfExpression provides Expression {
    field ifentry: {etest: Expression, value: Expression, binderinfo: [Expression, Nat, Expression, String]?};
    field elifentries: {etest: Expression, value: Expression, binderinfo: [Expression, Nat, Expression, String]?}[];
    field elseentry: {value: Expression, binderinfo: [Expression, Nat, Expression, String]?};
}

entity SwitchExpression provides Expression {
    field exp: Expression;
    field scratchidx: Nat;
    field clauses: {ematch: Expression, value: Expression, binderinfo: [Expression, String]?}[];
    field edefault: {value: Expression, binderinfo: [Expression, String]?}?;
    field isexhaustive: Bool;
}

entity MatchExpression provides Expression {
    field exp: Expression;
    field scratchidx: Nat;
    field clauses: {ematch: Expression, value: Expression, binderinfo: [Expression, String]?}[];
    field edefault: {value: Expression, binderinfo: [Expression, String]?}?;
    field isexhaustive: Bool;
}

entity TaskSelfFieldExpression provides Expression {
    field tasktype: TypeKey;
    field fieldkey: FieldKey;
    field fname: String;
}

entity TaskSelfControlExpression provides Expression {
    field tasktype: TypeKey;
}

entity TaskGetIDExpression provides Expression {
    field tasktype: TypeKey;
}

entity TIRCoerceSafeExpression provides Expression {
    field exp: Expression;
    field fromtype: TypeKey;
    field totype: TypeKey;
}

datatype InjectExtractExpression provides Expression using {
    exp: Expression,
    totype: TypeKey
} of
InjectExpression { }
| ExtractExpression { }
;

entity CreateCodePackExpression provides Expression {
    field pcodepack: CodePack;

    field capturedirect: List<String>;
    field captureindirect: List<String>;
    field capturepackdirect: List<String>;
    field capturepackindirect: List<String>;
}

concept TestIsExpression provides Expression {
    field exp: Expression;
}

datatype ITestIsSpecialExpression provides TestIsExpression 
of 
IsNoneSpecialExpression { }
| IsSomeSpecialExpression { }
| IsNothingSpecialExpression { }
| IsSomethingSpecialExpression { }
| IsOkSpecialExpression { }
| IsErrSpecialExpression { }
;

datatype ITestIsLiteralEqExpression provides TestIsExpression using {
    literal: LiteralValue
} of
IsEqualToLiteralExpression { }
| IsNotEqualToLiteralExpression { }
;

datatype ITestIsTypeExpression provides TestIsExpression using {
    ttype: TypeKey
} of 
IsTypeExpression { }
| IsNotTypeExpression { }
| IsSubTypeExpression { }
| IsNotSubTypeExpression { }
;


concept AsExpression provides Expression {
    field exp: Expression;
}

datatype AsSpecialExpression provides AsExpression using 
of
AsNoneSpecialExpression { }
| AsSomeSpecialExpression { }
| AsNothingSpecialExpression { }
| AsSomethingSpecialExpression { }
| AsOkSpecialExpression { }
| AsErrSpecialExpression { }
;

datatype AsLiteralEqExpression provides AsExpression using {
    literal: LiteralValue
} of
AsEqualToLiteralExpression { }
| AsNotEqualToLiteralExpression { }
;

datatype TestAsTypeExpression provides AsExpression using {
    ttype: TypeKey
} of
AsTypeExpression { }
| AsNotTypeExpression { }
| AsSubTypeExpression { }
| AsNotSubTypeExpression { }
;

datatype MemberFunctionExpression provides Expression using {
    tkey: TypeKey,
    fname: String,
    fkey: InvokeKey,
    fdecltype: TypeKey,
    thisarg: Expression,
    args: List<Expression>
} of
CallMemberFunctionExpression { }
| CallMemberFunctionDynamicExpression { }
| CallMemberFunctionSelfRefExpression { }
;

datatype FunctionTaskExpression provides Expression using {
    fname: String,
    fkey: InvokeKey,
    tsktype: TypeKey,
    args: List<Expression>
} of 
CallMemberFunctionTaskExpression { }
| CallMemberFunctionTaskSelfRefExpression { }
| CallMemberActionExpression { }
;

entity LiteralValue {
    field exp: Expression;
    field litstr: String;
}

concept Statement {
    field sinfo: SourceInfo;
}

entity NopStatement provides Statement {
}

entity AbortStatement provides Statement {
    field msg: String;
}

entity AssertCheckStatement provides Statement {
    field cond: Expression;
    field msg: String;
}

entity DebugStatement provides Statement {
    field value: Expression;
}