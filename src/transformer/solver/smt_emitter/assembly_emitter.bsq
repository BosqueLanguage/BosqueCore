namespace SMTEmit;

import TreeIR;

typedef TypeDeclInfo = {
    name: String,
    consop: String,
    consargs: List<{cname: String, ctype: String}>
};

function typeEncodedAsUnion(tt: TreeIR::TypeKey): Bool {
    let ttype = this.assembly.typeMap.get(tt);
    return (ttype?<TreeIR::ConceptType> || ttype?<TreeIR::UnionType>);
}

entity TypeInfoEmitter {
    field assembly: TreeIR::Assembly;
    field nemitter: NameEmitter;

    method getSMTTypeTag(t: TreeIR::Type | TreeIR::TypeKey): String {
        let ttype = if <TreeIR::Type> (t) then $ else this.assembly.typeMap.get($);
        return this.nemitter.emitTypeNameInfo(ttype).tagname;
    }

    method getSMTTypeName(t: TreeIR::Type | TreeIR::TypeKey): String {
        let ttype = if <TreeIR::Type> (t) then $ else this.assembly.typeMap.get($);
        return this.nemitter.emitTypeNameInfo(ttype).smtname;
    }

    function typeRequiresTagInfo(t: TreeIR::Type): Bool {
        match(t) {
            TreeIR::PrimitiveInternalEntityType => return false;
            | TreeIR::HavocEntityType => return false;
            | TreeIR::TaskType => return false;
            | _ => return true;
        }
    }

    function typeRequiresKeyTypeTagInfo(t: TreeIR::Type): Bool {
        return t?<OOType> && t@<OOType>.iskeytype;
    }

    function typeRequiresSubTypeTypeTagInfo(t: TreeIR::Type): Bool {
        if(t.supertypes?none || t.supertypes@!none.empty()) {
            return false;
        }

        return t.supertypes@!none.someOf(pred(st) => st !== "Any"_TreeIR::TypeKey && st !== "Some"_TreeIR::TypeKey);
    }

    function typeRequiresConstructorInfo(t: TreeIR::Type): Bool {
        match(t) {
            TreeIR::ObjectEntityType => return true;
            | TreeIR::EnumEntityType => return true;
            | TreeIR::MapEntryEntityType => return true;
            | TreeIR::TupleType => return true;
            | TreeIR::RecordType => return true;
            | TreeIR::EListType => return true;
            | _ => return false;
        }
    }

    function typeRequiresBoxingInfo(t: TreeIR::Type): Bool {
        match(t) {
            TreeIR::PrimitiveInternalEntityType => return false;
            | TreeIR::HavocEntityType => return false;
            | TreeIR::TaskType => return false;
            | TreeIR::ConceptType => return false;
            | TreeIR::ConceptSetType => return false;
            | TreeIR::UnionType => return false;
            | _ => return true;
        }
    }

    method emitEnumEntityTypeDeclAndConstructor(t: TreeIR::EnumEntityType): {decl: String, cons: String} {
        let eninfo = this.nemitter.emitTypeNameInfo(t);

        let tdecl = String::concat(List<String>{"(", eninfo.smtname, " 0)"});
        let tcons = String::concat(List<String>{"( (", eninfo.consname@<String>, " (", eninfo.smtname , "-value Nat)) )"});

        return {decl=tdecl, cons=tcons};
    }

    method emitObjectEntityTypeDeclAndConstructor(t: TreeIR::ObjectEntityType): {decl: String, cons: String} {
        return {name="[OBJECT]", consop="[OBJECT_cons]", consargs=List<{cname: String, ctype: String}>{}};
    }

    method emitMapEntryEntityTypeDeclAndConstructor(t: TreeIR::MapEntryEntityType): {decl: String, cons: String} {
        return {name="[MAPENTRY]", consop="[MAPENTRY_cons]", consargs=List<{cname: String, ctype: String}>{}};
    }

    method emitTupleTypeDeclAndConstructor(t: TreeIR::TupleType): {decl: String, cons: String} {
        return {name="[TUPLE]", consop="[TUPLE_cons]", consargs=List<{cname: String, ctype: String}>{}};
    }

    method emitRecordTypeDeclAndConstructor(t: TreeIR::RecordType): {decl: String, cons: String} {
        return {name="[RECORD]", consop="[RECORD_cons]", consargs=List<{cname: String, ctype: String}>{}};
    }

    method generateOOSMTDeclAndConstructor(t: TreeIR::Type): {decl: String, cons: String} {
        match(t) {
            TreeIR::ObjectEntityType => return this.emitObjectEntityTypeDeclAndConstructor($);
            | TreeIR::EnumEntityType => return this.emitEnumEntityTypeDeclAndConstructor($);
            | TreeIR::MapEntryEntityType => return this.emitMapEntryEntityTypeDeclAndConstructor($);
            | TreeIR::TupleType => return this.emitTupleTypeDeclAndConstructor($);
            | TreeIR::RecordType => return this.emitRecordTypeDeclAndConstructor($);
            | TreeIR::EListType => return {decl="[ELIST]", cons="[ELIST-mk]"};
            | TreeIR::TaskType => return {decl="[TASK]", cons="[TASK-mk]"};
        }
    }

    method emitEnumEntityTypeBinder(t: TreeIR::EnumEntityType): String {
        return "[ENUM]";
    }

    method emitTypedeclEntityTypeBinder(t: TreeIR::TypedeclEntityType): String {
        return "[TYPEDECL]";
    }

    method emitObjectEntityTypeBinder(t: TreeIR::ObjectEntityType): String {
        return "[OBJECT]";
    }

    method emitPrimitiveInternalEntityTypeBinder(t: TreeIR::PrimitiveInternalEntityType): String {
        return "[PRIMITIVE]";
    }

    function typeRequiresIOBinder(t: TreeIR::Type): Bool {
        match(t) {
            TreeIR::EnumEntityType => return true;
            | TreeIR::TypedeclEntityType => return true;
            | TreeIR::ObjectEntityType => return true;
            | TreeIR::PrimitiveInternalEntityType => return true;
            | _ => return false;
        }
    }

    method generateSMTIOBinder(t: TreeIR::Type): TypeDeclInfo {
        match(t) {
            TreeIR::EnumEntityType => return this.emitEnumEntityTypeBinder($);
            | TreeIR::TypedeclEntityType => return this.emitTypedeclEntityTypeBinder($);
            | TreeIR::ObjectEntityType => return this.emitObjectEntityTypeBinder($);
            | TreeIR::PrimitiveInternalEntityType => return this.emitPrimitiveInternalEntityTypeBinder($);
        }
    }
}

entity AssemblyEmitter {
    field assembly: TreeIR::Assembly;
    field nemitter: NameEmitter;
    field temitter: TypeInfoEmitter;

    function processAssembly(asm: TreeIR::Assembly): TreeIR::Assembly {
        //TODO: explicitly place code -- put validation/pre/post code in the right places
        //TODO: flatten expressions -- error inducing expressions and calls are at top-level
        //TODO: inline as needed
        //TODO: ensure bodies are trees
        //TODO: make all variable assignments unique

        return asm;
    }

    method generateTypeTagInfo(): {type_tag_decls: String, type_tag_distincts: String, key_type_tag_sort: String, type_tag_subtype: String} {    
        let alltypes = this.assembly.typeMap.values();

        let tagdeclinfo = alltypes
            .filter(pred(t) => TypeInfoEmitter::typeRequiresTagInfo(t))
            .map<String>(fn(t) => this.temitter.getSMTTypeTag(t))
            .keySort();

        let keytaginfo = alltypes
            .filter(pred(t) => TypeInfoEmitter::typeRequiresKeyTypeTagInfo(t))
            .map<String>(fn(t) => this.temitter.getSMTTypeTag(t))
            .keySort();
        
        let korder = alltypes
            .filter(pred(t) => TypeInfoEmitter::typeRequiresKeyTypeTagInfo(t) && !t?<TreeIR::PrimitiveInternalEntityType>)
            .map<String>(fn(t) => this.temitter.getSMTTypeTag(t))
            .keySort()
            .mapIdx<String>(fn(kt, ii) => {
                let ltt = if (ii == 0n) then "@TypeTag-SHAContentHash" else keytaginfo.get(ii - 1n);
                return String::concat(List<String>{"assert (@key_type_sort_order ", ltt, " ", kt, "))"});
            });

        let subtypeinfo = alltypes
            .filter(pred(t) => TypeInfoEmitter::typeRequiresSubTypeTypeTagInfo(t))
            .map<String>(fn(t) => {
                let ttag = this.temitter.getSMTTypeTag(t);
                let stags = t.supertypes@!none.filter(pred(st) => st !== "Some"_TreeIR::TypeKey && st !== "Any"_TreeIR::TypeKey).map<String>(fn(st) => this.temitter.getSMTTypeTag(st));
                let relations = stags.map<String>(fn(st) => String::concat(List<String>{"(assert (@subtypeof ", ttag, " ", st, "))"}));

                return String::join(" ", relations);
            });

        return {
            type_tag_decls = String::join("\n", tagdeclinfo.map<String>(fn(tg) => String::concat(List<String>{"(declare-const ", tg, " @TypeTag)"}))),
            type_tag_distincts = String::join("\n", tagdeclinfo),
            key_type_tag_sort = String::join("\n", korder),
            type_tag_subtype = String::join("\n", subtypeinfo)
        };
    }

    method generateTypeDecls(): {oo_decls: String, oo_constructors: String} {
        let alltypes = this.assembly.typeMap.values();

        let oodecltypes = alltypes.filter(pred(t) => TypeInfoEmitter::typeRequiresConstructorInfo(t));
        let oodeclinfo = oodecltypes.map<TypeDeclInfo>(fn(t) => this.temitter.generateOOSMTDeclAndConstructor(t));
        //let ooconsinfo = oodecltypes.map  

        return {
            oo_decls = String::join("\n    ", oodeclinfo.map<String>(fn(vv) => String::concat(List<String>{"(", vv.decl, " 0)"}))),
            oo_constructors = "[NOT IMPLEMENTED]"
        };
    }

    method generateSMTCode(invokeResultErrMap: Map<TreeIR::InvokeKey, TreeIR::ErrorKind>): String {
        let idecls = this.assembly.invokeMap.mapFlat<String>(fn(k, i) => {
            let iname = smtifyInvokeKey(i.invkey);
            let rtype = i.resultType;
            let rerr = if(invokeResultErrMap.has(i.invkey)) then invokeResultErrMap.get(i.invkey) else TreeIR::ErrorKind::safe;
            let bemitter = BodyEmitter{this.assembly, this.nemitter, this.temitter, i.srcFile, -1i, invokeResultErrMap, rtype, rerr};
            
            let args = i.params.map<String>(fn(p) => {
                let pname = p.name.value().value();
                let ptype = this.temitter.getSMTTypeName(p.type);

                return String::concat(List<String>{"(", pname, " ", ptype, ")"});
            });

            let body = match (i) {
                TreeIR::InvokeImplementation => bemitter.emitBodyStatementList($.body)
                | TreeIR::InvokePrimitive => "PRIMITIVE DECL"
                | _ => ""
            };

            if(body === "") {
                return "";
            }
            else {
                let smtrtype = this.temitter.getSMTTypeName(rtype);
                return String::concat(List<String>{"(define-fun ", iname, " (", String::join(" ", args), ") ", smtrtype, "\n", body, "\n)"});
            }
        });

        return String::join("\n", idecls);
    }
}
