namespace SMTEmit;

import TreeIR;

typedef TypeDeclInfo = {
    name: String,
    consop: String,
    consargs: List<{cname: String, ctype: String}>
};

entity TypeInfoEmitter {
    field assembly: TreeIR::Assembly;

    method getTypeTag(t: TreeIR::Type): String {
        return String::concat(List<String>{"@TypeTag-", smtifyType(t.tkey)});
    }

    function typeRequiresTagInfo(t: TreeIR::Type): Bool {
        match(t) {
            TreeIR::PrimitiveInternalEntityType => return false;
            | TreeIR::HavocEntityType => return false;
            | TreeIR::TaskType => return false;
            | _ => return true;
        }
    }

    function typeRequiresKeyTypeTagInfo(t: TreeIR::Type): Bool {
        return t?<OOType> && t@<OOType>.iskeytype;
    }

    function typeRequiresSubTypeTypeTagInfo(t: TreeIR::Type): Bool {
        if(t.supertypes?none || t.supertypes@!none.empty()) {
            return false;
        }

        return t.supertypes@!none.someOf(pred(st) => st !== "Any"_TreeIR::TypeKey && st !== "Some"_TreeIR::TypeKey);
    }

    method emitEnumEntityTypeDecl(t: TreeIR::EnumEntityType): TypeDeclInfo {
        return {name="[ENUM]", consop="[ENUM_cons]", consargs=List<{cname: String, ctype: String}>{}};
    }

    method emitTypedeclEntityTypeDecl(t: TreeIR::TypedeclEntityType): TypeDeclInfo {
        return {name="[TYPEDECL]", consop="[TYPEDECL_cons]", consargs=List<{cname: String, ctype: String}>{}};
    }

    method emitObjectEntityTypeDecl(t: TreeIR::ObjectEntityType): TypeDeclInfo {
        return {name="[OBJECT]", consop="[OBJECT_cons]", consargs=List<{cname: String, ctype: String}>{}};
    }

    method emitTaskTypeDecl(t: TreeIR::TaskType): TypeDeclInfo {
        return {name="[TASK]", consop="[TASK_cons]", consargs=List<{cname: String, ctype: String}>{}};
    }

    function typeRequiresOODeclInfo(t: TreeIR::Type): Bool {
        match(t) {
            TreeIR::EnumEntityType => return true;
            | TreeIR::TypedeclEntityType => return true;
            | TreeIR::ObjectEntityType => return true;
            | TreeIR::TaskType => return true;
            | _ => return false;
        }
    }

    method generateOOSMTDecl(t: TreeIR::Type): TypeDeclInfo {
        match(t) {
            TreeIR::EnumEntityType => return this.emitEnumEntityTypeDecl($);
            | TreeIR::TypedeclEntityType => return this.emitTypedeclEntityTypeDecl($);
            | TreeIR::ObjectEntityType => return this.emitObjectEntityTypeDecl($);
            | TreeIR::TaskType => return this.emitTaskTypeDecl($);
        }
    }

    method emitEnumEntityTypeBinder(t: TreeIR::EnumEntityType): String {
        return "[ENUM]";
    }

    method emitTypedeclEntityTypeBinder(t: TreeIR::TypedeclEntityType): String {
        return "[TYPEDECL]";
    }

    method emitObjectEntityTypeBinder(t: TreeIR::ObjectEntityType): String {
        return "[OBJECT]";
    }

    method emitPrimitiveInternalEntityTypeBinder(t: TreeIR::PrimitiveInternalEntityType): String {
        return "[PRIMITIVE]";
    }

    function typeRequiresIOBinder(t: TreeIR::Type): Bool {
        match(t) {
            TreeIR::EnumEntityType => return true;
            | TreeIR::TypedeclEntityType => return true;
            | TreeIR::ObjectEntityType => return true;
            | TreeIR::PrimitiveInternalEntityType => return true;
            | _ => return false;
        }
    }

    method generateSMTIOBinder(t: TreeIR::Type): TypeDeclInfo {
        match(t) {
            TreeIR::EnumEntityType => return this.emitEnumEntityTypeBinder($);
            | TreeIR::TypedeclEntityType => return this.emitTypedeclEntityTypeBinder($);
            | TreeIR::ObjectEntityType => return this.emitObjectEntityTypeBinder($);
            | TreeIR::PrimitiveInternalEntityType => return this.emitPrimitiveInternalEntityTypeBinder($);
        }
    }
}

entity AssemblyEmitter {
    function processAssembly(asm: TreeIR::Assembly): TreeIR::Assembly {
        //TODO: explicitly place code -- put validation/pre/post code in the right places
        //TODO: flatten expressions -- error inducing expressions and calls are at top-level
        //TODO: inline as needed
        //TODO: ensure bodies are trees
        //TODO: make are variable assignments unique

        return asm;
    }

    function generateTypeTagInfo(flatasm: TreeIR::Assembly): {type_tag_decls: String, type_tag_distincts: String, key_type_tag_sort: String, type_tag_subtype: String} {    
        let temitter = TypeInfoEmitter{flatasm};
        let alltypes = flatasm.typeMap.values();

        let tagdeclinfo = alltypes
            .filter(pred(t) => TypeInfoEmitter::typeRequiresTagInfo(t))
            .map<String>(fn(t) => temitter.getTypeTag(t))
            .keySort();

        let keytaginfo = alltypes
            .filter(pred(t) => TypeInfoEmitter::typeRequiresKeyTypeTagInfo(t))
            .map<String>(fn(t) => temitter.getTypeTag(t))
            .keySort();
        
        let korder = alltypes
            .filter(pred(t) => TypeInfoEmitter::typeRequiresKeyTypeTagInfo(t) && !t?<TreeIR::PrimitiveInternalEntityType>)
            .map<String>(fn(t) => temitter.getTypeTag(t))
            .keySort()
            .mapIdx<String>(fn(kt, ii) => {
                let ltt = if (ii == 0n) then "@TypeTag-SHAContentHash" else keytaginfo.get(ii - 1n);
                return String::concat(List<String>{"assert (@key_type_sort_order ", ltt, " ", kt, "))"});
            });

        let subtypeinfo = alltypes
            .filter(pred(t) => TypeInfoEmitter::typeRequiresSubTypeTypeTagInfo(t));

        return {
            type_tag_decls = String::join("\n", tagdeclinfo.map<String>(fn(tg) => String::concat(List<String>{"(declare-const ", tg, " @TypeTag)"}))),
            type_tag_distincts = String::join("\n", tagdeclinfo),
            key_type_tag_sort = String::join("\n", korder),
            type_tag_subtype = "[NOT IMPLEMENTED]"
        };
    }

    function generateTypeDecls(flatasm: TreeIR::Assembly): {oo_decls: String, oo_constructors: String} {
        let temitter = TypeInfoEmitter{flatasm};
        let alltypes = flatasm.typeMap.values();

        let oodeclinfo = alltypes
            .filter(pred(t) => TypeInfoEmitter::typeRequiresOODeclInfo(t))
            .map<TypeDeclInfo>(fn(t) => temitter.generateOOSMTDecl(t));
            
        return {
            oo_decls = String::join("\n    ", oodeclinfo.map<String>(fn(vv) => String::concat(List<String>{"(", vv.name, " 0)"}))),
            oo_constructors = "[NOT IMPLEMENTED]"
        };
    }

    function generateSMTCode(flatasm: TreeIR::Assembly, invokeResultErrMap: Map<TreeIR::InvokeKey, TreeIR::ErrorKind>): String {
        let idecls = flatasm.invokeMap.mapFlat<String>(fn(k, i) => {
            let iname = smtifyInvokeKey(i.invkey);
            let rtype = i.resultType;
            let rerr = if(invokeResultErrMap.has(i.invkey)) then invokeResultErrMap.get(i.invkey) else TreeIR::ErrorKind::safe;
            let bemitter = BodyEmitter{flatasm, i.srcFile, -1i, invokeResultErrMap, rtype, rerr};
            
            let args = i.params.map<String>(fn(p) => String::concat(List<String>{"(", p.name, " ", emitTypeName(p.type), ")"}));

            let body = match (i) {
                TreeIR::InvokeImplementation => bemitter.emitBodyStatementList($.body)
                | TreeIR::InvokePrimitive => "PRIMITIVE DECL"
                | _ => ""
            };

            if(body === "") {
                return "";
            }
            else {
                return String::concat(List<String>{"(define-fun ", iname, " (", String::join(" ", args), ") ", emitTypeName(rtype), "\n", body, "\n)"});
            }
        });

        return String::join("\n", idecls);
    }
}
