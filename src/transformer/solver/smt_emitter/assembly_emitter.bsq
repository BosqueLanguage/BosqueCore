namespace SMTEmit;

import TreeIR;

function typeEncodedAsUnion(tt: TreeIR::TypeKey): Bool {
    let ttype = this.assembly.typeMap.get(tt);
    return (ttype?<TreeIR::ConceptType> || ttype?<TreeIR::UnionType>);
}

entity TypeInfoEmitter {
    field assembly: TreeIR::Assembly;
    field nemitter: NameEmitter;

    method getSMTTypeName(t: TreeIR::Type | TreeIR::TypeKey): String {
        let ttype = if <TreeIR::Type> (t) then $ else this.assembly.typeMap.get($);
        return this.nemitter.getSMTTypeName(ttype);
    }

    method emitKeyTypeTagDecl(t: TreeIR::Type): String? {
        if(!t?<OOType> || t?<TreeIR::PrimitiveInternalEntityType>) {
            return none;
        }

        if(t@<OOType>.iskeytype) {
            return this.nemitter.getKeyTagName(t.tkey);
        }
        else {
            return none;
        }
    }

    function typeRequiresConstructorInfo(t: TreeIR::Type): Bool {
        match(t) {
            TreeIR::ObjectEntityType => return true;
            | TreeIR::EnumEntityType => return true;
            | TreeIR::MapEntryEntityType => return true;
            | TreeIR::TupleType => return true;
            | TreeIR::RecordType => return true;
            | TreeIR::EListType => return true;
            | _ => return false;
        }
    }

    method generateDeclAndConsInfo(t: TreeIR::Type): {decl: String, cons: String}? {
        if(!TypeInfoEmitter::typeRequiresConstructorInfo(t)) {
            return none;
        }

        let smtname = this.getSMTTypeName(t);
        let smttype = smtifyTypeKey(t.tkey);

        let tdecl = String::concat(List<String>{"(", smttype, " 0)"});

        var tcons: String;
        match(t) {
            TreeIR::ObjectEntityType => {
                let consops = $.allfields.map<String>(fn(f) => String::concat(List<String>{"(", this.nemitter.getFieldAccessorName($.tkey, f.fkey), " ", this.getSMTTypeName(f.ftype), ")"}));
                tcons = String::concat(List<String>{"( (", this.nemitter.getConstructorName($.tkey), " ", String::join(" ", consops), ") )"});
            }
            | TreeIR::EnumEntityType => {
                let consop = String::concat(List<String>{"(", this.nemitter.getEnumValueAccessorName($.tkey), " Int)"});
                tcons = String::concat(List<String>{"( (", this.nemitter.getConstructorName($.tkey), " ", consop, ")) )"});
            }
            | TreeIR::MapEntryEntityType => {
                let consops = List<String>{String::concat(List<String>{"(", this.nemitter.getMapEntryKeyAccessorName($.tkey), " ", this.getSMTTypeName($.typeK), ")"}), String::concat(List<String>{"(", this.nemitter.getMapEntryValueAccessorName($.tkey), " ", this.getSMTTypeName($.typeV), ")"})};
                tcons = String::concat(List<String>{"( (", this.nemitter.getConstructorName(t.tkey), " ", String::join(" ", consops), ") )"});
            }
            | TreeIR::TupleType => {
                let consops = $.types.mapIdx<String>(fn(te, i) => String::concat(List<String>{"(", this.nemitter.getIndexAccessorName($.tkey, i), " ", this.getSMTTypeName(te), ")"}));
                tcons = String::concat(List<String>{"( (", this.nemitter.getConstructorName($.tkey), " ", String::join(" ", consops), ") )"});
            }
            | TreeIR::RecordType => {
                let consops = $.entries.map<String>(fn(re) => String::concat(List<String>{"(", this.nemitter.getPropertyAccessorName($.tkey, re.pname), " ", this.getSMTTypeName(re.ptype), ")"}));
                tcons = String::concat(List<String>{"( (", this.nemitter.getConstructorName($.tkey), " ", String::join(" ", consops), ") )"});
            }
            | TreeIR::EListType => {
                let consops = $.types.mapIdx<String>(fn(ee, i) => String::concat(List<String>{"(", this.nemitter.getIndexAccessorName($.tkey, i), " ", this.getSMTTypeName(ee), ")"}));
                tcons = String::concat(List<String>{"( (", this.nemitter.getConstructorName($.tkey), " ", String::join(" ", consops), ") )"});
            }
        }

        return {decl=tdecl, cons=tcons};
    }

    function typeRequiresBoxingInfo(t: TreeIR::Type): Bool {
        match(t) {
            TreeIR::PrimitiveInternalEntityType => return false;
            | TreeIR::HavocEntityType => return false;
            | TreeIR::TaskType => return false;
            | TreeIR::ConceptType => return false;
            | TreeIR::ConceptSetType => return false;
            | TreeIR::UnionType => return false;
            | _ => return true;
        }
    }

    method generateBoxAndUnboxInfo(t: TreeIR::Type): {box: String, unbox: String, typebox: String}? {
        if(!TypeInfoEmitter::typeRequiresBoxingInfo(t)) {
            return none;
        }

        let smtname = this.getSMTTypeName(t);
        let smttype = smtifyTypeKey(t.tkey);

        let btname = this.nemitter.getBoxDataMKName(t.tkey);
        let btfname = this.nemitter.getBoxDataMKNameField(t.tkey);
        let typebox = String::concat(List<String>{"(", btname, " (", btfname, " ", smtname, "))"});

        let bname = this.nemitter.getBoxName(t.tkey);
        let ubname = this.nemitter.getUnboxName(t.tkey);

        var box: String;
        if (!t?<OOType> || !t@<OOType>.iskeytype) {
            box = String::concat(List<String>{"(define-fun ", bname, " ((v ", smtname, ")) @Term (@Term-mk (", btfname, " v) @BoxedKey-mk-NA))"});
        }
        else {
            let bkk = String::concat(List<String>{"(@BoxedKey-mk-of @KeyTypeTag-", smtname, " (@BoxedKeyValue-mk-", smtname, " v))"});
            box = String::concat(List<String>{"(define-fun ", bname, " ((v ", smtname, ")) @Term (@Term-mk (", btfname, " v) ", bkk, "))"});
        }

        let unbox = String::concat(List<String>{"(", ubname, " ((t @Term)) ", smtname, " (",  btfname, " (@Term-data t)))"});

        return {box=box, unbox=unbox, typebox=typebox};
    }






    function typeRequiresSuperTypeTypeTagInfo(t: TreeIR::Type): Bool {
        if(t.tkey == "Any"_TreeIR::TypeKey || t.tkey == "Some"_TreeIR::TypeKey) {
            return false;
        }

        return match(t) {
            TreeIR::ConceptType => true
            | TreeIR::ConceptSetType => true
            | TreeIR::UnionType => true
            | _ => false
        };
    }

    function typeRequiresIOBinder(t: TreeIR::Type): Bool {
        match(t) {
            TreeIR::EnumEntityType => return true;
            | TreeIR::TypedeclEntityType => return true;
            | TreeIR::ObjectEntityType => return true;
            | TreeIR::PrimitiveInternalEntityType => return true;
            | _ => return false;
        }
    }
}

entity AssemblyEmitter {
    field assembly: TreeIR::Assembly;
    field nemitter: NameEmitter;
    field temitter: TypeInfoEmitter;

    function processAssembly(asm: TreeIR::Assembly): TreeIR::Assembly {
        //TODO: ensure bodies are trees
        //TODO: make all variable assignments unique
        //TODO: flatten expressions -- error inducing expressions and calls are at top-level

        return asm;
    }

    method generateKeyTypeTagInfo(): {key_type_tag_decls: String, key_type_tag_distincts: String, key_type_tag_sort: String} {
        let alltypes = this.assembly.typeMap.values();
        let ktags = alltypes.map<String?>(fn(t) => this.temitter.emitKeyTypeTagDecl(t)).filterSome();

        let kdecls = String::join("\n", ktags.map<String>(fn(kt) => String::concat(List<String>{"(declare-const ", kt, " @KeyTypeTag)"})));
        let kdistincts = String::join(" ", ktags);
        let ksort = String::join("\n", ktags.mapIdx<String>(fn(kt, ii) => {
            let ltt = if (ii == 0n) then "@KeyTypeTag-SHAContentHash" else ktags.get(ii - 1n);
            return String::concat(List<String>{"(assert (@key_type_sort_order ", ltt, " ", kt, "))"});
        }));

        return {key_type_tag_decls=kdecls, key_type_tag_distincts=kdistincts, key_type_tag_sort=ksort};
    }

    method generateDeclAndConsInfo(): {decls: String, cons: String} {
        let alltypes = this.assembly.typeMap.values();

        let ccinfo = alltypes.map<{decl: String, cons: String}?>(fn(t) => this.temitter.generateDeclAndConsInfo(t)).filterSome();
        let ddecls = String::join("\n    ", ccinfo.map<String>(fn(vv) => vv.decl));
        let dcons = String::join("\n        ", ccinfo.map<String>(fn(vv) => vv.cons));

        return {decls=ddecls, cons=dcons};
    }

    method generateBoxAndUnboxInfo(): {box: String, unbox: String, typebox: String} {
        let alltypes = this.assembly.typeMap.values();

        let bbinfo = alltypes.map<{box: String, unbox: String, typebox: String}?>(fn(t) => this.temitter.generateBoxAndUnboxInfo(t)).filterSome();
        let tbox = String::join("\n        ", bbinfo.map<String>(fn(vv) => vv.typebox));
        let bbox = String::join("\n", bbinfo.map<String>(fn(vv) => vv.box));
        let ubbox = String::join("\n", bbinfo.map<String>(fn(vv) => vv.unbox));

        return {box=bbox, unbox=ubbox, typebox=tbox};
    }

    /*
    method generateTypeTagInfo(): {key_type_tag_decls: String, key_type_tag_distincts: String, key_type_tag_sort: String, type_subtype: String} {    
        let alltypes = this.assembly.typeMap.values();


        let subtypeinfo = alltypes
            .filter(pred(t) => TypeInfoEmitter::typeRequiresSubTypeTypeTagInfo(t))
            .map<String>(fn(t) => {
                let ttag = this.temitter.getSMTTypeTag(t);
                let stags = t.supertypes@!none.filter(pred(st) => st !== "Some"_TreeIR::TypeKey && st !== "Any"_TreeIR::TypeKey).map<String>(fn(st) => this.temitter.getSMTTypeTag(st));
                let relations = stags.map<String>(fn(st) => String::concat(List<String>{"(assert (@subtypeof ", ttag, " ", st, "))"}));

                return String::join(" ", relations);
            });

        return {
            key_type_tag_decls = String::join("\n", tagdeclinfo.map<String>(fn(tg) => String::concat(List<String>{"(declare-const ", tg, " @TypeTag)"}))),
            key_type_tag_distincts = String::join("\n", tagdeclinfo),
            key_type_tag_sort = String::join("\n", korder),
            type_subtype = String::join("\n", subtypeinfo)
        };
    }
    */

    method generateSMTCode(invokeResultErrMap: Map<TreeIR::InvokeKey, TreeIR::ErrorKind>): String {
        let idecls = this.assembly.invokeMap.mapFlat<String>(fn(k, i) => {
            let iname = smtifyInvokeKey(i.invkey);
            let rtype = i.resultType;
            let rerr = if(invokeResultErrMap.has(i.invkey)) then invokeResultErrMap.get(i.invkey) else TreeIR::ErrorKind::safe;
            let bemitter = BodyEmitter{this.assembly, this.nemitter, this.temitter, i.srcFile, -1i, invokeResultErrMap, rtype, rerr};
            
            let args = i.params.map<String>(fn(p) => {
                let pname = p.name.value().value();
                let ptype = this.temitter.getSMTTypeName(p.type);

                return String::concat(List<String>{"(", pname, " ", ptype, ")"});
            });

            let body = match (i) {
                TreeIR::InvokeImplementation => bemitter.emitBodyStatementList($.body)
                | TreeIR::InvokePrimitive => "PRIMITIVE DECL"
                | _ => ""
            };

            if(body === "") {
                return "";
            }
            else {
                let smtrtype = this.temitter.getSMTTypeName(rtype);
                return String::concat(List<String>{"(define-fun ", iname, " (", String::join(" ", args), ") ", smtrtype, "\n", body, "\n)"});
            }
        });

        return String::join("\n", idecls);
    }
}
