namespace SMTEmit;

import TreeIR;

entity TypeInfoEmitter {
    field assembly: TreeIR::Assembly;

    method generateSMTDecl(t: TreeIR::Type): String {
        return "TYPE DECL";
    }
}

entity AssemblyEmitter {
    function processAssembly(asm: TreeIR::Assembly): TreeIR::Assembly {
        //TODO: flatten expressions -- error inducing expressions and calls are at top-level
        //TODO: inline as needed
        //TODO: ensure bodies are trees
        //TODO: make are variable assignments unique

        return asm;
    }

    function generateSMTCode(flatasm: TreeIR::Assembly, smtcore: String, invokeResultErrMap: Map<TreeIR::InvokeKey, TreeIR::ErrorKind>): String {
        let temitter = TypeInfoEmitter{flatasm};
        let typedecls = flatasm.typeMap.mapFlat<String>(fn(k, t) => temitter.generateSMTDecl(t));

        let idecls = flatasm.invokeMap.mapFlat<String>(fn(k, i) => {
            let iname = smtifyInvokeKey(i.invkey);
            let rtype = i.resultType;
            let rerr = if(invokeResultErrMap.has(i.invkey)) then invokeResultErrMap.get(i.invkey) else TreeIR::ErrorKind::safe;
            let bemitter = BodyEmitter{flatasm, iname, i.srcFile, -1i, invokeResultErrMap, rtype, rerr};
            
            match (i) {
                TreeIR::InvokeImplementation => return bemitter.emitBodyStatementList($.body);
                | TreeIR::InvokePrimitive => return "PRIMITIVE DECL";
                | _ => return "";
            }
        });

        return String::concat(List<String>{String::join("\n", typedecls) + "\n" + String::join("\n", idecls)});
    }
}
