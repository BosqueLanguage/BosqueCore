namespace SMTEmit;

import TreeIR;

function unescapeString(str: String): String {
    return str;
}

function extractLiteralStringValue(str: String, unescape: Bool): String {
    return unescape ? unescapeString(str.removeFront("\"").removeEnd("\"")) : str;
}

function extractLiteralASCIIStringValue(Str: string, unescape: Bool): String {
    const ll = str.removeFront("ascii{").removeEnd("}");
    return unescape ? unescapeString(ll.removeFront("\"").removeEnd("\"")) : ll;
}

enum ArgExpErrorKind {
    safe,
    target,
    other,
    resource,
    anyT,
    anyO
}

function isSafeErrorKind(k: ArgExpErrorKind): Bool {
    return k === ArgExpErrorKind::safe;
}

function isOtherErrorKind(k: ArgExpErrorKind): Bool {
    return /\(k !== ArgExpErrorKind::safe, k !== ArgErrorKind::target, k !== ArgExpErrorKind::anyT);
}

function isTargetErrorKind(k: ArgExpErrorKind): Bool {
    return \/(k === ArgExpErrorKind::target, k === ArgErrorKind::anyT);
}

function joinArgExpErrorKinds(k1: ArgExpErrorKind, k2: ArgExpErrorKind): ArgExpErrorKind {
    if(k1 === k2) {
        return k1;
    }
    elif(\/(isTargetErrorKind(k1), isTargetErrorKind(k2))) {
        return ArgExpErrorKind::anyT;
    }
    else {
        return ArgExpErrorKind::anyO;
    }
}

function computeTargetErrorKind(l: List<ArgErrorOption>): ArgExpErrorKind {
    return l.reduce<ArgExpErrorKind>(ArgExpErrorKind::safe, fn(acc: ArgErrorKind, opt: ArgErrorOption): ArgErrorKind => joinArgExpErrorKinds(acc, opt.errkind));
}

datatype ArgExp using {
    field exp: String;
    field vexp: String;
    field argtype: TreeIR::TypeKey;
}
of
ArgOkOption { }
| ArgErrorOption {
    field vraw: String; //The variable to store this raw expression into
    field vok: String; //The variable to store/use when there is no error
    field errkind: ArgExpErrorKind;
}
;

entity SMTEmitResult {
    field exp: String;
    field einfo: ArgExpErrorKind;
}

entity BodyEmitter {
    field assembly: TreeIR::Assembly;

    field file: String;
    field ns: TreeIR::NamespaceIdentifier;

    field invokeErrMap: Map<TreeIR::InvokeKey, ArgErrorKind>;
    field expectedResultType: TreeIR::TypeKey;
    field resultErrKind: ArgErrorKind;

    function buildErrorIsTest(evar: String, errkind: ArgErrorKind): String {
        if(isOtherErrorKind(errkind)) {
            return String.concat(List<String>{"((_ is) @ResultO-mk-err ", evar, ")"});
        }
        else {
            return String.concat(List<String>{"((_ is) @ResultT-mk-err ", evar, ")"});
        }
    }

    function buildErrorExtract(evar: String, errkind: ArgErrorKind): String {
        if(isOtherErrorKind(errkind)) {
            return String.concat(List<String>{"(@ResultO-error ", evar, ")"});
        }
        else {
            return String.concat(List<String>{"(@ResultT-error ", evar, ")"});
        }
    }

    function buildValueExtract(okvar: String, errkind: ArgErrorKind): String {
        if(isOtherErrorKind(errkind)) {
            return String.concat(List<String>{"(@ResultO-value ", okvar, ")"});
        }
        else {
            return String.concat(List<String>{"(@ResultT-value ", okvar, ")"});
        }
    }

    function buildMakeError(evar: String, oftype: TReeIR::TypeKey, errkind: ArgErrorKind): String {
        if(isOtherErrorKind(errkind)) {
            return String.concat(List<String>{"(@ResultO-mk-err ", evar, ")"});
        }
        else {
            return String.concat(List<String>{"(@ResultT-mk-err ", evar, ")"});
        }
    }

    function buildMakeOk(okvar: String, oftype: TReeIR::TypeKey, errkind: ArgErrorKind): String {
        if(isOtherErrorKind(errkind)) {
            return String.concat(List<String>{"(@ResultO-mk-ok ", okvar, ")"});
        }
        else {
            return String.concat(List<String>{"(@ResultT-mk-ok ", okvar, ")"});
        }
    }

    function processArgExpErrorPassthrough(exp: String, exptype: TreeIR::TypeKey, experr: ArgErrorKind, trgttype: TreeIR::TypeKey, trgterr: ArgErrorKind): String {
        assert(/\(!isSafeErrorKind(experr), !isSafeErrorKind(trgterr)));

        if(/\(exptype === trgttype, isTargetErrorKind(experr) === isTargetErrorKind(trgterr))) {
            return exp;
        }
        else {
            return BodyEmitter::buildMakeError(BodyEmitter::buildErrorExtract(exp, experr), trgttype, trgterr);
        }
    }

    function processResultWrapSafe(exp: String, exptype: TreeIR::TypeKey, experr: ArgErrorKind): String {
        if(experr === ArgErrorKind::safe) {
            return exp;
        }
        else {
            return BodyEmitter::buildMakeOk(exp, exptype, experr);
        }
    }

    function processResultWrapGeneral(exp: String, exptype: TreeIR::TypeKey, experr: ArgErrorKind, operr: ArgErrorKind): String {
        if(experr === ArgErrorKind::safe) {
            return exp;
        }
        else {
            if(isTargetErrorKind(experr) === isTargetErrorKind(operr)) {
               return exp;
            }
            elif(isSafeErrorKind(operr)) {
                return BodyEmitter::buildMakeOk(exp, exptype, operr);
            }
            else {
                xxxx; //TODO need to do ok and error cases here + dynamic check if anyT
                return BodyEmitter::buildMakeError(BodyEmitter::buildErrorExtract(exp, operr), exptype, experr);
            }
        }
    }

    recursive method processArgSingle(exp: Expression, depth: Nat, idx: Nat, indent: String): ArgExp {
        let vv = this.emit[recursive](exp, depth + 1n, idx + ii, indent);

        if(vv.einfo === ArgExpErrorKind::safe) {
            return ArgOkOption{String::concat(List<String>{indent, vv.exp}), vv.exp, exp.etype};
        }
        else {
            let vraw = String.concat(List<String>{"@r", "-", String::fromNat(depth) + "-" + String.fromNat(idx + ii)});
            let vok = String.concat(List<String>{vraw, "-vv"});

            return ArgErrorOption{ee.exp, vok, exp.etype, vraw, vok, vv.einfo};
        }
    }

    ////
    //Specialize arg processing for single argument ops

    method applyBuilderUnary(op: String, argexp: ArgExp): String {
        return String::concat("(", op, " ", argexp.vexp, ")");
    }

    method buildOpUnary(arg: ArgExp, trgttype: TreeIR::TypeKey, trgterr: ArgErrorKind, opexp: String, indent: String): [String, ArgExpErrorKind] {
        if(arg?ArgOkOption) {
            return [opexp, ArgExpErrorKind::safe];
        }
        else {
            let ae = arg@ArgErrorOption;
            let iassigns = String.concat(List<String>{"(", ae.vraw, " ", ae.vexp, ")"});
            let okassigns = String.concat(List<String>{"(", ee.vok, " ", BodyEmitter::buildValueExtract(ae.vraw, ae.einfo), ")"});
            let vconv = BodyEmitter::processArgExpErrorPassthrough(ae.vraw, ae.argtype, ae.einfo, trgttype, trgterr);

            let opstr = String.concat(List<String>{
                indent, "(let (", String::join("\n", indent, "    ", iassigns), "\n", indent, ") (ite ", BodyEmitter::buildErrorIsTest(ae.vraw, ae.einfo), " ", vconv, " (let (", okassigns, ")\n", 
                    indent, "  ", opexp,
                "\n", indent, ")))"
            });

            return [opstr, opexp.einfo];
        }
    }

    ////
    //Specialize arg processing for binary argument ops
    recursive method processArgItemsBinary(arglhs: Expression, argrhs: Expression, depth: Nat, idx: Nat, indent: String): [ArgExp, ArgExp] {
        return [this.processArgSingle[recursive](arglhs, depth, idx, indent), this.processArgSingle[recursive](argrhs, depth, idx + 1n, indent)];
    }

    method buildArgErrPassthroughBinary(optlhs: ArgErrorOption, optrhs: ArgErrorOption, trgttype: TreeIR::TypeKey, trgterr: ArgErrorKind): [String, ArgExpErrorKind] {
        let lhsconv = BodyEmitter::processArgExpErrorPassthrough(optlhs.vraw, optlhs.argtype, optlhs.einfo, trgttype, trgterr);
        let rhsconv = BodyEmitter::processArgExpErrorPassthrough(optrhs.vraw, optrhs.argtype, optrhs.einfo, trgttype, trgterr);

        return [String.concat(List<String>{"(ite ", BodyEmitter::buildErrorIsTest(optlhs.vraw, this.resultErrKind), " ", lhsconv, " ", rhsconv, ")"}), joinArgExpErrorKinds(optlhs.einfo, optrhs.einfo)];
    }

    method applyBuilderBinary(op: String, arglhs: ArgExp, argrhs: ArgExp): String {
        return String::concat("(", op, " ", arglhs, " ", argrhs, ")");
    }

    method buildOpBinary(arglhs: ArgExp, argrhs: ArgExp, trgttype: TreeIR::TypeKey, trgterr: ArgErrorKind, opexp: String, indent: String): [String, ArgExpErrorKind] {
        if(/\(arglhs?ArgOkOption, argrhs?ArgOkOption)) {
            return [opexp, ArgExpErrorKind::safe];
        }
        elif(\/(arglhs?ArgOkOption, argrhs?ArgOkOption)) {
            let ae = if<ArgErrorOption>(arglhs) then arglhs@ArgErrorOption else argrhs@ArgErrorOption;
            let iassigns = String.concat(List<String>{"(", ae.vraw, " ", ae.vexp, ")"});
            let okassigns = String.concat(List<String>{"(", ee.vok, " ", BodyEmitter::buildValueExtract(ae.vraw, ae.einfo), ")"});
            let vconv = BodyEmitter::processArgExpErrorPassthrough(ae.vraw, ae.argtype, ae.einfo, trgttype, trgterr);

            let opstr = String.concat(List<String>{
                indent, "(let (", String::join("\n", indent, "    ", iassigns), "\n", indent, ") (ite ", BodyEmitter::buildErrorIsTest(ae.vraw, ae.einfo), " ", vconv, " (let (", okassigns, ")\n", 
                    indent, "  ", opexp, 
                "\n", indent, ")))"
            });

            return [opstr, ae.einfo];
        }
        else {
            let chkexps = List<ArgErrorOption>{arglhs@ArgErrorOption, argrhs@ArgErrorOption};

            let iassigns = chkexps.map<ArgExp>(fn(ae: ArgErrorOption): String => String.concat(List<String>{"(", ae.vraw, " ", ae.vexp, ")"}));
            let ichk = chkexps.map<ArgExp>(fn(ae: ArgErrorOption): String => BodyEmitter::buildErrorIsTest(ae.vraw, ae.einfo));
            let erropt = this.buildArgErrPassthroughBinary(chkexps[0], chkexps[1], trgttype, trgterr);
            let okassigns = chkexps.map<ArgExp>(fn(ae: ArgErrorOption): String => String.concat(List<String>{"(", ae.vok, " ", BodyEmitter::buildValueExtract(ae.vraw, ae.einfo), ")"}));

            let opstr = String.concat(List<String>{
                indent, "(let (", String::join("\n", indent, "    ", iassigns), "\n", indent, ") (ite (or ", String::join(", ", ichk), " ) ", erropt.0,  " (let (", String::join(" ", okassigns), ")\n", 
                    indent, "  ", opexp, 
                "\n", indent, ")))"
            });

            return [opstr, erropt.1];
        }
    }

    recursive method processArgsItems(args: List<Expression>, depth: Nat, idx: Nat, indent: String): List<ArgExp> {
        return args.mapIdx<ArgExp>(recursive fn(exp: Expression, ii: Nat): ArgExp {
            return this.processArgSingle[recursive](exp, depth, idx + ii, indent);
        });
    }

    recursive method buildErrPassthrough(opts: List<ArgErrorOption>, trgttype: TreeIR::TypeKey, trgterr: ArgErrorKind): String {
        if(opts.isSingleton()) {
            let opt = opts.getSingleton();
            return BodyEmitter::processArgExpErrorPassthrough(opt.vraw, opt.argtype, opt.einfo, trgttype, trgterr);
        }
        else {
            let opt = opts.front();
            return String.concat(List<String>{
                "(ite ", BodyEmitter::buildErrorIsTest(opt.vraw, opt.einfo), " ", BodyEmitter::processArgExpErrorPassthrough(opt.vraw, opt.argtype, opt.einfo, trgttype, trgterr), " ", this.buildErrPassthrough[recursive](opts.popFront()), ")"
            });
        }
    }

    method buildErrRet(opts: List<ArgErrorOption>, trgttype: TreeIR::TypeKey, trgterr: ArgErrorKind): [String, ArgExpErrorKind] {
        if(aops.allOf(pred(opt: ArgErrorOption): Bool => opt.errkind === ArgExpErrorKind::target)) {
            return [this.buildMakeError("@error-target", trgttype, trgterr), ArgExpErrorKind::target];
        }
        else if(aops.allOf(pred(opt: ArgErrorOption): Bool => opt.errkind === ArgExpErrorKind::resource)) {
            return [this.buildMakeError("@error-resource", trgttype, trgterr), ArgExpErrorKind::resource]
        }
        else if(aops.allOf(pred(opt: ArgErrorOption): Bool => opt.errkind === ArgExpErrorKind::other)) {
            return [this.buildMakeError("@error-other", trgttype, trgterr), ArgExpErrorKind::other]
        }
        else {
            let anyopt = if (aops.someOf(pred(opt: ArgErrorOption): Bool => opt.errkind === ArgExpErrorKind::target)) then ArgExpErrorKind::anyT else ArgExpErrorKind::anyO;
            return [this.buildErrPassthrough(aops, trgttype, trgterr), anyopt];
        }
    }

    method applyBuilder(op: String, args: List<ArgExp>): String {
        return String::concat("(", op, " ", String::join(" ", argexps.map(fn(argexp) => argexp.vexp)), ")");
    }

    method buildOp(args: List<ArgExp>, trgttype: TreeIR::TypeKey, trgterr: ArgErrorKind, opexp: String, indent: String): [String, ArgExpErrorKind] {
        if(args.allOf(pred(ae: ArgExp): Bool => a?ArgOkOption)) {
            return [opexp, ArgExpErrorKind::safe];
        }
        else {
            let chkexps = args.filterType<ArgErrorOption>();

            let iassigns = chkexps.map<ArgExp>(fn(ae: ArgErrorOption): String => String.concat(List<String>{"(", ae.vraw, " ", ae.vexp, ")"}));
            let ichk = chkexps.map<ArgExp>(fn(ae: ArgErrorOption): String => BodyEmitter::buildErrorIsTest(ae.vraw, ae.einfo));
            let erropt = this.buildErrRet(chkexps, trgttype, trgterr);
            let okassigns = chkexps.map<ArgExp>(fn(ae: ArgErrorOption): String => String.concat(List<String>{"(", ae.vok, " ", BodyEmitter::buildValueExtract(ae.vraw, ae.einfo), ")"}));

            let opstr = String.concat(List<String>{
                indent, "(let (", String::join("\n", indent, "    ", iassigns), "\n", indent, ") (ite (or ", String::join(", ", ichk), " ) ", erropt.0,  " (let (", String::join(" ", okassigns), ")\n", 
                    indent, "  ", opexp, 
                "\n", indent, ")))"
            });

            return [opstr, erropt.1];
        }
    }

    method emitLiteralNoneExpression(exp: TreeIR::LiteralNoneExpression): [String, ArgExpErrorKind] {
        return ["@none", ArgExpErrorKind::safe];
    }

    method emitLiteralNothingExpression(exp: TreeIR::LiteralNothingExpression): [String, ArgExpErrorKind] {
        return ["@nothing", ArgExpErrorKind::safe];
    }
    
    method emitLiteralBoolExpression(exp: TreeIR::LiteralBoolExpression): [String, ArgExpErrorKind] {
        return [if(exp.value) then "true" else "false", ArgExpErrorKind::safe];
    }

    method emitLiteralIntegralExpression(exp: TreeIR::LiteralIntegralExpression): [String, ArgExpErrorKind] {
        return [exp.expstr.removeEnd("n"), ArgExpErrorKind::safe];
    }

    method emitLiteralRationalExpression(exp: TreeIR::LiteralRationalExpression): [String, ArgExpErrorKind] {
        return [String.concat(List<String>{"@Rational_uninterp(", exp.expstr, ")"}), ArgExpErrorKind::safe];
    }

    method emitLiteralFloatPointExpression(exp: TreeIR::LiteralFloatPointExpression): [String, ArgExpErrorKind] {
        let fstr: String = if(exp.etype === "Float") then exp.value.removeEnd("f") else exp.value.removeEnd("d"), ArgExpErrorKind::safe];

        if(fstr === "0.0") {
            return [if(exp.etype === "Float") then "@Float_0" else "@Decimal_0", ArgExpErrorKind::safe];
        }
        else {
            return [if(exp.etype === "Float") then String.concat(List<String>{"@Float_uninterp(", exp.expstr, ")"}) else String.concat(List<String>{"@Decimal_uninterp(", exp.expstr, ")"}), ArgExpErrorKind::safe];
        }
    }

    method emitLiteralRegexExpression(exp: TreeIR::LiteralRegexExpression): [String, ArgExpErrorKind] {
        return ["[NOT IMPLEMENTED Regex]", ArgExpErrorKind::safe];
    }

    method emitLiteralStringExpression(exp: TreeIR::LiteralStringExpression): [String, ArgExpErrorKind] {
        return [extractLiteralStringValue(exp.value, false), ArgExpErrorKind::safe];
    }

    method emitLiteralASCIIStringExpression(exp: TIRLiteralASCIIStringExpression): [String, ArgExpErrorKind] {
        return [extractLiteralASCIIStringValue(exp.value, false), ArgExpErrorKind::safe];
    }
    
    method emitLiteralTypedStringExpression(exp: TreeIR::LiteralTypedStringExpression): [String, ArgExpErrorKind] {
        return [extractLiteralStringValue(exp.value, false), ArgExpErrorKind::safe];
    }

    method emitLiteralASCIITypedStringExpression(exp: TreeIR::LiteralASCIITypedStringExpression): [String, ArgExpErrorKind] {
        return [extractLiteralASCIIStringValue(exp.value, false), ArgExpErrorKind::safe];
    }
    
    method emitLiteralTemplateStringExpression(exp: TreeIR::LiteralTemplateStringExpression): [String, ArgExpErrorKind] {
        return [extractLiteralStringValue(exp.value, false), ArgExpErrorKind::safe];
    }

    method emitLiteralASCIITemplateStringExpression(exp: TreeIR::LiteralASCIITemplateStringExpression): [String, ArgExpErrorKind] {
        return [extractLiteralASCIIStringValue(exp.value, false), ArgExpErrorKind::safe];
    }
    
    method emitLiteralTypedPrimitiveDirectExpression(exp: TreeIR::LiteralTypedPrimitiveDirectExpression): [String, ArgExpErrorKind] {
        return ["[NOT IMPLEMENTED TypedPrimitiveDirect]", ArgExpErrorKind::safe];
    }

    method emitLiteralTypedPrimitiveConstructorExpression(exp: TreeIR::LiteralTypedPrimitiveConstructorExpression): [String, ArgExpErrorKind] {
        return ["[NOT IMPLEMENTED TypedPrimitiveConstructor]", ArgExpErrorKind::safe];
    }

    method emitAccessEnvValueExpression(exp: TreeIR::AccessEnvValueExpression): [String, ArgExpErrorKind] {
        return ["[NOT IMPLEMENTED EnvValue]", ArgExpErrorKind::safe];
    }

    method emitAccessNamespaceConstantExpression(exp: TreeIR::AccessNamespaceConstantExpression): [String, ArgExpErrorKind] {
        return [String.concat(List<String>{smtifyNamespace(exp.ns), SMTEncodingSymbol::coloncolon, smtifyIdentifier(exp.cname)}), ArgExpErrorKind::safe];
    }

    method emitAccessConstMemberFieldExpression(exp: TreeIR::AccessConstMemberFieldExpression): [String, ArgExpErrorKind] {
        return [String.concat(List<String>{smtifyType(exp.tkey), SMTEncodingSymbol::coloncolon, smtifyIdentifier(exp.cname)}), ArgExpErrorKind::safe];
    }

    method emitAccessVariableExpression(exp: TreeIR::AccessVariableExpression): [String, ArgExpErrorKind] {
        return [smtifyIdentifier(exp.name), ArgExpErrorKind::safe];
    }
/*
    method emitAccessCapturedVariableExpression(exp: TIRAccessCapturedVariableExpression): String {
        return `$CodePack.${exp.name}`;
    }

    method emitAccessScratchSingleValueExpression(exp: TIRAccessScratchSingleValueExpression): String {
        this.m_hasScratch = true;
        return `$$scratch[${exp.sidx}]`;
    }

    method emitAccessScratchIndexExpression(exp: TIRAccessScratchIndexExpression): String {
        this.m_hasScratch = true;
        return `$$scratch[${exp.sidx}][${exp.index}]`
    }

    method emitLoadIndexExpression(exp: TIRLoadIndexExpression): String {
        return `${this.emitExpression(exp.exp)}[${exp.index}]`;
    }

    method emitLoadPropertyExpression(exp: TIRLoadPropertyExpression): String {
        return `${this.emitExpression(exp.exp)}.${exp.property}`;
    }

    method emitLoadFieldExpression(exp: TIRLoadFieldExpression): String {
        const fname = (this.m_assembly.fieldMap.get(exp.fieldkey) as TIRMemberFieldDecl).name;
        return `${this.emitExpression(exp.exp)}.${fname}`;
    }

    method emitLoadFieldVirtualExpression(exp: TIRLoadFieldVirtualExpression): String {
        const fname = (this.m_assembly.fieldMap.get(exp.fieldkey) as TIRMemberFieldDecl).name;
        const bexp = (this.typeEncodedAsUnion(exp.exp.etype) ? `${this.emitExpression(exp.exp)}.value` : this.emitExpression(exp.exp));

        return `${bexp}.${fname}`;
    }

    method emitConstructorPrimaryDirectExpression(exp: TIRConstructorPrimaryDirectExpression): String {
        const tname = this.resolveTypeMemberAccess(exp.oftype);
        const args = exp.args.map((arg) => this.emitExpression(arg, true));

        return `${tname}.$constructorDirect(${args.join(", ")})`;
    }

    method emitConstructorPrimaryCheckExpression(exp: TIRConstructorPrimaryCheckExpression): String {
        const tname = this.resolveTypeMemberAccess(exp.oftype);
        const args = exp.args.map((arg) => this.emitExpression(arg, true));
        
        return `${tname}.$constructorWithChecks(${args.join(", ")})`;
    }

    method emitConstructorTupleExpression(exp: TIRConstructorTupleExpression): String {
        return `[${exp.args.map((arg) => this.emitExpression(arg, true)).join(", ")}]`;
    }

    method emitConstructorRecordExpression(exp: TIRConstructorRecordExpression): String {
        const tt = this.m_assembly.getTypeAs<TIRRecordType>(exp.oftype);
        const entries = exp.args.map((arg, ii) => `${tt.entries[ii].pname}: ${this.emitExpression(arg, true)}`);
        return `{${entries.join(", ")}}`;
    }

    method emitConstructorListExpression(exp: TIRConstructorListExpression): String {
        return `$CoreLibs.$ListOps.create(${exp.args.map((arg) => this.emitExpression(arg, true)).join(", ")})`;
    }

    method emitConstructorMapExpression(exp: TIRConstructorMapExpression): String {
        return `$CoreLibs.$MapOps.create("${exp.etype}", ${exp.args.map((arg) => this.emitExpression(arg, true)).join(", ")})`;
    }

    method emitCodePackInvokeExpression(exp: TIRCodePackInvokeExpression): String {
        return `($Runtime.lambdas.get("${exp.cpack.invk}"))(${[...exp.args.map((arg) => this.emitExpression(arg, true))].join(", ")})`;
    }

    method emitResultOkConstructorExpression(exp: TIRResultOkConstructorExpression, toplevel: boolean): String {
        return this.emitExpression(exp.arg, toplevel);
    }

    method emitResultErrConstructorExpression(exp: TIRResultErrConstructorExpression, toplevel: boolean): String {
        return this.emitExpression(exp.arg, toplevel);
    }

    method emitSomethingConstructorExpression(exp: TIRSomethingConstructorExpression, toplevel: boolean): String {
        return this.emitExpression(exp.arg, toplevel);
    }

    method emitTypedeclDirectExpression(exp: TIRTypedeclDirectExpression, toplevel: boolean): String {
        return this.emitExpression(exp.arg, toplevel);
    }

    method emitTypedeclConstructorExpression(exp: TIRSomethingConstructorExpression): String {
        return `${this.resolveTypeMemberAccess(exp.oftype)}.$constructorWithChecks(${this.emitExpression(exp.arg, true)})`;
    }
*/
    method emitCallNamespaceFunctionExpression(exp: TreeIR::CallNamespaceFunctionExpression, depth: Nat, indent: String): [String, ArgExpErrorKind] {
        let invks = this.assembly.namespaceMap.get(exp.ns).functions.get(exp.fname);
        let invk = invks.find(pred(ii) => ii.ikey === exp.fkey);

        let argexps = this.processArgsItems[recursive](exp.args, depth + 1, indent);
        let trgterr = computeTargetErrorKind(argexps); 

        xxxx; //TODO -- preconditions
        let opexp = BodyEmitter::processResultWrapGeneral(this.applyBuilder(smtifyInvokeKey(invk.ikey), argexps), exp.etype, trgterr, this.invokeErrMap.get(invk.ikey));

        return this.buildOp(argexps, exp.etype, trgterr, opexp, indent);
    }
/*
    method emitCallNamespaceOperatorExpression(exp: TIRCallNamespaceOperatorExpression): String {
       return NOT_IMPLEMENTED_EXPRESSION(exp.tag);
    }
    
    method emitCallStaticFunctionExpression(exp: TIRCallStaticFunctionExpression): String {
        const ttype = this.m_assembly.typeMap.get(exp.tkey) as TIROOType;
        const invk = ttype.staticFunctions.find((sf) => sf.ikey === exp.fkey);
        assert(invk !== undefined, "emitCallStaticFunctionExpression");

        const accessterm = this.resolveTypeMemberAccess(ttype.tkey);
        if((invk as TIRStaticFunctionDecl).invoke.tbinds.size === 0 && (invk as TIRStaticFunctionDecl).invoke.pcodes.size === 0) {
            return `${accessterm}.${(invk as TIRStaticFunctionDecl).name}(${exp.args.map((arg) => this.emitExpression(arg)).join(", ")})`;
        }
        else {
            return `${accessterm}.$Functions["${(invk as TIRStaticFunctionDecl).ikey}"](${exp.args.map((arg) => this.emitExpression(arg)).join(", ")})`;
        }
    }
*/
    method emitLogicActionAndExpression(exp: TreeIR::LogicActionAndExpression, depth: Nat, indent: String): [String, ArgExpErrorKind] {
        let argexps = this.processArgsItems[recursive](exp.args, depth + 1, indent);
        let trgterr = computeTargetErrorKind(argexps); 

        let opexp = BodyEmitter::processResultWrap(this.applyBuilder("and", argexps), "Bool", trgterr);
        return this.buildOp(argexps, "Bool", trgterr, opexp, indent);
    }

    method emitLogicActionOrExpression(exp: TreeIR::LogicActionOrExpression, depth: Nat, indent: String): [String, ArgExpErrorKind] {
        let argexps = this.processArgsItems[recursive](exp.args, depth + 1, indent);
        let opexp = this.applyBuilder("or", argexps);

        return this.buildOp(argexps, opexp, indent);
    }

    method emitPrefixNotOpExpression(exp: TreeIR::PrefixNotExpression, depth: Nat, indent: String): [String, ArgExpErrorKind] {
        let argexp = this.processArgSingle(exp.exp, depth + 1, indent);
        let opexp = this.applyBuilderUnary("not", argexp);

        return this.buildOpUnary(argexp, opexp, indent);
    }

    method processArithOpResult(restype: TreeIR::TypeKey, dataop: String): [String, ArgExpErrorKind]
        let ttype = this.assembly.typeMap.get(restype);
        if(ttype?TreeIR::TypedeclEntityType) {
            if(ttype.consinvariantsall.empty()) {
                return [dataop, ArgExpErrorKind::safe];
            }
            else {
                return ["[NOT IMPLEMENTED processArithOpResult]", ArgExpErrorKind::any];
            }
        }
        else {
            return [dataop, ArgExpErrorKind::safe];
        }
    }

    method emitPrefixNegateOpExpression(exp: TReeIR::PrefixNegateExpression, depth: Nat, indent: String): [String, ArgExpErrorKind] {
        let nexp: String;
        if(exp.etype === "Rational"TreeIR::TypeKey) {
            nexp = "@Rational_unary";
        }
        else if(exp.etype === "Float"TreeIR::TypeKey) {
            nexp = "@Float_unary";
        }
        else if(exp.etype === "Decimal"TreeIR::TypeKey) {
            nexp = "@Decmial_unary";
        }
        else {
            nexp = "-";
        }

        let argexp = this.processArgSingle(exp.exp, depth + 1, indent);
        let opexp = this.applyBuilderUnary(nexp, argexp);
        let finalexp = this.processArithOpResult(exp.etype, opexp);
        let rop = this.buildOpUnary(argexp, finalexp.0, indent);

        return [rop.0, joinArgExpErrorKinds(rop.1, finalexp.1)];
    }

    method emitBinAddExpression(exp: TIRBinAddExpression, toplevel: boolean): String {
        let bexp = "[NOT SET]";
        if(exp.etype === "Rational") {
            bexp = `${this.emitExpression(exp.lhs)}.add(${this.emitExpression(exp.rhs, true)})`;
        }
        else if(exp.etype === "Decimal") {
            bexp = `${this.emitExpression(exp.lhs)}.plus(${this.emitExpression(exp.rhs, true)})`;
        }
        else {
            bexp = `${this.emitExpression(exp.lhs)} + ${this.emitExpression(exp.rhs)}`;
        }

        let dataop = "[NOT SET]"
        if(exp.optype === "Nat") {
            dataop = `$Runtime.safeMath(${bexp}, 0n, $Runtime.FIXED_NUMBER_MAX)`;
        }
        else if(exp.optype === "Int") {
            dataop = `$Runtime.safeMath(${bexp}, $Runtime.FIXED_NUMBER_MIN, $Runtime.FIXED_NUMBER_MAX)`;
        }
        else {
            dataop = toplevel ? bexp : ("(" + bexp + ")");
        }

        return this.processArithOpResult(exp.etype, dataop);
    }

    method emitBinSubExpression(exp: TIRBinSubExpression, toplevel: boolean): String {
        let bexp = "[NOT SET]";
        if(exp.etype === "Rational") {
            bexp = `${this.emitExpression(exp.lhs)}.sub(${this.emitExpression(exp.rhs, true)})`;
        }
        else if(exp.etype === "Decimal") {
            bexp = `${this.emitExpression(exp.lhs)}.minus(${this.emitExpression(exp.rhs, true)})`;
        }
        else {
            bexp = `${this.emitExpression(exp.lhs)} - ${this.emitExpression(exp.rhs)}`;
        }
        
        let dataop = "[NOT SET]"
        if(exp.optype === "Nat") {
            dataop = `$Runtime.safeMath(${bexp}, 0n, $Runtime.FIXED_NUMBER_MAX)`;
        }
        else if(exp.optype === "Int") {
            dataop = `$Runtime.safeMath(${bexp}, $Runtime.FIXED_NUMBER_MIN, $Runtime.FIXED_NUMBER_MAX)`;
        }
        else if(exp.optype === "BigNat") {
            dataop = `$Runtime.safeMathUnderflow(${bexp}, 0n)`;
        }
        else {
            dataop = toplevel ? bexp : ("(" + bexp + ")");
        }

        return this.processArithOpResult(exp.etype, dataop);
    }

    method emitBinMultExpression(exp: TIRBinMultExpression, toplevel: boolean): String {
        let bexp = "[NOT SET]";
        if(exp.etype === "Rational") {
            bexp = `${this.emitExpression(exp.lhs)}.mul(${this.emitExpression(exp.rhs, true)})`;
        }
        else if(exp.etype === "Decimal") {
            bexp = `${this.emitExpression(exp.lhs)}.times(${this.emitExpression(exp.rhs, true)})`;
        }
        else {
            bexp = `${this.emitExpression(exp.lhs)} * ${this.emitExpression(exp.rhs)}`;
        }
        
        let dataop = "[NOT SET]"
        if(exp.optype === "Nat") {
            dataop = `$Runtime.safeMath(${bexp}, 0n, $Runtime.FIXED_NUMBER_MAX)`;
        }
        else if(exp.optype === "Int") {
            dataop = `$Runtime.safeMath(${bexp}, $Runtime.FIXED_NUMBER_MIN, $Runtime.FIXED_NUMBER_MAX)`;
        }
        else {
            dataop = toplevel ? bexp : ("(" + bexp + ")");
        }

        return this.processArithOpResult(exp.etype, dataop);
    }

    method emitBinDivExpression(exp: TIRBinDivExpression, toplevel: boolean): String {
        const lexp = this.emitExpression(exp.lhs);
        const rexp = this.emitExpression(exp.rhs);

        let dataop = "[NOT SET]"
        if(exp.optype === "Nat") {
            dataop = `$Runtime.safeMathDiv((a, b) => a / b, (b) => b === 0n, ${lexp}, ${rexp})`;
        }
        else if(exp.optype === "Int") {
            dataop = `$Runtime.safeMathDiv((a, b) => a / b, (b) => b === 0n, ${lexp}, ${rexp})`;
        }
        else if(exp.optype === "BigNat") {
            dataop = `$Runtime.safeMathDiv((a, b) => a / b, (b) => b === 0n, ${lexp}, ${rexp})`;
        }
        else if(exp.optype === "BigInt") {
            dataop = `$Runtime.safeMathDiv((a, b) => a / b, (b) => b === 0n, ${lexp}, ${rexp})`;
        }
        else if(exp.optype === "Rational") {
            dataop = `$Runtime.safeMathDiv((a, b) => a.div(b), (b) => b.equals(new $Runtime.Fraction(0.0)), ${lexp}, ${rexp})`;
        }
        else if(exp.optype === "Decimal") {
            dataop = `$Runtime.safeMathDiv((a, b) => a.dividedBy(b), (b) => b.equals(new $Runtime.Decimal(0.0)), ${lexp}, ${rexp})`;
        }
        else {
            dataop = `$Runtime.safeMathDiv((a, b) => a / b, (b) => b === 0.0, ${lexp}, ${rexp})`;
        }

        return this.processArithOpResult(exp.etype, dataop);
    }
/*
    method emitBinKeyEqBothUniqueExpression(exp: TIRBinKeyEqBothUniqueExpression): String {
        return `($CoreLibs.$KeyEqualOps.get("${exp.optype}"))(${this.emitExpression(exp.lhs, true)}, ${this.emitExpression(exp.rhs, true)})`;
    }

    method emitBinKeyEqOneUniqueExpression(exp: TIRBinKeyEqOneUniqueExpression): String {
        return `$CoreLibs.$KeyEqualMixed(${this.emitExpression(exp.uarg, true)}, ${this.emitExpression(exp.garg, true)}, "${exp.oftype}")`;
    }
    
    method emitBinKeyEqGeneralExpression(exp: TIRBinKeyEqGeneralExpression): String {
        return `$CoreLibs.$KeyEqualGeneral(${this.emitExpression(exp.lhs, true)}, ${this.emitExpression(exp.rhs, true)})`;
    }

    method emitBinKeyNeqBothUniqueExpression(exp: TIRBinKeyNeqBothUniqueExpression, toplevel: boolean): String {
        const rr = `!($CoreLibs.$KeyEqualOps.get("${exp.optype}"))(${this.emitExpression(exp.lhs, true)}, ${this.emitExpression(exp.rhs, true)})`;
        return toplevel ? rr : "(" + rr + ")";
    }

    method emitBinKeyNeqOneUniqueExpression(exp: TIRBinKeyNeqOneUniqueExpression, toplevel: boolean): String {
        const rr = `!$CoreLibs.$KeyEqualMixed(${this.emitExpression(exp.uarg, true)}, ${this.emitExpression(exp.garg, true)}, "${exp.oftype}")`;
        return toplevel ? rr : "(" + rr + ")";
    }
    
    method emitBinKeyNeqGeneralExpression(exp: TIRBinKeyNeqGeneralExpression, toplevel: boolean): String {
        const rr = `!$CoreLibs.$KeyEqualGeneral(${this.emitExpression(exp.lhs, true)}, ${this.emitExpression(exp.rhs, true)})`;
        return toplevel ? rr : "(" + rr + ")";
    }

    method emitBinKeyUniqueLessExpression(exp: TIRBinKeyUniqueLessExpression): String {
        return `($CoreLibs.$KeyLessOps.get("${exp.optype}"))(${this.emitExpression(exp.lhs, true)}, ${this.emitExpression(exp.rhs, true)})`;
    }

    method emitBinKeyGeneralLessExpression(exp: TIRBinKeyGeneralLessExpression): String {
        return `$CoreLibs.$KeyLessGeneral(${this.emitExpression(exp.lhs, true)}, ${this.emitExpression(exp.rhs, true)})`;
    }
*/
    method emitNumericEqExpression(exp: TIRNumericEqExpression, toplevel: boolean): String {
        const lexp = this.emitExpression(exp.lhs);
        const rexp = this.emitExpression(exp.rhs);

        let cmp = "[MISSING]";
        if(exp.optype === "Nat" || exp.optype === "Int") {
            cmp = `${lexp} === ${rexp}`;
        }
        else if(exp.optype === "BigNat" || exp.optype === "BigInt") {
            cmp = `${lexp} === ${rexp}`;
        }
        else if(exp.optype === "Rational") {
            cmp = `${lexp}.equals(${rexp})`;
        }
        else if(exp.optype === "Float") {
            cmp = `${lexp} === ${rexp}`;
        }
        else {
            cmp = `${lexp}.equals(${rexp})`;
        }

        return toplevel ? cmp : "(" + cmp + ")";
    }

    method emitNumericNeqExpression(exp: TIRNumericNeqExpression, toplevel: boolean): String {
        const lexp = this.emitExpression(exp.lhs);
        const rexp = this.emitExpression(exp.rhs);

        let cmp = "[MISSING]";
        if(exp.optype === "Nat" || exp.optype === "Int") {
            cmp = `${lexp} !== ${rexp}`;
        }
        else if(exp.optype === "BigNat" || exp.optype === "BigInt") {
            cmp = `${lexp} !== ${rexp}`;
        }
        else if(exp.optype === "Rational") {
            cmp = `!(${lexp}.equals(${rexp}))`;
        }
        else if(exp.optype === "Float") {
            cmp = `${lexp} !== ${rexp}`;
        }
        else {
            cmp = `!(${lexp}.equals(${rexp}))`;
        }

        return toplevel ? cmp : "(" + cmp + ")";
    }

    method emitNumericLessExpression(exp: TIRNumericLessExpression, toplevel: boolean): String {
        const lexp = this.emitExpression(exp.lhs);
        const rexp = this.emitExpression(exp.rhs);

        let cmp = "[MISSING]";
        if(exp.optype === "Nat" || exp.optype === "Int") {
            cmp = `${lexp} < ${rexp}`;
        }
        else if(exp.optype === "BigNat" || exp.optype === "BigInt") {
            cmp = `${lexp} < ${rexp}`;
        }
        else if(exp.optype === "Rational") {
            cmp = `(${lexp}.compare(${rexp}) < 0)`;
        }
        else if(exp.optype === "Float") {
            cmp = `${lexp} < ${rexp}`;
        }
        else {
            cmp = `${lexp}.lessThan(${rexp})`;
        }

        return toplevel ? cmp : "(" + cmp + ")";
    }

    method emitNumericLessEqExpression(exp: TIRNumericLessEqExpression, toplevel: boolean): String {
        const lexp = this.emitExpression(exp.lhs);
        const rexp = this.emitExpression(exp.rhs);

        let cmp = "[MISSING]";
        if(exp.optype === "Nat" || exp.optype === "Int") {
            cmp = `${lexp} <= ${rexp}`;
        }
        else if(exp.optype === "BigNat" || exp.optype === "BigInt") {
            cmp = `${lexp} <= ${rexp}`;
        }
        else if(exp.optype === "Rational") {
            cmp = `(${lexp}.compare(${rexp}) <= 0)`;
        }
        else if(exp.optype === "Float") {
            cmp = `${lexp} <= ${rexp}`;
        }
        else {
            cmp = `${lexp}.lessThanOrEqualTo(${rexp})`;
        }

        return toplevel ? cmp : "(" + cmp + ")";
    }

    method emitNumericGreaterExpression(exp: TIRNumericGreaterExpression, toplevel: boolean): String {
        const lexp = this.emitExpression(exp.lhs);
        const rexp = this.emitExpression(exp.rhs);

        let cmp = "[MISSING]";
        if(exp.optype === "Nat" || exp.optype === "Int") {
            cmp = `${lexp} > ${rexp}`;
        }
        else if(exp.optype === "BigNat" || exp.optype === "BigInt") {
            cmp = `${lexp} > ${rexp}`;
        }
        else if(exp.optype === "Rational") {
            cmp = `(${lexp}.compare(${rexp}) > 0)`;
        }
        else if(exp.optype === "Float") {
            cmp = `${lexp} > ${rexp}`;
        }
        else {
            cmp = `${lexp}.greaterThan(${rexp})`;
        }

        return toplevel ? cmp : "(" + cmp + ")";
    }

    method emitNumericGreaterEqExpression(exp: TIRNumericGreaterEqExpression, toplevel: boolean): String {
        const lexp = this.emitExpression(exp.lhs);
        const rexp = this.emitExpression(exp.rhs);

        let cmp = "[MISSING]";
        if(exp.optype === "Nat" || exp.optype === "Int") {
            cmp = `${lexp} >= ${rexp}`;
        }
        else if(exp.optype === "BigNat" || exp.optype === "BigInt") {
            cmp = `${lexp} >= ${rexp}`;
        }
        else if(exp.optype === "Rational") {
            cmp = `(${lexp}.compare(${rexp}) >= 0)`;
        }
        else if(exp.optype === "Float") {
            cmp = `${lexp} >= ${rexp}`;
        }
        else {
            cmp = `${lexp}.greaterThanOrEqualTo(${rexp})`;
        }

        return toplevel ? cmp : "(" + cmp + ")";
    }

    method emitBinLogicAndExpression(exp: TIRBinLogicAndExpression, toplevel: boolean): String {
        const rr = `${this.emitExpression(exp.lhs)} && ${this.emitExpression(exp.rhs)}`;
        return toplevel ? rr : "(" + rr + ")";
    }

    method emitBinLogicOrExpression(exp: TIRBinLogicOrExpression, toplevel: boolean): String {
        const rr = `${this.emitExpression(exp.lhs)} || ${this.emitExpression(exp.rhs)}`;
        return toplevel ? rr : "(" + rr + ")";
    }

    method emitBinLogicImpliesExpression(exp: TIRBinLogicImpliesExpression, toplevel: boolean): String {
        const rr = `!${this.emitExpression(exp.lhs)} || ${this.emitExpression(exp.rhs)}`;
        return toplevel ? rr : "(" + rr + ")";
    }
/*
    method emitMapEntryConstructorExpression(exp: TIRMapEntryConstructorExpression): String {
        return `[${this.emitExpression(exp.kexp, true)}, ${this.emitExpression(exp.vexp, true)}]`;
    }

    method emitIfExpression(exp: TIRIfExpression, toplevel: boolean): String {
        let rstr = "";
        if(exp.ifentry.binderinfo === undefined) {
            rstr = `${this.emitExpression(exp.ifentry.test)} ? ${this.emitExpression(exp.ifentry.value)} : `;
        }
        else {
            this.m_hasScratch = true;
            const tstr = `($Runtime.setScratchValue($$scratch, ${exp.ifentry.binderinfo[1]}, ${this.emitExpression(exp.ifentry.binderinfo[0])}) || ${this.emitExpression(exp.ifentry.test)})`;
            const texp = `((${exp.ifentry.binderinfo[3]}) => ${this.emitExpression(exp.ifentry.value)})(${this.emitExpression(exp.ifentry.binderinfo[2])})`;
            rstr = `${tstr} ? ${texp} : `;
        } 

        for(let i = 0; i < exp.elifentries.length; ++i){
            const eii = exp.elifentries[i];

            if(eii.binderinfo === undefined) {
                rstr += `${this.emitExpression(eii.test)} ? ${this.emitExpression(eii.value)} : `
            }
            else {
                this.m_hasScratch = true;
                const tstr = `($Runtime.setScratchValue($$scratch, ${eii.binderinfo[1]}, ${this.emitExpression(eii.binderinfo[0])}) || ${this.emitExpression(eii.test)})`;
                const texp = `((${eii.binderinfo[3]}) => ${this.emitExpression(eii.value)})(${this.emitExpression(eii.binderinfo[2])})`;
                rstr += `${tstr} ? ${texp} : `;
            }
        }

        if(exp.elseentry.binderinfo === undefined) {
            rstr += this.emitExpression(exp.elseentry.value);
        }
        else {
            this.m_hasScratch = true;
            const tstr = `$Runtime.setScratchValue($$scratch, ${exp.elseentry.binderinfo[1]}, ${this.emitExpression(exp.elseentry.binderinfo[0])})`;
            const texp = `((${exp.elseentry.binderinfo[3]}) => ${this.emitExpression(exp.elseentry.value)})(${this.emitExpression(exp.elseentry.binderinfo[2])})`;
            rstr += `(${tstr} || ${texp})`;
        }

        return toplevel ? rstr : "(" + rstr + ")";
    }

    method emitSwitchExpression(exp: TIRSwitchExpression, toplevel: boolean): String {
        this.m_hasScratch = true;
        let sstr = `$Runtime.setScratchValue($$scratch, ${exp.scratchidx}, ${this.emitExpression(exp.exp, true)}) || `;

        if(exp.clauses[0].binderinfo === undefined) {
            sstr += `${this.emitExpression(exp.clauses[0].match, false)} ? ${this.emitExpression(exp.clauses[0].value, false)} : `;
        }
        else {
            sstr += `${this.emitExpression(exp.clauses[0].match, false)} ? ((${exp.clauses[0].binderinfo[1]}) => ${this.emitExpression(exp.clauses[0].value, true)})(${this.emitExpression(exp.clauses[0].binderinfo[0], true)}) : `;
        }

        for(let i = 1; i < exp.clauses.length; ++i) {
            if(exp.clauses[i].binderinfo === undefined) {
                sstr += `${this.emitExpression(exp.clauses[i].match, false)} ? ${this.emitExpression(exp.clauses[i].value, false)} : `;
            }
            else {
                const binfo = exp.clauses[i].binderinfo as [TIRExpression, string];
                sstr += `${this.emitExpression(exp.clauses[i].match, false)} ? ((${binfo[1]}) => ${this.emitExpression(exp.clauses[i].value, true)})(${this.emitExpression(binfo[0], true)}) : `;
            }
        }

        if(exp.edefault !== undefined) {
            if(exp.edefault.binderinfo === undefined) {
                sstr += `${this.emitExpression(exp.edefault.value, false)}\n`;
            }
            else {
                sstr += `((${exp.edefault.binderinfo[1]}) => ${this.emitExpression(exp.edefault.value, true)})(${this.emitExpression(exp.edefault.binderinfo[0], true)})`;
            }
        }
        else {
            //we just ignore exp.isexhaustive -- maybe want to be more optimized in the future
            sstr += `$Runtime.raiseRuntimeError("Non-exhaustive switch statement" + " -- ${this.m_file} @ line ${exp.sinfo.line}")`;
        }

        return toplevel ? sstr : ("(" + sstr + ")");
    }
    
    method emitMatchExpression(exp: TIRMatchExpression, toplevel: boolean): String {
        this.m_hasScratch = true;
        let sstr = `$Runtime.setScratchValue($$scratch, ${exp.scratchidx}, ${this.emitExpression(exp.exp, true)}) || `;

        if(exp.clauses[0].binderinfo === undefined) {
            sstr += `${this.emitExpression(exp.clauses[0].match, false)} ? ${this.emitExpression(exp.clauses[0].value, false)} : `;
        }
        else {
            sstr += `${this.emitExpression(exp.clauses[0].match, false)} ? ((${exp.clauses[0].binderinfo[1]}) => ${this.emitExpression(exp.clauses[0].value, true)})(${this.emitExpression(exp.clauses[0].binderinfo[0], true)}) : `;
        }

        for(let i = 1; i < exp.clauses.length; ++i) {
            if(exp.clauses[i].binderinfo === undefined) {
                sstr += `${this.emitExpression(exp.clauses[i].match, false)} ? ${this.emitExpression(exp.clauses[i].value, false)} : `;
            }
            else {
                const binfo = exp.clauses[i].binderinfo as [TIRExpression, string];
                sstr += `${this.emitExpression(exp.clauses[i].match, false)} ? ((${binfo[1]}) => ${this.emitExpression(exp.clauses[i].value, true)})(${this.emitExpression(binfo[0], true)}) : `;
            }
        }

        if(exp.edefault !== undefined) {
            if(exp.edefault.binderinfo === undefined) {
                sstr += `${this.emitExpression(exp.edefault.value, false)}\n`;
            }
            else {
                sstr += `((${exp.edefault.binderinfo[1]}) => ${this.emitExpression(exp.edefault.value, true)})(${this.emitExpression(exp.edefault.binderinfo[0], true)})`;
            }
        }
        else {
            //we just ignore exp.isexhaustive -- maybe want to be more optimized in the future
            sstr += `$Runtime.raiseRuntimeError("Non-exhaustive match statement" + " -- ${this.m_file} @ line ${exp.sinfo.line}")`;
        }

        return toplevel ? sstr : ("(" + sstr + ")");
    }

    method emitTaskSelfFieldExpression(exp: TIRTaskSelfFieldExpression): String {
        return `self.${exp.fname}`;
    }

    method emitTaskSelfControlExpression(exp: TIRTaskSelfControlExpression): String {
        return "self.$CNTL";
    }

    method emitTaskGetIDExpression(exp: TIRTaskGetIDExpression): String {
        return "self.$ID";
    }
*/
    method emitCoerceSafeExpression(exp: TIRCoerceSafeExpression, toplevel: boolean): String {
        const srcunion = this.typeEncodedAsUnion(exp.exp.etype);
        const trgtunion = this.typeEncodedAsUnion(exp.totype);

        if(srcunion === trgtunion) {
            return this.emitExpression(exp.exp, toplevel);
        }
        else if(trgtunion) {
            const bval = `$Runtime.UnionValue.create("${exp.fromtype}", ${this.emitExpression(exp.exp)})`;
            return toplevel ? bval : "(" + bval + ")";
        }
        else {
            const bval = `${this.emitExpression(exp.exp)}.value`;
            return toplevel ? bval : "(" + bval + ")";
        }
    }

    method emitInjectExpression(exp: TIRInjectExpression, toplevel: boolean): String {
       return this.emitExpression(exp.exp, toplevel);
    }

    method emitExtractExpression(exp: TIRExtractExpression, toplevel: boolean): String {
       return this.emitExpression(exp.exp, toplevel);
    }
/*    
    method emitCreateCodePackExpression(exp: TIRCreateCodePackExpression): String {
        const capturepcdirect = exp.capturepackdirect.map((pcc) => `${pcc}: ${pcc}`);
        const capturepcindirect = exp.capturepackindirect.map((pcc) => `${pcc}: $CodePack.${pcc}`);
        const capturevvdirect = exp.capturedirect.map((pcc) => `${pcc}: ${pcc === "this" ? "$_this" : pcc}`);
        const capturevvindirect = exp.captureindirect.map((pcc) => `${pcc}: $CodePack.${pcc}`);

        return `{${[...capturevvdirect, ...capturevvindirect, ...capturepcdirect, ...capturepcindirect].join(", ")}}`;
    }

    method emitIsNoneSpecialExpression(exp: TIRIsNoneSpecialExpression, toplevel: boolean): String {
       assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

       const bval = `${this.emitExpression(exp.exp)}.tkey === "None"`;
       return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsSomeSpecialExpression(exp: TIRIsSomeSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `${this.emitExpression(exp.exp)}.tkey !== "None"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsNothingSpecialExpression(exp: TIRIsNothingSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `${this.emitExpression(exp.exp)}.tkey === "Nothing"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsSomethingSpecialExpression(exp: TIRIsSomethingSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `${this.emitExpression(exp.exp)}.tkey !== "Nothing"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsOkSpecialExpression(exp: TIRIsOkSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `${this.emitExpression(exp.exp)}.tkey === "${exp.oktype}"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsErrSpecialExpression(exp: TIRIsErrSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `${this.emitExpression(exp.exp)}.tkey === "${exp.errtype}"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsEqualToLiteralExpression(exp: TIRIsEqualToLiteralExpression, toplevel: boolean): String {
        if(this.typeEncodedAsUnion(exp.exp.etype)) {
            const rr = `$CoreLibs.$KeyEqualMixed(${this.emitExpression(exp.literal.exp, true)}, ${this.emitExpression(exp.exp, true)}, "${exp.literal.exp.etype}")`;
            return toplevel ? rr : "(" + rr + ")";
        }
        else {
            const rr = `($CoreLibs.$KeyEqualOps.get("${exp.literal.exp.etype}"))(${this.emitExpression(exp.literal.exp, true)}, ${this.emitExpression(exp.exp, true)})`;
            return toplevel ? rr : "(" + rr + ")";
        }
    }

    method emitIsNotEqualToLiteralExpression(exp: TIRIsNotEqualToLiteralExpression, toplevel: boolean): String {
        if(this.typeEncodedAsUnion(exp.exp.etype)) {
            const rr = `!$CoreLibs.$KeyEqualMixed(${this.emitExpression(exp.literal.exp, true)}, ${this.emitExpression(exp.exp, true)}, "${exp.literal.exp.etype}")`;
            return toplevel ? rr : "(" + rr + ")";
        }
        else {
            const rr = `!($CoreLibs.$KeyEqualOps.get("${exp.literal.exp.etype}"))(${this.emitExpression(exp.literal.exp, true)}, ${this.emitExpression(exp.exp, true)})`;
            return toplevel ? rr : "(" + rr + ")";
        }
    }

    method emitIsTypeExpression(exp: TIRIsTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(!this.typeEncodedAsUnion(exp.ttype), "this should be a subtype then");

        const bval = `${this.emitExpression(exp.exp)}.tkey === "${exp.ttype}"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsNotTypeExpression(exp: TIRIsNotTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(!this.typeEncodedAsUnion(exp.ttype), "this should be a subtype then");

        const bval = `${this.emitExpression(exp.exp)}.tkey !== "${exp.ttype}"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsSubTypeExpression(exp: TIRIsSubTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(this.typeEncodedAsUnion(exp.ttype), "this should be a oftype then");

        const bval = `$Runtime.isSubtype(${this.emitExpression(exp.exp, true)}.tkey, "${exp.ttype}")`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsNotSubTypeExpression(exp: TIRIsNotSubTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(this.typeEncodedAsUnion(exp.ttype), "this should be a oftype then");

        const bval = `!$Runtime.isSubtype(${this.emitExpression(exp.exp, true)}.tkey, "${exp.ttype}")`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsNoneSpecialExpression(exp: TIRAsNoneSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `(${this.emitExpression(exp.exp)}.tkey === "None") ? undefined : $Runtime.raiseRuntimeError("cannot convert value to None")`;
        return toplevel ? bval : "(" + bval + ")";
    }
    
    method emitAsSomeSpecialExpression(exp: TIRAsSomeSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        let bval = "[NOT SET]";
        if(this.typeEncodedAsUnion(exp.etype)) {
            bval = `((__expval__) => (__expval__.tkey !== "None") ? __expval__ : $Runtime.raiseRuntimeError("cannot convert value to Some"))(${this.emitExpression(exp.exp)})`;
        }
        else {
            bval = `((__expval__) => (__expval__.tkey !== "None") ? __expval__.value : $Runtime.raiseRuntimeError("cannot convert value to Some"))(${this.emitExpression(exp.exp)})`;
        }

        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsNothingSpecialExpression(exp: TIRAsNothingSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `(${this.emitExpression(exp.exp)}.tkey === "Nothing") ? null : $Runtime.raiseRuntimeError("cannot convert value to Nothing")`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsSomethingSpecialExpression(exp: TIRAsSomethingSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `((__expval__) => (__expval__.tkey !== "Nothing") ? __expval__.value : $Runtime.raiseRuntimeError("cannot convert value to Something"))(${this.emitExpression(exp.exp)})`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsOkSpecialExpression(exp: TIRAsOkSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `((__expval__) => (${this.emitExpression(exp.exp)}.tkey === "${exp.etype}") ? __expval__.value : $Runtime.raiseRuntimeError("cannot convert value to ok"))(${this.emitExpression(exp.exp)})`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsErrSpecialExpression(exp: TIRAsErrSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `((__expval__) => (${this.emitExpression(exp.exp)}.tkey === "${exp.etype}") ? __expval__.value : $Runtime.raiseRuntimeError("cannot convert value to err"))(${this.emitExpression(exp.exp)})`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsEqualToLiteralExpression(exp: TIRAsEqualToLiteralExpression, toplevel: boolean): String {
        if(this.typeEncodedAsUnion(exp.exp.etype)) {
            const rr = `$CoreLibs.$KeyEqualMixed(${this.emitExpression(exp.literal.exp, true)}, __expval__, "${exp.literal.exp.etype}")`;
            const bval = `((__expval__) => ${rr} ? ${this.emitExpression(exp.literal.exp, true)} : $Runtime.raiseRuntimeError("cannot convert value to literal"))(${this.emitExpression(exp.exp)})`;
            return toplevel ? bval : "(" + bval + ")";
        }
        else {
            const rr = `($CoreLibs.$KeyEqualOps.get("${exp.literal.exp.etype}"))(${this.emitExpression(exp.literal.exp, true)}, __expval__)`;
            const bval = `((__expval__) => ${rr} ? ${this.emitExpression(exp.literal.exp, true)} : $Runtime.raiseRuntimeError("cannot convert value to literal"))(${this.emitExpression(exp.exp)})`;
            return toplevel ? bval : "(" + bval + ")";
        }
    }

    method emitAsNotEqualToLiteralExpression(exp: TIRAsNotEqualToLiteralExpression, toplevel: boolean): String {
        if(this.typeEncodedAsUnion(exp.exp.etype)) {
            const rr = `!$CoreLibs.$KeyEqualMixed(${this.emitExpression(exp.literal.exp, true)}, __expval__, "${exp.literal.exp.etype}")`;
            const bval = `((__expval__) => ${rr} ? __expval__${!this.typeEncodedAsUnion(exp.etype) ? ".value" : ""} : $Runtime.raiseRuntimeError("cannot convert value to literal"))(${this.emitExpression(exp.exp)})`;
            return toplevel ? bval : "(" + bval + ")";
        }
        else {
            const rr = `!($CoreLibs.$KeyEqualOps.get("${exp.literal.exp.etype}"))(${this.emitExpression(exp.literal.exp, true)}, __expval__)`;
            const bval = `((__expval__) => ${rr} ? ${this.emitExpression(exp.literal.exp, true)} : $Runtime.raiseRuntimeError("cannot convert value to literal"))(${this.emitExpression(exp.exp)})`;
            return toplevel ? bval : "(" + bval + ")";
        }
    }

    method emitAsTypeExpression(exp: TIRAsTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(!this.typeEncodedAsUnion(exp.ttype), "this should be a subtype then");

        const bval = `((__expval__) => (__expval__.tkey === "${exp.ttype}") ? __expval__.value : $Runtime.raiseRuntimeError("cannot convert value to ${exp.etype}"))(${this.emitExpression(exp.exp, true)})`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsNotTypeExpression(exp: TIRAsNotTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(!this.typeEncodedAsUnion(exp.ttype), "this should be a subtype then");

        const bval = `((__expval__) => (__expval__.tkey === "${exp.ttype}") ? __expval__${!this.typeEncodedAsUnion(exp.etype) ? ".value" : ""} : $Runtime.raiseRuntimeError("cannot convert value to ${exp.etype}"))(${this.emitExpression(exp.exp, true)})`;
        return toplevel ? bval : "(" + bval + ")";
    }
    
    method emitAsSubTypeExpression(exp: TIRAsSubTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(this.typeEncodedAsUnion(exp.ttype), "this should be a oftype then");

        const bval = `((__expval__) => $Runtime.isSubtype(__expval__.tkey, "${exp.ttype}") ? __expval__ : $Runtime.raiseRuntimeError("cannot convert value to ${exp.ttype}"))(${this.emitExpression(exp.exp, true)})`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsNotSubTypeExpression(exp: TIRAsNotSubTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(this.typeEncodedAsUnion(exp.ttype), "this should be a oftype then");

        const bval = `((__expval__) => $Runtime.isSubtype(__expval__.tkey, "${exp.ttype}") ? __expval__${!this.typeEncodedAsUnion(exp.etype) ? ".value" : ""} : $Runtime.raiseRuntimeError("cannot convert value to ${exp.ttype}"))(${this.emitExpression(exp.exp, true)})`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitCallMemberFunctionExpression(exp: TIRCallMemberFunctionExpression, toplevel: boolean): String {
        const aargs = [this.emitExpression(exp.thisarg, true), ...exp.args.map((arg) => this.emitExpression(arg, true))];

        const ttype = this.m_assembly.typeMap.get(exp.tkey) as TIROOType;
        const invk = ttype.memberMethods.find((mm) => mm.ikey === exp.fkey);
        assert(invk !== undefined, "emitCallMemberFunctionExpression");

        const fexp = `${this.resolveTypeMemberAccess(exp.tkey)}`;
        let meexp = "[NOT SET]";
        if((invk as TIRMemberMethodDecl).invoke.tbinds.size === 0 && (invk as TIRMemberMethodDecl).invoke.pcodes.size === 0) {
            meexp = `.${exp.fname}`;
        }
        else {
            meexp = `.$Methods["${exp.fkey}"]`;
        }
        
        const eexp = `${fexp}${meexp}(${aargs.join(", ")})`;

        return toplevel ? eexp : "(" + eexp + ")";
    }

    method emitCallMemberFunctionDynamicExpression(exp: TIRCallMemberFunctionDynamicExpression, toplevel: boolean): String {
        const thisarg = this.emitExpression(exp.thisarg, true);
        const thisunion = this.typeEncodedAsUnion(exp.thisarg.etype);

        const aargs = exp.args.map((arg) => this.emitExpression(arg, true));

        let vtable = "[NOT SET]";
        if (thisunion) {
            vtable = `$Runtime.invmap.get($Runtime.vtablemap.get(__expval__.tkey).get("${exp.fname}")).op`
        }
        else {
            vtable = `$Runtime.invmap.get($Runtime.vtablemap.get("${exp.thisarg.etype}").get("${exp.fname}")).op`;
        }

        let thisargas = "[NOT SET]";
        if(thisunion) {
            thisargas = `($Runtime.invmap.get($Runtime.vtablemap.get(__expval__.tkey).get("${exp.fname}")).isatom ? __expval__.value : __expval__)`;
        }
        else {
            thisargas = `($Runtime.invmap.get($Runtime.vtablemap.get(__expval__.tkey).get("${exp.fname}")).isatom ? __expval__ : $Runtime.UnionValue.create("${exp.thisarg.etype}", ${thisarg}))`;
        }

        const eexp = `((__expval__) => ${vtable}(${[thisargas, ...aargs].join(", ")}))(${thisarg})`;

        return toplevel ? eexp : "(" + eexp + ")";
    }
    
    method emitCallMemberFunctionSelfRefExpression(exp: TIRCallMemberFunctionSelfRefExpression, toplevel: boolean): String {
        const aargs = [this.emitExpression(exp.thisarg, true), ...exp.args.map((arg) => this.emitExpression(arg, true))];

        const ttype = this.m_assembly.typeMap.get(exp.tkey) as TIROOType;
        const invk = ttype.memberMethods.find((mm) => mm.ikey === exp.fkey);
        assert(invk !== undefined, "emitCallMemberFunctionExpression");

        const fexp = `${this.resolveTypeMemberAccess(exp.tkey)}`;
        let meexp = "[NOT SET]";
        if((invk as TIRMemberMethodDecl).invoke.tbinds.size === 0 && (invk as TIRMemberMethodDecl).invoke.pcodes.size === 0) {
            meexp = `.${exp.fname}`;
        }
        else {
            meexp = `.$Methods["${exp.fkey}"]`;
        }

        this.m_hasScratch = true;
        return `$Runtime.setScratchValue($$scratch, ${exp.scidx}, ${fexp}${meexp}(${aargs.join(", ")}));`;
    }

    method emitCallMemberFunctionTaskExpression(exp: TIRCallMemberFunctionTaskExpression, toplevel: boolean): String {
        const aargs = ["self", ...exp.args.map((arg) => this.emitExpression(arg, true))];

        const ttype = this.m_assembly.typeMap.get(exp.tsktype) as TIRTaskType;
        const invk = ttype.memberMethods.find((mm) => mm.ikey === exp.fkey);
        assert(invk !== undefined, "emitCallMemberFunctionExpression");

        const fexp = `${this.resolveTypeMemberAccess(exp.tsktype)}`;
        let meexp = "[NOT SET]";
        if((invk as TIRMemberMethodDecl).invoke.tbinds.size === 0 && (invk as TIRMemberMethodDecl).invoke.pcodes.size === 0) {
            meexp = `.${exp.fname}`;
        }
        else {
            meexp = `.$Methods["${exp.fkey}"]`;
        }

        const eexp = `${fexp}${meexp}(${aargs.join(", ")})`;

        return toplevel ? eexp : "(" + eexp + ")";
    }

    method emitCallMemberFunctionTaskSelfRefExpression(exp: TIRCallMemberFunctionTaskSelfRefExpression, toplevel: boolean): String {
        const aargs = ["self", ...exp.args.map((arg) => this.emitExpression(arg, true))];

        const ttype = this.m_assembly.typeMap.get(exp.tsktype) as TIRTaskType;
        const invk = ttype.memberMethods.find((mm) => mm.ikey === exp.fkey);
        assert(invk !== undefined, "emitCallMemberFunctionExpression");

        const fexp = `${this.resolveTypeMemberAccess(exp.tsktype)}`;
        let meexp = "[NOT SET]";
        if((invk as TIRMemberMethodDecl).invoke.tbinds.size === 0 && (invk as TIRMemberMethodDecl).invoke.pcodes.size === 0) {
            meexp = `.${exp.fname}`;
        }
        else {
            meexp = `.$Methods["${exp.fkey}"]`;
        }

        this.m_hasScratch = true;
        return `$Runtime.setScratchValue($$scratch, ${exp.scidx}, ${fexp}${meexp}(${aargs.join(", ")}));`;
    }

    method emitCallMemberActionExpression(exp: TIRCallMemberActionExpression, toplevel: boolean): String {
        const aargs = ["self", ...exp.args.map((arg) => this.emitExpression(arg, true))];
        const fexp = `${this.resolveTypeMemberAccess(exp.tsktype)}.${exp.fname}`;

        this.m_hasScratch = true;
        return `$Runtime.setScratchValue($$scratch, ${exp.scidx}, ${fexp}(${aargs.join(", ")}));`;
    }
*/
    method emitExpression(exp: TreeIR::Expression): String {
        /*
        switch (exp.tag) {
            case TIRExpressionTag.LiteralNoneExpression: {
                return this.emitLiteralNoneExpression(exp as TIRLiteralNoneExpression);
            }
            case TIRExpressionTag.LiteralNothingExpression: {
                return this.emitLiteralNothingExpression(exp as TIRLiteralNothingExpression);
            }
            case TIRExpressionTag.LiteralBoolExpression: {
                return this.emitLiteralBoolExpression(exp as TIRLiteralBoolExpression);
            }
            case TIRExpressionTag.LiteralIntegralExpression: {
                return this.emitLiteralIntegralExpression(exp as TIRLiteralIntegralExpression);
            }
            case TIRExpressionTag.LiteralRationalExpression: {
                return this.emitLiteralRationalExpression(exp as TIRLiteralRationalExpression);
            }
            case TIRExpressionTag.LiteralFloatPointExpression: {
                return this.emitLiteralFloatPointExpression(exp as TIRLiteralFloatPointExpression);
            }
            case TIRExpressionTag.LiteralRegexExpression: {
                return this.emitLiteralRegexExpression(exp as TIRLiteralRegexExpression);
            }
            case TIRExpressionTag.LiteralStringExpression: {
                return this.emitLiteralStringExpression(exp as TIRLiteralStringExpression);
            }
            case TIRExpressionTag.LiteralASCIIStringExpression: {
                return this.emitLiteralASCIIStringExpression(exp as TIRLiteralASCIIStringExpression);
            }
            case TIRExpressionTag.LiteralTypedStringExpression: {
                return this.emitLiteralTypedStringExpression(exp as TIRLiteralTypedStringExpression);
            }
            case TIRExpressionTag.LiteralASCIITypedStringExpression: {
                return this.emitLiteralASCIITypedStringExpression(exp as TIRLiteralASCIITypedStringExpression);
            }
            case TIRExpressionTag.LiteralTemplateStringExpression: {
                return this.emitLiteralTemplateStringExpression(exp as TIRLiteralTemplateStringExpression);
            }
            case TIRExpressionTag.LiteralASCIITemplateStringExpression: {
                return this.emitLiteralASCIITemplateStringExpression(exp as TIRLiteralASCIITemplateStringExpression);
            }
            case TIRExpressionTag.LiteralTypedPrimitiveDirectExpression: {
                return this.emitLiteralTypedPrimitiveDirectExpression(exp as TIRLiteralTypedPrimitiveDirectExpression, toplevel || false);
            }
            case TIRExpressionTag.LiteralTypedPrimitiveConstructorExpression: {
                return this.emitLiteralTypedPrimitiveConstructorExpression(exp as TIRLiteralTypedPrimitiveConstructorExpression);
            }
            case TIRExpressionTag.AccessEnvValueExpression: {
                return this.emitAccessEnvValueExpression(exp as TIRAccessEnvValueExpression);
            }
            case TIRExpressionTag.AccessNamespaceConstantExpression: {
                return this.emitAccessNamespaceConstantExpression(exp as TIRAccessNamespaceConstantExpression);
            }
            case TIRExpressionTag.AccessConstMemberFieldExpression: {
                return this.emitAccessConstMemberFieldExpression(exp as TIRAccessConstMemberFieldExpression);
            }
            case TIRExpressionTag.AccessVariableExpression: {
                return this.emitAccessVariableExpression(exp as TIRAccessVariableExpression);
            }
            case TIRExpressionTag.AccessCapturedVariableExpression: {
                return this.emitAccessCapturedVariableExpression(exp as TIRAccessCapturedVariableExpression);
            }
            case TIRExpressionTag.AccessScratchSingleValueExpression: {
                return this.emitAccessScratchSingleValueExpression(exp as TIRAccessScratchSingleValueExpression);
            }
            case TIRExpressionTag.AccessScratchIndexExpression: {
                return this.emitAccessScratchIndexExpression(exp as TIRAccessScratchIndexExpression);
            }
            case TIRExpressionTag.LoadIndexExpression: {
                return this.emitLoadIndexExpression(exp as TIRLoadIndexExpression);
            }
            case TIRExpressionTag.LoadPropertyExpression: {
                return this.emitLoadPropertyExpression(exp as TIRLoadPropertyExpression);
            }
            case TIRExpressionTag.LoadFieldExpression: {
                return this.emitLoadFieldExpression(exp as TIRLoadFieldExpression);
            }
            case TIRExpressionTag.LoadFieldVirtualExpression: {
                return this.emitLoadFieldVirtualExpression(exp as TIRLoadFieldVirtualExpression);
            }
            case TIRExpressionTag.ConstructorPrimaryDirectExpression: {
                return this.emitConstructorPrimaryDirectExpression(exp as TIRConstructorPrimaryDirectExpression);
            }
            case TIRExpressionTag.ConstructorPrimaryCheckExpression: {
                return this.emitConstructorPrimaryCheckExpression(exp as TIRConstructorPrimaryCheckExpression);
            }
            case TIRExpressionTag.ConstructorTupleExpression: {
                return this.emitConstructorTupleExpression(exp as TIRConstructorTupleExpression);
            }
            case TIRExpressionTag.ConstructorRecordExpression: {
                return this.emitConstructorRecordExpression(exp as TIRConstructorRecordExpression);
            }
            case TIRExpressionTag.ConstructorListExpression : {
                return this.emitConstructorListExpression(exp as TIRConstructorListExpression);
            }
            case TIRExpressionTag.ConstructorMapExpression: {
                return this.emitConstructorMapExpression(exp as TIRConstructorMapExpression);
            }
            case TIRExpressionTag.CodePackInvokeExpression: {
                return this.emitCodePackInvokeExpression(exp as TIRCodePackInvokeExpression);
            }
            case TIRExpressionTag.ResultOkConstructorExpression: {
                return this.emitResultOkConstructorExpression(exp as TIRResultOkConstructorExpression, toplevel || false);
            }
            case TIRExpressionTag.ResultErrConstructorExpression: {
                return this.emitResultErrConstructorExpression(exp as TIRResultErrConstructorExpression, toplevel || false);
            }
            case TIRExpressionTag.SomethingConstructorExpression: {
                return this.emitSomethingConstructorExpression(exp as TIRSomethingConstructorExpression, toplevel || false);
            }
            case TIRExpressionTag.TypedeclDirectExpression: {
                return this.emitTypedeclDirectExpression(exp as TIRTypedeclDirectExpression, toplevel || false);
            }
            case TIRExpressionTag.TypedeclConstructorExpression: {
                return this.emitTypedeclConstructorExpression(exp as TIRTypedeclConstructorExpression);
            }
            case TIRExpressionTag.CallNamespaceFunctionExpression: {
                return this.emitCallNamespaceFunctionExpression(exp as TIRCallNamespaceFunctionExpression);
            }
            case TIRExpressionTag.CallNamespaceOperatorExpression: {
                return this.emitCallNamespaceOperatorExpression(exp as TIRCallNamespaceOperatorExpression);
            }
            case TIRExpressionTag.CallStaticFunctionExpression: {
                return this.emitCallStaticFunctionExpression(exp as TIRCallStaticFunctionExpression);
            }
            case TIRExpressionTag.LogicActionAndExpression: {
                return this.emitLogicActionAndExpression(exp as TIRLogicActionAndExpression, toplevel || false);
            }
            case TIRExpressionTag.LogicActionOrExpression: {
                return this.emitLogicActionOrExpression(exp as TIRLogicActionOrExpression, toplevel || false);
            }
            case TIRExpressionTag.PrefixNotExpression: {
                return this.emitPrefixNotOpExpression(exp as TIRPrefixNotExpression, toplevel || false);
            }
            case TIRExpressionTag.PrefixNegateExpression: {
                return this.emitPrefixNegateOpExpression(exp as TIRPrefixNegateExpression, toplevel || false);
            }
            case TIRExpressionTag.BinAddExpression: {
                return this.emitBinAddExpression(exp as TIRBinAddExpression, toplevel || false);
            }
            case TIRExpressionTag.BinSubExpression: {
                return this.emitBinSubExpression(exp as TIRBinSubExpression, toplevel || false);
            }
            case TIRExpressionTag.BinMultExpression: {
                return this.emitBinMultExpression(exp as TIRBinMultExpression, toplevel || false);
            }
            case TIRExpressionTag.BinDivExpression: {
                return this.emitBinDivExpression(exp as TIRBinDivExpression, toplevel || false);
            }
            case TIRExpressionTag.BinKeyEqBothUniqueExpression: {
                return this.emitBinKeyEqBothUniqueExpression(exp as TIRBinKeyEqBothUniqueExpression);
            }
            case TIRExpressionTag.BinKeyEqOneUniqueExpression: {
                return this.emitBinKeyEqOneUniqueExpression(exp as TIRBinKeyEqOneUniqueExpression);
            }
            case TIRExpressionTag.BinKeyEqGeneralExpression: {
                return this.emitBinKeyEqGeneralExpression(exp as TIRBinKeyEqGeneralExpression);
            }
            case TIRExpressionTag.BinKeyNeqBothUniqueExpression: {
                return this.emitBinKeyNeqBothUniqueExpression(exp as TIRBinKeyNeqBothUniqueExpression, toplevel || false);
            }
            case TIRExpressionTag.BinKeyNeqOneUniqueExpression: {
                return this.emitBinKeyNeqOneUniqueExpression(exp as TIRBinKeyNeqOneUniqueExpression, toplevel || false);
            }
            case TIRExpressionTag.BinKeyNeqGeneralExpression: {
                return this.emitBinKeyNeqGeneralExpression(exp as TIRBinKeyNeqGeneralExpression, toplevel || false);
            }
            case TIRExpressionTag.BinKeyUniqueLessExpression: {
                return this.emitBinKeyUniqueLessExpression(exp as TIRBinKeyUniqueLessExpression);
            }
            case TIRExpressionTag.BinKeyGeneralLessExpression: {
                return this.emitBinKeyGeneralLessExpression(exp as TIRBinKeyGeneralLessExpression);
            }
            case TIRExpressionTag.NumericEqExpression: {
                return this.emitNumericEqExpression(exp as TIRNumericEqExpression, toplevel || false);
            }
            case TIRExpressionTag.NumericNeqExpression: {
                return this.emitNumericNeqExpression(exp as TIRNumericNeqExpression, toplevel || false);
            }
            case TIRExpressionTag.NumericLessExpression: {
                return this.emitNumericLessExpression(exp as TIRNumericLessExpression, toplevel || false);
            }
            case TIRExpressionTag.NumericLessEqExpression: {
                return this.emitNumericLessEqExpression(exp as TIRNumericLessEqExpression, toplevel || false);
            }
            case TIRExpressionTag.NumericGreaterExpression: {
                return this.emitNumericGreaterExpression(exp as TIRNumericGreaterExpression, toplevel || false);
            }
            case TIRExpressionTag.NumericGreaterEqExpression: {
                return this.emitNumericGreaterEqExpression(exp as TIRNumericGreaterEqExpression, toplevel || false);
            }
            case TIRExpressionTag.BinLogicAndExpression: {
                return this.emitBinLogicAndExpression(exp as TIRBinLogicAndExpression, toplevel || false);
            }
            case TIRExpressionTag.BinLogicOrExpression: {
                return this.emitBinLogicOrExpression(exp as TIRBinLogicOrExpression, toplevel || false);
            }
            case TIRExpressionTag.BinLogicImpliesExpression: {
                return this.emitBinLogicImpliesExpression(exp as TIRBinLogicImpliesExpression, toplevel || false);
            }
            case TIRExpressionTag.MapEntryConstructorExpression: {
                return this.emitMapEntryConstructorExpression(exp as TIRMapEntryConstructorExpression);
            }
            case TIRExpressionTag.IfExpression: {
                return this.emitIfExpression(exp as TIRIfExpression, toplevel || false);
            }
            case TIRExpressionTag.SwitchExpression: {
                return this.emitSwitchExpression(exp as TIRSwitchExpression, toplevel || false);
            }
            case TIRExpressionTag.MatchExpression: {
                return this.emitMatchExpression(exp as TIRMatchExpression, toplevel || false);
            }
            case TIRExpressionTag.TaskSelfFieldExpression: {
                return this.emitTaskSelfFieldExpression(exp as TIRTaskSelfFieldExpression);
            }
            case TIRExpressionTag.TaskSelfControlExpression: {
                return this.emitTaskSelfControlExpression(exp as TIRTaskSelfControlExpression);
            }
            case TIRExpressionTag.TaskGetIDExpression: {
                return this.emitTaskGetIDExpression(exp as TIRTaskGetIDExpression);
            }
            case TIRExpressionTag.CoerceSafeExpression: {
                return this.emitCoerceSafeExpression(exp as TIRCoerceSafeExpression, toplevel || false);
            }
            case TIRExpressionTag.InjectExpression: {
                return this.emitInjectExpression(exp as TIRInjectExpression, toplevel || false);
            }
            case TIRExpressionTag.ExtractExpression: {
                return this.emitExtractExpression(exp as TIRExtractExpression, toplevel || false);
            }
            case TIRExpressionTag.CreateCodePackExpression: {
                return this.emitCreateCodePackExpression(exp as TIRCreateCodePackExpression);
            }
            case TIRExpressionTag.IsNoneSpecialExpression: {
                return this.emitIsNoneSpecialExpression(exp as TIRIsNoneSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.IsSomeSpecialExpression: {
                return this.emitIsSomeSpecialExpression(exp as TIRIsSomeSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.IsNothingSpecialExpression: {
                return this.emitIsNothingSpecialExpression(exp as TIRIsNothingSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.IsSomethingSpecialExpression: {
                return this.emitIsSomethingSpecialExpression(exp as TIRIsSomethingSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.IsOkSpecialExpression: {
                return this.emitIsOkSpecialExpression(exp as TIRIsOkSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.IsErrSpecialExpression: {
                return this.emitIsErrSpecialExpression(exp as TIRIsErrSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.IsEqualToLiteralExpression: {
                return this.emitIsEqualToLiteralExpression(exp as TIRIsEqualToLiteralExpression, toplevel || false);
            }
            case TIRExpressionTag.IsNotEqualToLiteralExpression: {
                return this.emitIsNotEqualToLiteralExpression(exp as TIRIsNotEqualToLiteralExpression, toplevel || false);
            }
            case TIRExpressionTag.IsTypeExpression: {
                return this.emitIsTypeExpression(exp as TIRIsTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.IsNotTypeExpression: {
                return this.emitIsNotTypeExpression(exp as TIRIsNotTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.IsSubTypeExpression: {
                return this.emitIsSubTypeExpression(exp as TIRIsSubTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.IsNotSubTypeExpression: {
                return this.emitIsNotSubTypeExpression(exp as TIRIsNotSubTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNoneSpecialExpression: {
                return this.emitAsNoneSpecialExpression(exp as TIRAsNoneSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsSomeSpecialExpression: {
                return this.emitAsSomeSpecialExpression(exp as TIRAsSomeSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNothingSpecialExpression: {
                return this.emitAsNothingSpecialExpression(exp as TIRAsNothingSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsSomethingSpecialExpression: {
                return this.emitAsSomethingSpecialExpression(exp as TIRAsSomethingSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsOkSpecialExpression: {
                return this.emitAsOkSpecialExpression(exp as TIRAsOkSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsErrSpecialExpression: {
                return this.emitAsErrSpecialExpression(exp as TIRAsErrSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsEqualToLiteralExpression: {
                return this.emitAsEqualToLiteralExpression(exp as TIRAsEqualToLiteralExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNotEqualToLiteralExpression: {
                return this.emitAsNotEqualToLiteralExpression(exp as TIRAsNotEqualToLiteralExpression, toplevel || false);
            }
            case TIRExpressionTag.AsTypeExpression: {
                return this.emitAsTypeExpression(exp as TIRAsTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNotTypeExpression: {
                return this.emitAsNotTypeExpression(exp as TIRAsNotTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.AsSubTypeExpression: {
                return this.emitAsSubTypeExpression(exp as TIRAsSubTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNotSubTypeExpression: {
                return this.emitAsNotSubTypeExpression(exp as TIRAsNotSubTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionExpression: {
                return this.emitCallMemberFunctionExpression(exp as TIRCallMemberFunctionExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionDynamicExpression: {
                return this.emitCallMemberFunctionDynamicExpression(exp as TIRCallMemberFunctionDynamicExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionSelfRefExpression: {
                return this.emitCallMemberFunctionSelfRefExpression(exp as TIRCallMemberFunctionSelfRefExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionTaskExpression: {
                return this.emitCallMemberFunctionTaskExpression(exp as TIRCallMemberFunctionTaskExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionTaskSelfRefExpression: {
                return this.emitCallMemberFunctionTaskSelfRefExpression(exp as TIRCallMemberFunctionTaskSelfRefExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberActionExpression: {
                return this.emitCallMemberActionExpression(exp as TIRCallMemberActionExpression, toplevel || false);
            }
            default: {
                assert(false, `Unknown expression kind ${exp.tag}`);
                return `[UNKNOWN TAG ${exp.tag}]`
            }
        }
        */
    }

    method emitNopStatement(stmt: TIRNopStatement): String {
        return "; //nop";
    }
/*
    method emitAbortStatement(stmt: TIRAbortStatement): String {
        return `$Runtime.raiseUserAssert("${stmt.msg}");`;
    }

    method emitAssertCheckStatement(stmt: TIRAssertCheckStatement): String {
        return `$Runtime.raiseUserAssertIf(!((() => { try { return ${this.emitExpression(stmt.cond, true)}; } catch (ex) { $Runtime.log("warn", "AssertEvalFailure", "condition failure"); return true; } })()), "${stmt.msg}");`;
    }

    method emitDebugStatement(stmt: TIRDebugStatement): String {
        return `try { console.log(${this.emitExpression(stmt.value, true)}); } catch(ex) { console.log("__debug(${stmt.value.expstr}) evaluation failed"); }`;
    }
*/
    method emitVarDeclareStatement(stmt: TIRVarDeclareStatement): String {
        return `let ${stmt.vname};`;
    }

    method emitVarDeclareAndAssignStatement(stmt: TIRVarDeclareAndAssignStatement): String {
        return `let ${stmt.vname} = ${this.emitExpression(stmt.vexp, true)};`;
    }

    method emitVarAssignStatement(stmt: TIRVarAssignStatement): String {
        if(stmt.vname !== "this") {
            return `${stmt.vname} = ${this.emitExpression(stmt.vexp, true)};`;
        }
        else {
            return `$_this = ${this.emitExpression(stmt.vexp, true)};`;
        }
    }
/*
    method emitStoreToScratch(stmt: TIRStoreToScratch): String {
        this.m_hasScratch = true;
        return `$Runtime.setScratchValue($$scratch, ${stmt.scidx}, ${this.emitExpression(stmt.exp, true)});`;
    }

    method emitVarRefAssignFromScratch(stmt: TIRVarRefAssignFromScratch): String {
        if(stmt.vname !== "this") {
            return `${stmt.vname} = $$scratch[${stmt.scidx}][0];`;
        }
        else {
            return `$_this = $$scratch[${stmt.scidx}][0];`;
        }
    }

    method emitTaskRefAssignFromScratch(stmt: TIRTaskRefAssignFromScratch): String {
        return `self = $$scratch[${stmt.scidx}];`;
    }

    method emitCallStatementWRef(stmt: TIRCallStatementWRef): String {
        return this.emitExpression(stmt.vexp, true);
    }

    method emitCallStatementWTaskRef(stmt: TIRCallStatementWTaskRef): String {
        return this.emitExpression(stmt.vexp, true);
    }

    method emitCallStatementWAction(stmt: TIRCallStatementWAction): String {
        return this.emitExpression(stmt.vexp, true);
    }

    method emitVariableRetypeStatement(stmt: TIRVariableRetypeStatement): String {
       return `${stmt.vname} = ${this.emitExpression(stmt.asconv, true)};`
    }

    method emitVariableSCRetypeStatement(stmt: TIRVariableSCRetypeStatement): String {
        const binder = stmt.binderinfo !== undefined ? ` ${stmt.binderinfo[1]} = ${this.emitExpression(stmt.binderinfo[0], true)};` : ""
        return `if(${this.emitExpression(stmt.test, true)}) { ${stmt.vname} = ${this.emitExpression(stmt.asconv, true)}; } else {${binder} return ${this.emitExpression(stmt.resexp, true)}; }`
    }

    method emitScratchSCStatement(stmt: TIRScratchSCStatement): String {
        assert(false, "NOT IMPLEMENTED -- TIRScratchSCStatement");
        return "NOT IMPLEMENTED -- TIRScratchSCStatement";
    }
*/
    method emitReturnStatement(stmt: TIRReturnStatement): String {
        return `return ${this.emitExpression(stmt.value, true)};`;
    }
/*
    method emitReturnStatementWRef(stmt: TIRReturnStatementWRef): String {
        return `return [$_this, ${this.emitExpression(stmt.value, true)}];`;
    }

    method emitReturnStatementWTaskRef(stmt: TIRReturnStatementWTaskRef): String {
        return `return [self, ${this.emitExpression(stmt.value, true)}];`;
    }

    method emitReturnStatementWAction(stmt: TIRReturnStatementWAction): String {
        return `return [self, ${this.emitExpression(stmt.value, true)}];`;
    }   

    method emitIfStatement(stmt: TIRIfStatement, indent: String): String {
        let sstr = "";
        if(stmt.ifentry.binderinfo === undefined) {
            const poststr = stmt.ifentry.recasttypes.length !== 0 ? stmt.ifentry.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
            sstr = `if(${this.emitExpression(stmt.ifentry.test, true)}) ${this.emitScopedBlock(stmt.ifentry.value, indent, undefined, poststr)}\n`;
        }
        else {
            this.m_hasScratch = true;
            const tstr = `($Runtime.setScratchValue($$scratch, ${stmt.ifentry.binderinfo[1]}, ${this.emitExpression(stmt.ifentry.binderinfo[0])}) || ${this.emitExpression(stmt.ifentry.test)})`;
            const prestr = `var ${stmt.ifentry.binderinfo[3]} = ${this.emitExpression(stmt.ifentry.binderinfo[2], true)};`
            const poststr = stmt.ifentry.recasttypes.length !== 0 ? stmt.ifentry.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
            sstr = `if(${tstr}) ${this.emitScopedBlock(stmt.ifentry.value, indent, prestr, poststr)}\n`;
        } 

        for (let i = 0; i < stmt.elifentries.length; ++i) {
            const eei = stmt.elifentries[i];
            const poststr = stmt.ifentry.recasttypes.length !== 0 ? eei.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;

            if (eei.binderinfo === undefined) {
                sstr += indent + `else if(${this.emitExpression(eei.test, true)}) ${this.emitScopedBlock(eei.value, indent, undefined, poststr)}\n`;
            }
            else {
                this.m_hasScratch = true;
                const tstr = `($Runtime.setScratchValue($$scratch, ${eei.binderinfo[1]}, ${this.emitExpression(eei.binderinfo[0], true)}) || ${this.emitExpression(eei.test)})`;
                const prestr = `var ${eei.binderinfo[3]} = ${this.emitExpression(eei.binderinfo[2], true)};`
                sstr += `if(${tstr}) ${this.emitScopedBlock(eei.value, indent, prestr, poststr)}\n`;
            }
        }

        if(stmt.elseentry.binderinfo === undefined) {
            const poststr = stmt.ifentry.recasttypes.length !== 0 ? stmt.elseentry.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
            sstr += indent + `else ${this.emitScopedBlock(stmt.elseentry.value, indent, undefined, poststr)}\n`;
        }
        else {
            this.m_hasScratch = true;
            const poststr = stmt.ifentry.recasttypes.length !== 0 ? stmt.elseentry.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
            const prestr = `$Runtime.setScratchValue($$scratch, ${stmt.elseentry.binderinfo[1]}, ${this.emitExpression(stmt.elseentry.binderinfo[0], true)}); var ${stmt.elseentry.binderinfo[3]} = ${this.emitExpression(stmt.elseentry.binderinfo[2], true)};`
            sstr += indent + `else ${this.emitScopedBlock(stmt.elseentry.value, indent, prestr, poststr)}\n`;
        }

        return sstr;
    }

    method emitSwitchStatement(stmt: TIRSwitchStatement, indent: String): String {
        assert(false, "NOT IMPLEMENTED -- TIRSwitchStatement");
        return "NOT IMPLEMENTED -- TIRSwitchStatement";
    }

    method emitMatchStatement(stmt: TIRMatchStatement, indent: String): String {
        this.m_hasScratch = true;
        let sstr = `$Runtime.setScratchValue($$scratch, ${stmt.scratchidx}, ${this.emitExpression(stmt.exp, true)});\n\n`;

        if(stmt.clauses[0].binderinfo === undefined) {
            const poststr = stmt.clauses[0].recasttypes.length !== 0 ? stmt.clauses[0].recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
            sstr += indent + `if(${this.emitExpression(stmt.clauses[0].match, true)}) ${this.emitScopedBlock(stmt.clauses[0].value, indent, undefined, poststr)}\n`;
        }
        else {
            const prestr = `var ${stmt.clauses[0].binderinfo[1]} = ${this.emitExpression(stmt.clauses[0].binderinfo[0], true)};`
            const poststr = stmt.clauses[0].recasttypes.length !== 0 ? stmt.clauses[0].recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
            sstr += indent + `if(${this.emitExpression(stmt.clauses[0].match, true)}) ${this.emitScopedBlock(stmt.clauses[0].value, indent, prestr, poststr)}\n`;
        }

        for(let i = 1; i < stmt.clauses.length; ++i) {
            if(stmt.clauses[i].binderinfo === undefined) {
                const poststr = stmt.clauses[i].recasttypes.length !== 0 ? stmt.clauses[i].recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
                sstr += indent + `else if(${this.emitExpression(stmt.clauses[i].match, true)}) ${this.emitScopedBlock(stmt.clauses[i].value, indent, undefined, poststr)}\n`;
            }
            else {
                const binfo = stmt.clauses[i].binderinfo as [TIRExpression, string];

                const prestr = `var ${binfo[1]} = ${this.emitExpression(binfo[0], true)};`
                const poststr = stmt.clauses[i].recasttypes.length !== 0 ? stmt.clauses[i].recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
                sstr += indent + `else if(${this.emitExpression(stmt.clauses[i].match, true)}) ${this.emitScopedBlock(stmt.clauses[i].value, indent, prestr, poststr)}\n`;
            }
        }

        if(stmt.edefault !== undefined) {
            if(stmt.edefault.binderinfo === undefined) {
                const poststr = stmt.edefault.recasttypes.length !== 0 ? stmt.edefault.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
                sstr += indent + `else ${this.emitScopedBlock(stmt.edefault.value, indent, undefined, poststr)}\n`;
            }
            else {
                const prestr = `var ${stmt.edefault.binderinfo[1]} = ${this.emitExpression(stmt.edefault.binderinfo[0], true)};`
                const poststr = stmt.edefault.recasttypes.length !== 0 ? stmt.edefault.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
                sstr += indent + `else ${this.emitScopedBlock(stmt.edefault.value, indent, prestr, poststr)}\n`;
            }
        }
        else {
            sstr += indent + "else {\n"
            if(stmt.isexhaustive) {
                sstr += indent + "    ;\n";
            }
            else {
                sstr += indent + "    " + `$Runtime.raiseRuntimeError("Non-exhaustive match statement" + " -- ${this.m_file} @ line ${stmt.sinfo.line}")` + ";\n"
            }
            sstr += indent + "}\n";
        }

        return sstr;
    }

    method emitEnvironmentFreshStatement(stmt: TIREnvironmentFreshStatement): String {
        const binds = stmt.assigns.map((asgn) => `["${asgn.keyname}", {tkey: "${asgn.valexp[0]}", value: ${this.emitExpression(asgn.valexp[1], true)}}]`);
        return `self.$environment = new $Runtime.BSQEnvironment(undefined, ${binds.join(", ")});`
    }

    method emitEnvironmentSetStatement(stmt: TIREnvironmentSetStatement): String {
        const binds = stmt.assigns.map((asgn) => {
            if(asgn.valexp === undefined) {
                return `$Runtime.BSQEnvironment.clear(self.$environment, "${asgn.keyname}");`
            }
            else {
                return `$Runtime.BSQEnvironment.set(self.$environment, "${asgn.keyname}", ${this.emitExpression(asgn.valexp[1], true)}, "${asgn.valexp[0]}");`
            }
        });

        return binds.join(" ");
    }

    method emitEnvironmentSetStatementBracket(stmt: TIREnvironmentSetStatementBracket, indent: String): String {
        let sstr = "";
        let tmpe = `$_tmpenv_${this.m_varCtr++}`;
        if(stmt.isFresh) {
            sstr = `const ${tmpe} = self.$environment; self.$environment = new $Runtime.BSQEnvironment(undefined);`;
        }
        else {
            sstr = `self.$environment = $Runtime.BSQEnvironment.push(self.$environment);`;
        }

        const binds = stmt.assigns.map((asgn) => {
            if(asgn.valexp === undefined) {
                return `$Runtime.BSQEnvironment.clear(self.$environment, "${asgn.keyname}");`
            }
            else {
                return `$Runtime.BSQEnvironment.set(self.$environment, "${asgn.keyname}", ${this.emitExpression(asgn.valexp[1], true)}, "${asgn.valexp[0]}");`
            }
        });
        sstr += (binds.length !== 0) ? ("\n" + indent + binds.join(" ")) : ""

        if(stmt.block instanceof TIRScopedBlockStatement) {
            sstr += this.emitScopedBlock(stmt.block, indent);
        }
        else {
            sstr += this.emitUnscopedBlock(stmt.block, indent);
        }

        if(stmt.isFresh) {
            sstr += `self.$environment = ${tmpe}\n`;
        }
        else {
            sstr += `self.$environment = $Runtime.BSQEnvironment.pop(self.$environment);\n`;
        }

        return sstr;
    }

    method emitTaskRunStatement(stmt: TIRTaskRunStatement): String {
        const taskaccess = this.resolveTypeMemberAccess(stmt.task);
        const vdcl = stmt.isdefine ? (stmt.isconst ? `let ${stmt.vtrgt.name}` : `var ${stmt.vtrgt.name}`) : stmt.vtrgt.name;

        const execargs = `{${stmt.taskargs.map((earg) => earg.argn + ": " + this.emitExpression(earg.argv, true)).join(", ")}}`;
        const consarg = this.emitExpression(stmt.consarg.rarg, true);
        const callargs = stmt.args.map((arg) => this.emitExpression(arg, true));

        return `${vdcl} = await ${taskaccess}.$mainfunc(${execargs}, ${consarg}, ${callargs});`;
    }

    method emitTaskMultiStatement(stmt: TIRTaskMultiStatement): String {
        return NOT_IMPLEMENTED_STATEMENT(stmt.tag);
    }

    method emitTaskDashStatement(stmt: TIRTaskDashStatement): String {
        return NOT_IMPLEMENTED_STATEMENT(stmt.tag);
    }

    method emitTaskAllStatement(stmt: TIRTaskAllStatement): String {
        return NOT_IMPLEMENTED_STATEMENT(stmt.tag);
    }

    method emitTaskRaceStatement(stmt: TIRTaskRaceStatement): String {
        return NOT_IMPLEMENTED_STATEMENT(stmt.tag);
    }

    method emitTaskSetSelfFieldStatement(stmt: TIRTaskSetSelfFieldStatement): String {
        return `self.${stmt.fname} = ${this.emitExpression(stmt.value, true)};`;
    }

    method emitLoggerEmitStatement(stmt: TIRLoggerEmitStatement): String {
        const fmt = `${stmt.fmt.ns}.${stmt.fmt}`; 
        const args = stmt.args.map((arg) => this.emitExpression(arg)).join(", ")

        return `if($Runtime.checkloglevel(${stmt.level})) { try { $Runtime.log("${fmt}", ${stmt.level}, ${fmt}, ${args}); } catch(ex) { $Runtime.log("LoggerError", "error", "[[logging failure -- ${this.m_file}@${stmt.sinfo.line}]]"); } }`;
    }

    method emitLoggerEmitConditionalStatement(stmt: TIRLoggerEmitConditionalStatement): String {
        const fmt = `${stmt.fmt.ns}.${stmt.fmt}`; 
        const args = stmt.args.map((arg) => this.emitExpression(arg)).join(", ")
        
        const test = this.emitExpression(stmt.cond);
        return `if($Runtime.checkloglevel(${stmt.level} && ${test})) { try { $Runtime.log("${fmt}", ${stmt.level}, ${fmt}, ${args}); } catch(ex) { $Runtime.log("LoggerError", "error", "[[logging failure -- ${this.m_file}@${stmt.sinfo.line}]]"); } }`
    }

    method emitLoggerSetPrefixStatement(stmt: TIRLoggerSetPrefixStatement, indent: String): String {
        const fmt = `${stmt.fmt.ns}.${stmt.fmt}`; 
        const args = stmt.args.map((arg) => this.emitExpression(arg)).join(", ")
        
        const bblock = (stmt.block instanceof TIRScopedBlockStatement) ? this.emitScopedBlock(stmt.block, indent) : this.emitUnscopedBlock(stmt.block, indent);

        //TODO: unscoped block needs some work here!
        return `$Runtime.pushlogprefix(${fmt}, ${args}); try ${bblock}\n${indent}catch(ex) { $Runtime.log("LoggerError", "error", "[[logging failure -- ${this.m_file}@${stmt.sinfo.line}]]"); } \n${indent}$Runtime.poplogprefix();`
    }

    emitScopedBlock(blck: TIRScopedBlockStatement, indent: String, prestr?: String | undefined, poststr?: String | undefined): String {
        const stmts = blck.ops.map((op) => indent + "    " + this.emitStatement(op, indent + "    ")).join("\n");

        return " {\n" + (prestr !== undefined ? `${indent + "    "}${prestr}\n` : "") + stmts + "\n" + (poststr !== undefined ? `${indent + "    "}${poststr}\n` : "") + indent + "}";
    }

    emitUnscopedBlock(blck: TIRUnscopedBlockStatement, indent: String): String {
        //TODO: need to declare vars as let before block so we can support things like -- LoggerSetPrefix that need to wrap the block as a try{...}catch{...}
        return NOT_IMPLEMENTED_STATEMENT("TIRUnscopedBLock");
    }
*/
    method emitStatement(stmt: TreeIR::Statement, indent: String): String {
        /*
        switch(stmt.tag) {
            case TIRStatementTag.NopStatement: {
                return this.emitNopStatement(stmt as TIRNopStatement);
            }
            case TIRStatementTag.AbortStatement: {
                return this.emitAbortStatement(stmt as TIRAbortStatement);
            }
            case TIRStatementTag.AssertCheckStatement: {
                return this.emitAssertCheckStatement(stmt as TIRAssertCheckStatement);
            }
            case TIRStatementTag.DebugStatement: {
                return this.emitDebugStatement(stmt as TIRDebugStatement);
            }
            case TIRStatementTag.VarDeclareStatement: {
                return this.emitVarDeclareStatement(stmt as TIRVarDeclareStatement);
            }
            case TIRStatementTag.VarDeclareAndAssignStatement: {
                return this.emitVarDeclareAndAssignStatement(stmt as TIRVarDeclareAndAssignStatement);
            }
            case TIRStatementTag.VarAssignStatement: {
                return this.emitVarAssignStatement(stmt as TIRVarAssignStatement);
            }
            case TIRStatementTag.StoreToScratch: {
                return this.emitStoreToScratch(stmt as TIRStoreToScratch);
            }
            case TIRStatementTag.VarRefAssignFromScratch: {
                return this.emitVarRefAssignFromScratch(stmt as TIRVarRefAssignFromScratch);
            }
            case TIRStatementTag.TaskRefAssignFromScratch: {
                return this.emitTaskRefAssignFromScratch(stmt as TIRTaskRefAssignFromScratch);
            }
            case TIRStatementTag.CallWRefStatement: {
                return this.emitCallStatementWRef(stmt as TIRCallStatementWRef);
            }
            case TIRStatementTag.CallStatementWTaskRef: {
                return this.emitCallStatementWTaskRef(stmt as TIRCallStatementWTaskRef);
            }
            case TIRStatementTag.CallStatementWTaskAction: {
                return this.emitCallStatementWAction(stmt as TIRCallStatementWAction);
            }
            case TIRStatementTag.VariableRetypeStatement: {
                return this.emitVariableRetypeStatement(stmt as TIRVariableRetypeStatement);
            }
            case TIRStatementTag.VariableSCRetypeStatement: {
                return this.emitVariableSCRetypeStatement(stmt as TIRVariableSCRetypeStatement);
            }
            case TIRStatementTag.ScratchSCStatement: {
                return this.emitScratchSCStatement(stmt as TIRScratchSCStatement);
            }
            case TIRStatementTag.ReturnStatement: {
                return this.emitReturnStatement(stmt as TIRReturnStatement);
            }
            case TIRStatementTag.ReturnStatementWRef: {
                return this.emitReturnStatementWRef(stmt as TIRReturnStatementWRef);
            }
            case TIRStatementTag.ReturnStatementWTaskRef: {
                return this.emitReturnStatementWTaskRef(stmt as TIRReturnStatementWTaskRef);
            }
            case TIRStatementTag.ReturnStatementWAction: {
                return this.emitReturnStatementWAction(stmt as TIRReturnStatementWAction);
            }
            case TIRStatementTag.IfStatement: {
                return this.emitIfStatement(stmt as TIRIfStatement, indent);
            }
            case TIRStatementTag.SwitchStatement: {
                return this.emitSwitchStatement(stmt as TIRSwitchStatement, indent);
            }
            case TIRStatementTag.MatchStatement: {
                return this.emitMatchStatement(stmt as TIRMatchStatement, indent);
            }
            case TIRStatementTag.EnvironmentFreshStatement: {
                return this.emitEnvironmentFreshStatement(stmt as TIREnvironmentFreshStatement);
            }
            case TIRStatementTag.EnvironmentSetStatement: {
                return this.emitEnvironmentSetStatement(stmt as TIREnvironmentSetStatement);
            }
            case TIRStatementTag.EnvironmentSetStatementBracket: {
                return this.emitEnvironmentSetStatementBracket(stmt as TIREnvironmentSetStatementBracket, indent);
            }
            case TIRStatementTag.TaskRunStatement: {
                return this.emitTaskRunStatement(stmt as TIRTaskRunStatement);
            }
            case TIRStatementTag.TaskMultiStatement: {
                return this.emitTaskMultiStatement(stmt as TIRTaskMultiStatement);
            }
            case TIRStatementTag.TaskDashStatement: {
                return this.emitTaskDashStatement(stmt as TIRTaskDashStatement);
            }
            case TIRStatementTag.TaskAllStatement: {
                return this.emitTaskAllStatement(stmt as TIRTaskAllStatement);
            }
            case TIRStatementTag.TaskRaceStatement: {
                return this.emitTaskRaceStatement(stmt as TIRTaskRaceStatement);
            }
            case TIRStatementTag.TaskSetSelfFieldStatement: {
                return this.emitTaskSetSelfFieldStatement(stmt as TIRTaskSetSelfFieldStatement);
            }
            case TIRStatementTag.LoggerEmitStatement: {
                return this.emitLoggerEmitStatement(stmt as TIRLoggerEmitStatement);
            }
            case TIRStatementTag.LoggerEmitConditionalStatement: {
                return this.emitLoggerEmitConditionalStatement(stmt as TIRLoggerEmitConditionalStatement);
            }
            case TIRStatementTag.LoggerSetPrefixStatement: {
                return this.emitLoggerSetPrefixStatement(stmt as TIRLoggerSetPrefixStatement, indent);
            }
            default: {
                assert(false, `Unknown statement kind ${stmt.tag}`);
                return `[UNKNOWN TAG ${stmt.tag}]`
            }
        }
        */
    }

    emitBodyStatementList(body: TIRStatement[], preconds: TIRPreConditionDecl[], postconds: TIRPostConditionDecl[], indent: String, fname: String, extractres: boolean): String {
        const bodyindent = indent + "    ";
        const wbodyindent = bodyindent + "    ";
        let rconds = "";

        if(preconds.length !== 0) {
            rconds = bodyindent + preconds.map((pc) => `$Runtime.raiseUserAssertIf(!((() => { try { return ${this.emitExpression(pc.exp)}; } catch (ex) { $Runtime.log("warn", "PreCondEvalFailure", "condition failure"); return true; } })()), "Failed precondition ${fname} -- ${pc.exp.expstr}");`).join("\n" + bodyindent) + "\n";
        }

        const bstmts = body.map((stmt) => this.emitStatement(stmt, postconds.length === 0 ? bodyindent : wbodyindent));
        const scratch = this.m_hasScratch ? `${bodyindent}let $$scratch = [];\n` : "";

        if(postconds.length === 0) {
            return `{\n${scratch}${rconds}${bodyindent}${bstmts.join("\n" + bodyindent)}\n${indent}}`;
        }
        else {
            const bstr = `{\n${bstmts.join("\n" + wbodyindent)}\n${bodyindent}}`;
            const econds = bodyindent + postconds.map((pc) => `$Runtime.raiseUserAssertIf(!((() => { try { return ${this.emitExpression(pc.exp)}; } catch (ex) { $Runtime.log("warn", "PreCondEvalFailure", "condition failure"); return true; } })()), "Failed postcondition ${fname} -- ${pc.exp.expstr}");`).join("\n" + bodyindent);

            return `{\n${scratch}${rconds}const $$return" = (() => ${bstr})();\n${bodyindent}$return = ${extractres ? "$$return[1]" : "$$return"};\n${econds}\n${bodyindent}return $$return;\n${indent}}`;
        }
    }
}
