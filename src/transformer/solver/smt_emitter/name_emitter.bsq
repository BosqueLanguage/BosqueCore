namespace SMTEmit;

import TreeIR;

entity SMTEncodingSymbol {
    const coloncolon: String = "-cc-";
    const comma: String = "-c-";
    const lbrace: String = "-lc-";
    const rbrace: String = "-rc-";
    const lbracket: String = "-lb-";
    const rbracket: String = "-rb-";
    const langle: String = "-la-";
    const rangle: String = "-ra-";
    const space: String = "";
}

function smtifyNamespace(ns: TreeIR::NamespaceIdentifier): String {
    return ns.value();
}

function smtifyType(tkey: TreeIR::TypeKey): String {
    //replace special characters with @enc@
    let rawname = tkey.value().value();
    let name = rawname
        .replaceAllTry("::", SMTEncodingSymbol::coloncolon)
        .replaceAllTry(",", SMTEncodingSymbol::comma)
        .replaceAllTry("<", SMTEncodingSymbol::langle)
        .replaceAllTry(">", SMTEncodingSymbol::rangle)
        .replaceAllTry("[", SMTEncodingSymbol::lbracket)
        .replaceAllTry("]", SMTEncodingSymbol::rbracket)
        .replaceAllTry("{", SMTEncodingSymbol::lbrace)
        .replaceAllTry("}", SMTEncodingSymbol::rbrace)
        .replaceAllTry(" ", SMTEncodingSymbol::space);

    return name;
}

function smtifyIdentifier(ii: TreeIR::Identifier): String {
    return ii.value().value();
}

function smtifyInvokeKey(ii: TreeIR::InvokeKey): String {
    //replace special characters with @enc@
    let rawname = ii.value().value();
    let name = rawname
        .replaceAllTry("::", SMTEncodingSymbol::coloncolon)
        .replaceAllTry(",", SMTEncodingSymbol::comma)
        .replaceAllTry("<", SMTEncodingSymbol::langle)
        .replaceAllTry(">", SMTEncodingSymbol::rangle)
        .replaceAllTry("[", SMTEncodingSymbol::lbracket)
        .replaceAllTry("]", SMTEncodingSymbol::rbracket)
        .replaceAllTry("{", SMTEncodingSymbol::lbrace)
        .replaceAllTry("}", SMTEncodingSymbol::rbrace)
        .replaceAllTry(" ", SMTEncodingSymbol::space);

    return name;
}

function emitTypeName(tkey: TreeIR::TypeKey): String {
    //TODO: mapping from types to special names and/or cleaning
    if(tkey === "None"_TreeIR::TypeKey) {
        return "None";
    }
    elif(tkey === "Bool"_TreeIR::TypeKey) {
        return "Bool";
    }
    elif(tkey === "Int"_TreeIR::TypeKey) {
        return "Int";
    }
    elif(tkey === "Nat"_TreeIR::TypeKey) {
        return "Int";
    }
    elif(tkey === "BigInt"_TreeIR::TypeKey) {
        return "Int";
    }
    elif(tkey === "BigNat"_TreeIR::TypeKey) {
        return "Int";
    }
    elif(tkey === "Rational"_TreeIR::TypeKey) {
        return "@Rational";
    }
    elif(tkey === "Float"_TreeIR::TypeKey) {
        return "@Float";
    }
    elif(tkey === "Decimal"_TreeIR::TypeKey) {
        return "@Decimal";
    }
    elif(tkey === "String"_TreeIR::TypeKey) {
        return "String";
    }
    elif(tkey === "ASCIIString"_TreeIR::TypeKey) {
        return "String";
    }
    elif(tkey === "ByteBuffer"_TreeIR::TypeKey) {
        return "(Seq (_ BitVec 8))";
    }

    else {
        //let ttype = this.assembly.typeMap.get(tt);
        //match on type options here
        return smtifyType(tkey);
    }
}

function typeEncodedAsUnion(tt: TreeIR::TypeKey): Bool {
    let ttype = this.assembly.typeMap.get(tt);
    return (ttype?<TreeIR::ConceptType> || ttype?<TreeIR::UnionType>);
}
