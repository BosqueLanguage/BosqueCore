namespace SMTEmit;

import TreeIR;

entity SMTEncodingSymbol {
    const coloncolon: String = "@cc-";
    const comma: String = "@c-";
    const commaspace: String = "@c_-";
    const lparen: String = "@lp-";
    const rparen: String = "@rp-";
    const lbracket: String = "@lb-";
    const rbracket: String = "@rb-";
    const langle: String = "@la-";
    const randle: String = "@ra-";
}

function smtifyNamespace(ns: TreeIR::NamespaceIdentifier): String {
    return ns.value();
}

function smtifyType(tkey: TreeIR::TypeKey): String {
    //eplace special characters with @enc@
    return tkey.value().value();
}

function smtifyIdentifier(ii: TreeIR::Identifier): String {
    return ii.value().value();
}

function smtifyInvokeKey(ii: TreeIR::InvokeKey): String {
    //TODO: replace special characters with @enc@
    return ii.value().value();
}

function emitTypeName(tkey: TreeIR::TypeKey): String {
    //TODO: mapping from types to special names and/or cleaning
    if(tkey === "None"_TreeIR::TypeKey) {
        return "None";
    }
    elif(tkey === "Bool"_TreeIR::TypeKey) {
        return "Bool";
    }
    elif(tkey === "Int"_TreeIR::TypeKey) {
        return "Int";
    }
    elif(tkey === "Nat"_TreeIR::TypeKey) {
        return "Int";
    }
    elif(tkey === "BigInt"_TreeIR::TypeKey) {
        return "Int";
    }
    elif(tkey === "BigNat"_TreeIR::TypeKey) {
        return "Int";
    }
    elif(tkey === "Rational"_TreeIR::TypeKey) {
        return "@Rational";
    }
    elif(tkey === "Float"_TreeIR::TypeKey) {
        return "@Float";
    }
    elif(tkey === "Decimal"_TreeIR::TypeKey) {
        return "@Decimal";
    }
    elif(tkey === "String"_TreeIR::TypeKey) {
        return "String";
    }
    elif(tkey === "ASCIIString"_TreeIR::TypeKey) {
        return "String";
    }
    elif(tkey === "ByteBuffer"_TreeIR::TypeKey) {
        return "(Seq (_ BitVec 8))";
    }

    else {
        //let ttype = this.assembly.typeMap.get(tt);
        //match on type options here
        return smtifyType(tkey);
    }
}

function typeEncodedAsUnion(tt: TreeIR::TypeKey): Bool {
    let ttype = this.assembly.typeMap.get(tt);
    return (ttype?<TreeIR::ConceptType> || ttype?<TreeIR::UnionType>);
}
