namespace CPPEmitter;

%%
%% I suspect either somewhere in this file or in the transform we hit an abort and never actually emit any cpp
%% Not sure exactly where thought...
%%

function emitIncludes(): CString {
    return '#include "cppruntime.hpp"';
}

function emitFunction(ik: CPPAssembly::InvokeKey): CString {
    return ik.value;
}

recursive function emitBinAddExpression(add: CPPAssembly::BinAddExpression): CString {
    let lhs = emitExpression[recursive](add.lhs);
    let rhs = emitExpression[recursive](add.rhs);

    %% In my cppruntime header I need to for each primitive write out a struct
    %% with correct operator overloading to correctly map Int -> int64_t and stuff
    %% Here we also need to something like Struct Int_TypeInfo IN THE HEADER ITSELF.
    %% We also want to do overflow safe like __safe_add__ . We overload plus with these values

    return CString::concat('(', lhs, ' + ', rhs, ')');
}

recursive function emitBinSubExpression(add: CPPAssembly::BinSubExpression): CString {
    abort;
}

function emitBinaryArithExpression(e: CPPAssembly::BinaryArithExpression): CString {
    match(e)@ {
        CPPAssembly::BinAddExpression => { return emitBinAddExpression[recursive]($e); }
        %% | CPPAssembly::BinSubExpression => { return emitBinSubExpression[recursive]($e); }
        | _ => { abort; }
    }
}

function emitExpression(e: CPPAssembly::Expression): CString {
    match(e)@ {
        CPPAssembly::BinaryArithExpression => { return emitBinaryArithExpression[recursive]($e); }
        | _ => { abort; }
    }
}

function emitVariableInitializationStatement(stmt: CPPAssembly::VariableInitializationStatement): CString {
    let name: CString = 'hi'; %% need to convert stmt.name
    let stype: CString = 'int'; %% Needs some real magic
    let exp: CString = emitExpression(stmt.exp);

    return CString::concat(stype, ' ', stype, ' = ', exp);
}

function emitStatement(stmt: CPPAssembly::Statement): CString {
    match(stmt)@ {
        CPPAssembly::VariableInitializationStatement => { return emitVariableInitializationStatement($stmt); }
        | CPPAssembly::ReturnSingleStatement => { return ''; } %% TODO
        | _ => { abort; }
    }
}

function emitStandardBodyImplementation(body: CPPAssembly::StandardBodyImplementation): CString {
    return CString::joinAll('%n;', body.statements.map<CString>(fn(stmt) => emitStatement(stmt)));
}

function emitBodyImplementation(body: CPPAssembly::BodyImplementation): CString {
    match(body)@ {
        %% CPPAssembly::AbstractBodyImplementation => { abort; }
        %% | CPPAssembly::PredicateUFBodyImplementation => { abort; }
        %% | CPPAssembly::BuiltinBodyImplementation => { abort; }
        %% | CPPAssembly::SynthesisBodyImplementation => { abort; }
        %% | CPPAssembly::ExpressionBodyImplementation => { abort; }
        CPPAssembly::StandardBodyImplementation => { return emitStandardBodyImplementation($body); }
        | _ => { abort; }
    }
}


function emitNamespaceFunctionDecl(func: CPPAssembly::NamespaceFunctionDecl): CString {
    %% Function name
    %% Params
    %% Return?
    return emitBodyImplementation(func.body);
}

%% CPP Pre-defined backend
namespace PathStack {
    function emitPathStackCreate(): CString {
        return 'PathStack ps = PathStack::create();';
    }

    function emitPathStackLeft(): CString {
        return 'ps.left();';
    }

    function emitPathStackRight(): CString {
        return 'ps.right();';
    }

    function emitPathStackUp(): CString {
        return 'ps.up();';
    }
}

namespace CCharBuffer {
    %% Emit c++ for buffer creation here
}

namespace UnicodeCharBuffer {
    %% Emit c++ for buffer creation here
}


function emitAssembly(asm: CPPAssembly::Assembly): CString {
    %% For now we just grab every function
    let includes = emitIncludes();

    let efuncs_list = asm.allfuncs.map<CString>(fn(t) => { 
        if(asm.nsfuncs.has(t)) {
            return emitNamespaceFunctionDecl(asm.nsfuncs.get(t));
        }
        return 'NOT IMPLEMENTED!';
     });
    let efuncs = CString::joinAll('%n;%n;', efuncs_list);

    %% For CCharBuf and Unicode... will need to emit builtin functions explicitly

    %% We dont even emit the headers, so something must be causing aborting
    return CString::join('%n;', includes, efuncs);
}