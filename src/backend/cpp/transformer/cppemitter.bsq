namespace CPPEmitter;

%% CPP Pre-defined backend
namespace PathStack {
    function emitPathStackCreate(): String {
        return "PathStack ps = PathStack::create();";
    }

    function emitPathStackLeft(): String {
        return "ps.left();";
    }

    function emitPathStackRight(): String {
        return "ps.right();";
    }

    function emitPathStackUp(): String {
        return "ps.up();";
    }
}

namespace CCharBuffer {
    %% Emit c++ for buffer creation here
}

namespace UnicodeCharBuffer {
    %% Emit c++ for buffer creation here
}

entity Context {
    field asm: CPPAssembly::Assembly;
    field fullns_key: CPPAssembly::NamespaceKey; %% Main::Foo::Bar::...
    field fullns_list: List<CString>; %% ["Main", "Foo", "Bar", ...]

    method updateCurrentNamespace(new_ns: CPPAssembly::NamespaceKey, new_nsname: List<CString>): Context {
        return Context{ this.asm, new_ns, new_nsname };
    }
}

function emitEnclosedParen(s: CString): String {
    return String::fromCString(CString::concat('"', s, '"'));
}

function emitTypeKeyValue(tk: CPPAssembly::TypeKey): String {
    return String::fromCString(tk.value);
}

function emitInvokeKeyValue(ik: CPPAssembly::InvokeKey): String {
    return String::fromCString(ik.value);
}

function emitIdentifierValue(i: CPPAssembly::Identifier): String {
    return String::fromCString(i.value);
}

function emitVarIdentifierValue(vi: CPPAssembly::VarIdentifier): String {
    return String::fromCString(vi.value);
}

function emitSpecialThis(): String {
    return "ùê≠ùê°ùê¢ùê¨";
}    

function getAccessor(tk: CPPAssembly::TypeKey, ctx: Context): String {
    return if(ctx.asm.typeinfos.get(tk).tag === CPPAssembly::Tag#Ref) then ".access_ref" else ".access";
}

function removeCommonPrefix(name: String, prefix: String): String {
    if(!name.startsWithString(prefix)) {
        return "";
    }
    return name.removePrefixString(prefix);
}

function emitSpecialTemplate(name: String): String {
    if(name.startsWithString("__CoreCpp")) {
        return name;
    }
    
    let base = name.replaceAllStringOccurrences(" ", "");
    let first = base.replaceAllStringOccurrences("<", "·ê∏");
    let second = first.replaceAllStringOccurrences(",", "·êß");
    let third = second.replaceAllStringOccurrences(">", "·ê≥");
    let final = third.replaceAllStringOccurrences("::", "·òè");

    return final;
}

function emitBindVar(bname: CPPAssembly::VarIdentifier, convert: String, converttype: String, exp: String): String { 
    let name = emitVarIdentifier(bname); 
    let tbindtype = String::concat("[[maybe_unused]] ", converttype, " ");
    return String::concat(tbindtype, name, " = ", exp, convert, "; ");
}

function findFieldOffset(tk: CPPAssembly::TypeKey, fname: CPPAssembly::Identifier, ctx: Context): Nat {
    return ctx.asm.lookupNominalTypeDeclaration(tk).saturatedBFieldInfo
        .reduce<(|Nat, Bool|)>((|0n, false|), fn(acc, f) => {
            if(acc.1 === false) {
                let found = fname.value === f.fname.value;
                let size = if(found) then 0n else ctx.asm.typeinfos.get(f.ftype.tkeystr).slotsize;
                return (|acc.0 + size, found|);
            }
            else {
                return acc;
            }
        }).0;
}

function canUseDirectFieldAccess(act: CPPAssembly::AbstractConceptTypeDecl, fname: CPPAssembly::Identifier, ctx: Context): Bool, Nat {
    if(act.subtypes.size() == 0n) {
        return false, 0n;
    }
    
    let baseidx = findFieldOffset(act.subtypes.front(), fname, ctx);
    let allsubtypessame = act.subtypes.reduce<Bool>(false, fn(acc, subtype) => {
        return baseidx == findFieldOffset(subtype, fname, ctx);
    });

    return allsubtypessame, baseidx;
}

%% We dont want __CoreCpp prefix when emitting typeinfo field for primitives
function removeCppPrefix(s: String): String {
    return if(s.startsWithString("__CoreCpp::")) then s.removePrefixString("__CoreCpp::") else s;
}

function convertCStringList(l: List<CString>): List<String> {
    return l.map<String>(fn(e) => String::fromCString(e));
}

function emitResolvedTemplates(tk: Option<CPPAssembly::TypeKey>, ik: Option<CPPAssembly::InvokeKey>, ctx: Context): String {
    if(tk?some && tk@some.value.startsWithString('(|')) { %% Handle elists explicitly
        return emitSpecialTemplate(String::fromCString(tk@some.value));
    }
    
    %% Handle Type Funcs explicitly as their InvokeKey is missing the "Core::" prefix
    let isTypeFunc = if(ik)@some then ctx.asm.typefuncs.has($ik) else false;
    
    var resolvedik: Option<CPPAssembly::InvokeKey>;
    match(ik) {
        Some<CPPAssembly::InvokeKey> => { resolvedik = if(isTypeFunc) 
            then some(ctx.asm.typefuncs.get(ik@some).completeikey) 
            else ik; }
        | None => { resolvedik = ik; }
    }

    var declaredInNS: String;
    match(tk) {
        Some<CPPAssembly::TypeKey> => { declaredInNS = emitNamespaceKey(ctx.asm.lookupNominalTypeDeclaration(tk@some).declaredInNS); }
        | None => { declaredInNS = emitNamespaceKey(ctx.asm.tryLookupInvokeImplDeclaration(ik@some)@some.declaredInNS); }
    }
    
    %% If a typefunc we need to create the namespace key from its completens (as tfunc.declaredInNS is lacking "Core::" prefix)
    var resolvedns: String;
    match(ik) { 
        Some<CPPAssembly::InvokeKey> => { resolvedns = if(isTypeFunc) 
            then String::joinAll("::", convertCStringList(ctx.asm.typefuncs.get(ik@some).completens)) 
            else declaredInNS; }
        | None => { resolvedns = declaredInNS; }
    }

    let key = if(tk)@some then emitTypeKeyValue($tk) else emitInvokeKeyValue(resolvedik@some);
    if(key.startsWithString("__CoreCpp") || key === "bool") { %% No backend impl for bools 
        return key;
    }
    else { 
        let ns = String::concat(resolvedns, "::");
        let resolvedkey = if(ns.startsWithString("Core") && !key.startsWithString("Core")) 
            then String::concat("Core::", key)
            else key;
        let noprekey = removeCommonPrefix(resolvedkey, ns);
        let template = emitSpecialTemplate(noprekey);
        
        return if(template === "") then String::concat(ns, noprekey) 
            else String::concat(ns, template);
    }
}

function emitTypeSignature(ts: CPPAssembly::TypeSignature, shouldCheckTag: Bool, ctx: Context): String {
    if(ts)@<CPPAssembly::EListTypeSignature> {
        let argssizes = $ts.entries.map<String>(fn(e) => {
            let tinfo = ctx.asm.typeinfos.get(e.tkeystr);
            return if(tinfo.tag !== CPPAssembly::Tag#Ref) then String::fromCString(tinfo.slotsize.toCString())
                else "1";
        });
        let argstemplate = String::concat("<", String::joinAll(", ", argssizes), ">");
        let n = String::fromCString($ts.entries.size().toCString());

        return String::concat("__CoreCpp::Tuple", n, argstemplate);
    }
    else {
        return emitTypeKey(ts.tkeystr, shouldCheckTag, ctx);
    }
}

function emitTypeKey(tk: CPPAssembly::TypeKey, shouldCheckTag: Bool, ctx: Context): String {
    let emit = emitResolvedNamespace(ctx.fullns_list, emitResolvedTemplates(some(tk), none, ctx)); 

    if(shouldCheckTag) {
        let tinfo = ctx.asm.typeinfos.tryGet(tk)@some;

        switch(tinfo.tag) {
            CPPAssembly::Tag#Value => { return emit; }
            | CPPAssembly::Tag#Ref => { return String::concat(emit, "*"); }
            | CPPAssembly::Tag#Tagged => { return emit; }
        }
    }
    return emit;
}

function emitIdentifier(i: CPPAssembly::Identifier): String {
    return emitSpecialTemplate(emitIdentifierValue(i));
}

function emitVarIdentifier(vi: CPPAssembly::VarIdentifier): String {
    let vival = emitVarIdentifierValue(vi);
    if(vival === "this") {
        return emitSpecialThis();
    }
    elif (vival === "$this") {
        return String::concat("$", emitSpecialThis());
    }
    else {
        return emitSpecialTemplate(vival);
    }
}

function emitInvokeKey(ik: CPPAssembly::InvokeKey, ctx: Context): String {
    return emitResolvedNamespace(ctx.fullns_list, emitResolvedTemplates(none, some(ik), ctx)); 
}

function emitNamespaceKey(nsk: CPPAssembly::NamespaceKey): String {
    return String::fromCString(nsk.value);
}

%% Given a namespace key (like Main::Foo::Bar), remove all matching prefix strings
function emitResolvedNamespace(fullns_list: List<CString>, fullns: String): String {
    return fullns_list.reduce<String>(fullns, fn(acc, s) => {
        let val = String::fromCString(s);
        if(acc.startsWithString(val)) {
            let nopre = acc.removePrefixString(val);
            if(nopre.startsWithString("::")) {
                return nopre.removePrefixString("::");
            }
            else {
                return nopre;
            }
        }
        else {
            return acc;
        }
    });
}

function emitLiteralSimpleExpression(exp: CPPAssembly::LiteralSimpleExpression): String {
    let val = String::fromCString(exp.value);
    let etype = String::fromCString(exp.etype.tkeystr.value);
    switch(etype) {
        "__CoreCpp::Int" => { return String::concat(val, "_i"); }
        | "__CoreCpp::BigInt" => { return String::concat(val, "_I"); } 
        | "__CoreCpp::Nat" => { return String::concat(val, "_n"); }
        | "__CoreCpp::BigNat" => { return String::concat(val, "_N"); }
        | "__CoreCpp::Float" => { return String::concat(val, "_f"); }
        | "bool" => { return val; }
        | _ => { abort; }
    }
}

function emitLiteralNoneExpression(exp: CPPAssembly::LiteralNoneExpression, ctx: Context): String {
    return "INTPTR_MAX";
}

function emitAccessVariableExpression(exp: CPPAssembly::AccessVariableExpression, ctx: Context): String {
    return emitVarIdentifier(exp.vname);
}

function emitReturnSingleStatement(ret: CPPAssembly::ReturnSingleStatement, ctx: Context, indent: String): String {
    let exp = emitExpression(ret.value, ctx);

    let full_indent: String = String::concat(indent, "    ");
    return String::concat(full_indent, "return ", exp, ";%n;");
}

recursive function emitBinAddExpression(add: CPPAssembly::BinAddExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](add.lhs, ctx);
    let rhs = emitExpression[recursive](add.rhs, ctx);

    return String::concat("(", lhs, " + ", rhs, ")");
}

recursive function emitBinSubExpression(sub: CPPAssembly::BinSubExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](sub.lhs, ctx);
    let rhs = emitExpression[recursive](sub.rhs, ctx);

    return String::concat("(", lhs, " - ", rhs, ")");
}

recursive function emitBinDivExpression(div: CPPAssembly::BinDivExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](div.lhs, ctx);
    let rhs = emitExpression[recursive](div.rhs, ctx);

    return String::concat("(", lhs, " / ", rhs, ")");
}

recursive function emitBinMultExpression(mult: CPPAssembly::BinMultExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](mult.lhs, ctx);
    let rhs = emitExpression[recursive](mult.rhs, ctx);

    return String::concat("(", lhs, " * ", rhs, ")");
}

recursive function emitBinaryArithExpression(e: CPPAssembly::BinaryArithExpression, ctx: Context): String {
    match(e)@ {
        CPPAssembly::BinAddExpression => { return emitBinAddExpression[recursive]($e, ctx); }
        | CPPAssembly::BinSubExpression => { return emitBinSubExpression[recursive]($e, ctx); }
        | CPPAssembly::BinDivExpression => { return emitBinDivExpression[recursive]($e, ctx); }
        | CPPAssembly::BinMultExpression => { return emitBinMultExpression[recursive]($e, ctx); }
    }
}

recursive function emitPrefixNotOpExpression(notop: CPPAssembly::PrefixNotOpExpression, ctx: Context): String {
    let expr = emitExpression[recursive](notop.expr, ctx);
    return String::concat("!", expr);
}

recursive function emitPrefixNegateOpExpression(negop: CPPAssembly::PrefixNegateOpExpression, ctx: Context): String {
    let expr = emitExpression[recursive](negop.expr, ctx);
    return String::concat("-", expr);
}

recursive function emitPrefixPlusOpExpression(plusop: CPPAssembly::PrefixPlusOpExpression, ctx: Context): String {
    return emitExpression[recursive](plusop.expr, ctx);
}

recursive function emitUnaryExpression(e: CPPAssembly::UnaryExpression, ctx: Context): String {
    match(e)@ {
        CPPAssembly::PrefixNotOpExpression => { return emitPrefixNotOpExpression[recursive]($e, ctx); }
        | CPPAssembly::PrefixNegateOpExpression => { return emitPrefixNegateOpExpression[recursive]($e, ctx); }
        | CPPAssembly::PrefixPlusOpExpression => { return emitPrefixPlusOpExpression[recursive]($e, ctx); }
    }
}

recursive function emitNumericEqExpression(e: CPPAssembly::NumericEqExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " == ", rhs, ")");   
}

recursive function emitNumericNeqExpression(e: CPPAssembly::NumericNeqExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " != ", rhs, ")");   
}

recursive function emitNumericLessExpression(e: CPPAssembly::NumericLessExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " < ", rhs, ")");   
}

recursive function emitNumericLessEqExpression(e: CPPAssembly::NumericLessEqExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " <= ", rhs, ")");   
}

recursive function emitNumericGreaterExpression(e: CPPAssembly::NumericGreaterExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " > ", rhs, ")");   
}

recursive function emitNumericGreaterEqExpression(e: CPPAssembly::NumericGreaterEqExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " >= ", rhs, ")");   
}

recursive function emitBinaryNumericExpression(e: CPPAssembly::BinaryNumericExpression, ctx: Context): String {
    match(e)@ {
        CPPAssembly::NumericEqExpression => { return emitNumericEqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericNeqExpression => { return emitNumericNeqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericLessExpression => { return emitNumericLessExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericLessEqExpression => { return emitNumericLessEqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericGreaterExpression => { return emitNumericGreaterExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericGreaterEqExpression => { return emitNumericGreaterEqExpression[recursive]($e, ctx); }
    }
}

recursive function emitBinLogicAndExpression(e: CPPAssembly::BinLogicAndExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);   

    return String::concat("(", lhs, " && ", rhs, ")");
}

recursive function emitBinLogicOrExpression(e: CPPAssembly::BinLogicOrExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);   

    return String::concat("(", lhs, " || ", rhs, ")");
}

recursive function emitBinLogicImpliesExpression(e: CPPAssembly::BinLogicImpliesExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);  

    let implies: String = String::concat("!", lhs, " || ", rhs);
    return String::concat("(", implies ,")");
}

recursive function emitBinLogicIFFExpression(e: CPPAssembly::BinLogicIFFExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx); 
    let nlhs: String = String::concat("!", lhs);
    let nrhs: String = String::concat("!", rhs);

    let first: String = String::concat("(", lhs, " && ", rhs, ")");
    let second: String = String::concat("(", nlhs, " && ", nrhs, ")");

    return String::concat("(", first, " || ", second, ")");
}

recursive function emitBinLogicExpression(e: CPPAssembly::BinLogicExpression, ctx: Context): String {
    match(e)@ {
        CPPAssembly::BinLogicAndExpression => { return emitBinLogicAndExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicOrExpression => { return emitBinLogicOrExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicImpliesExpression => { return emitBinLogicImpliesExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicIFFExpression => { return emitBinLogicIFFExpression[recursive]($e, ctx); }
    }
}

recursive function emitLogicActionAndExpression(e: CPPAssembly::LogicActionAndExpression, ctx: Context): String {
    let args = e.args.map<String>(fn(expr) => emitExpression[recursive](expr, ctx));
    return String::concat("(", String::joinAll(" && ", args), ")");
}

recursive function emitLogicActionOrExpression(e: CPPAssembly::LogicActionOrExpression, ctx: Context): String {
    let args = e.args.map<String>(fn(expr) => emitExpression[recursive](expr, ctx));
    return String::concat("(", String::joinAll(" || ", args), ")");
}

function emitArguments(al: List<CPPAssembly::Expression>, ctx: Context): String {
    let emit_al = al.map<String>(fn(arg) => emitExpression(arg, ctx));
    return String::joinAll(", ", emit_al);
}

function emitCallNamespaceFunctionExpression(e: CPPAssembly::CallNamespaceFunctionExpression, ctx: Context): String { 
    let name = emitInvokeKey(e.ikey, ctx);
    let nsfunc = ctx.asm.nsfuncs.get(e.ikey); 
    let args = emitArguments(e.args, ctx); 

    return String::concat(name, "(", args, ")");
}

function emitCallTypeFunctionExpression(e: CPPAssembly::CallTypeFunctionExpression, ctx: Context): String { 
    let typefunc = ctx.asm.typefuncs.get(e.ikey);
    let name = emitInvokeKey(typefunc.ikey, ctx);
    let args = emitArguments(e.args, ctx); 

    return String::concat(name, "(", args, ")");
}

function emitPostfixAccessFromName(op: CPPAssembly::PostfixAccessFromName, ctx: Context): String {
    let op_tinfo = ctx.asm.typeinfos.get(op.declaredInType.tkeystr);
    let base_tinfo = ctx.asm.typeinfos.get(op.baseType.tkeystr);
    let ident = emitIdentifier(op.name);

    %% We dont want to try to access value on a collection (they just emit as the underlying datastructure)
    if(ctx.asm.collections.has(op.baseType.tkeystr)) {
        return "";
    }
    if(ctx.asm.isNominalTypeConcept(op.baseType.tkeystr)) {
        let e = ctx.asm.lookupNominalTypeDeclaration(op.baseType.tkeystr)@<CPPAssembly::AbstractConceptTypeDecl>;
        let canresolve, offset = canUseDirectFieldAccess(e, op.name, ctx);
        let ftype = emitTypeSignature(op.ftype, true, ctx);
        
        let accessor = getAccessor(op.ftype.tkeystr, ctx);
        if(canresolve) {
            return String::concat(accessor, "<", ftype, ", ", String::fromCString(offset.toCString()), ">()");
        }
        else {
            let declaredInType = emitTypeSignature(op.declaredInType, false, ctx);
            let enumentry = String::concat(", ", declaredInType, "_entries::", declaredInType, "_", ident);
            let args = String::concat(declaredInType, "Type.vtable)");
            return String::concat(accessor, "vlookup<", ftype, enumentry, ">(", args); 
        }
    }

    switch(op_tinfo.tag) {
        CPPAssembly::Tag#Value => { return String::concat(".", ident); }
        | CPPAssembly::Tag#Ref => { return String::concat("->", ident); }
        | CPPAssembly::Tag#Tagged => { return String::concat(".", ident); } 
    }
}

%% For now we assume this is only used for accessing elist fields
function emitPostfixAccessFromIndex(op: CPPAssembly::PostfixAccessFromIndex, acc: String, ctx: Context): String {
    let accesstype = op.baseType@<CPPAssembly::EListTypeSignature>.entries.get(Nat::fromCString(op.idx));
    let accessed = emitTypeSignature(accesstype, true, ctx);
    let idx = String::fromCString(op.idx);

    return String::concat(acc, ".access<", accessed, ", ", idx, ">()");
}

function emitPostfixInvokeStatic(op: CPPAssembly::PostfixInvokeStatic, rootexp: CPPAssembly::Expression, ctx: Context): String {
    %% We don't want to do any resolution of these keys yet
    let ik = String::fromCString(op.resolvedTrgt.value);
    let tk = String::fromCString(op.resolvedType.tkeystr.value);

    let args = emitArguments(op.args, ctx);
    let exp = emitExpression(rootexp, ctx);

    %% The "this" arguemnt does not exist in explicitify so we handle the coersion here (we manually added it for cpp emission)
    var thisarg: String;
    if(!ctx.asm.areTypesSame(rootexp.etype, op.resolvedType)) {
        let rootexptype = emitTypeSignature(rootexp.etype, false, ctx);
        let roottinfo = ctx.asm.typeinfos.get(rootexp.etype.tkeystr);
        let targettype = emitTypeKey(op.resolvedType.tkeystr, false, ctx);

        let slotsize = if(roottinfo.tag === CPPAssembly::Tag#Tagged) then roottinfo.slotsize - 1n else roottinfo.slotsize;
        thisarg = if(slotsize == 0n) then String::concat(targettype, "{ &", rootexptype, "Type }")
            else String::concat(targettype, "{ &", rootexptype, "Type, ", exp, " }"); 
    }
    else {
        thisarg = exp;
    } 

    %% Remove abstract nominal we were in
    var resolvedInvoke = emitSpecialTemplate(ik.removePrefixString(tk).removePrefixString("::"));
    if(args === "") {
        return String::concat(resolvedInvoke, "(", thisarg, ")");
    }
    else {
         return String::concat(resolvedInvoke, "(", thisarg, ", ", args, ")");       
    }
}

function emitPostfixAccessSomeValue(op: CPPAssembly::PostfixAccessSomeValue, acc: String, baseType: CPPAssembly::TypeSignature, ctx: Context): String {
    return String::concat(acc, ".value"); 
}

function emitITestType(it: CPPAssembly::ITestType, baseType: CPPAssembly::TypeSignature, ctx: Context): String {
    %% For now we only support ITests where both types are concrete
    if(ctx.asm.isNominalTypeConcrete(it.ttype.tkeystr) && ctx.asm.isNominalTypeConcrete(baseType.tkeystr)) {
        let areTypesSame = ctx.asm.areTypesSame(it.ttype, baseType);
        return if(it.isnot) then (if(!areTypesSame) then "true" else "false")
            else if(areTypesSame) then "true" else "false";
    }
    else {
        %% T-type is concrete case
        if(ctx.asm.isNominalTypeConcrete(it.ttype.tkeystr)) {
            let ttype = emitTypeSignature(it.ttype, false, ctx);
            return if(it.isnot) then String::concat(".typeinfo != &", ttype, "Type")
                else String::concat(".typeinfo == &", ttype, "Type");
        }
        else {
            abort; %% Handle case where both are abstract (vtable lookup likely)
        }
    }
}

function emitITestSome(it: CPPAssembly::ITestSome, baseType: CPPAssembly::TypeSignature, ctx: Context): String {
    return if(it.isnot) 
        then ".typeinfo == &NoneType" 
        else ".typeinfo != &NoneType";
}

function emitITestNone(it: CPPAssembly::ITestNone, baseType: CPPAssembly::TypeSignature, ctx: Context): String {
    return if(it.isnot) 
        then ".typeinfo != &NoneType" 
        else ".typeinfo == &NoneType";
}

function emitITestAsTest(it: CPPAssembly::ITest, baseType: CPPAssembly::TypeSignature, ctx: Context): String {
    match(it)@ {
        CPPAssembly::ITestType => { return emitITestType($it, baseType, ctx); }
        | CPPAssembly::ITestNone => { return emitITestNone($it, baseType, ctx); }
        | CPPAssembly::ITestSome => { return emitITestSome($it, baseType, ctx); }
        | CPPAssembly::ITestOk => { abort; }
        | CPPAssembly::ITestFail => { abort; }
    }
}

function emitITestAsConvertNone(isnot: Bool, fromtype: CPPAssembly::TypeKey, ctx: Context): (|String, String|) {
    if(isnot) {
        return emitITestAsConvertSome(false, fromtype, ctx);
    }
    else {
        return (|String::concat(getAccessor(fromtype, ctx), "none()"), "__CoreCpp::None" |);
    }
}

function emitITestAsConvertSome(isnot: Bool, fromtype: CPPAssembly::TypeKey, ctx: Context): (|String, String|) {
    let ant = ctx.asm.lookupNominalTypeDeclaration(fromtype);
    
    if(ant)@<CPPAssembly::OptionTypeDecl> {
        if(isnot) {
            return emitITestAsConvertNone(false, fromtype, ctx);
        }
        else {
            return (|String::concat(getAccessor($ant.someType.tkeystr, ctx), "<", emitTypeSignature($ant.someType, true, ctx), ">().value"),
                emitTypeKey($ant.oftype.tkeystr, true, ctx)|);
        }
    }
    else {
        abort; %% Only options are supported for now
    }
}

function emitITestAsConvertType(isnot: Bool, fromtype: CPPAssembly::TypeKey, totype: CPPAssembly::TypeKey, ctx: Context): (|String, String|) { 
    let ttype = if(isnot) then fromtype else totype;
    let emittotype = emitTypeKey(ttype, false, ctx);

    %% We want to make sure we return the totype as a possible field here(our access method handles ref case)
    return if(fromtype.value === ttype.value) then (|"", emittotype|) 
        else (|String::concat(getAccessor(ttype, ctx), "<", emittotype, ">()"), emitTypeKey(ttype, true, ctx)|);
}

function emitITestAsConvert(isnot: Bool, itc: CPPAssembly::ITest, fromtype: CPPAssembly::TypeKey, totype: Option<CPPAssembly::TypeKey>, ctx: Context): (|String, String|) { %% Convert, Emitted type
    match(itc)@ {
        CPPAssembly::ITestType => { 
            let ntotype = if(totype)none then $itc.ttype.tkeystr else totype@some; %% For postfix itest convert case
            return emitITestAsConvertType(isnot, fromtype, ntotype, ctx); 
        }
        | CPPAssembly::ITestNone => { return emitITestAsConvertNone(isnot, fromtype, ctx); }
        | CPPAssembly::ITestSome => { return emitITestAsConvertSome(isnot, fromtype, ctx); }
        | CPPAssembly::ITestOk => { abort; }
        | CPPAssembly::ITestFail => { abort; }
    }
}

function emitPostfixOp(pop: CPPAssembly::PostfixOp, ctx: Context): String {
    let rootExp = emitExpression(pop.rootExp, ctx);
    let rootType = emitTypeSignature(pop.rootExp.etype, false, ctx);

    return pop.ops.reduce<String>(rootExp, fn(acc, op) => {
        match(op)@ {
            CPPAssembly::PostfixAccessFromName => { return String::concat(acc, emitPostfixAccessFromName($op, ctx)); }
            | CPPAssembly::PostfixAccessFromIndex => { return emitPostfixAccessFromIndex($op, acc, ctx); }
            | CPPAssembly::PostfixIsTest => { return String::concat(acc, emitITestAsTest($op.ttest, $op.baseType, ctx)); }
            | CPPAssembly::PostfixAsConvert => { return String::concat(acc, emitITestAsConvert($op.ttest.isnot, $op.ttest, $op.baseType.tkeystr, none, ctx).0); }
            | CPPAssembly::PostfixInvokeStatic => { return emitPostfixInvokeStatic($op, pop.rootExp, ctx); } %% This will not chain method calls :(
            | CPPAssembly::PostfixBoolConstant => { return if($op.value === true) then "true" else "false"; }
            | CPPAssembly::PostfixAccessSomeValue => { return emitPostfixAccessSomeValue($op, acc, pop.rootExp.etype, ctx); }
        }
    });
}

function emitConstructorPrimarySpecialSomeExpression(cpsse: CPPAssembly::ConstructorPrimarySpecialSomeExpression, ctx: Context): String {
    let value = emitExpression(cpsse.value, ctx);
    let sometype = emitTypeSignature(cpsse.ctype, false, ctx);

    return String::concat(sometype, "{ ", value, "}");
}

function emitConstructorPrimarySpecialOkExpression(cpsoe: CPPAssembly::ConstructorPrimarySpecialOkExpression, ctx: Context): String {
    abort; %% TODO: Not implemented!
}

function emitConstructorPrimarySpecialFailExpression(cpsfe: CPPAssembly::ConstructorPrimarySpecialFailExpression, ctx: Context): String {
    abort; %% TODO: Not Implemented!
}

function emitConstructorPrimarySpecialConstructableExpression(exp: CPPAssembly::ConstructorPrimarySpecialConstructableExpression, ctx: Context): String {    
    match(exp)@ {
        CPPAssembly::ConstructorPrimarySpecialSomeExpression => { return emitConstructorPrimarySpecialSomeExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialOkExpression => { return emitConstructorPrimarySpecialOkExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialFailExpression => { return emitConstructorPrimarySpecialFailExpression($exp, ctx); }
    }
}

%%
%% TODO: Once the GC is integrated we will need to call our special GC allocate on ref type objects instead of the default
%% constructor like we do now. Currently they call "new"
%%
function emitConstructorStdExpression(exp: CPPAssembly::ConstructorStdExpression, ctx: Context): String {
    let emitargs = emitArguments(exp.args, ctx); 
    let name = emitTypeSignature(exp.ctype, false, ctx);
    let tinfo = ctx.asm.typeinfos.get(exp.ctype.tkeystr);
    let ant = ctx.asm.lookupNominalTypeDeclaration(exp.ctype.tkeystr);

    var cons: String;
    if(ant)@<CPPAssembly::DatatypeMemberEntityTypeDecl> { 
        if($ant.saturatedBFieldInfo.size() == 0n) { %% Boxed<0> case
            cons = "";
        }
        else {
            cons = String::concat(name, "{ ", emitargs, " }");
        }
    }
    else {
        cons = String::concat(name, "{ ", emitargs, " }");
    }

    if(tinfo.tag === CPPAssembly::Tag#Ref) {
        return String::concat("new ", cons); %% We use new solely to keep the code compiling before GC integration
    }
    else {
        return cons;
    } 
}

function emitConstructorEListExpression(exp: CPPAssembly::ConstructorEListExpression, ctx: Context): String {
    if(exp.args.size() > 4n) {
        abort; %% Tuples of size > 4 not supported yet
    }
    let ceetype = emitTypeSignature(exp.etype, false, ctx);
    let args = String::joinAll(", ", exp.args.map<String>(fn(e) => emitExpression(e, ctx))); 

    return String::concat(ceetype, "(", args, ")");
}

function emitConstructorPrimaryListExpression(exp: CPPAssembly::ConstructorPrimaryListExpression, ctx: Context): String {
    return "";
}

function emitConstructorPrimaryMapExpression(exp: CPPAssembly::ConstructorPrimaryMapExpression, ctx: Context): String {
    abort;
}

function emitConstructorPrimaryCollectionSingletonExpression(exp: CPPAssembly::ConstructorPrimaryCollectionSingletonsExpression, ctx: Context): String {
    match(exp)@ {
        CPPAssembly::ConstructorPrimaryListExpression => { return emitConstructorPrimaryListExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimaryMapExpression => { return emitConstructorPrimaryMapExpression($exp, ctx); }
    }
}

function emitConstructorPrimaryExpression(exp: CPPAssembly::ConstructorPrimaryExpression, ctx: Context): String {
    match(exp)@ {
        CPPAssembly::ConstructorStdExpression => { return emitConstructorStdExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialConstructableExpression => { return emitConstructorPrimarySpecialConstructableExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimaryCollectionSingletonsExpression => { return emitConstructorPrimaryCollectionSingletonExpression($exp, ctx); }
    }
}

function emitConstructorExpression(exp: CPPAssembly::ConstructorExpression, ctx: Context): String {
    match(exp)@ {
        CPPAssembly::ConstructorPrimaryExpression => { return emitConstructorPrimaryExpression($exp, ctx); }
        | CPPAssembly::ConstructorEListExpression => { return emitConstructorEListExpression($exp, ctx); }
    }
}

function emitIfTestExpression(exp: CPPAssembly::IfTestExpression, i: String, t: String, e: String, ctx: Context): String {
    let itest = String::concat(i, emitITestAsTest(exp.itest, exp.texp.etype, ctx)); %% Likely doesnt work if the itest is just bool

    let ite = String::concat(itest, " ? (", t, ") : (", e, ")");
    return String::concat("( ", ite, " )");
}

%% TODO: Both this and convert maybe special case will need to handle abstract concepts
function getSubtypeCount(tk: CPPAssembly::TypeKey, ctx: Context): Nat, CPPAssembly::AbstractNominalTypeDecl {
    let concretetype = ctx.asm.lookupNominalTypeDeclaration(tk);
    if(concretetype)@<CPPAssembly::DatatypeTypeDecl> {
        return $concretetype.associatedMemberEntityDecls.size(), concretetype;
    }
    else {
        return 0n, concretetype;
    }
}

%% Handles special case convert where we have two member entities 
function doConvertMaybeSpecialCase(isnot: Bool, itest: CPPAssembly::ITest, fromtype: CPPAssembly::TypeKey, totype: Option<CPPAssembly::TypeKey>, 
    ctx: Context): (|String, String|) {
        let n, concretetype = getSubtypeCount(fromtype, ctx);

        if(n == 2n) {
            let othermember = concretetype@<CPPAssembly::DatatypeTypeDecl>
                .associatedMemberEntityDecls.find(
                    pred(ets) => !ctx.asm.areTypesSame(ets, itest@<CPPAssembly::ITestType>.ttype)).tkeystr;

            return if(isnot === true) then emitITestAsConvert(false, itest, fromtype, some(othermember), ctx)
                else emitITestAsConvert(isnot, itest, fromtype, totype, ctx);         
        }
        else {
            return emitITestAsConvert(isnot, itest, fromtype, totype, ctx); 
        }
}

%% TODO: We should format this a bit better as these expressions get quite long
function emitIfBinderExpression(exp: CPPAssembly::IfBinderExpression, i: String, t: String, e: String, ctx: Context): String {
    let capture = String::concat("[&]() -> ", emitTypeKey(exp.etype.tkeystr, false, ctx), " { ");
    let etype = exp.texp.etype; 

    let itest = String::concat(i, emitITestAsTest(exp.itest, exp.texp.etype, ctx));

    let tconvert = doConvertMaybeSpecialCase(exp.itest.isnot, exp.itest, etype.tkeystr, none, ctx);
    let treassign = emitBindVar(exp.binder.srcname, tconvert.0, tconvert.1, i);
    let texp = String::concat(capture, treassign, "return ", t, "; }() ");

    let fconvert = doConvertMaybeSpecialCase(!exp.itest.isnot, exp.itest, etype.tkeystr, none, ctx);
    let freassign = emitBindVar(exp.binder.srcname, fconvert.0, fconvert.1, i);
    let fexp = String::concat(capture, freassign, "return ", e, "; }() ");

    let ibe = String::concat( itest, " ? (", texp, ") : (", fexp, ")");
    return String::concat( "( ", ibe, " )");
}

function emitIfExpression(exp: CPPAssembly::IfExpression, ctx: Context): String {
    let texp = emitExpression(exp.texp, ctx);
    let thenexp = emitExpression(exp.thenexp, ctx);
    let elseexp = emitExpression(exp.elseexp, ctx);

    match(exp)@ {
        CPPAssembly::IfSimpleExpression => { 
            let ise = String::concat(texp, " ? (", thenexp, ") : (", elseexp, ")");
            return String::concat("( ", ise, " )");
        }
        | CPPAssembly::IfTestExpression => { return emitIfTestExpression($exp, texp, thenexp, elseexp, ctx); }
        | CPPAssembly::IfBinderExpression => { return emitIfBinderExpression($exp, texp, thenexp, elseexp, ctx); }
    }
}

%% We are only widening to options for now
function emitWidenedTypeExpression(exp: CPPAssembly::CoerceWidenTypeExpression, ctx: Context): String {
    let fromtkey = exp.srctype.tkeystr;
    let tottsig = exp.trgttype;
    let emitexp = emitExpression(exp.exp, ctx);

    let fromtkey_size = String::fromCString(ctx.asm.typeinfos.tryGet(fromtkey)@some.slotsize.toCString()); %% This is T
    let name = emitTypeSignature(tottsig, false, ctx);

    let ttype = String::concat(emitTypeSignature(exp.srctype, false, ctx), "Type");

    if(exp.exp?<CPPAssembly::LiteralNoneExpression>) {
        return String::concat(name, "{ &", removeCppPrefix(ttype) ," }");
    }

    return if(emitexp === "") then String::concat(name, "{ &", ttype, " }")
        else String::concat(name, "{ &", ttype, ", ", emitexp, " }");
}

%% We will need this to help us take "this.f?<Int>" to "false"
function emitNarrowedTypeExpression(exp: CPPAssembly::CoerceNarrowTypeExpression, ctx: Context): String {
    let tottype = emitTypeSignature(exp.trgttype, false, ctx);
    let emitexp = emitExpression(exp.exp, ctx);   

    if(ctx.asm.isNominalTypeConcept(exp.srctype.tkeystr)) {
        return String::concat(emitexp, getAccessor(exp.trgttype.tkeystr, ctx), "<", tottype, ">()");
    }
    else {
        return emitexp;
    }
}

function emitSafeConvertExpression(exp: CPPAssembly::SafeConvertExpression, ctx: Context): String {
   return emitExpression(exp.exp, ctx);
}

function emitCreateDirectExpression(exp: CPPAssembly::CreateDirectExpression, ctx: Context): String {
   return emitExpression(exp.exp, ctx); 
}

function emitAccessEnumExpression(exp: CPPAssembly::AccessEnumExpression, ctx: Context): String {
    let enumtype = emitTypeSignature(exp.etype, false, ctx);
    let name = String::fromCString(exp.name);

    return String::concat(enumtype, "::", name);
}

function emitAccessStaticFieldExpression(exp: CPPAssembly::AccessStaticFieldExpression, ctx: Context): String {
    let typeconst = ctx.asm.typeconsts.get(exp.resolvedname);
    let ns = emitTypeSignature(typeconst.declaredInType, false, ctx);

    return String::concat(ns, "·òè", emitIdentifier(typeconst.name));
}

function emitBinKeyEqExpression(exp: CPPAssembly::BinKeyEqExpression, opertype: String, ctx: Context): String {
    let lhs = emitExpression(exp.lhs, ctx);
    let rhs = emitExpression(exp.rhs, ctx);

    return String::concat("(", lhs, " == ", rhs, ")");
}

function emitBinKeyNotEqExpression(exp: CPPAssembly::BinKeyNotEqExpression, opertype: String, ctx: Context): String {
    let lhs = emitExpression(exp.lhs, ctx);
    let rhs = emitExpression(exp.rhs, ctx);

    return String::concat("(", lhs, " != ", rhs, ")");
}

function emitBinaryKeyEqExpression(exp: CPPAssembly::BinaryKeyEqExpression, ctx: Context): String {
    let opertype = emitTypeSignature(exp.opertype, false, ctx);
    match(exp)@ {
        CPPAssembly::BinKeyEqNoneExpression => { abort; }
        | CPPAssembly::BinKeyNotEqNoneExpression => { abort; }
        | CPPAssembly::BinKeySomeEqExpression => { abort; }
        | CPPAssembly::BinKeyEqExpression => { return emitBinKeyEqExpression($exp, opertype, ctx); }
        | CPPAssembly::BinKeyNotEqExpression => { return emitBinKeyNotEqExpression($exp, opertype, ctx); }
    }
}

function emitExpression(e: CPPAssembly::Expression, ctx: Context): String {
    match(e)@ {
        CPPAssembly::LiteralNoneExpression => { return emitLiteralNoneExpression($e, ctx); }
        | CPPAssembly::LiteralSimpleExpression => { return emitLiteralSimpleExpression($e); }
        %%| CPPAssembly::LiteralCCharExpression => { abort; }
        %%| CPPAssembly::LiteralUnicodeCharExpression => { abort; }
        %%| CPPAssembly::LiteralCStringExpression => { abort; }
        %%| CPPAssembly::LiteralStringExpression => { abort; }
        %%| CPPAssembly::LiteralCRegexExpression => { abort; }
        %%| CPPAssembly::LiteralRegexExpression => { abort; }
        %%| CPPAssembly::LiteralTypeDeclValueExpression => { abort; }
        %%| CPPAssembly::AccessNamespaceConstantExpression => { abort; }
        | CPPAssembly::AccessStaticFieldExpression => { return emitAccessStaticFieldExpression($e, ctx); } 
        | CPPAssembly::AccessEnumExpression => { return emitAccessEnumExpression($e, ctx); }
        | CPPAssembly::AccessVariableExpression => { return emitAccessVariableExpression($e, ctx); }
        %%| CPPAssembly::AccessCapturedVariableExpression => { abort; }
        | CPPAssembly::ConstructorExpression => { return emitConstructorExpression($e, ctx); }
        | CPPAssembly::ConstructorPrimaryExpression => { return emitConstructorPrimaryExpression($e, ctx); }
        %%| CPPAssembly::ConstructorPrimaryCollectionSingletonsExpression => { abort; } 
        %%| CPPAssembly::ConstructorTypeDeclExpression => { abort; }
        %%| CPPAssembly::ConstructorTypeDeclStringExpression => { abort; } 
        %%| CPPAssembly::ConstructorLambdaExpression => { abort; }
        %%| CPPAssembly::LetExpression => { abort; }
        %%| CPPAssembly::LambdaInvokeExpression => { abort; } 
        | CPPAssembly::CallNamespaceFunctionExpression => { return emitCallNamespaceFunctionExpression($e, ctx); }
        | CPPAssembly::CallTypeFunctionExpression => { return emitCallTypeFunctionExpression($e, ctx); }      
        %%| CPPAssembly::CallRefInvokeStaticResolveExpression => { abort; }
        %%| CPPAssembly::CallRefInvokeVirtualExpression => { abort; } 
        | CPPAssembly::LogicActionAndExpression => { return emitLogicActionAndExpression[recursive]($e, ctx); }
        | CPPAssembly::LogicActionOrExpression => { return emitLogicActionOrExpression[recursive]($e, ctx); }       
        %%| CPPAssembly::TypeDeclPrimitiveFieldAccessExpression => { abort; }
        | CPPAssembly::CoerceWidenTypeExpression => { return emitWidenedTypeExpression($e, ctx); }
        | CPPAssembly::CoerceNarrowTypeExpression => { return emitNarrowedTypeExpression($e, ctx); }
        | CPPAssembly::SafeConvertExpression => { abort; }
        | CPPAssembly::CreateDirectExpression => { return emitCreateDirectExpression($e, ctx); }
        | CPPAssembly::PostfixOp => { return emitPostfixOp($e, ctx); }
        | CPPAssembly::UnaryExpression => { return emitUnaryExpression[recursive]($e, ctx); }
        | CPPAssembly::BinaryArithExpression => { return emitBinaryArithExpression[recursive]($e, ctx); }
        | CPPAssembly::BinaryKeyEqExpression => { return emitBinaryKeyEqExpression($e, ctx); }
        %%| CPPAssembly::BinaryKeyCmpEqualExpression => { abort; }
        %%| CPPAssembly::BinaryKeyCmpLessExpression => { abort; }
        | CPPAssembly::BinaryNumericExpression => { return emitBinaryNumericExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicExpression => { return emitBinLogicExpression[recursive]($e, ctx); }
        %%| CPPAssembly::MapEntryConstructorExpression => { abort; }
        | CPPAssembly::IfExpression => { return emitIfExpression($e, ctx); }
    }
}

function emitVariableInitializationStatement(stmt: CPPAssembly::VariableInitializationStatement, ctx: Context, indent: String): String {
    let name = emitIdentifier(stmt.name);
    let stype = emitTypeSignature(stmt.vtype, true, ctx);
    let exp = emitExpression(stmt.exp, ctx);

    let full_indent: String = String::concat(indent, "    ", stype);
    return String::concat(full_indent, " ", name, " = ", exp, ";");
}

function emitBlockStatement(block: CPPAssembly::BlockStatement, ctx: Context, indent: String): String {
    let stmts = block.statements.map<String>(fn(stmt) => emitStatement(stmt, ctx, indent));
    return String::joinAll("%n;", stmts);
}

function emitIfSimpleStatement(stmt: CPPAssembly::IfSimpleStatement, ctx: Context, indent: String): String {
    let expr = emitExpression(stmt.cond, ctx);
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);

    let ifstmt = String::concat(indent, "if( ", expr, " ) {%n;");
    return String::concat(ifstmt, trueBlock, indent, "}");
}

function emitIfTestStatement(stmt: CPPAssembly::IfTestStatement, ctx: Context, indent: String): String {
    let expr = emitExpression(stmt.cond, ctx);
    let itest = String::concat(expr, emitITestAsTest(stmt.itest, stmt.cond.etype, ctx));
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);

    let ifstmt = String::concat(indent, "if( ", itest, " ) {%n;");
    return String::concat(ifstmt, trueBlock, indent, "}");
}

%% TODO: This is lacking proper redefine for "@@*" itest!
function emitIfBinderStatement(stmt: CPPAssembly::IfBinderStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    
    let expr = emitExpression(stmt.cond, ctx);
    let itest = String::concat(expr, emitITestAsTest(stmt.itest, stmt.cond.etype, ctx));
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);

    let bname = emitVarIdentifier(stmt.binder.srcname);
    let convert = doConvertMaybeSpecialCase(stmt.itest.isnot, stmt.itest, stmt.cond.etype.tkeystr, none, ctx);
    let reasign = String::concat(bname, " = ", expr, convert.0);

    let tbassign = String::concat(full_indent, "[[maybe_unused]] ", convert.1, " ", reasign, ";%n;");

    let ifstmt = String::concat(indent, "if( ", itest, " ) {%n;");
    return String::concat(ifstmt, tbassign, trueBlock, indent, "}%n;");
}

function emitIfStatement(stmt: CPPAssembly::IfStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 

    match(stmt)@ { 
        CPPAssembly::IfSimpleStatement => { return emitIfSimpleStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfTestStatement => { return emitIfTestStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfBinderStatement => { return emitIfBinderStatement($stmt, ctx, full_indent); }
    }
}

%% May want to remove some o the repetitive code in the 3 flavours of ifelse
function emitIfElseSimpleStatement(stmt: CPPAssembly::IfElseSimpleStatement, ctx: Context, indent: String): String {
    let expr = emitExpression(stmt.cond, ctx);
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);
    let falseBlock = emitBlockStatement(stmt.falseBlock, ctx, indent);
    let elseBlockText = String::concat(indent, "else {%n;", falseBlock, indent, "}%n;");
    
    let ifstmt = String::concat(indent, "if( ", expr, " ) {%n;"); 
    return String::concat(ifstmt, trueBlock, indent, "}%n;", elseBlockText);
}

function emitIfElseTestStatement(stmt: CPPAssembly::IfElseTestStatement, ctx: Context, indent: String): String {
    let expr = emitExpression(stmt.cond, ctx);
    let itest = String::concat(expr, emitITestAsTest(stmt.itest, stmt.cond.etype, ctx));
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);
    let falseBlock = emitBlockStatement(stmt.falseBlock, ctx, indent);
    let elseBlockText = String::concat(indent, "else {%n;", falseBlock, indent, "}%n;");
    
    let ifstmt = String::concat(indent, "if( ", itest, " ) {%n;"); 
    return String::concat(ifstmt, trueBlock, indent, "}%n;", elseBlockText);
}

%% This does not work if we do something like if(...)@!type, the else block should bind to the type
function emitIfElseBinderStatement(stmt: CPPAssembly::IfElseBinderStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    
    let expr = emitExpression(stmt.cond, ctx);
    let etype = stmt.cond.etype;
    let itest = String::concat(expr, emitITestAsTest(stmt.itest, etype, ctx));

    let tconvert = doConvertMaybeSpecialCase(stmt.itest.isnot, stmt.itest, stmt.cond.etype.tkeystr, none, ctx); 
    let treassign = String::concat(full_indent, emitBindVar(stmt.binder.srcname, tconvert.0, tconvert.1, expr), "%n;");

    let fconvert = doConvertMaybeSpecialCase(!stmt.itest.isnot, stmt.itest, stmt.cond.etype.tkeystr, none, ctx);
    let freassign = String::concat(full_indent, emitBindVar(stmt.binder.srcname, fconvert.0, fconvert.1, expr), "%n;");

    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);
    let falseBlock = emitBlockStatement(stmt.falseBlock, ctx, indent);
    let elseBlockText = String::concat(indent, "else {%n;", freassign, falseBlock, indent, "}%n;");
    
    let ifstmt = String::concat(indent, "if( ", itest, " ) {%n;"); 
    return String::concat(ifstmt, treassign, trueBlock, indent, "}%n;", elseBlockText);
}

function emitIfElseStatement(stmt: CPPAssembly::IfElseStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 
    
    match(stmt)@ {
        CPPAssembly::IfElseSimpleStatement => { return emitIfElseSimpleStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfElseTestStatement => { return emitIfElseTestStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfElseBinderStatement => { return emitIfElseBinderStatement($stmt, ctx, full_indent); }
    }
}

function emitIfElifElseStatement(stmt: CPPAssembly::IfElifElseStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 
    let ifcond = String::concat(full_indent, "if(", emitExpression(stmt.ifcond, ctx), ") {%n;");
    let ifbody = String::concat(emitBlockStatement(stmt.ifflow, ctx, full_indent), full_indent, "}%n;");
    let ifblock = String::concat(ifcond, ifbody);
    let elseblock = String::concat(full_indent, "else {%n;", emitBlockStatement(stmt.elseflow, ctx, full_indent), full_indent, "}%n;");

    let elifs_list = stmt.condflow.map<String>(fn(elifs) => {
        let cond = emitExpression(elifs.0, ctx);
        let body = emitBlockStatement(elifs.1, ctx, full_indent);

        let elif_stmt = String::concat(full_indent, "else if(", cond, ") {%n;");
        return String::concat(elif_stmt, body, full_indent, "}%n;");
    });
    let elifs = String::joinAll("", elifs_list);

    return String::concat(ifcond, ifbody, elifs, elseblock);
}

function emitAssertStatement(stmt: CPPAssembly::AssertStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    let cond = emitExpression(stmt.cond, ctx);

    return String::concat(full_indent, "ùêöùê¨ùê¨ùêûùê´ùê≠(", cond, ");");
} 

function tryGenerateBindType(bind: Option<CPPAssembly::BinderInfo>, expr: String, fromtype: CPPAssembly::TypeKey, totype: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    if(bind)@none {
        return "";
    }
    else {
        let bname = emitVarIdentifier($bind.srcname);
        let convert = emitITestAsConvertType(false, fromtype, totype, ctx); 
        let bindtype = String::concat("[[maybe_unused]] ", convert.1, " ");
        let reassign = String::concat(bindtype, bname, " = ", expr, convert.0, ";%n;");

        return String::concat(full_indent, reassign);
    }
}

function emitMatchStatement(stmt: CPPAssembly::MatchStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 
    let fullfull_indent = String::concat("    ", full_indent);

    let expr = emitExpression(stmt.sval, ctx);
    let sval = String::concat(expr, ".typeinfo == &");
    var bind: String;

    let matchflow = stmt.matchflow.mapIdx<String>(fn(mf, ii) => {
        let bind = tryGenerateBindType(stmt.bindInfo, expr, stmt.sval.etype.tkeystr, mf.0.tkeystr, ctx, full_indent);
        let block = String::concat(bind, emitBlockStatement(mf.1, ctx, full_indent), full_indent, "}%n;");
        let ts = removeCppPrefix(emitTypeSignature(mf.0, false, ctx));

        if(ii == 0n) {
            return String::concat(full_indent, "if(", sval, ts, "Type) {%n;", block);
        }
        else {
            return String::concat(full_indent, "else if(", sval, ts, "Type) {%n;", block);
        }
    });

    let matches = String::joinAll("", matchflow);
    let failure = String::concat(full_indent, "else {%n;", fullfull_indent, "ùêöùêõùê®ùê´ùê≠;%n;", full_indent, "}%n;");
    return String::concat(matches, failure);
}

function emitSwitchStatement(stmt: CPPAssembly::SwitchStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 
    let fullfull_indent = String::concat("    ", full_indent);

    let sval = emitExpression(stmt.sval, ctx);

    let switchflow = stmt.switchflow.mapIdx<String>(fn(sf, ii) => {
        let block = String::concat(emitBlockStatement(sf.1, ctx, full_indent), full_indent, "}%n;");
        let exp = if(sf.0)none then "true" else String::concat(sval, " == ", emitExpression(sf.0@some, ctx)); 

        if(ii == 0n) {
            return String::concat(full_indent, "if( ", exp, " ) {%n;", block);
        }
        else {
            return String::concat(full_indent, "else if( ", exp, " ) {%n;", block);
        }
    });

    let matches = String::joinAll("", switchflow);
    let failure = String::concat(full_indent, "else {%n;", fullfull_indent, "ùêöùêõùê®ùê´ùê≠;%n;", full_indent, "}%n;");
    return String::concat(matches, failure);
}

function emitStatement(stmt: CPPAssembly::Statement, ctx: Context, indent: String): String {
    match(stmt)@ {
        CPPAssembly::EmptyStatement => { return ""; }
        %%| CPPAssembly::VariableDeclarationStatement => { abort; }
        %%| CPPAssembly::VariableMultiDeclarationStatement => { abort; }
        | CPPAssembly::VariableInitializationStatement => { return emitVariableInitializationStatement($stmt, ctx, indent); }
        %%| CPPAssembly::VariableMultiInitializationExplicitStatement => { abort; }
        %%| CPPAssembly::VariableMultiInitializationImplicitStatement => { abort; }
        %%| CPPAssembly::VariableAssignmentStatement => { abort; }
        %%| CPPAssembly::VariableMultiInitializationExplicitStatement => { abort; }
        %%| CPPAssembly::VariableMultiAssignmentImplicitStatement => { abort; }
        %%| CPPAssembly::VariableRetypeStatement => { abort; }
        %%| CPPAssembly::ReturnVoidStatement => { abort; }
        | CPPAssembly::ReturnSingleStatement => { return emitReturnSingleStatement($stmt, ctx, indent); }
        %%| CPPAssembly::ReturnMultiStatement => { abort; }
        | CPPAssembly::IfStatement => { return emitIfStatement($stmt, ctx, indent); }
        | CPPAssembly::IfElseStatement => { return emitIfElseStatement($stmt, ctx, indent); }
        | CPPAssembly::IfElifElseStatement => { return emitIfElifElseStatement($stmt, ctx, indent); }
        | CPPAssembly::SwitchStatement => { return emitSwitchStatement($stmt, ctx, indent); }
        | CPPAssembly::MatchStatement => { return emitMatchStatement($stmt, ctx, indent); }
        %%| CPPAssembly::AbortStatement => { abort; }
        | CPPAssembly::AssertStatement => { return emitAssertStatement($stmt, ctx, indent); }
        %%| CPPAssembly::ValidateStatement => { abort; }
        %%| CPPAssembly::DebugStatement => { abort; }
        %%| CPPAssembly::VoidRefCallStatement => { abort; }
        %%| CPPAssembly::UpdateDirectStatement => { abort; }
        %%| CPPAssembly::UpdateIndirectStatement => { abort; }
        | CPPAssembly::BlockStatement => { return emitBlockStatement($stmt, ctx, indent); }
     }
}

function emitBuiltinBodyImplementation(body: CPPAssembly::BuiltinBodyImplementation, ctx: Context, indent: String): String {
    switch(String::fromCString(body.builtin)) {
        "s_float_power" => { return String::concat(indent, "    ", "return __CoreCpp::Float(powf64(a.get(), b.get()));%n;"); }
        | "s_float_sqrt" => { return String::concat(indent, "    ", "return __CoreCpp::Float(sqrtf64(a.get()));%n;"); }
        | _ => { abort; } %% TODO: Not implemented
    }
}

function emitStandardBodyImplementation(body: CPPAssembly::StandardBodyImplementation, ctx: Context, indent: String): String {
    return String::joinAll("%n;", body.statements.map<String>(fn(stmt) => emitStatement(stmt, ctx, indent)));
}

function emitBodyImplementation(body: CPPAssembly::BodyImplementation, ctx: Context, indent: String): String {
    match(body)@ {
        %% CPPAssembly::AbstractBodyImplementation => { abort; }
        %% | CPPAssembly::PredicateUFBodyImplementation => { abort; }
        CPPAssembly::BuiltinBodyImplementation => { return emitBuiltinBodyImplementation($body, ctx, indent); }
        %% | CPPAssembly::SynthesisBodyImplementation => { abort; }
        %% | CPPAssembly::ExpressionBodyImplementation => { abort; }
        | CPPAssembly::StandardBodyImplementation => { return emitStandardBodyImplementation($body, ctx, indent); }
        | _ => { abort; }
    }
}

function emitParameters(params: List<CPPAssembly::ParameterDecl>, ctx: Context): String {
    let all_params = params.map<String>(fn(param) => {
        let ptype = emitTypeSignature(param.ptype, true, ctx);
        let pident = emitIdentifier(param.pname);

        return String::concat(ptype, " ", pident);
    });

    return String::joinAll(", ", all_params);
}

%% Determine whether to emit this param as const this* or this
function emitThisType(tk: CPPAssembly::TypeKey, ctx: Context): String {
    let resolved_type = String::concat("[[maybe_unused]] ", emitTypeKey(tk, false, ctx));

    if(ctx.asm.typeinfos.get(tk).tag === CPPAssembly::Tag#Ref) {
        return String::concat("const ", resolved_type, "*");
    }
    return resolved_type;
}

function emitMethodDecl(m: CPPAssembly::MethodDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(m.declaredInNS, m.fullns);
    let full_indent = String::concat("    ", indent);

    let name = m.ikey.value.removePrefixString(declaredIn.value).removePrefixString('::');
    let params = emitParameters(m.params, nctx);
    let rtype = emitTypeSignature(m.resultType, false, ctx);
    let this_type = emitThisType(declaredIn, nctx);    
    let specialName = emitSpecialTemplate(String::fromCString(name));
    
    let pre = if(rtype === "bool") 
        then String::concat(indent, rtype, " ", specialName)
        else String::concat(indent, "const ", rtype, " ", specialName);

    var params_impl: String;
    if(params === "") {
        params_impl = String::concat("(", this_type, " ", emitSpecialThis(), ") noexcept");
    }
    else {
        let base = String::concat("(", this_type, " ");
        params_impl = String::concat(base, emitSpecialThis(), ", ", params, ") noexcept");           
    }

    return String::concat(pre, params_impl, " {%n;", emitBodyImplementation(m.body, nctx, indent), indent, "}%n;");
}

function emitMethods(ant: CPPAssembly::AbstractNominalTypeDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let staticmethods = ant.staticmethods
        .reduce<String>("", fn(acc, ik) => {
            return String::concat(acc, emitMethodDecl(ctx.asm.staticmethods.get(ik), declaredIn, ctx, indent));
    });

    %%
    %% TODO: Virtual, Abstract, and Override methods
    %%

    return staticmethods;
}

%% Type funcs are fully resolved before cpp emission so we can group them with nsfuncs
function emitFunctionDecl(func: CPPAssembly::AbstractInvokeDecl, ctx: Context, indent: String): String {
    let isTypeFunc = ctx.asm.typefuncs.has(func.ikey);
    let ikey = func.ikey;   
    let ns = if(isTypeFunc) then ctx.asm.typefuncs.get(func.ikey).completens else func.fullns;
    let nctx = ctx.updateCurrentNamespace(func.declaredInNS, ns);

    let name = emitInvokeKey(ikey, nctx);
    let params = emitParameters(func.params, nctx);
    let rtype = emitTypeSignature(func.resultType, true, nctx); 

    let pre: String = String::concat(indent, rtype, " ", name );
    let params_impl: String = String::concat("(", params, ") noexcept ");

    return String::concat(pre, params_impl, " {%n;", emitBodyImplementation(func.body, nctx, indent), indent, "}%n;");
}

function emitSaturatedFieldInfo(sfi: CPPAssembly::SaturatedFieldInfo, ctx: Context, indent: String): String {
    let ftype = emitTypeSignature(sfi.ftype, true, ctx);
    let fname = emitIdentifier(sfi.fname);
    return String::concat(indent, ftype, " ", fname, ";%n;");
}

function emitEntityTypeDecl(e: CPPAssembly::EntityTypeDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(e.declaredInNS, e.fullns);
    let tkey = emitTypeKey(declaredIn, false, nctx);

    let e_enum = generateEntriesEnum(e@<CPPAssembly::AbstractNominalTypeDecl>, e.fields, ctx, indent);
    let e_vtable = generateVTable(e@<CPPAssembly::AbstractNominalTypeDecl>, e.fields, ctx, indent);
    let e_tinfo = emitTypeInfo(ctx.asm.typeinfos.get(e.tkey), some(e), ctx, indent);

    let base = String::concat(e_enum, e_vtable, e_tinfo);

    let entries = e.saturatedBFieldInfo.reduce<String>(String::concat(base, indent, "struct ", tkey, " { %n;"), 
        fn(acc, entry) => {
            return String::concat(acc, emitSaturatedFieldInfo(entry, nctx, String::concat("    ", indent)));
    });

    return String::concat(entries, indent, "};%n;");
}

function emitDatatypeMemberEntityDecl(dm: CPPAssembly::DatatypeMemberEntityTypeDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(dm.declaredInNS, dm.fullns);
    let tkey = emitTypeKey(dm.tkey, false, nctx); 

    let dm_enum = generateEntriesEnum(dm@<CPPAssembly::AbstractNominalTypeDecl>, dm.fields, ctx, indent);
    let dm_vtable = generateVTable(dm@<CPPAssembly::AbstractNominalTypeDecl>, dm.fields, ctx, indent);
    let dm_tinfo = emitTypeInfo(ctx.asm.typeinfos.get(dm.tkey), some(dm), ctx, indent);

    let base = String::concat(dm_enum, dm_vtable, dm_tinfo);

    let fields = dm.saturatedBFieldInfo.reduce<String>(String::concat(base, indent, "struct ", tkey, "{ %n;"), 
        fn(acc, entry) => {
            return String::concat(acc, emitSaturatedFieldInfo(entry, nctx, String::concat("    ", indent)));
    });

    return String::concat(fields, indent, "};%n;");
}

function emitDatatypeTypeDecl(dt: CPPAssembly::DatatypeTypeDecl, ctx: Context, indent: String): String {
    let dm_enum = generateEntriesEnum(dt@<CPPAssembly::AbstractNominalTypeDecl>, dt.fields, ctx, indent);
    let dm_vtable = generateVTable(dt@<CPPAssembly::AbstractNominalTypeDecl>, dt.fields, ctx, indent);
    let dm_tinfo = ctx.asm.typeinfos.get(dt.tkey);
    
    return String::concat(dm_enum, dm_vtable, emitTypeInfo(dm_tinfo, some(dt@<CPPAssembly::AbstractNominalTypeDecl>), ctx, indent));
}

function emitEnumTypeDecl(etd: CPPAssembly::EnumTypeDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);

    let etd_tinfo = emitTypeInfo(ctx.asm.typeinfos.get(etd.tkey), some(etd), ctx, indent);

    let base = String::concat(indent, "enum class ", String::fromCString(etd.name), " {%n;");
    let entries = etd.members.map<String>(fn(e) => String::concat(full_indent, String::fromCString(e)));
    let wentries = String::concat(base, String::joinAll(",%n;", entries), "%n;", indent, "};%n;");

    return String::concat(etd_tinfo, wentries);
}

function emitAbstractNominalForwardDeclaration(e: CPPAssembly::AbstractNominalTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(e.declaredInNS, e.fullns);
    let tkey = emitTypeKey(e.tkey, false, nctx);

    if(e)@<CPPAssembly::AbstractConceptTypeDecl> { %% Emit our concepts typedefs with our fwd decls (their vtables and type info can just go with their subtypes)
        let k = String::fromCString((nctx.asm.typeinfos.get($e.tkey).slotsize - 1n).toCString()); %% Slot size includes "2" ptr to typeinfo, so we ignore
        return String::concat(indent, "typedef __CoreCpp::Boxed<", k, "> ", emitTypeKey($e.tkey, false, nctx), ";%n;");
    }

    return String::concat(indent, "struct ", tkey, ";%n;");
}

function emitMethodForwardDeclaration(m: CPPAssembly::MethodDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(m.declaredInNS, m.fullns);

    if(m)@<CPPAssembly::MethodDeclStatic> {
        let pre = m.ikey.value.removePrefixString(declaredIn.value).removePrefixString('::');
        let rtype = emitTypeSignature(m.resultType, true, nctx);
        let this_type = emitThisType(declaredIn, nctx);
        let params = emitParameters(m.params, nctx);

        let specialName = emitSpecialTemplate(String::fromCString(pre));

        let first = if(rtype !== "bool") then String::concat(indent, "const ", rtype, " ", specialName, "(")
            else String::concat(indent, rtype, " ", specialName, "(");

        if(params === "") {
            return String::concat(first, this_type, " ", emitSpecialThis(), params, ") noexcept;%n;");
        }
        else {
            let base = String::concat(first, this_type, " ");
            return String::concat(base, emitSpecialThis(), ", ", params, ") noexcept;%n;");           
        }
    }
    else {
        abort; %% TODO: Support other method types!
    }
}

function emitFunctionForwardDeclaration(decl: CPPAssembly::AbstractInvokeDecl, ctx: Context, ident: String): String {
    let isTypeFunc = ctx.asm.typefuncs.has(decl.ikey);
    let ns = if(isTypeFunc) then ctx.asm.typefuncs.get(decl.ikey).completens else decl.fullns;
    let nctx = ctx.updateCurrentNamespace(decl.declaredInNS, ns);

    let ikey = emitInvokeKey(decl.ikey, nctx);
    let rtype = emitTypeSignature(decl.resultType, true, nctx); 
    let params = emitParameters(decl.params, nctx);

    let first = String::concat(ident, rtype, " ", ikey);
    return String::concat(first, "(", params, ") noexcept;%n;");
}

%%
%% TODO: Need to add lookup methods for these vtables and give this some thought. A lot of this code is repetitive or could be
%% cleaned up pretty signifigantly. We currently emit a vtable entry for all fields, not just those who are derived. (this may need changed)
%%

function generateVTableEntry(entry: CPPAssembly::MemberFieldDecl, resolved_name: String, enum_name: String, idx: Nat, ctx: Context, indent: String): String {
    let tinfo = ctx.asm.typeinfos.tryGet(entry.declaredType.tkeystr)@some;

    let id = String::fromCString(tinfo.id.toCString());
    let entrytype = String::concat(enum_name, "::", resolved_name, "_", emitIdentifier(entry.name));
    let byteoffset = String::fromCString((idx * 8n).toCString()); %% Woudlnt be a bad idea to make these 8 byte alignment a const

    let base = String::concat("{ ", id, ", ", entrytype, ", ", byteoffset);
    return String::concat(indent, base, " }");
}

function generateVTable(ant: CPPAssembly::AbstractNominalTypeDecl, fields: List<CPPAssembly::MemberFieldDecl>, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(ant.declaredInNS, ant.fullns);
    let full_indent = String::concat("    ", indent);
    
    let name = emitTypeKey(ant.tkey, false, nctx);
    let enum_name = String::concat(name, "_entries");
    let vtable_name = String::concat(name, "_vtable");

    let base = String::concat("const __CoreCpp::FieldOffsetInfo ", vtable_name, "[] = ", "{%n;");
    let field_names = fields.mapIdx<String>(fn(f_entry, ii) => generateVTableEntry(f_entry, name, enum_name, ii, ctx, full_indent));
    return String::concat(indent, base, String::joinAll(",%n;", field_names), "%n;", indent, "};%n;"); 
}

function generateEntriesEnum(ant: CPPAssembly::AbstractNominalTypeDecl, fields: List<CPPAssembly::MemberFieldDecl>, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(ant.declaredInNS, ant.fullns);
    let full_indent = String::concat("    ", indent);
    
    let name = emitTypeKey(ant.tkey, false, nctx);
    let enum_name = String::concat(name, "_entries");

    let base = String::concat("enum ", enum_name, " : uintptr_t {%n;");
    let field_names = fields.map<String>(fn(f_entry) => String::concat(full_indent, name, "_", emitIdentifier(f_entry.name)));
    return String::concat(indent, base, String::joinAll(",%n;", field_names), "%n;", indent, "};%n;");
}

function convertTagEnumEntries(e: CPPAssembly::Tag): String {
    switch(e) {
        CPPAssembly::Tag#Value => { return "Value"; }
        | CPPAssembly::Tag#Ref => { return "Ref"; }
        | CPPAssembly::Tag#Tagged => { return "Tagged"; }    
   }
}

function emitTypeInfo(info: CPPAssembly::TypeInfo, ant: Option<CPPAssembly::AbstractNominalTypeDecl>, ctx: Context, indent: String): String {
    let nctx = if(ant)@some then ctx.updateCurrentNamespace($ant.declaredInNS, $ant.fullns) else ctx;
    let full_indent = String::concat("    ", indent);

    let name = removeCppPrefix(emitTypeKey(info.typekey, false, nctx));
    var needsvtable: Bool;
    if(ant)@none { %% We should only need to generate a vtable for concepts
        needsvtable = false;
    }
    else {
        let e = ctx.asm.lookupNominalTypeDeclaration($ant.tkey);
        if(e?<CPPAssembly::ConceptTypeDecl> || e?<CPPAssembly::DatatypeTypeDecl>) {
            needsvtable = true; 
        }
        else {
            needsvtable = false;
        }
    }

    let tinfo_name = String::concat(name, "Type");

    let base = String::concat(indent, "__CoreCpp::TypeInfoBase ", tinfo_name, " = {%n;");
    let id = String::concat(base, full_indent, ".type_id = ", String::fromCString(info.id.toCString()), ",%n;");
    let typesize = String::concat(id, full_indent, ".type_size = ", String::fromCString(info.typesize.toCString()), ", %n;");
    let slotsize = String::concat(typesize, full_indent, ".slot_size = ", String::fromCString(info.slotsize.toCString()), ",%n;");
    let tag = String::concat(slotsize, full_indent, ".tag = __CoreCpp::Tag::", convertTagEnumEntries(info.tag), ",%n;");
    let ptrmask = String::concat(tag, full_indent, ".ptr_mask = ", emitEnclosedParen(info.ptrmask), ",%n;");
    let typekey = String::concat(ptrmask, full_indent, ".typekey = ", emitEnclosedParen(info.typekey.value), ",%n;");
    let vtable = if(needsvtable) then String::concat(typekey, full_indent, ".vtable = ", String::concat(name, "_vtable"), "%n;")
        else String::concat(typekey, full_indent, ".vtable = nullptr%n;");

    return String::concat(vtable, indent, "};%n;");
}

function emitMapEntryTypeDecl(mtd: CPPAssembly::MapEntryTypeDecl, ctx: Context, indent: String): String {
    abort; %% TODO: Not Implemented!   
}

function emitConstructableTypeDecl(ctd: CPPAssembly::ConstructableTypeDecl, ctx: Context, indent: String): String {
    match(ctd)@ {
        CPPAssembly::SomeTypeDecl => { return emitSomeTypeDecl($ctd, ctx, indent); }
        | CPPAssembly::MapEntryTypeDecl => { return emitMapEntryTypeDecl($ctd, ctx, indent); }
    }
}

function emitCollectionTypeDecl(ctd: CPPAssembly::CollectionTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(ctd.declaredInNS, ctd.fullns);
    let ttype = emitTypeSignature(ctd.oftype, false, nctx);
    let resolvedttype = if(ttype.startsWithString("__CoreCpp::")) then ttype.removePrefixString("__CoreCpp::") 
        else ttype;
    return String::concat(indent, "typedef ListOps::Tree·ê∏", resolvedttype, "·ê≥ ", emitTypeKey(ctd.tkey, false, nctx), ";%n;");
}

function emitAbstractNominalTypeDecl(ant: CPPAssembly::AbstractNominalTypeDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    %% The entries who need a vtable should manually do it
    match(ant)@ {
        CPPAssembly::EntityTypeDecl => { return emitEntityTypeDecl($ant, declaredIn, ctx, indent); }
        | CPPAssembly::DatatypeMemberEntityTypeDecl => { return emitDatatypeMemberEntityDecl($ant, declaredIn, ctx, indent); }
        | CPPAssembly::PrimitiveConceptTypeDecl => { return emitPrimtiveConceptTypeDecl($ant, ctx, indent); }
        | CPPAssembly::ConstructableTypeDecl => { return emitConstructableTypeDecl($ant, ctx, indent); }
        | CPPAssembly::CollectionTypeDecl => { return emitCollectionTypeDecl($ant, ctx, indent); }
        | CPPAssembly::DatatypeTypeDecl => { return emitDatatypeTypeDecl($ant, ctx, indent); } 
        | CPPAssembly::EnumTypeDecl => { return emitEnumTypeDecl($ant, ctx, indent); }
    }
}

function emitConstMemberDecl(cmd: CPPAssembly::ConstMemberDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(cmd.declaredInNS, cmd.fullns);
    
    let exp = emitExpression(cmd.value, nctx);
    let rtype = emitTypeSignature(cmd.declaredType, true, nctx);

    %% Not 100% about removing previx, fixes bug for emitting "one" and "zero" constmember decls
    let name = removeCppPrefix(String::concat(rtype, "·òè", emitIdentifier(cmd.name)));

    let pre = String::concat(indent, rtype, " ", name, " = ");
    return String::concat(pre, exp, ";%n;");
}

function emitSomeTypeDecl(std: CPPAssembly::SomeTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(std.declaredInNS, std.fullns);
    
    let full_indent = String::concat("    ", indent);
    let sometype = emitTypeKey(std.tkey, false, nctx);
    let ttype = emitTypeSignature(std.oftype, true, nctx);

    let std_tinfo = emitTypeInfo(nctx.asm.typeinfos.get(std.tkey), some(std@<CPPAssembly::AbstractNominalTypeDecl>), nctx, indent);

    let value = String::concat(sometype, " {%n;", full_indent, ttype, " value;%n;", indent);
    return String::concat(std_tinfo, indent, "struct ", value, "};%n;");
}

function emitPrimtiveConceptTypeDecl(pc: CPPAssembly::PrimitiveConceptTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(pc.declaredInNS, pc.fullns); 
    return emitTypeInfo(nctx.asm.typeinfos.get(pc.tkey), some(pc@<CPPAssembly::AbstractNominalTypeDecl>), nctx, indent);
}

recursive function emitFuncForwardDeclarations(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);

    let subns_fwddecls = nsdecl.subns.reduce<String>("", fn(acc, nsname, subns) => {
        let ns = String::concat(indent, "namespace ", String::fromCString(nsname), " {%n;");
        return String::concat(ns, emitFuncForwardDeclarations[recursive](subns, ctx, full_indent), indent, "}%n;");
    });

    %% Emit our method and func fwd decls
    let nsfunc_fwddecls = nsdecl.nsfuncs.reduce<String>(subns_fwddecls, fn(acc, ikey) => {
        return String::concat(acc, emitFunctionForwardDeclaration(ctx.asm.nsfuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, indent));
    });

    let typefunc_fwddecls = nsdecl.typefuncs.reduce<String>(nsfunc_fwddecls, fn(acc, ikey) => {
        return String::concat(acc, emitFunctionForwardDeclaration(ctx.asm.typefuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, indent));
    });

    return typefunc_fwddecls;
}

recursive function emitNamespaceDecl(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    %% Emit namespace 
    let ns = String::concat(indent, "namespace ", String::fromCString(nsdecl.nsname), " {%n;");
    let full_indent = String::concat("    ", indent);

    %% Emit sub-namespace declarations
    let subns = nsdecl.subns.reduce<String>(ns, fn(acc, name, decl) => {
        return String::concat(acc, emitNamespaceDecl[recursive](decl, ctx, full_indent));
    });

    %% Emit functions in current namespace
    let nsfuncs = nsdecl.nsfuncs.reduce<String>(subns , fn(acc, ikey) => {
        return String::concat(acc, emitFunctionDecl(ctx.asm.nsfuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, full_indent)); 
    });

    let typefuncs = nsdecl.typefuncs.reduce<String>(nsfuncs, fn(acc, ikey) => {
        return String::concat(acc, emitFunctionDecl(ctx.asm.typefuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, full_indent)); 
    });

    return String::concat(typefuncs, indent, "}%n;");
}

%%
%% Emits forward decls of Ref and Tagged types
%%
function emitNamespaceDeclFwdDecls(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    let ns = String::concat(indent, "namespace ", String::fromCString(nsdecl.nsname), " {%n;");

    let subns_fwddecls = nsdecl.subns
        .reduce<String>(ns, fn(acc, name, decl) => {
            return String::concat(acc, emitNamespaceDeclFwdDecls[recursive](decl, ctx, full_indent));
    });

    let ant_fwddecls = nsdecl.alltypes
        .filter(pred(tk) => ctx.asm.typeinfos.get(tk).tag !== CPPAssembly::Tag#Value)
        .reduce<String>("", fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let fwddecl = emitAbstractNominalForwardDeclaration(ant, ctx, full_indent); 
            return String::concat(acc, fwddecl);
    });

    return String::concat(subns_fwddecls, ant_fwddecls, indent, "}%n;");
}

%%
%% Emits all necessary types given nsdecl (their concrete definitions)
%%
function emitNamespaceDeclTypes(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    let ns = String::concat(indent, "namespace ", String::fromCString(nsdecl.nsname), " {%n;");

    let subns = nsdecl.subns
        .reduce<String>(ns, fn(acc, name, decl) => {
            return String::concat(acc, emitNamespaceDeclTypes[recursive](decl, ctx, full_indent));
    });

    %% Emit enums first as they are just integers
    let enums = nsdecl.alltypes
        .filter(pred(tk) => ctx.asm.enums.has(tk))
        .reduce<String>(String::concat(subns, "//%n;// Value Type Definitions%n;//%n;"), fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let def = emitAbstractNominalTypeDecl(ant, tk, ctx, full_indent);
            return String::concat(acc, def);
    });

    %% Value types
    let values = nsdecl.alltypes
        .filter(pred(tk) => ctx.asm.typeinfos.get(tk).tag === CPPAssembly::Tag#Value && !ctx.asm.enums.has(tk))
        .reduce<String>(enums, fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let def = emitAbstractNominalTypeDecl(ant, tk, ctx, full_indent);
            return String::concat(acc, def);
    });

    %% Ref and Tagged types
    let other = nsdecl.alltypes
        .filter(pred(tk) => ctx.asm.typeinfos.get(tk).tag !== CPPAssembly::Tag#Value)
        .reduce<String>(String::concat(values, "//%n;// Ref and Tagged Type Definitions%n;//%n;"), fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let def = emitAbstractNominalTypeDecl(ant, tk, ctx, full_indent);
            return String::concat(acc, def);
    });

    %% Will ns nsdecl consts too, this is just ConstMemberDecls 
    let types = nsdecl.typeconsts.reduce<String>(String::concat(other, "//%n;// Constants%n;//%n;"), fn(acc, s) => {
        let tc = ctx.asm.typeconsts.get(s);
        let def = emitConstMemberDecl(tc, ctx, full_indent);
        return String::concat(acc, def);
    });

    %% Only support static methods for now
    let method_fwddecls = nsdecl.staticmethods
        .reduce<String>(String::concat(types, "//%n;// All Methods%n;//%n;"), fn(acc, mtkey) => {
            return String::concat(acc, emitMethodForwardDeclaration(ctx.asm.staticmethods.get(mtkey.0), mtkey.1, ctx, full_indent));
    });

    %% Emit methods after all type defintions to prevent types not being fully defined but used
    let methods = nsdecl.alltypes
        .reduce<String>(method_fwddecls, fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let func = emitMethods(ant, tk, ctx, full_indent);
            return String::concat(acc, func);
    });

    return String::concat(methods, indent, "}%n;");
}

function emitAssembly(asm: CPPAssembly::Assembly): String {    
    let ctx: Context = Context{ asm, CPPAssembly::NamespaceKey::from('Tmp'), List<CString>{''} }; %% No known namespace yet

    let primitive_typeinfos = asm.typeinfos.reduce<String>("//%n;// Primitive Types%n;//%n;", fn(acc, tk, ti) => {
        return if(asm.isPrimtitiveType(tk)) then String::concat(acc, emitTypeInfo(ti, none, ctx, "")) else acc;
    }); 

    %% Non-value type forward decls
    let fwddecls = asm.nsdecls
        .reduce<String>(String::concat(primitive_typeinfos, "//%n;// Ref and Tagged Type Forward Declarations%n;//%n;"),
        fn(acc, nsname, nsdecl) => {
            return String::concat(acc, emitNamespaceDeclFwdDecls(nsdecl, ctx, ""));
    });

    %% Defintion of Value and Non-value types
    let types = asm.nsdecls.reduce<String>(fwddecls, fn(acc, nsname, nsdecl) => {
        return String::concat(acc, emitNamespaceDeclTypes(nsdecl, ctx, ""));
    });

    %% Function forward decls
    let funcfwddecls = asm.nsdecls
        .reduce<String>(String::concat(types, "//%n;// Namespace/Type Function Forward Declarations%n;//%n;"), fn(acc, nsname, nsdecl) => {
            let ns = String::concat("", "namespace ", String::fromCString(nsname), " {%n;");
            return String::concat(acc, ns, emitFuncForwardDeclarations(nsdecl, ctx, "    "), "}%n;");
        });


    let ns_emission = asm.nsdecls.reduce<String>("//%n;// Emitted Functions%n;//%n;", fn(acc, nsname, nsdecl) => {
        return String::concat(acc, emitNamespaceDecl[recursive](nsdecl, ctx, ""));
    });

    %% We use this bold src so we can split our header and src files into two strings in analyzecpp
    return String::concat(funcfwddecls, "ùê¨ùê´ùêú", ns_emission);
}