namespace CPPEmitter;

%% CPP Pre-defined backend
namespace PathStack {
    function emitPathStackCreate(): CString {
        return 'PathStack ps = PathStack::create();';
    }

    function emitPathStackLeft(): CString {
        return 'ps.left();';
    }

    function emitPathStackRight(): CString {
        return 'ps.right();';
    }

    function emitPathStackUp(): CString {
        return 'ps.up();';
    }
}

namespace CCharBuffer {
    %% Emit c++ for buffer creation here
}

namespace UnicodeCharBuffer {
    %% Emit c++ for buffer creation here
}

entity Context {
    field asm: CPPAssembly::Assembly;
    field fullns_key: CPPAssembly::NamespaceKey; %% Main::Foo::Bar::...
    field fullns_list: List<CString>; %% ['Main', 'Foo', 'Bar', ...]

    method updateCurrentNamespace(new_ns: CPPAssembly::NamespaceKey, new_nsname: List<CString>): Context {
        return Context{ this.asm, new_ns, new_nsname };
    }
    method updateInOption(new_inoption: Option<CPPAssembly::TypeSignature>): Context {
        return Context{ this.asm, this.fullns_key, this.fullns_list };
    }
}

%% Temporary invalid string we replace just before emission (with our special unicode tᖺis)
function emitSpecialThis(): CString {
    return '!!!';
}

%% replaces '<', '>', and comma in that order
function getSpecialTemplates(): (|CString, CString, CString|) {
    return (|'$!', '##', '!$'|);
}

%% Replaces templates '<', '>', and comma with temporary invalid characters to be replaced just before emission
function emitSpecialTemplate(name: CString): CString {
    %% let templates = name.replaceAllRegexOccurences(CPPAssembly::templateMatch, ''); %% Does not work 
    %%let ns = name.removePrefixString(templates);

    %% Regex replace match for <*> to get ns
    %% remove found ns to get template
    %% replace :: in template with _

    let st = getSpecialTemplates();
    let base = name.replaceAllStringOccurrences(' ', '');
    let first = base.replaceAllStringOccurrences('<', st.0);
    let second = first.replaceAllStringOccurrences(',', st.1);
    let third = second.replaceAllStringOccurrences('>', st.2);

    %% return CString::concat(ns, third);
    return third;
}

%% We dont want this prefix when emitting typeinfo for primitives
function removeCppPrefix(s: CString): CString {
    return if(s.startsWithString('__CoreCpp::')) then s.removePrefixString('__CoreCpp::') else s;
}

function emitTypeKey(tk: CPPAssembly::TypeKey, isParamField: Bool, ctx: Context): CString {
    let emit = emitResolvedNamespace(ctx.fullns_list, emitSpecialTemplate(tk.value)); 

    if(isParamField) {
        let tinfo = ctx.asm.typeinfos.tryGet(tk)@some;

        switch(tinfo.tag) {
            CPPAssembly::Tag#Value => { return emit; }
            | CPPAssembly::Tag#Ref => { return CString::concat(emit, '*'); }
            | CPPAssembly::Tag#Tagged => { abort; } %% Not fully confident on how to handle this quite yet
        }
    }
    return emit;
}

function emitIdentifier(ident: CPPAssembly::Identifier): CString {
    return emitSpecialTemplate(ident.value);
}

function emitVarIdentifier(vident: CPPAssembly::VarIdentifier): CString {
    if(vident.value === 'this') {
        return emitSpecialThis();
    }
    return emitSpecialTemplate(vident.value);
}

function emitInvokeKey(ik: CPPAssembly::InvokeKey, ctx: Context): CString {
    return emitResolvedNamespace(ctx.fullns_list, emitSpecialTemplate(ik.value)); 
}

function emitNamespaceKey(nsk: CPPAssembly::NamespaceKey): CString {
    return nsk.value;
}

%% Given a namespace key (like Main::Foo::Bar), remove all matching prefix strings
%% giving resolved namespace for given scope
function emitResolvedNamespace(fullns_list: List<CString>, fullns: CString): CString {
    return fullns_list.reduce<CString>(fullns, fn(acc, s) => {
        if(acc.startsWithString(s)) {
            let nopre = acc.removePrefixString(s);
            if(nopre.startsWithString('::')) {
                return nopre.removePrefixString('::');
            }
            return nopre;
        }
        return acc;
    });
}

function emitLiteralSimpleExpression(exp: CPPAssembly::LiteralSimpleExpression): CString {
    %% We may want to make this matching a tad nicer, although not too bad as is 
    switch(exp.etype.tkeystr.value) {
        '__CoreCpp::Int' => { return CString::concat(exp.value, '_i'); }
        | '__CoreCpp::BigInt' => { return CString::concat(exp.value, '_I'); } 
        | '__CoreCpp::Nat' => { return CString::concat(exp.value, '_n'); }
        | '__CoreCpp::BigNat' => { return CString::concat(exp.value, '_N'); }
        | '__CoreCpp::Float' => { return CString::concat(exp.value, '_f'); }
        | 'bool' => { return exp.value; }
        | _ => { abort; }
    }
}

function emitLiteralNoneExpression(exp: CPPAssembly::LiteralNoneExpression, ctx: Context): CString {
    return 'UINT64_MAX';
}

function emitAccessVariableExpression(exp: CPPAssembly::AccessVariableExpression): CString {
    return emitVarIdentifier(exp.vname);
}

function emitReturnSingleStatement(ret: CPPAssembly::ReturnSingleStatement, ctx: Context, indent: CString): CString {
    let exp = emitExpression(ret.value, ctx);

    let full_indent: CString = CString::concat(indent, '    ');
    return CString::concat(full_indent, 'return ', exp, ';%n;');
}

recursive function emitBinAddExpression(add: CPPAssembly::BinAddExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](add.lhs, ctx);
    let rhs = emitExpression[recursive](add.rhs, ctx);

    return CString::concat('(', lhs, ' + ', rhs, ')');
}

recursive function emitBinSubExpression(sub: CPPAssembly::BinSubExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](sub.lhs, ctx);
    let rhs = emitExpression[recursive](sub.rhs, ctx);

    return CString::concat('(', lhs, ' - ', rhs, ')');
}

recursive function emitBinDivExpression(div: CPPAssembly::BinDivExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](div.lhs, ctx);
    let rhs = emitExpression[recursive](div.rhs, ctx);

    return CString::concat('(', lhs, ' / ', rhs, ')');
}

recursive function emitBinMultExpression(mult: CPPAssembly::BinMultExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](mult.lhs, ctx);
    let rhs = emitExpression[recursive](mult.rhs, ctx);

    return CString::concat('(', lhs, ' * ', rhs, ')');
}

recursive function emitBinaryArithExpression(e: CPPAssembly::BinaryArithExpression, ctx: Context): CString {
    match(e)@ {
        CPPAssembly::BinAddExpression => { return emitBinAddExpression[recursive]($e, ctx); }
        | CPPAssembly::BinSubExpression => { return emitBinSubExpression[recursive]($e, ctx); }
        | CPPAssembly::BinDivExpression => { return emitBinDivExpression[recursive]($e, ctx); }
        | CPPAssembly::BinMultExpression => { return emitBinMultExpression[recursive]($e, ctx); }
    }
}

recursive function emitPrefixNotOpExpression(notop: CPPAssembly::PrefixNotOpExpression, ctx: Context): CString {
    let expr = emitExpression[recursive](notop.expr, ctx);
    return CString::concat('!', expr);
}

recursive function emitPrefixNegateOpExpression(negop: CPPAssembly::PrefixNegateOpExpression, ctx: Context): CString {
    let expr = emitExpression[recursive](negop.expr, ctx);
    return CString::concat('-', expr);
}

recursive function emitPrefixPlusOpExpression(plusop: CPPAssembly::PrefixPlusOpExpression, ctx: Context): CString {
    return emitExpression[recursive](plusop.expr, ctx);
}

recursive function emitUnaryExpression(e: CPPAssembly::UnaryExpression, ctx: Context): CString {
    match(e)@ {
        CPPAssembly::PrefixNotOpExpression => { return emitPrefixNotOpExpression[recursive]($e, ctx); }
        | CPPAssembly::PrefixNegateOpExpression => { return emitPrefixNegateOpExpression[recursive]($e, ctx); }
        | CPPAssembly::PrefixPlusOpExpression => { return emitPrefixPlusOpExpression[recursive]($e, ctx); }
    }
}

recursive function emitNumericEqExpression(e: CPPAssembly::NumericEqExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return CString::concat('(', lhs, ' == ', rhs, ')');   
}

recursive function emitNumericNeqExpression(e: CPPAssembly::NumericNeqExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return CString::concat('(', lhs, ' != ', rhs, ')');   
}

recursive function emitNumericLessExpression(e: CPPAssembly::NumericLessExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return CString::concat('(', lhs, ' < ', rhs, ')');   
}

recursive function emitNumericLessEqExpression(e: CPPAssembly::NumericLessEqExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return CString::concat('(', lhs, ' <= ', rhs, ')');   
}

recursive function emitNumericGreaterExpression(e: CPPAssembly::NumericGreaterExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return CString::concat('(', lhs, ' > ', rhs, ')');   
}

recursive function emitNumericGreaterEqExpression(e: CPPAssembly::NumericGreaterEqExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return CString::concat('(', lhs, ' >= ', rhs, ')');   
}

recursive function emitBinaryNumericExpression(e: CPPAssembly::BinaryNumericExpression, ctx: Context): CString {
    match(e)@ {
        CPPAssembly::NumericEqExpression => { return emitNumericEqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericNeqExpression => { return emitNumericNeqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericLessExpression => { return emitNumericLessExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericLessEqExpression => { return emitNumericLessEqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericGreaterExpression => { return emitNumericGreaterExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericGreaterEqExpression => { return emitNumericGreaterEqExpression[recursive]($e, ctx); }
    }
}

recursive function emitBinLogicAndExpression(e: CPPAssembly::BinLogicAndExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);   

    return CString::concat('(', lhs, ' && ', rhs, ')');
}

recursive function emitBinLogicOrExpression(e: CPPAssembly::BinLogicOrExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);   

    return CString::concat('(', lhs, ' || ', rhs, ')');
}

recursive function emitBinLogicImpliesExpression(e: CPPAssembly::BinLogicImpliesExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);  

    let implies: CString = CString::concat('!', lhs, ' || ', rhs);
    return CString::concat('(', implies ,')');
}

recursive function emitBinLogicIFFExpression(e: CPPAssembly::BinLogicIFFExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx); 
    let nlhs: CString = CString::concat('!', lhs);
    let nrhs: CString = CString::concat('!', rhs);

    let first: CString = CString::concat('(', lhs, ' && ', rhs, ')');
    let second: CString = CString::concat('(', nlhs, ' && ', nrhs, ')');

    return CString::concat('(', first, ' || ', second, ')');
}

recursive function emitBinLogicExpression(e: CPPAssembly::BinLogicExpression, ctx: Context): CString {
    match(e)@ {
        CPPAssembly::BinLogicAndExpression => { return emitBinLogicAndExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicOrExpression => { return emitBinLogicOrExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicImpliesExpression => { return emitBinLogicImpliesExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicIFFExpression => { return emitBinLogicIFFExpression[recursive]($e, ctx); }
    }
}

recursive function emitLogicActionAndExpression(e: CPPAssembly::LogicActionAndExpression, ctx: Context): CString {
    let args = e.args.map<CString>(fn(expr) => emitExpression[recursive](expr, ctx));
    return CString::concat('(', CString::joinAll(' && ', args), ')');
}

recursive function emitLogicActionOrExpression(e: CPPAssembly::LogicActionOrExpression, ctx: Context): CString {
    let args = e.args.map<CString>(fn(expr) => emitExpression[recursive](expr, ctx));
    return CString::concat('(', CString::joinAll(' || ', args), ')');
}

function emitArgumentValue(av: Option<CPPAssembly::ArgumentValue>, i: Nat, params: List<CPPAssembly::ParameterDecl>, ctx: Context): CString {
    if(av)@none {
        let param = params.get(i).defaultval;
        if(param)@none {
            abort; %% Should be impossible
        }
        else {
            return emitExpression[recursive]($param, ctx);
        }
    }
    else {
        let arg = $av;
        let expr = emitExpression[recursive](arg.exp, ctx);
        match(arg)@ {
            CPPAssembly::NamedArgumentValue => { return expr; } 
            | CPPAssembly::PositionalArgumentValue => { return expr; }
            | _ => { abort; }
        }
    }
}

function resolveDefaultParams(al: List<CString>, params: List<CPPAssembly::ParameterDecl>): List<CString> {
    return al.map<CString>(fn(arg) => { 
        if(arg.startsWithString('$')) {
            let ident = arg.removePrefixString('$');

            %% This is a bit hacky but works for getting default val idx
            let idx = params.mapIdx<Nat>(fn(param, ii) => {
                if(emitIdentifier(param.pname) === ident) {
                    return ii;
                }
                return 0n;
            }).sum();

            return al.get(idx);
        }
        return arg; 
    });
}

function emitArgumentList(al: CPPAssembly::ArgumentList, params: List<CPPAssembly::ParameterDecl>, ctx: Context): CString {
    let emit_al = al.args.mapIdx<CString>(fn(arg, ii) => emitArgumentValue(arg, ii, params, ctx));
    
    return CString::joinAll(', ', resolveDefaultParams[recursive](emit_al, params));
}

function emitCallNamespaceFunctionExpression(e: CPPAssembly::CallNamespaceFunctionExpression, ctx: Context): CString { 
    let resolvedns = emitResolvedNamespace(ctx.fullns_list, e.ns.value); 
    let ikey = emitInvokeKey(e.ikey, ctx);

    let name: CString = if(ikey.startsWithString(e.ns.value)) then ikey.removePrefixString(e.ns.value) else ikey;
    let resolvedName: CString = if(name.startsWithString('::')) then name.removePrefixString('::') else name;

    let nsfunc = ctx.asm.nsfuncs.get(e.ikey); 
    let args = emitArgumentList(e.args, nsfunc.params, ctx); 

    if(resolvedns !== '') {
        return CString::concat(resolvedns, '::', resolvedName ,'(', args, ')');
    }
    return CString::concat(resolvedName, '(', args, ')');
}

function emitCallTypeFunctionExpression(e: CPPAssembly::CallTypeFunctionExpression, ctx: Context): CString { 
    let ttype = emitTypeKey(e.ttype.tkeystr, false, ctx);
    let resolvedDeclType = emitTypeKey(e.resolvedDeclType.tkeystr, false, ctx);
    let typefunc = ctx.asm.typefuncs.get(e.ikey);
    let completeikey = typefunc.completeikey.value;
    let args = emitArgumentList(e.args, typefunc.params, ctx); 

    let tfuncns = typefunc.declaredInNS.value;
    let name: CString = if(completeikey.startsWithString(tfuncns)) then completeikey.removePrefixString(tfuncns) else completeikey;
    let resolvedName: CString = if(name.startsWithString('::')) then name.removePrefixString('::') else name;

    let resolvedns = emitResolvedNamespace(ctx.fullns_list, typefunc.declaredInNS.value);
    if(resolvedns !== '') {
        return CString::concat(resolvedns, '::', resolvedName, '(', args, ')');
    }
    return CString::concat(resolvedName, '(', args, ')');
}

function emitPostfixAccessFromName(op: CPPAssembly::PostfixAccessFromName, ctx: Context): CString {
    let ident = emitIdentifier(op.name);

    let op_tinfo = ctx.asm.typeinfos.get(op.declaredInType.tkeystr);
    switch(op_tinfo.tag) {
        CPPAssembly::Tag#Value => { return CString::concat('.', ident); }
        | CPPAssembly::Tag#Ref => { return CString::concat('->', ident); }
        | CPPAssembly::Tag#Tagged => { abort; } %% TODO: Need to handle virtual lookups (and add our little vtable to backend that emits)
    }
}

function emitPostfixInvokeStatic(op: CPPAssembly::PostfixInvokeStatic, expr: CString, ctx: Context): CString {
    let ik = emitInvokeKey(op.resolvedTrgt, ctx);
    let tk = emitTypeKey(op.resolvedType.tkeystr, false, ctx);

    var args: CString;
    var name: CString;
    if(ctx.asm.staticmethods.has(op.resolvedTrgt)) {
        let trgt = ctx.asm.staticmethods.get(op.resolvedTrgt);
        name = trgt.name;
        args = emitArgumentList(op.args, trgt.params, ctx);
    }
    else {
        abort; %% TODO: Add support for Override, Abstract, and Virtual methods!
    }

    %% Remove abstract nominal we were in
    var resolvedInvoke: CString;
    if(ik.startsWithString(tk)) {
        let tmp = ik.removePrefixString(tk);
        if(tmp.startsWithString('::')) {
            resolvedInvoke = tmp.removePrefixString('::');
        }
        else {
            resolvedInvoke = tmp;
        } 
    }
    else {
        resolvedInvoke = ik;
    }

    if(args === '') {
        return CString::concat(resolvedInvoke, '(', expr, ')');
    }
    else {
         return CString::concat(resolvedInvoke, '(', expr, ', ', args, ')');       
    }
}

function emitITestType(it: CPPAssembly::ITestType, baseType: CPPAssembly::TypeSignature, ctx: Context): CString {
    %% For now we only support ITests where both types are concrete
    if(ctx.asm.isNominalTypeConcrete(it.ttype.tkeystr) && ctx.asm.isNominalTypeConcrete(baseType.tkeystr)) {
        let areTypesSame = ctx.asm.areTypesSame(it.ttype, baseType);
        return if(it.isnot) then (if(!areTypesSame) then 'true' else 'false')
            else if(areTypesSame) then 'true' else 'false';
    }
    else {
        abort; %% TODO: ITests on concepts not yet supported!
    }
}

function emitITestSome(it: CPPAssembly::ITestSome, baseType: CPPAssembly::TypeSignature, rootExp: CString, ctx: Context): CString {
    return if(it.isnot) then CString::concat(rootExp, '.typeinfo == &NoneType') else CString::concat(rootExp, '.typeinfo != &NoneType');
}

function emitITestAsTest(it: CPPAssembly::ITest, baseType: CPPAssembly::TypeSignature, rootExp: CString, ctx: Context): CString {
    match(it)@ {
        CPPAssembly::ITestType => { return emitITestType($it, baseType, ctx); }
        | CPPAssembly::ITestSome => { return emitITestSome($it, baseType, rootExp, ctx); }
        | _ => { abort; } %% TODO: Not Implemented!
    }
}

function emitPostfixOp(pop: CPPAssembly::PostfixOp, ctx: Context): CString {
    let rootExp = emitExpression(pop.rootExp, ctx);
    let ops = pop.ops.mapIdx<CString>(fn(op, ii) => {
        match(op)@ {
            CPPAssembly::PostfixAccessFromName => {
                if (ii == 0n) {
                    return CString::concat(rootExp, emitPostfixAccessFromName($op, ctx));
                }
                return emitPostfixAccessFromName($op, ctx);
            }
            | CPPAssembly::PostfixInvokeStatic => { return emitPostfixInvokeStatic($op, rootExp, ctx); }
            | CPPAssembly::PostfixIsTest => { return emitITestAsTest($op.ttest, $op.baseType, rootExp, ctx); }
        }
    });

    return CString::joinAll('', ops);
}

function emitConstructorPrimarySpecialSomeExpression(cpsse: CPPAssembly::ConstructorPrimarySpecialSomeExpression, ctx: Context): CString {
    var data: CString;
    if(ctx.asm.typeinfos.get(cpsse.ofttype.tkeystr).slotsize == 1n) {
        let arg = emitExpression(cpsse.args.args.get(0n)@some.exp, ctx);
        data = CString::concat('(', arg, ').get()');
    }
    else {
        let args = cpsse.args.args.reduce<CString>('', fn(acc, arg) => { %% arg is just foos constructor here
            let val = emitExpression(arg@some.exp, ctx);
            return CString::concat(acc, '(', val, ').get()');
        });
        data = CString::concat('(uint64_t[]){ ', args,' } ');
    }

    let sometype = CString::concat('Core::', emitTypeKey(cpsse.ctype.tkeystr, false, ctx));
    let ttypeName = CString::concat('&', sometype, 'Type, ');
    return CString::concat('{ ', ttypeName, data ,'}');
}

function emitConstructorPrimarySpecialOkExpression(cpsoe: CPPAssembly::ConstructorPrimarySpecialOkExpression, ctx: Context): CString {
    abort; %% TODO: Not implemented!
}

function emitConstructorPrimarySpecialFailExpression(cpsfe: CPPAssembly::ConstructorPrimarySpecialFailExpression, ctx: Context): CString {
    abort; %% TODO: Not Implemented!
}

function emitConstructorPrimarySpecialConstructableExpression(exp: CPPAssembly::ConstructorPrimarySpecialConstructableExpression, ctx: Context): CString {    
    match(exp)@ {
        CPPAssembly::ConstructorPrimarySpecialSomeExpression => { return emitConstructorPrimarySpecialSomeExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialOkExpression => { return emitConstructorPrimarySpecialOkExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialFailExpression => { return emitConstructorPrimarySpecialFailExpression($exp, ctx); }
    }
}

%%
%% TODO: Once the GC is integrated we will need to call our special GC allocate on ref type objects instead of the default
%% constructor like we do now. Currently they call 'new'
%%
function emitConstructorStdExpression(exp: CPPAssembly::ConstructorStdExpression, ctx: Context): CString {
    %% Eventually might want to rework emitArgumentList to support constructors too 
    let emitargs =  CString::joinAll(', ', exp.args.args.mapIdx<CString>(fn(av, ii) => {
        if(av)@none {
            let e = ctx.asm.entities.tryGet(exp.ctype.tkeystr)@some;
            let member_defval = e.fields.get(ii).defaultval;
            if(member_defval)@none {
                abort; %% Default value detected in transform, yet none provided for emission
            }
            else {
                return emitExpression[recursive]($member_defval, ctx);
            }
        }
        else {
            let arg = $av;
            let argexp = emitExpression[recursive](arg.exp, ctx);
            match(arg)@ {
                CPPAssembly::NamedArgumentValue => { return argexp; } 
                | CPPAssembly::PositionalArgumentValue => { return argexp; }
                | _ => { abort; }
            }
        }
    }));

    let resolved_type = emitResolvedNamespace(ctx.fullns_list, exp.ctype.tkeystr.value);
    let specialName = emitSpecialTemplate(resolved_type);

    if(ctx.asm.typeinfos.get(exp.ctype.tkeystr).tag === CPPAssembly::Tag#Ref) {
        return CString::concat('new ', specialName, '{ ', emitargs, ' }'); %% We use new solely to keep the code compiling before GC integration
    }
    return CString::concat(specialName, '{ ', emitargs, ' }'); 
}

function emitIfExpression(exp: CPPAssembly::IfExpression, ctx: Context): CString {
    let texp = emitExpression(exp.texp, ctx);
    let thenexp = emitExpression(exp.thenexp, ctx);
    let elseexp = emitExpression(exp.elseexp, ctx);

    match(exp) {
        CPPAssembly::IfSimpleExpression => { return CString::concat(texp, ' ? ', thenexp, ' : ', elseexp); }
        | _ => { abort; } %% TODO: Not Implemented
    }
}

function emitWidenedTypeExpression(exp: CPPAssembly::CoerceWidenTypeExpression, ctx: Context): CString {
    let fromtkey = exp.srctype.tkeystr;
    let totkey = exp.trgttype.tkeystr;
    let emitexp = emitExpression(exp.exp, ctx);

    let fromtkey_size = ctx.asm.typeinfos.tryGet(fromtkey)@some.slotsize.toCString(); %% This is T
    let name = CString::concat('Core::', emitTypeKey(totkey, false, ctx));
    if(exp.exp?<CPPAssembly::LiteralNoneExpression>) {
        let ttype = CString::concat(emitTypeKey(exp.srctype.tkeystr, false, ctx));

        let ttypeName = CString::concat('&', removeCppPrefix(ttype), 'Type ');
        return CString::concat(name, '{ ', ttypeName ,'}');
    }

    return CString::concat(name, emitexp);
}

%% We will need this to help us take 'this.f?<Int>' to 'false'
function emitNarrowedTypeExpression(exp: CPPAssembly::CoerceNarrowTypeExpression, ctx: Context): CString {
    return emitExpression(exp.exp, ctx);
}

function emitExpression(e: CPPAssembly::Expression, ctx: Context): CString {
    match(e)@ {
        CPPAssembly::BinaryArithExpression => { return emitBinaryArithExpression[recursive]($e, ctx); }
        | CPPAssembly::BinaryNumericExpression => { return emitBinaryNumericExpression[recursive]($e, ctx); }
        | CPPAssembly::UnaryExpression => { return emitUnaryExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicExpression => { return emitBinLogicExpression[recursive]($e, ctx); }
        | CPPAssembly::LogicActionAndExpression => { return emitLogicActionAndExpression[recursive]($e, ctx); }
        | CPPAssembly::LogicActionOrExpression => { return emitLogicActionOrExpression[recursive]($e, ctx); }
        | CPPAssembly::LiteralNoneExpression => { return emitLiteralNoneExpression($e, ctx); }
        | CPPAssembly::LiteralSimpleExpression => { return emitLiteralSimpleExpression($e); }
        | CPPAssembly::AccessVariableExpression => { return emitAccessVariableExpression($e); }
        | CPPAssembly::CallNamespaceFunctionExpression => { return emitCallNamespaceFunctionExpression($e, ctx); }
        | CPPAssembly::CallTypeFunctionExpression => { return emitCallTypeFunctionExpression($e, ctx); }
        | CPPAssembly::PostfixOp => { return emitPostfixOp($e, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialConstructableExpression => { return emitConstructorPrimarySpecialConstructableExpression($e, ctx); }
        | CPPAssembly::ConstructorStdExpression => { return emitConstructorStdExpression($e, ctx); }
        | CPPAssembly::IfExpression => { return emitIfExpression($e, ctx); }
        | CPPAssembly::CoerceWidenTypeExpression => { return emitWidenedTypeExpression($e, ctx); }
        | CPPAssembly::CoerceNarrowTypeExpression => { return emitNarrowedTypeExpression($e, ctx); }
        | _ => { abort; }
    }
}

function emitVariableInitializationStatement(stmt: CPPAssembly::VariableInitializationStatement, ctx: Context, indent: CString): CString {
    let name = emitIdentifier(stmt.name);
    let stype = emitTypeKey(stmt.vtype.tkeystr, false, ctx);
    let resolved_stype = if(stype.startsWithString('Option')) then CString::concat('Core::', stype) else stype;
    let exp = emitExpression(stmt.exp, ctx);

    let full_indent: CString = CString::concat(indent, '    ', resolved_stype);
    return CString::concat(full_indent, ' ', name, ' = ', exp, ';');
}

function emitBlockStatement(block: CPPAssembly::BlockStatement, ctx: Context, indent: CString): CString {
    let stmts = block.statements.map<CString>(fn(stmt) => emitStatement(stmt, ctx, indent));
    return CString::joinAll('%n;', stmts);
}

function emitIfSimpleStatement(stmt: CPPAssembly::IfSimpleStatement, ctx: Context, indent: CString): CString {
    let expr = emitExpression(stmt.cond, ctx);
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);

    let ifstmt = CString::concat(indent, 'if( ', expr, ' ) {%n;');
    return CString::concat(ifstmt, trueBlock, indent, '}');
}

function emitIfTestStatement(stmt: CPPAssembly::IfTestStatement, ctx: Context, indent: CString): CString {
    let expr = emitExpression(stmt.cond, ctx);
    let itest = emitITestAsTest(stmt.itest, stmt.cond.etype, expr, ctx);
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);

    let ifstmt = CString::concat(indent, 'if( ', itest, ' ) {%n;');
    return CString::concat(ifstmt, trueBlock, indent, '}');
}

function emitIfBinderStatement(stmt: CPPAssembly::IfStatement, ctx: Context, indent: CString): CString {
    abort; %% TODO: Not Implemented!    
}

function emitIfStatement(stmt: CPPAssembly::IfStatement, ctx: Context, indent: CString): CString {
    let full_indent = CString::concat('    ', indent); 

    match(stmt)@ { 
        CPPAssembly::IfSimpleStatement => { return emitIfSimpleStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfTestStatement => { return emitIfTestStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfBinderStatement => { return emitIfBinderStatement($stmt, ctx, full_indent); }
    }
}

function emitIfElseSimpleStatement(stmt: CPPAssembly::IfElseSimpleStatement, ctx: Context, indent: CString): CString {
    let expr = emitExpression(stmt.cond, ctx);
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);
    let falseBlock = emitBlockStatement(stmt.falseBlock, ctx, indent);
    let elseBlockText = CString::concat(indent, 'else {%n;', falseBlock, indent, '}%n;');
    
    let ifstmt = CString::concat(indent, 'if( ', expr, ' ) {%n;'); 
    return CString::concat(ifstmt, trueBlock, indent, '}%n;', elseBlockText);
}

function emitIfElseTestStatement(stmt: CPPAssembly::IfElseTestStatement, ctx: Context, indent: CString): CString {
    let expr = emitExpression(stmt.cond, ctx);
    let itest = emitITestAsTest(stmt.itest, stmt.cond.etype, expr, ctx);
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);
    let falseBlock = emitBlockStatement(stmt.falseBlock, ctx, indent);
    let elseBlockText = CString::concat(indent, 'else {%n;', falseBlock, indent, '}%n;');
    
    let ifstmt = CString::concat(indent, 'if( ', itest, ' ) {%n;'); 
    return CString::concat(ifstmt, trueBlock, indent, '}%n;', elseBlockText);
}

function emitIfElseBinderStatement(stmt: CPPAssembly::IfElseBinderStatement, ctx: Context, ident: CString): CString {
    abort; %% TODO: Not Implemented!
}

function emitIfElseStatement(stmt: CPPAssembly::IfElseStatement, ctx: Context, indent: CString): CString {
    let full_indent = CString::concat('    ', indent); 
    
    match(stmt)@ {
        CPPAssembly::IfElseSimpleStatement => { return emitIfElseSimpleStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfElseTestStatement => { return emitIfElseTestStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfElseBinderStatement => { return emitIfElseBinderStatement($stmt, ctx, full_indent); }
    }
}

function emitIfElifElseStatement(stmt: CPPAssembly::IfElifElseStatement, ctx: Context, indent: CString): CString {
    let full_indent = CString::concat('    ', indent); 
    let ifcond = CString::concat(full_indent, 'if(', emitExpression(stmt.ifcond, ctx), ') {%n;');
    let ifbody = CString::concat(emitBlockStatement(stmt.ifflow, ctx, full_indent), full_indent, '}%n;');
    let ifblock = CString::concat(ifcond, ifbody);
    let elseblock = CString::concat(full_indent, 'else {%n;', emitBlockStatement(stmt.elseflow, ctx, full_indent), full_indent, '}%n;');

    let elifs_list = stmt.condflow.map<CString>(fn(elifs) => {
        let cond = emitExpression(elifs.0, ctx);
        let body = emitBlockStatement(elifs.1, ctx, full_indent);

        let elif_stmt = CString::concat(full_indent, 'else if(', cond, ') {%n;');
        return CString::concat(elif_stmt, body, full_indent, '}%n;');
    });
    let elifs = CString::joinAll('', elifs_list);

    return CString::concat(ifcond, ifbody, elifs, elseblock);
}

function emitStatement(stmt: CPPAssembly::Statement, ctx: Context, indent: CString): CString {
    match(stmt)@ {
        CPPAssembly::VariableInitializationStatement => { return emitVariableInitializationStatement($stmt, ctx, indent); }
        | CPPAssembly::ReturnSingleStatement => { return emitReturnSingleStatement($stmt, ctx, indent); }
        | CPPAssembly::IfStatement => { return emitIfStatement($stmt, ctx, indent); }
        | CPPAssembly::IfElseStatement => { return emitIfElseStatement($stmt, ctx, indent); }
        | CPPAssembly::IfElifElseStatement => { return emitIfElifElseStatement($stmt, ctx, indent); }
        | _ => { abort; }
    }
}

function emitBuiltinBodyImplementation(body: CPPAssembly::BuiltinBodyImplementation, ctx: Context, indent: CString): CString {
    switch(body.builtin) {
        's_float_power' => { return CString::concat(indent, '    ', 'return __CoreCpp::Float(powf64(a.get(), b.get()));%n;'); }
        | 's_float_sqrt' => { return CString::concat(indent, '    ', 'return __CoreCpp::Float(sqrtf64(a.get()));%n;'); }
        | _ => { abort; } %% TODO: Not implemented
    }
}

function emitStandardBodyImplementation(body: CPPAssembly::StandardBodyImplementation, ctx: Context, indent: CString): CString {
    return CString::joinAll('%n;', body.statements.map<CString>(fn(stmt) => emitStatement(stmt, ctx, indent)));
}

function emitBodyImplementation(body: CPPAssembly::BodyImplementation, ctx: Context, indent: CString): CString {
    match(body)@ {
        %% CPPAssembly::AbstractBodyImplementation => { abort; }
        %% | CPPAssembly::PredicateUFBodyImplementation => { abort; }
        CPPAssembly::BuiltinBodyImplementation => { return emitBuiltinBodyImplementation($body, ctx, indent); }
        %% | CPPAssembly::SynthesisBodyImplementation => { abort; }
        %% | CPPAssembly::ExpressionBodyImplementation => { abort; }
        | CPPAssembly::StandardBodyImplementation => { return emitStandardBodyImplementation($body, ctx, indent); }
        | _ => { abort; }
    }
}

function emitParameters(params: List<CPPAssembly::ParameterDecl>, ctx: Context): CString {
    let all_params = params.map<CString>(fn(param) => {
        let ptype = emitTypeKey(param.ptype.tkeystr, true, ctx);
        let pident = emitIdentifier(param.pname);

        return CString::concat(ptype, ' ', pident);
    });

    return CString::joinAll(', ', all_params);
}

%% Determine whether to emit this param as const this* or this
function emitThisType(tk: CPPAssembly::TypeKey, ctx: Context): CString {
    let resolved_type = emitTypeKey(tk, false, ctx);

    if(ctx.asm.typeinfos.get(tk).tag === CPPAssembly::Tag#Ref) {
        return CString::concat('const ', resolved_type, '*');
    }
    return resolved_type;
}

function emitMethodDecl(m: CPPAssembly::MethodDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: CString): CString {
    let nctx = ctx.updateCurrentNamespace(m.declaredInNS, m.fullns);

    let name = m.ikey.value.removePrefixString(declaredIn.value).removePrefixString('::');
    let params = emitParameters(m.params, nctx);
    let rtype = emitTypeKey(m.resultType.tkeystr, false, ctx);
    let this_type = emitThisType(declaredIn, nctx);    
    let specialName = emitSpecialTemplate(name);
    
    let pre = if(rtype !== 'bool') then CString::concat(indent, 'const ', rtype, ' ', specialName)
        else CString::concat(indent, rtype, ' ', specialName);
    let specialThis = emitSpecialTemplate(this_type);

    var params_impl: CString;
    if(params === '') {
        params_impl = CString::concat('(', specialThis, ' ', emitSpecialThis(), ') noexcept');
    }
    else {
        let base = CString::concat('(', specialThis, ' ');
        params_impl = CString::concat(base, emitSpecialThis(), ', ', params, ') noexcept');           
    }

    return CString::concat(pre, params_impl, ' {%n;', emitBodyImplementation(m.body, nctx, indent), indent, '}%n;');
}

%% Type funcs are fully resolved before cpp emission so we can group them with nsfuncs
function emitFunctionDecl(func: CPPAssembly::AbstractInvokeDecl, ctx: Context, indent: CString): CString {
    let isTypeFunc = ctx.asm.typefuncs.has(func.ikey);
    let ikey = if(isTypeFunc) then ctx.asm.typefuncs.get(func.ikey).completeikey else func.ikey;   
    let ns = if(isTypeFunc) then ctx.asm.typefuncs.get(func.ikey).completens else func.fullns;
    let nctx = ctx.updateCurrentNamespace(func.declaredInNS, ns);

    let name = emitInvokeKey(ikey, nctx);
    let params = emitParameters(func.params, nctx);
    let rtype = emitTypeKey(func.resultType.tkeystr, false, ctx); 

    let pre: CString = CString::concat(indent, rtype, ' ', name );
    let params_impl: CString = CString::concat('(', params, ') noexcept ');

    return CString::concat(pre, params_impl, ' {%n;', emitBodyImplementation(func.body, ctx, indent), indent, '}%n;');
}

%*
function emitMemberFieldDecl(member: CPPAssembly::MemberFieldDecl, ctx: Context, indent: CString): CString {
    let name = emitIdentifier(member.name);
    let mtype = emitTypeKey(member.declaredType, ctx);
    return CString::concat(indent, mtype, ' ', name, ';%n;');
}
*%

function emitSaturatedFieldInfo(sfi: CPPAssembly::SaturatedFieldInfo, ctx: Context, indent: CString): CString {
    let ftype = emitTypeKey(sfi.ftype.tkeystr, true, ctx);
    let fname = emitIdentifier(sfi.fname);
    return CString::concat(indent, ftype, ' ', fname, ';%n;');
}

function emitEntityTypeDecl(e: CPPAssembly::EntityTypeDecl, tk: CPPAssembly::TypeKey, ctx: Context, indent: CString): CString {
    let nctx = ctx.updateCurrentNamespace(e.declaredInNS, e.fullns);
    let tkey = emitTypeKey(tk, false, nctx);

    let entries = e.saturatedBFieldInfo.reduce<CString>(CString::concat(indent, 'struct ', tkey, ' { %n;'), 
        fn(acc, entry) => {
            return CString::concat(acc, emitSaturatedFieldInfo(entry, nctx, CString::concat('    ', indent)));
    });

    return CString::concat(entries, indent, '};%n;');
}

function emitDatatypeMemberEntityDecl(dm: CPPAssembly::DatatypeMemberEntityTypeDecl, ctx: Context, indent: CString): CString {
    let nctx = ctx.updateCurrentNamespace(dm.declaredInNS, dm.fullns);
    let tkey = emitTypeKey(dm.tkey, false, nctx); 

    let fields = dm.saturatedBFieldInfo.reduce<CString>(CString::concat(indent, 'struct ', tkey, '{ %n;'), 
        fn(acc, entry) => {
            return CString::concat(acc, emitSaturatedFieldInfo(entry, nctx, CString::concat('    ', indent)));
    });

    return CString::concat(fields, indent, '};%n;');
}

function emitAbstractNominalForwardDeclaration(e: CPPAssembly::AbstractNominalTypeDecl, ctx: Context, indent: CString): CString {
    let nctx = ctx.updateCurrentNamespace(e.declaredInNS, e.fullns);
    let tkey = emitTypeKey(e.tkey, false, nctx);

    return CString::concat(indent, 'struct ', tkey, ';%n;');
}

function emitMethodForwardDeclaration(m: CPPAssembly::MethodDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: CString): CString {
    let nctx = ctx.updateCurrentNamespace(m.declaredInNS, m.fullns);

    if(m)@<CPPAssembly::MethodDeclStatic> {
        let pre = m.ikey.value.removePrefixString(declaredIn.value).removePrefixString('::');
        let rtype = emitTypeKey(m.resultType.tkeystr, false, nctx);
        let this_type = emitThisType(declaredIn, nctx);
        let params = emitParameters(m.params, nctx);

        let specialName = emitSpecialTemplate(pre);

        let first = if(rtype !== 'bool') then CString::concat(indent, 'const ', rtype, ' ', specialName, '(')
            else CString::concat(indent, rtype, ' ', specialName, '(');

        if(params === '') {
            return CString::concat(first, this_type, ' ', emitSpecialThis(), params, ') noexcept;%n;');
        }
        else {
            let base = CString::concat(first, this_type, ' ');
            return CString::concat(base, emitSpecialThis(), ', ', params, ') noexcept;%n;');           
        }
    }
    abort; %% TODO: Support other method types!
}

function emitFunctionForwardDeclaration(decl: CPPAssembly::AbstractInvokeDecl, ctx: Context, ident: CString): CString {
    let isTypeFunc = ctx.asm.typefuncs.has(decl.ikey);
    let ikey = if(isTypeFunc) then ctx.asm.typefuncs.get(decl.ikey).completeikey else decl.ikey;   
    let ns = if(isTypeFunc) then ctx.asm.typefuncs.get(decl.ikey).completens else decl.fullns;
    let nctx = ctx.updateCurrentNamespace(decl.declaredInNS, ns);

    let pre = emitInvokeKey(ikey, nctx);
    let rtype = emitTypeKey(decl.resultType.tkeystr, false, nctx); 
    let params = emitParameters(decl.params, nctx);
    let specialName = emitSpecialTemplate(pre);

    let first = CString::concat(ident, rtype, ' ', specialName );
    return CString::concat(first, '(', params, ') noexcept;%n;');
}

%%
%% TODO: Need to add lookup methods for these vtables and give this some thought. A lot of this code is repetitive or could be
%% cleaned up pretty signifigantly. We currently emit a vtable entry for all fields, not just those who are derived. (this may need changed)
%%

function generateVTableEntry(entry: CPPAssembly::MemberFieldDecl, resolved_name: CString, enum_name: CString, idx: Nat, ctx: Context, indent: CString): CString {
    let tinfo = ctx.asm.typeinfos.tryGet(entry.declaredType.tkeystr)@some;

    let id = tinfo.id.toCString();
    let entrytype = CString::concat(enum_name, '::', resolved_name, '_', emitIdentifier(entry.name));
    let byteoffset = (idx * 8n).toCString(); %% Woudlnt be a bad idea to make these 8 byte alignment a const

    let base = CString::concat('{ ', id, ', ', entrytype, ', ', byteoffset);
    return CString::concat(indent, base, ' }');
}

function generateVTable(ant: CPPAssembly::AbstractNominalTypeDecl, fields: List<CPPAssembly::MemberFieldDecl>, ctx: Context, indent: CString): CString {
    let nctx = ctx.updateCurrentNamespace(ant.declaredInNS, ant.fullns);
    let full_indent = CString::concat('    ', indent);
    
    let name = emitTypeKey(ant.tkey, false, nctx);
    let enum_name = CString::concat(name, '_entries');
    let vtable_name = CString::concat(name, '_vtable');

    let base = CString::concat('const __CoreCpp::FieldOffsetInfo ', vtable_name, '[] = ', '{%n;');
    let field_names = fields.mapIdx<CString>(fn(f_entry, ii) => generateVTableEntry(f_entry, name, enum_name, ii, ctx, full_indent));
    return CString::concat(indent, base, CString::joinAll(',%n;', field_names), '%n;', indent, '};%n;'); 
}

%% Might need to be a bit careful with the naming here, perhaps some funny unicode magic again
function generateEntriesEnum(ant: CPPAssembly::AbstractNominalTypeDecl, fields: List<CPPAssembly::MemberFieldDecl>, ctx: Context, indent: CString): CString {
    let nctx = ctx.updateCurrentNamespace(ant.declaredInNS, ant.fullns);
    let full_indent = CString::concat('    ', indent);
    
    let name = emitTypeKey(ant.tkey, false, nctx);
    let enum_name = CString::concat(name, '_entries');

    let base = CString::concat('enum ', enum_name, ' {%n;');
    let field_names = fields.map<CString>(fn(f_entry) => CString::concat(full_indent, name, '_', emitIdentifier(f_entry.name)));
    return CString::concat(indent, base, CString::joinAll(',%n;', field_names), '%n;', indent, '};%n;');
}

function emitTypeInfo(info: CPPAssembly::TypeInfo, ant: Option<CPPAssembly::AbstractNominalTypeDecl>, hasfields: Bool, ctx: Context, indent: CString): CString {
    let nctx = if(ant)@some then ctx.updateCurrentNamespace($ant.declaredInNS, $ant.fullns) else ctx;
    let full_indent = CString::concat('    ', indent);

    let name = removeCppPrefix(emitTypeKey(info.typekey, false, nctx));

    let tinfo_name = CString::concat(name, 'Type');

    let base = CString::concat(indent, '__CoreCpp::TypeInfoBase ', tinfo_name, ' = {%n;');
    let id = CString::concat(base, full_indent, '.type_id = ', info.id.toCString(), ',%n;');
    let typesize = CString::concat(id, full_indent, '.type_size = ', info.typesize.toCString(), ', %n;');
    let slotsize = CString::concat(typesize, full_indent, '.slot_size = ', info.slotsize.toCString(), ',%n;');
    let ptrmask = CString::concat(slotsize, full_indent, '.ptr_mask = "', info.ptrmask, '",%n;');
    let typekey = CString::concat(ptrmask, full_indent, '.typekey = "', info.typekey.value, '",%n;');
    let vtable = if(hasfields) then CString::concat(typekey, full_indent, '.vtable = ', CString::concat(name, '_vtable'), '%n;')
        else CString::concat(typekey, full_indent, '.vtable = nullptr%n;');

    return CString::concat(vtable, indent, '};%n;');
}

function emitAbstractNominalTypeDecl(ant: CPPAssembly::AbstractNominalTypeDecl, fields: List<CPPAssembly::MemberFieldDecl>, body: CString, ctx: Context, indent: CString): CString {
    let ant_enum = generateEntriesEnum(ant, fields, ctx, indent);
    let vtable = generateVTable(ant, fields, ctx, indent);
    let tinfo = emitTypeInfo(ctx.asm.typeinfos.tryGet(ant.tkey)@some, some(ant), false, ctx, indent);
    let staticmethods = ant.staticmethods.reduce<CString>('', fn(acc, m) => { 
        return CString::concat(acc, emitMethodDecl(ctx.asm.staticmethods.get(m), ant.tkey, ctx, indent));
    });
    
    return CString::concat(ant_enum, vtable, tinfo, body, staticmethods);
}

function emitPrimtiveConceptTypeDecl(pc: CPPAssembly::PrimitiveConceptTypeDecl, ctx: Context, indent: CString): CString {
    let full_indent = CString::concat('    ', indent);
    let tkey = emitTypeKey(pc.tkey, false, ctx);
    let k = (ctx.asm.typeinfos.get(pc.tkey).slotsize - 1n).toCString(); %% Slot size includes '2' ptr to typeinfo, so we ignore

    let def = CString::concat(indent, 'class ', tkey, ' : public __CoreCpp::Boxed<', k, '>{%n;');
    let visibility = CString::concat(def, indent, 'public:%n;');

    let defaultc = CString::concat(full_indent, tkey, '()=default;%n;');
    let assign = CString::concat(full_indent, tkey, '(const ', tkey, '&)=default;%n;');
    let copy = CString::concat(full_indent, tkey, '& operator=(const ', tkey, '&)=default;%n;%n;');

    let somecons = CString::concat(full_indent, tkey, '(__CoreCpp::TypeInfoBase* ti, uint64_t d): Boxed(ti, d) {};%n;');
    let nonecons = CString::concat(full_indent, tkey, '(__CoreCpp::TypeInfoBase* ti): Boxed(ti) {};%n;');

    let cons = CString::concat(defaultc, assign, copy, somecons, nonecons);
    return CString::concat(visibility, cons, indent, '};%n;');
}

function emitForwardDeclarationBody(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: CString): CString {    
    let entity_fwddecls = nsdecl.entities.reduce<CString>('', fn(acc, tk) => {
        return CString::concat(acc, emitAbstractNominalForwardDeclaration(ctx.asm.entities.get(tk)@<CPPAssembly::AbstractNominalTypeDecl>, ctx, indent));
    });

    let datamember_fwddecls = nsdecl.datamembers.reduce<CString>(entity_fwddecls, fn(acc, tk) => {
        return CString::concat(acc, emitAbstractNominalForwardDeclaration(ctx.asm.datamembers.get(tk)@<CPPAssembly::AbstractNominalTypeDecl>, ctx, indent));
    });

    %% Emit our method and func fwd decls
    let nsfunc_fwddecls = nsdecl.nsfuncs.reduce<CString>(datamember_fwddecls, fn(acc, ikey) => {
        return CString::concat(acc, emitFunctionForwardDeclaration(ctx.asm.nsfuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, indent));
    });

    let typefunc_fwddecls = nsdecl.typefuncs.reduce<CString>(nsfunc_fwddecls, fn(acc, ikey) => {
        return CString::concat(acc, emitFunctionForwardDeclaration(ctx.asm.typefuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, indent));
    });

    %% Eventually will need to modify this to allow other method types
    let method_fwddecls = nsdecl.staticmethods.reduce<CString>(typefunc_fwddecls, fn(acc, mtkey) => {
        return CString::concat(acc, emitMethodForwardDeclaration(ctx.asm.staticmethods.get(mtkey.0), mtkey.1, ctx, indent));
    });

    return method_fwddecls;
}

recursive function emitForwardDeclarations(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: CString): CString {
    %% Emit namespace 
    let ns = CString::concat(indent, 'namespace ', nsdecl.nsname, ' {%n;');
    let full_indent = CString::concat('    ', indent);

    return CString::concat(ns, emitForwardDeclarationBody(nsdecl, ctx, full_indent), indent, '}%n;');
}

recursive function emitNamespaceDecl(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: CString): CString {
    %% Emit namespace 
    let ns = CString::concat(indent, 'namespace ', nsdecl.nsname, ' {%n;');
    let full_indent = CString::concat('    ', indent);

    let constructables_tinfos = nsdecl.constructables.reduce<CString>(ns, fn(acc, tk) => {
        return CString::concat(acc, emitTypeInfo(ctx.asm.typeinfos.get(tk), none, false, ctx, full_indent));
    });

    let pconcepts = nsdecl.pconcepts.reduce<CString>(constructables_tinfos, fn(acc, tk) => {
        let tinfo = emitTypeInfo(ctx.asm.typeinfos.get(tk), none, false, ctx, full_indent);
        return CString::concat(acc, tinfo, emitPrimtiveConceptTypeDecl(ctx.asm.pconcepts.get(tk), ctx, full_indent));
    });

    %% Ensure no conflicts when accessing functions from other ns (might need to recursively explore other deeper ns)
    let subns_fwddecls = nsdecl.subns.reduce<CString>(pconcepts, fn(acc, name, subns) => {
        return CString::concat(acc, emitForwardDeclarations(subns, ctx, full_indent));
    });

    %% Fwd decls for all in current namespace
    let curns_fwddecls = CString::concat(subns_fwddecls, emitForwardDeclarationBody(nsdecl, ctx, full_indent));

    %% Emit sub-namespace declarations
    let subns = nsdecl.subns.reduce<CString>(curns_fwddecls, fn(acc, name, decl) => {
        return CString::concat(acc, emitNamespaceDecl[recursive](decl, ctx, full_indent));
    });

    %% All entities && their typeinfo
    let entities = nsdecl.entities.reduce<CString>(subns, fn(acc, tk) => {
        let e = ctx.asm.entities.get(tk);
        let emit_entity = emitEntityTypeDecl(e, tk, ctx, full_indent);
        return CString::concat(acc, emitAbstractNominalTypeDecl(e@<CPPAssembly::AbstractNominalTypeDecl>, e.fields, emit_entity, ctx, full_indent));
    });

    let datamembers = nsdecl.datamembers.reduce<CString>(entities, fn(acc, tk) => {
        let dm = ctx.asm.datamembers.get(tk);
        let emit_dm = emitDatatypeMemberEntityDecl(dm, ctx, full_indent);
        return CString::concat(acc, emitAbstractNominalTypeDecl(dm@<CPPAssembly::AbstractNominalTypeDecl>, dm.fields, emit_dm, ctx, full_indent));
    });

    %% Emit functions in current namespace
    let nsfuncs = nsdecl.nsfuncs.reduce<CString>(datamembers, fn(acc, ikey) => {
        return CString::concat(acc, emitFunctionDecl(ctx.asm.nsfuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, full_indent)); 
    });

    let typefuncs = nsdecl.typefuncs.reduce<CString>(nsfuncs, fn(acc, ikey) => {
        return CString::concat(acc, emitFunctionDecl(ctx.asm.typefuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, full_indent)); 
    });

    return CString::concat(typefuncs, indent, '}%n;');
}

function emitAssembly(asm: CPPAssembly::Assembly): String {    
    let ctx: Context = Context{ asm, CPPAssembly::NamespaceKey::from('Tmp'), List<CString>{''} }; %% No known namespace yet
    
    let primitive_typeinfos = asm.typeinfos.reduce<CString>('', fn(acc, tk, ti) => {
        return if(asm.isPrimtitiveType(tk)) then CString::concat(acc, emitTypeInfo(ti, none, false, ctx, '')) else acc;
    }); 
    let ns_emission = asm.nsdecls.reduce<CString>(primitive_typeinfos, fn(acc, nsname, nsdecl) => {
        return CString::concat(acc, emitNamespaceDecl[recursive](nsdecl, ctx, ''));
    });

    %% TODO: Other non namespace functions

    %% For CCharBuf and Unicode... will need to emit builtin functions explicitly

    let asstring = String::fromCString(ns_emission);
    let replace_this = String::fromCString(emitSpecialThis());

    let st = getSpecialTemplates();
    let replace_templates = (|String::fromCString(st.0), String::fromCString(st.1), String::fromCString(st.2)|);

    let first = asstring.replaceAllStringOccurrences(replace_templates.0, "ᐸ");
    let second = first.replaceAllStringOccurrences(replace_templates.1, "ᐧ");
    let third = second.replaceAllStringOccurrences(replace_templates.2, "ᐳ");
    let final = third.replaceAllStringOccurrences(replace_this, "tᖺis");

    return String::join("%n;", final, "%n;");
}