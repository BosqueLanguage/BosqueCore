namespace CPPEmitter;

%% CPP Pre-defined backend
namespace PathStack {
    function emitPathStackCreate(): String {
        return "PathStack ps = PathStack::create();";
    }

    function emitPathStackLeft(): String {
        return "ps.left();";
    }

    function emitPathStackRight(): String {
        return "ps.right();";
    }

    function emitPathStackUp(): String {
        return "ps.up();";
    }
}

namespace CCharBuffer {
    %% Emit c++ for buffer creation here
}

namespace UnicodeCharBuffer {
    %% Emit c++ for buffer creation here
}

entity Context {
    field asm: CPPAssembly::Assembly;
    field fullns_key: CPPAssembly::NamespaceKey; %% Main::Foo::Bar::...
    field fullns_list: List<CString>; %% ["Main", "Foo", "Bar", ...]

    method updateCurrentNamespace(new_ns: CPPAssembly::NamespaceKey, new_nsname: List<CString>): Context {
        return Context{ this.asm, new_ns, new_nsname };
    }
}

function emitEnclosedParen(s: CString): String {
    return String::fromCString(CString::concat('"', s, '"'));
}

function emitTypeKeyValue(tk: CPPAssembly::TypeKey): String {
    return String::fromCString(tk.value);
}

function emitInvokeKeyValue(ik: CPPAssembly::InvokeKey): String {
    return String::fromCString(ik.value);
}

function emitIdentifierValue(i: CPPAssembly::Identifier): String {
    return String::fromCString(i.value);
}

function emitVarIdentifierValue(vi: CPPAssembly::VarIdentifier): String {
    return String::fromCString(vi.value);
}

function emitSpecialThis(): String {
    return "ùê≠ùê°ùê¢ùê¨";
}    

function removeCommonPrefix(name: String, prefix: String): String {
    if(!name.startsWithString(prefix)) {
        return "";
    }
    return name.removePrefixString(prefix);
}

function emitSpecialTemplate(name: String): String {
    if(name.startsWithString("__CoreCpp")) {
        return name;
    }
    
    let base = name.replaceAllStringOccurrences(" ", "");
    let first = base.replaceAllStringOccurrences("<", "·ê∏");
    let second = first.replaceAllStringOccurrences(",", "·êß");
    let third = second.replaceAllStringOccurrences(">", "·ê≥");
    let final = third.replaceAllStringOccurrences("::", "·òè");

    return final;
}

%% We dont want __CoreCpp prefix when emitting typeinfo field for primitives
function removeCppPrefix(s: String): String {
    return if(s.startsWithString("__CoreCpp::")) then s.removePrefixString("__CoreCpp::") else s;
}

function convertCStringList(l: List<CString>): List<String> {
    return l.map<String>(fn(e) => String::fromCString(e));
}

function emitResolvedTemplates(tk: Option<CPPAssembly::TypeKey>, ik: Option<CPPAssembly::InvokeKey>, ctx: Context): String {
    if(tk?some && tk@some.value.startsWithString('(|')) { %% Handle elists explicitly
        return emitSpecialTemplate(String::fromCString(tk@some.value));
    }
    
    %% Handle Type Funcs explicitly as their InvokeKey is missing the "Core::" prefix
    let isTypeFunc = if(ik)@some then ctx.asm.typefuncs.has($ik) else false;
    
    var resolvedik: Option<CPPAssembly::InvokeKey>;
    match(ik) {
        Some<CPPAssembly::InvokeKey> => { resolvedik = if(isTypeFunc) 
            then some(ctx.asm.typefuncs.get(ik@some).completeikey) 
            else ik; }
        | None => { resolvedik = ik; }
    }

    var declaredInNS: String;
    match(tk) {
        Some<CPPAssembly::TypeKey> => { declaredInNS = emitNamespaceKey(ctx.asm.lookupNominalTypeDeclaration(tk@some).declaredInNS); }
        | None => { declaredInNS = emitNamespaceKey(ctx.asm.tryLookupInvokeImplDeclaration(ik@some)@some.declaredInNS); }
    }
    
    %% If a typefunc we need to create the namespace key from its completens (as tfunc.declaredInNS is lacking "Core::" prefix)
    var resolvedns: String;
    match(ik) { 
        Some<CPPAssembly::InvokeKey> => { resolvedns = if(isTypeFunc) 
            then String::joinAll("::", convertCStringList(ctx.asm.typefuncs.get(ik@some).completens)) 
            else declaredInNS; }
        | None => { resolvedns = declaredInNS; }
    }

    let ns = String::concat(resolvedns, "::");
    let key = if(tk)@some then emitTypeKeyValue($tk) else emitInvokeKeyValue(resolvedik@some);
    let template = emitSpecialTemplate(removeCommonPrefix(key, ns));
    
    return if(template === "") then emitSpecialTemplate(key) 
        else String::concat(ns, template);
}

function emitTypeSignature(ts: CPPAssembly::TypeSignature, isParamField: Bool, ctx: Context): String {
    if(ts)@<CPPAssembly::EListTypeSignature> {
        let argssizes = $ts.entries.map<String>(fn(e) => {
            let tinfo = ctx.asm.typeinfos.get(e.tkeystr);
            return if(tinfo.tag !== CPPAssembly::Tag#Ref) then String::fromCString(tinfo.slotsize.toCString())
                else "1";
        });
        let argstemplate = String::concat("<", String::joinAll(", ", argssizes), ">");
        let n = String::fromCString($ts.entries.size().toCString());

        return String::concat("__CoreCpp::Tuple", n, argstemplate);
    }
    else {
        return emitTypeKey(ts.tkeystr, isParamField, ctx);
    }
}

function emitTypeKey(tk: CPPAssembly::TypeKey, isParamField: Bool, ctx: Context): String {
    let emit = emitResolvedNamespace(ctx.fullns_list, emitResolvedTemplates(some(tk), none, ctx)); 
    let asnominal = ctx.asm.lookupNominalTypeDeclaration(tk);

    %% explicitly emit core prefix where necessary
    var resolveddef: String;
    if(ctx.fullns_list.get(0n) === 'Core') {
        resolveddef = emit;
    }
    elif(asnominal?<CPPAssembly::OptionTypeDecl> || asnominal?<CPPAssembly::SomeTypeDecl>) {
        resolveddef = String::concat("Core::", emit);
    }
    else {
        resolveddef = emit;
    }

    if(isParamField) {
        let tinfo = ctx.asm.typeinfos.tryGet(tk)@some;

        switch(tinfo.tag) {
            CPPAssembly::Tag#Value => { return resolveddef; }
            | CPPAssembly::Tag#Ref => { return String::concat(resolveddef, "*"); }
            | CPPAssembly::Tag#Tagged => { abort; } %% Not fully confident on how to handle this quite yet
        }
    }
    return resolveddef;
}

function emitIdentifier(i: CPPAssembly::Identifier): String {
    return emitSpecialTemplate(emitIdentifierValue(i));
}

function emitVarIdentifier(vi: CPPAssembly::VarIdentifier): String {
    let vival = emitVarIdentifierValue(vi);
    if(vival === "this") {
        return emitSpecialThis();
    }
    return emitSpecialTemplate(vival);
}

function emitInvokeKey(ik: CPPAssembly::InvokeKey, ctx: Context): String {
    return emitResolvedNamespace(ctx.fullns_list, emitResolvedTemplates(none, some(ik), ctx)); 
}

function emitNamespaceKey(nsk: CPPAssembly::NamespaceKey): String {
    return String::fromCString(nsk.value);
}

%% Given a namespace key (like Main::Foo::Bar), remove all matching prefix strings
function emitResolvedNamespace(fullns_list: List<CString>, fullns: String): String {
    return fullns_list.reduce<String>(fullns, fn(acc, s) => {
        let val = String::fromCString(s);
        if(acc.startsWithString(val)) {
            let nopre = acc.removePrefixString(val);
            if(nopre.startsWithString("::")) {
                return nopre.removePrefixString("::");
            }
            return nopre;
        }
        return acc;
    });
}

function emitLiteralSimpleExpression(exp: CPPAssembly::LiteralSimpleExpression): String {
    let val = String::fromCString(exp.value);
    let etype = String::fromCString(exp.etype.tkeystr.value);
    switch(etype) {
        "__CoreCpp::Int" => { return String::concat(val, "_i"); }
        | "__CoreCpp::BigInt" => { return String::concat(val, "_I"); } 
        | "__CoreCpp::Nat" => { return String::concat(val, "_n"); }
        | "__CoreCpp::BigNat" => { return String::concat(val, "_N"); }
        | "__CoreCpp::Float" => { return String::concat(val, "_f"); }
        | "bool" => { return val; }
        | _ => { abort; }
    }
}

function emitLiteralNoneExpression(exp: CPPAssembly::LiteralNoneExpression, ctx: Context): String {
    return "UINT64_MAX";
}

function emitAccessVariableExpression(exp: CPPAssembly::AccessVariableExpression): String {
    return emitVarIdentifier(exp.vname);
}

function emitReturnSingleStatement(ret: CPPAssembly::ReturnSingleStatement, ctx: Context, indent: String): String {
    let exp = emitExpression(ret.value, ctx);

    let full_indent: String = String::concat(indent, "    ");
    return String::concat(full_indent, "return ", exp, ";%n;");
}

recursive function emitBinAddExpression(add: CPPAssembly::BinAddExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](add.lhs, ctx);
    let rhs = emitExpression[recursive](add.rhs, ctx);

    return String::concat("(", lhs, " + ", rhs, ")");
}

recursive function emitBinSubExpression(sub: CPPAssembly::BinSubExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](sub.lhs, ctx);
    let rhs = emitExpression[recursive](sub.rhs, ctx);

    return String::concat("(", lhs, " - ", rhs, ")");
}

recursive function emitBinDivExpression(div: CPPAssembly::BinDivExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](div.lhs, ctx);
    let rhs = emitExpression[recursive](div.rhs, ctx);

    return String::concat("(", lhs, " / ", rhs, ")");
}

recursive function emitBinMultExpression(mult: CPPAssembly::BinMultExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](mult.lhs, ctx);
    let rhs = emitExpression[recursive](mult.rhs, ctx);

    return String::concat("(", lhs, " * ", rhs, ")");
}

recursive function emitBinaryArithExpression(e: CPPAssembly::BinaryArithExpression, ctx: Context): String {
    match(e)@ {
        CPPAssembly::BinAddExpression => { return emitBinAddExpression[recursive]($e, ctx); }
        | CPPAssembly::BinSubExpression => { return emitBinSubExpression[recursive]($e, ctx); }
        | CPPAssembly::BinDivExpression => { return emitBinDivExpression[recursive]($e, ctx); }
        | CPPAssembly::BinMultExpression => { return emitBinMultExpression[recursive]($e, ctx); }
    }
}

recursive function emitPrefixNotOpExpression(notop: CPPAssembly::PrefixNotOpExpression, ctx: Context): String {
    let expr = emitExpression[recursive](notop.expr, ctx);
    return String::concat("!", expr);
}

recursive function emitPrefixNegateOpExpression(negop: CPPAssembly::PrefixNegateOpExpression, ctx: Context): String {
    let expr = emitExpression[recursive](negop.expr, ctx);
    return String::concat("-", expr);
}

recursive function emitPrefixPlusOpExpression(plusop: CPPAssembly::PrefixPlusOpExpression, ctx: Context): String {
    return emitExpression[recursive](plusop.expr, ctx);
}

recursive function emitUnaryExpression(e: CPPAssembly::UnaryExpression, ctx: Context): String {
    match(e)@ {
        CPPAssembly::PrefixNotOpExpression => { return emitPrefixNotOpExpression[recursive]($e, ctx); }
        | CPPAssembly::PrefixNegateOpExpression => { return emitPrefixNegateOpExpression[recursive]($e, ctx); }
        | CPPAssembly::PrefixPlusOpExpression => { return emitPrefixPlusOpExpression[recursive]($e, ctx); }
    }
}

recursive function emitNumericEqExpression(e: CPPAssembly::NumericEqExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " == ", rhs, ")");   
}

recursive function emitNumericNeqExpression(e: CPPAssembly::NumericNeqExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " != ", rhs, ")");   
}

recursive function emitNumericLessExpression(e: CPPAssembly::NumericLessExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " < ", rhs, ")");   
}

recursive function emitNumericLessEqExpression(e: CPPAssembly::NumericLessEqExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " <= ", rhs, ")");   
}

recursive function emitNumericGreaterExpression(e: CPPAssembly::NumericGreaterExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " > ", rhs, ")");   
}

recursive function emitNumericGreaterEqExpression(e: CPPAssembly::NumericGreaterEqExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " >= ", rhs, ")");   
}

recursive function emitBinaryNumericExpression(e: CPPAssembly::BinaryNumericExpression, ctx: Context): String {
    match(e)@ {
        CPPAssembly::NumericEqExpression => { return emitNumericEqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericNeqExpression => { return emitNumericNeqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericLessExpression => { return emitNumericLessExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericLessEqExpression => { return emitNumericLessEqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericGreaterExpression => { return emitNumericGreaterExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericGreaterEqExpression => { return emitNumericGreaterEqExpression[recursive]($e, ctx); }
    }
}

recursive function emitBinLogicAndExpression(e: CPPAssembly::BinLogicAndExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);   

    return String::concat("(", lhs, " && ", rhs, ")");
}

recursive function emitBinLogicOrExpression(e: CPPAssembly::BinLogicOrExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);   

    return String::concat("(", lhs, " || ", rhs, ")");
}

recursive function emitBinLogicImpliesExpression(e: CPPAssembly::BinLogicImpliesExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);  

    let implies: String = String::concat("!", lhs, " || ", rhs);
    return String::concat("(", implies ,")");
}

recursive function emitBinLogicIFFExpression(e: CPPAssembly::BinLogicIFFExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx); 
    let nlhs: String = String::concat("!", lhs);
    let nrhs: String = String::concat("!", rhs);

    let first: String = String::concat("(", lhs, " && ", rhs, ")");
    let second: String = String::concat("(", nlhs, " && ", nrhs, ")");

    return String::concat("(", first, " || ", second, ")");
}

recursive function emitBinLogicExpression(e: CPPAssembly::BinLogicExpression, ctx: Context): String {
    match(e)@ {
        CPPAssembly::BinLogicAndExpression => { return emitBinLogicAndExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicOrExpression => { return emitBinLogicOrExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicImpliesExpression => { return emitBinLogicImpliesExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicIFFExpression => { return emitBinLogicIFFExpression[recursive]($e, ctx); }
    }
}

recursive function emitLogicActionAndExpression(e: CPPAssembly::LogicActionAndExpression, ctx: Context): String {
    let args = e.args.map<String>(fn(expr) => emitExpression[recursive](expr, ctx));
    return String::concat("(", String::joinAll(" && ", args), ")");
}

recursive function emitLogicActionOrExpression(e: CPPAssembly::LogicActionOrExpression, ctx: Context): String {
    let args = e.args.map<String>(fn(expr) => emitExpression[recursive](expr, ctx));
    return String::concat("(", String::joinAll(" || ", args), ")");
}

function emitArgumentValue(av: CPPAssembly::ArgumentValue, ctx: Context): String {
    let expr = emitExpression[recursive](av.exp, ctx);
    match(av)@ {
        CPPAssembly::NamedArgumentValue => { return expr; } 
        | CPPAssembly::PositionalArgumentValue => { return expr; }
        | _ => { abort; }
    }
}

function emitArgumentList(al: CPPAssembly::ArgumentList, ctx: Context): String {
    let emit_al = al.args.mapIdx<String>(fn(arg, ii) => emitArgumentValue(arg, ctx));
    
    return String::joinAll(", ", emit_al);
}

function emitCallNamespaceFunctionExpression(e: CPPAssembly::CallNamespaceFunctionExpression, ctx: Context): String { 
    let name = emitInvokeKey(e.ikey, ctx);
    let nsfunc = ctx.asm.nsfuncs.get(e.ikey); 
    let args = emitArgumentList(e.args, ctx); 

    return String::concat(name, "(", args, ")");
}

function emitCallTypeFunctionExpression(e: CPPAssembly::CallTypeFunctionExpression, ctx: Context): String { 
    let typefunc = ctx.asm.typefuncs.get(e.ikey);
    let name = emitInvokeKey(typefunc.ikey, ctx);
    let args = emitArgumentList(e.args, ctx); 

    return String::concat(name, "(", args, ")");
}

function emitPostfixAccessFromName(op: CPPAssembly::PostfixAccessFromName, ctx: Context): String {
    let ident = emitIdentifier(op.name);

    let op_tinfo = ctx.asm.typeinfos.get(op.declaredInType.tkeystr);
    switch(op_tinfo.tag) {
        CPPAssembly::Tag#Value => { return String::concat(".", ident); }
        | CPPAssembly::Tag#Ref => { return String::concat("->", ident); }
        | CPPAssembly::Tag#Tagged => { abort; } %% TODO: Need to handle virtual lookups (and add our little vtable to backend that emits)
    }
}

%% For now we assume this is only used for accessing elist fields
function emitPostfixAccessFromIndex(op: CPPAssembly::PostfixAccessFromIndex, acc: String, ctx: Context): String {
    let accesstype = op.baseType@<CPPAssembly::EListTypeSignature>.entries.get(Nat::fromCString(op.idx));
    let accessed = emitTypeSignature(accesstype, true, ctx);
    let idx = String::fromCString(op.idx);

    return String::concat(acc, ".access<", accessed, ", ", idx, ">()");
}

function emitPostfixInvokeStatic(op: CPPAssembly::PostfixInvokeStatic, expr: String, ctx: Context): String {
    %% We don't want to do any resolution of these keys yet
    let ik = String::fromCString(op.resolvedTrgt.value);
    let tk = String::fromCString(op.resolvedType.tkeystr.value);

    let args = emitArgumentList(op.args, ctx);
    
    %% Remove abstract nominal we were in
    var resolvedInvoke = emitSpecialTemplate(ik.removePrefixString(tk).removePrefixString("::"));
    if(args === "") {
        return String::concat(resolvedInvoke, "(", expr, ")");
    }
    else {
         return String::concat(resolvedInvoke, "(", expr, ", ", args, ")");       
    }
}

function emitITestType(it: CPPAssembly::ITestType, baseType: CPPAssembly::TypeSignature, ctx: Context): String {
    %% For now we only support ITests where both types are concrete
    if(ctx.asm.isNominalTypeConcrete(it.ttype.tkeystr) && ctx.asm.isNominalTypeConcrete(baseType.tkeystr)) {
        let areTypesSame = ctx.asm.areTypesSame(it.ttype, baseType);
        return if(it.isnot) then (if(!areTypesSame) then "true" else "false")
            else if(areTypesSame) then "true" else "false";
    }
    else {
        abort; %% TODO: ITests on concepts not yet supported!
    }
}

function emitITestSome(it: CPPAssembly::ITestSome, baseType: CPPAssembly::TypeSignature, ctx: Context): String {
    return if(it.isnot) 
        then ".typeinfo == &NoneType" 
        else ".typeinfo != &NoneType";
}

function emitITestNone(it: CPPAssembly::ITestNone, baseType: CPPAssembly::TypeSignature, ctx: Context): String {
    return if(it.isnot) 
        then ".typeinfo != &NoneType" 
        else ".typeinfo == &NoneType";
}

function emitITestAsTest(it: CPPAssembly::ITest, baseType: CPPAssembly::TypeSignature, ctx: Context): String {
    match(it)@ {
        CPPAssembly::ITestType => { return emitITestType($it, baseType, ctx); }
        | CPPAssembly::ITestNone => { return emitITestNone($it, baseType, ctx); }
        | CPPAssembly::ITestSome => { return emitITestSome($it, baseType, ctx); }
        | CPPAssembly::ITestOk => { abort; }
        | CPPAssembly::ITestFail => { abort; }
    }
}

function emitITestAsConvert(itc: CPPAssembly::PostfixAsConvert, baseType: CPPAssembly::TypeSignature, ctx: Context): String {
    if(ctx.asm.lookupNominalTypeDeclaration(baseType.tkeystr)?<CPPAssembly::OptionTypeDecl>) {
        let tinfo = ctx.asm.typeinfos.get(baseType.tkeystr);
        let accessor = if(tinfo.tag === CPPAssembly::Tag#Ref) then "->" else ".";

        return String::concat(accessor, "some().value");
    }
    else {
        abort; %% Only options are supported for now
    }
}

function emitPostfixOp(pop: CPPAssembly::PostfixOp, ctx: Context): String {
    let rootExp = emitExpression(pop.rootExp, ctx);
    let rootType = emitTypeSignature(pop.rootExp.etype, false, ctx);

    return pop.ops.reduce<String>(rootExp, fn(acc, op) => {
        match(op)@ {
            CPPAssembly::PostfixAccessFromName => { return String::concat(acc, emitPostfixAccessFromName($op, ctx)); }
            | CPPAssembly::PostfixAccessFromIndex => { return emitPostfixAccessFromIndex($op, acc, ctx); }
            | CPPAssembly::PostfixIsTest => { return String::concat(acc, emitITestAsTest($op.ttest, $op.baseType, ctx)); }
            | CPPAssembly::PostfixAsConvert => { return String::concat(acc, emitITestAsConvert($op, $op.baseType, ctx)); }
            | CPPAssembly::PostfixInvokeStatic => { return emitPostfixInvokeStatic($op, rootExp, ctx); } %% This will not chain method calls :(
            | CPPAssembly::PostfixBoolConstant => { return if($op.value === true) then "true" else "false"; }
        }
    });
}

function emitConstructorPrimarySpecialSomeExpression(cpsse: CPPAssembly::ConstructorPrimarySpecialSomeExpression, ctx: Context): String {
    let args = cpsse.args.args.map<String>(fn(arg) => emitExpression(arg.exp, ctx) );
    let sometype = emitTypeSignature(cpsse.ctype, false, ctx);

    return String::concat(sometype, "{ ", String::joinAll(", ", args), "}");
}

function emitConstructorPrimarySpecialOkExpression(cpsoe: CPPAssembly::ConstructorPrimarySpecialOkExpression, ctx: Context): String {
    abort; %% TODO: Not implemented!
}

function emitConstructorPrimarySpecialFailExpression(cpsfe: CPPAssembly::ConstructorPrimarySpecialFailExpression, ctx: Context): String {
    abort; %% TODO: Not Implemented!
}

function emitConstructorPrimarySpecialConstructableExpression(exp: CPPAssembly::ConstructorPrimarySpecialConstructableExpression, ctx: Context): String {    
    match(exp)@ {
        CPPAssembly::ConstructorPrimarySpecialSomeExpression => { return emitConstructorPrimarySpecialSomeExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialOkExpression => { return emitConstructorPrimarySpecialOkExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialFailExpression => { return emitConstructorPrimarySpecialFailExpression($exp, ctx); }
    }
}

%%
%% TODO: Once the GC is integrated we will need to call our special GC allocate on ref type objects instead of the default
%% constructor like we do now. Currently they call "new"
%%
function emitConstructorStdExpression(exp: CPPAssembly::ConstructorStdExpression, ctx: Context): String {
    let emitargs = emitArgumentList(exp.args, ctx); 
    let name = emitTypeSignature(exp.ctype, false, ctx);
    if(ctx.asm.typeinfos.get(exp.ctype.tkeystr).tag === CPPAssembly::Tag#Ref) {
        return String::concat("new ", name, "{ ", emitargs, " }"); %% We use new solely to keep the code compiling before GC integration
    }
    return String::concat(name, "{ ", emitargs, " }"); 
}

function emitConstructorEListExpression(exp: CPPAssembly::ConstructorEListExpression, ctx: Context): String {
    if(exp.args.args.size() > 4n) {
        abort; %% Tuples of size > 4 not supported yet
    }
    let ceetype = emitTypeSignature(exp.etype, false, ctx);
    let args = emitArgumentList(exp.args, ctx);    

    return String::concat(ceetype, "(", args, ")");
}

function emitConstructorPrimaryExpression(exp: CPPAssembly::ConstructorPrimaryExpression, ctx: Context): String {
    match(exp)@ {
        CPPAssembly::ConstructorStdExpression => { return emitConstructorStdExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialConstructableExpression => { return emitConstructorPrimarySpecialConstructableExpression($exp, ctx); }
    }
}

function emitConstructorExpression(exp: CPPAssembly::ConstructorExpression, ctx: Context): String {
    match(exp)@ {
        CPPAssembly::ConstructorPrimaryExpression => { return emitConstructorPrimaryExpression($exp, ctx); }
        | CPPAssembly::ConstructorEListExpression => { return emitConstructorEListExpression($exp, ctx); }
    }
}

function emitIfExpression(exp: CPPAssembly::IfExpression, ctx: Context): String {
    let texp = emitExpression(exp.texp, ctx);
    let thenexp = emitExpression(exp.thenexp, ctx);
    let elseexp = emitExpression(exp.elseexp, ctx);

    match(exp) {
        CPPAssembly::IfSimpleExpression => { return String::concat(texp, " ? ", thenexp, " : ", elseexp); }
        | _ => { abort; } %% TODO: Not Implemented
    }
}

%% We are only widening to options for now
function emitWidenedTypeExpression(exp: CPPAssembly::CoerceWidenTypeExpression, ctx: Context): String {
    let fromtkey = exp.srctype.tkeystr;
    let tottsig = exp.trgttype;
    let emitexp = emitExpression(exp.exp, ctx);

    let fromtkey_size = String::fromCString(ctx.asm.typeinfos.tryGet(fromtkey)@some.slotsize.toCString()); %% This is T
    let name = emitTypeSignature(tottsig, false, ctx);

    let ttype = String::concat(emitTypeSignature(exp.srctype, false, ctx), "Type");

    if(exp.exp?<CPPAssembly::LiteralNoneExpression>) {
        return String::concat(name, "{ &", removeCppPrefix(ttype) ," }");
    }

    return String::concat(name, "{ &", ttype, ", ", emitexp, " }");
}

%% We will need this to help us take "this.f?<Int>" to "false"
function emitNarrowedTypeExpression(exp: CPPAssembly::CoerceNarrowTypeExpression, ctx: Context): String {
    return emitExpression(exp.exp, ctx);
}

function emitSafeConvertExpression(exp: CPPAssembly::SafeConvertExpression, ctx: Context): String {
   return emitExpression(exp.exp, ctx);
}

function emitCreateDirectExpression(exp: CPPAssembly::CreateDirectExpression, ctx: Context): String {
   return emitExpression(exp.exp, ctx); 
}

function emitAccessEnumExpression(exp: CPPAssembly::AccessEnumExpression, ctx: Context): String {
    let enumtype = emitTypeSignature(exp.etype, false, ctx);
    let name = String::fromCString(exp.name);

    return String::concat(enumtype, "::", name);
}

function emitBinKeyEqExpression(exp: CPPAssembly::BinKeyEqExpression, opertype: String, ctx: Context): String {
    let lhs = emitExpression(exp.lhs, ctx);
    let rhs = emitExpression(exp.rhs, ctx);

    return String::concat("(", lhs, " == ", rhs, ")");
}

function emitBinKeyNotEqExpression(exp: CPPAssembly::BinKeyNotEqExpression, opertype: String, ctx: Context): String {
    let lhs = emitExpression(exp.lhs, ctx);
    let rhs = emitExpression(exp.rhs, ctx);

    return String::concat("(", lhs, " != ", rhs, ")");
}

function emitBinaryKeyEqExpression(exp: CPPAssembly::BinaryKeyEqExpression, ctx: Context): String {
    let opertype = emitTypeSignature(exp.opertype, false, ctx);
    match(exp)@ {
        CPPAssembly::BinKeyEqNoneExpression => { abort; }
        | CPPAssembly::BinKeyNotEqNoneExpression => { abort; }
        | CPPAssembly::BinKeySomeEqExpression => { abort; }
        | CPPAssembly::BinKeyEqExpression => { return emitBinKeyEqExpression($exp, opertype, ctx); }
        | CPPAssembly::BinKeyNotEqExpression => { return emitBinKeyNotEqExpression($exp, opertype, ctx); }
    }
}

function emitExpression(e: CPPAssembly::Expression, ctx: Context): String {
    match(e)@ {
        CPPAssembly::LiteralNoneExpression => { return emitLiteralNoneExpression($e, ctx); }
        | CPPAssembly::LiteralSimpleExpression => { return emitLiteralSimpleExpression($e); }
        %%| CPPAssembly::LiteralCCharExpression => { abort; }
        %%| CPPAssembly::LiteralUnicodeCharExpression => { abort; }
        %%| CPPAssembly::LiteralCStringExpression => { abort; }
        %%| CPPAssembly::LiteralStringExpression => { abort; }
        %%| CPPAssembly::LiteralCRegexExpression => { abort; }
        %%| CPPAssembly::LiteralRegexExpression => { abort; }
        %%| CPPAssembly::LiteralTypeDeclValueExpression => { abort; }
        %%| CPPAssembly::AccessNamespaceConstantExpression => { abort; }
        %%| CPPAssembly::AccessStaticFieldExpression => { abort; } 
        | CPPAssembly::AccessEnumExpression => { return emitAccessEnumExpression($e, ctx); }
        | CPPAssembly::AccessVariableExpression => { return emitAccessVariableExpression($e); }
        %%| CPPAssembly::AccessCapturedVariableExpression => { abort; }
        | CPPAssembly::ConstructorExpression => { return emitConstructorExpression($e, ctx); }
        | CPPAssembly::ConstructorPrimaryExpression => { return emitConstructorPrimaryExpression($e, ctx); }
        %%| CPPAssembly::ConstructorPrimaryCollectionSingletonsExpression => { abort; } 
        %%| CPPAssembly::ConstructorTypeDeclExpression => { abort; }
        %%| CPPAssembly::ConstructorTypeDeclStringExpression => { abort; } 
        %%| CPPAssembly::ConstructorLambdaExpression => { abort; }
        %%| CPPAssembly::LetExpression => { abort; }
        %%| CPPAssembly::LambdaInvokeExpression => { abort; } 
        | CPPAssembly::CallNamespaceFunctionExpression => { return emitCallNamespaceFunctionExpression($e, ctx); }
        | CPPAssembly::CallTypeFunctionExpression => { return emitCallTypeFunctionExpression($e, ctx); }      
        %%| CPPAssembly::CallRefInvokeStaticResolveExpression => { abort; }
        %%| CPPAssembly::CallRefInvokeVirtualExpression => { abort; } 
        | CPPAssembly::LogicActionAndExpression => { return emitLogicActionAndExpression[recursive]($e, ctx); }
        | CPPAssembly::LogicActionOrExpression => { return emitLogicActionOrExpression[recursive]($e, ctx); }       
        %%| CPPAssembly::TypeDeclPrimitiveFieldAccessExpression => { abort; }
        | CPPAssembly::CoerceWidenTypeExpression => { return emitWidenedTypeExpression($e, ctx); }
        | CPPAssembly::CoerceNarrowTypeExpression => { return emitNarrowedTypeExpression($e, ctx); }
        | CPPAssembly::SafeConvertExpression => { abort; }
        | CPPAssembly::CreateDirectExpression => { abort; }
        | CPPAssembly::PostfixOp => { return emitPostfixOp($e, ctx); }
        | CPPAssembly::UnaryExpression => { return emitUnaryExpression[recursive]($e, ctx); }
        | CPPAssembly::BinaryArithExpression => { return emitBinaryArithExpression[recursive]($e, ctx); }
        | CPPAssembly::BinaryKeyEqExpression => { return emitBinaryKeyEqExpression($e, ctx); }
        %%| CPPAssembly::BinaryKeyCmpEqualExpression => { abort; }
        %%| CPPAssembly::BinaryKeyCmpLessExpression => { abort; }
        | CPPAssembly::BinaryNumericExpression => { return emitBinaryNumericExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicExpression => { return emitBinLogicExpression[recursive]($e, ctx); }
        %%| CPPAssembly::MapEntryConstructorExpression => { abort; }
        | CPPAssembly::IfExpression => { return emitIfExpression($e, ctx); }
    }
}

function emitVariableInitializationStatement(stmt: CPPAssembly::VariableInitializationStatement, ctx: Context, indent: String): String {
    let name = emitIdentifier(stmt.name);
    let stype = emitTypeSignature(stmt.vtype, false, ctx);
    let exp = emitExpression(stmt.exp, ctx);

    let full_indent: String = String::concat(indent, "    ", stype);
    return String::concat(full_indent, " ", name, " = ", exp, ";");
}

function emitBlockStatement(block: CPPAssembly::BlockStatement, ctx: Context, indent: String): String {
    let stmts = block.statements.map<String>(fn(stmt) => emitStatement(stmt, ctx, indent));
    return String::joinAll("%n;", stmts);
}

function emitIfSimpleStatement(stmt: CPPAssembly::IfSimpleStatement, ctx: Context, indent: String): String {
    let expr = emitExpression(stmt.cond, ctx);
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);

    let ifstmt = String::concat(indent, "if( ", expr, " ) {%n;");
    return String::concat(ifstmt, trueBlock, indent, "}");
}

function emitIfTestStatement(stmt: CPPAssembly::IfTestStatement, ctx: Context, indent: String): String {
    let expr = emitExpression(stmt.cond, ctx);
    let itest = String::concat(expr, emitITestAsTest(stmt.itest, stmt.cond.etype, ctx));
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);

    let ifstmt = String::concat(indent, "if( ", itest, " ) {%n;");
    return String::concat(ifstmt, trueBlock, indent, "}");
}

function emitIfBinderStatement(stmt: CPPAssembly::IfStatement, ctx: Context, indent: String): String {
    abort; %% TODO: Not Implemented!    
}

function emitIfStatement(stmt: CPPAssembly::IfStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 

    match(stmt)@ { 
        CPPAssembly::IfSimpleStatement => { return emitIfSimpleStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfTestStatement => { return emitIfTestStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfBinderStatement => { return emitIfBinderStatement($stmt, ctx, full_indent); }
    }
}

function emitIfElseSimpleStatement(stmt: CPPAssembly::IfElseSimpleStatement, ctx: Context, indent: String): String {
    let expr = emitExpression(stmt.cond, ctx);
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);
    let falseBlock = emitBlockStatement(stmt.falseBlock, ctx, indent);
    let elseBlockText = String::concat(indent, "else {%n;", falseBlock, indent, "}%n;");
    
    let ifstmt = String::concat(indent, "if( ", expr, " ) {%n;"); 
    return String::concat(ifstmt, trueBlock, indent, "}%n;", elseBlockText);
}

function emitIfElseTestStatement(stmt: CPPAssembly::IfElseTestStatement, ctx: Context, indent: String): String {
    let expr = emitExpression(stmt.cond, ctx);
    let itest = String::concat(expr, emitITestAsTest(stmt.itest, stmt.cond.etype, ctx));
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);
    let falseBlock = emitBlockStatement(stmt.falseBlock, ctx, indent);
    let elseBlockText = String::concat(indent, "else {%n;", falseBlock, indent, "}%n;");
    
    let ifstmt = String::concat(indent, "if( ", itest, " ) {%n;"); 
    return String::concat(ifstmt, trueBlock, indent, "}%n;", elseBlockText);
}

function emitIfElseBinderStatement(stmt: CPPAssembly::IfElseBinderStatement, ctx: Context, ident: String): String {
    abort; %% TODO: Not Implemented!
}

function emitIfElseStatement(stmt: CPPAssembly::IfElseStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 
    
    match(stmt)@ {
        CPPAssembly::IfElseSimpleStatement => { return emitIfElseSimpleStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfElseTestStatement => { return emitIfElseTestStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfElseBinderStatement => { return emitIfElseBinderStatement($stmt, ctx, full_indent); }
    }
}

function emitIfElifElseStatement(stmt: CPPAssembly::IfElifElseStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 
    let ifcond = String::concat(full_indent, "if(", emitExpression(stmt.ifcond, ctx), ") {%n;");
    let ifbody = String::concat(emitBlockStatement(stmt.ifflow, ctx, full_indent), full_indent, "}%n;");
    let ifblock = String::concat(ifcond, ifbody);
    let elseblock = String::concat(full_indent, "else {%n;", emitBlockStatement(stmt.elseflow, ctx, full_indent), full_indent, "}%n;");

    let elifs_list = stmt.condflow.map<String>(fn(elifs) => {
        let cond = emitExpression(elifs.0, ctx);
        let body = emitBlockStatement(elifs.1, ctx, full_indent);

        let elif_stmt = String::concat(full_indent, "else if(", cond, ") {%n;");
        return String::concat(elif_stmt, body, full_indent, "}%n;");
    });
    let elifs = String::joinAll("", elifs_list);

    return String::concat(ifcond, ifbody, elifs, elseblock);
}

function emitAssertStatement(stmt: CPPAssembly::AssertStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    let cond = emitExpression(stmt.cond, ctx);

    return String::concat(full_indent, "ùêöùê¨ùê¨ùêûùê´ùê≠(", cond, ");");
} 

function emitStatement(stmt: CPPAssembly::Statement, ctx: Context, indent: String): String {
    match(stmt)@ {
        CPPAssembly::EmptyStatement => { return ""; }
        %%| CPPAssembly::VariableDeclarationStatement => { abort; }
        %%| CPPAssembly::VariableMultiDeclarationStatement => { abort; }
        | CPPAssembly::VariableInitializationStatement => { return emitVariableInitializationStatement($stmt, ctx, indent); }
        %%| CPPAssembly::VariableMultiInitializationExplicitStatement => { abort; }
        %%| CPPAssembly::VariableMultiInitializationImplicitStatement => { abort; }
        %%| CPPAssembly::VariableAssignmentStatement => { abort; }
        %%| CPPAssembly::VariableMultiInitializationExplicitStatement => { abort; }
        %%| CPPAssembly::VariableMultiAssignmentImplicitStatement => { abort; }
        %%| CPPAssembly::VariableRetypeStatement => { abort; }
        %%| CPPAssembly::ReturnVoidStatement => { abort; }
        | CPPAssembly::ReturnSingleStatement => { return emitReturnSingleStatement($stmt, ctx, indent); }
        %%| CPPAssembly::ReturnMultiStatement => { abort; }
        | CPPAssembly::IfStatement => { return emitIfStatement($stmt, ctx, indent); }
        | CPPAssembly::IfElseStatement => { return emitIfElseStatement($stmt, ctx, indent); }
        | CPPAssembly::IfElifElseStatement => { return emitIfElifElseStatement($stmt, ctx, indent); }
        %%| CPPAssembly::SwitchStatement => { abort; }
        %%| CPPAssembly::MatchStatement => { abort; }
        %%| CPPAssembly::AbortStatement => { abort; }
        | CPPAssembly::AssertStatement => { return emitAssertStatement($stmt, ctx, indent); }
        %%| CPPAssembly::ValidateStatement => { abort; }
        %%| CPPAssembly::DebugStatement => { abort; }
        %%| CPPAssembly::VoidRefCallStatement => { abort; }
        %%| CPPAssembly::UpdateDirectStatement => { abort; }
        %%| CPPAssembly::UpdateIndirectStatement => { abort; }
        | CPPAssembly::BlockStatement => { return emitBlockStatement($stmt, ctx, indent); }
     }
}

function emitBuiltinBodyImplementation(body: CPPAssembly::BuiltinBodyImplementation, ctx: Context, indent: String): String {
    switch(String::fromCString(body.builtin)) {
        "s_float_power" => { return String::concat(indent, "    ", "return __CoreCpp::Float(powf64(a.get(), b.get()));%n;"); }
        | "s_float_sqrt" => { return String::concat(indent, "    ", "return __CoreCpp::Float(sqrtf64(a.get()));%n;"); }
        | _ => { abort; } %% TODO: Not implemented
    }
}

function emitStandardBodyImplementation(body: CPPAssembly::StandardBodyImplementation, ctx: Context, indent: String): String {
    return String::joinAll("%n;", body.statements.map<String>(fn(stmt) => emitStatement(stmt, ctx, indent)));
}

function emitBodyImplementation(body: CPPAssembly::BodyImplementation, ctx: Context, indent: String): String {
    match(body)@ {
        %% CPPAssembly::AbstractBodyImplementation => { abort; }
        %% | CPPAssembly::PredicateUFBodyImplementation => { abort; }
        CPPAssembly::BuiltinBodyImplementation => { return emitBuiltinBodyImplementation($body, ctx, indent); }
        %% | CPPAssembly::SynthesisBodyImplementation => { abort; }
        %% | CPPAssembly::ExpressionBodyImplementation => { abort; }
        | CPPAssembly::StandardBodyImplementation => { return emitStandardBodyImplementation($body, ctx, indent); }
        | _ => { abort; }
    }
}

function emitParameters(params: List<CPPAssembly::ParameterDecl>, ctx: Context): String {
    let all_params = params.map<String>(fn(param) => {
        let ptype = emitTypeSignature(param.ptype, true, ctx);
        let pident = emitIdentifier(param.pname);

        return String::concat(ptype, " ", pident);
    });

    return String::joinAll(", ", all_params);
}

%% Determine whether to emit this param as const this* or this
function emitThisType(tk: CPPAssembly::TypeKey, ctx: Context): String {
    let resolved_type = String::concat("[[maybe_unused]] ", emitTypeKey(tk, false, ctx));

    if(ctx.asm.typeinfos.get(tk).tag === CPPAssembly::Tag#Ref) {
        return String::concat("const ", resolved_type, "*");
    }
    return resolved_type;
}

function emitMethodDecl(m: CPPAssembly::MethodDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(m.declaredInNS, m.fullns);
    let full_indent = String::concat("    ", indent);

    let name = m.ikey.value.removePrefixString(declaredIn.value).removePrefixString('::');
    let params = emitParameters(m.params, nctx);
    let rtype = emitTypeSignature(m.resultType, false, ctx);
    let this_type = emitThisType(declaredIn, nctx);    
    let specialName = emitSpecialTemplate(String::fromCString(name));
    
    let pre = if(rtype === "bool") 
        then String::concat(rtype, " ", specialName)
        else String::concat("const ", rtype, " ", specialName);

    var params_impl: String;
    if(params === "") {
        params_impl = String::concat("(", this_type, " ", emitSpecialThis(), ") noexcept");
    }
    else {
        let base = String::concat("(", this_type, " ");
        params_impl = String::concat(base, emitSpecialThis(), ", ", params, ") noexcept");           
    }

    return String::concat(pre, params_impl, " {%n;", emitBodyImplementation(m.body, nctx, indent), indent, "}%n;");
}

function emitMethods(ant: CPPAssembly::AbstractNominalTypeDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let staticmethods = ant.staticmethods
        .reduce<String>(indent, fn(acc, ik) => {
            return String::concat(acc, emitMethodDecl(ctx.asm.staticmethods.get(ik), declaredIn, ctx, indent));
    });

    %%
    %% TODO: Virtual, Abstract, and Override methods
    %%

    return staticmethods;
}

%% Type funcs are fully resolved before cpp emission so we can group them with nsfuncs
function emitFunctionDecl(func: CPPAssembly::AbstractInvokeDecl, ctx: Context, indent: String): String {   
    let isTypeFunc = ctx.asm.typefuncs.has(func.ikey);
    let ikey = func.ikey;   
    let ns = if(isTypeFunc) then ctx.asm.typefuncs.get(func.ikey).completens else func.fullns;
    let nctx = ctx.updateCurrentNamespace(func.declaredInNS, ns);

    let name = emitInvokeKey(ikey, nctx);
    let params = emitParameters(func.params, nctx);
    let rtype = emitTypeSignature(func.resultType, false, ctx); 

    let pre: String = String::concat(rtype, " ", name );
    let params_impl: String = String::concat("(", params, ") noexcept ");

    return String::concat(pre, params_impl, " {%n;", emitBodyImplementation(func.body, nctx, indent), indent, "}%n;");
}

function emitSaturatedFieldInfo(sfi: CPPAssembly::SaturatedFieldInfo, ctx: Context, indent: String): String {
    let ftype = emitTypeSignature(sfi.ftype, true, ctx);
    let fname = emitIdentifier(sfi.fname);
    return String::concat(indent, ftype, " ", fname, ";%n;");
}

function emitEntityTypeDecl(e: CPPAssembly::EntityTypeDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(e.declaredInNS, e.fullns);
    let tkey = emitTypeKey(declaredIn, false, nctx);

    let e_enum = generateEntriesEnum(e@<CPPAssembly::AbstractNominalTypeDecl>, e.fields, ctx, indent);
    let e_vtable = generateVTable(e@<CPPAssembly::AbstractNominalTypeDecl>, e.fields, ctx, indent);
    let e_tinfo = emitTypeInfo(ctx.asm.typeinfos.get(e.tkey), some(e), ctx, indent);
    let e_methods = emitMethods(e@<CPPAssembly::AbstractNominalTypeDecl>, declaredIn, ctx, indent);    

    let base = String::concat(e_enum, e_vtable, e_tinfo);

    let entries = e.saturatedBFieldInfo.reduce<String>(String::concat(base, indent, "struct ", tkey, " { %n;"), 
        fn(acc, entry) => {
            return String::concat(acc, emitSaturatedFieldInfo(entry, nctx, String::concat("    ", indent)));
    });

    return String::concat(entries, indent, "};%n;", e_methods);
}

function emitDatatypeMemberEntityDecl(dm: CPPAssembly::DatatypeMemberEntityTypeDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(dm.declaredInNS, dm.fullns);
    let tkey = emitTypeKey(dm.tkey, false, nctx); 

    let dm_enum = generateEntriesEnum(dm@<CPPAssembly::AbstractNominalTypeDecl>, dm.fields, ctx, indent);
    let dm_vtable = generateVTable(dm@<CPPAssembly::AbstractNominalTypeDecl>, dm.fields, ctx, indent);
    let dm_tinfo = emitTypeInfo(ctx.asm.typeinfos.get(dm.tkey), some(dm), ctx, indent);
    let dm_methods = emitMethods(dm@<CPPAssembly::AbstractNominalTypeDecl>, declaredIn, ctx, indent);

    let base = String::concat(dm_enum, dm_vtable, dm_tinfo);

    let fields = dm.saturatedBFieldInfo.reduce<String>(String::concat(base, indent, "struct ", tkey, "{ %n;"), 
        fn(acc, entry) => {
            return String::concat(acc, emitSaturatedFieldInfo(entry, nctx, String::concat("    ", indent)));
    });

    return String::concat(fields, indent, "};%n;", dm_methods);
}

function emitEnumTypeDecl(etd: CPPAssembly::EnumTypeDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);

    let etd_tinfo = emitTypeInfo(ctx.asm.typeinfos.get(etd.tkey), some(etd), ctx, indent);

    let base = String::concat(indent, "enum class ", String::fromCString(etd.name), " {%n;");
    let entries = etd.members.map<String>(fn(e) => String::concat(full_indent, String::fromCString(e)));
    let wentries = String::concat(base, String::joinAll(",%n;", entries), "%n;", indent, "};%n;");

    return String::concat(etd_tinfo, wentries);
}

function emitAbstractNominalForwardDeclaration(e: CPPAssembly::AbstractNominalTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(e.declaredInNS, e.fullns);
    let tkey = emitTypeKey(e.tkey, false, nctx);

    return String::concat(indent, "struct ", tkey, ";%n;");
}

function emitMethodForwardDeclaration(m: CPPAssembly::MethodDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(m.declaredInNS, m.fullns);

    if(m)@<CPPAssembly::MethodDeclStatic> {
        let pre = m.ikey.value.removePrefixString(declaredIn.value).removePrefixString('::');
        let rtype = emitTypeSignature(m.resultType, false, nctx);
        let this_type = emitThisType(declaredIn, nctx);
        let params = emitParameters(m.params, nctx);

        let specialName = emitSpecialTemplate(String::fromCString(pre));

        let first = if(rtype !== "bool") then String::concat(indent, "const ", rtype, " ", specialName, "(")
            else String::concat(indent, rtype, " ", specialName, "(");

        if(params === "") {
            return String::concat(first, this_type, " ", emitSpecialThis(), params, ") noexcept;%n;");
        }
        else {
            let base = String::concat(first, this_type, " ");
            return String::concat(base, emitSpecialThis(), ", ", params, ") noexcept;%n;");           
        }
    }
    abort; %% TODO: Support other method types!
}

function emitFunctionForwardDeclaration(decl: CPPAssembly::AbstractInvokeDecl, ctx: Context, ident: String): String {
    let isTypeFunc = ctx.asm.typefuncs.has(decl.ikey);
    let ns = if(isTypeFunc) then ctx.asm.typefuncs.get(decl.ikey).completens else decl.fullns;
    let nctx = ctx.updateCurrentNamespace(decl.declaredInNS, ns);

    let ikey = emitInvokeKey(decl.ikey, nctx);
    let rtype = emitTypeSignature(decl.resultType, false, nctx); 
    let params = emitParameters(decl.params, nctx);

    let first = String::concat(ident, rtype, " ", ikey);
    return String::concat(first, "(", params, ") noexcept;%n;");
}

%%
%% TODO: Need to add lookup methods for these vtables and give this some thought. A lot of this code is repetitive or could be
%% cleaned up pretty signifigantly. We currently emit a vtable entry for all fields, not just those who are derived. (this may need changed)
%%

function generateVTableEntry(entry: CPPAssembly::MemberFieldDecl, resolved_name: String, enum_name: String, idx: Nat, ctx: Context, indent: String): String {
    let tinfo = ctx.asm.typeinfos.tryGet(entry.declaredType.tkeystr)@some;

    let id = String::fromCString(tinfo.id.toCString());
    let entrytype = String::concat(enum_name, "::", resolved_name, "_", emitIdentifier(entry.name));
    let byteoffset = String::fromCString((idx * 8n).toCString()); %% Woudlnt be a bad idea to make these 8 byte alignment a const

    let base = String::concat("{ ", id, ", ", entrytype, ", ", byteoffset);
    return String::concat(indent, base, " }");
}

function generateVTable(ant: CPPAssembly::AbstractNominalTypeDecl, fields: List<CPPAssembly::MemberFieldDecl>, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(ant.declaredInNS, ant.fullns);
    let full_indent = String::concat("    ", indent);
    
    let name = emitTypeKey(ant.tkey, false, nctx);
    let enum_name = String::concat(name, "_entries");
    let vtable_name = String::concat(name, "_vtable");

    let base = String::concat("const __CoreCpp::FieldOffsetInfo ", vtable_name, "[] = ", "{%n;");
    let field_names = fields.mapIdx<String>(fn(f_entry, ii) => generateVTableEntry(f_entry, name, enum_name, ii, ctx, full_indent));
    return String::concat(indent, base, String::joinAll(",%n;", field_names), "%n;", indent, "};%n;"); 
}

function generateEntriesEnum(ant: CPPAssembly::AbstractNominalTypeDecl, fields: List<CPPAssembly::MemberFieldDecl>, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(ant.declaredInNS, ant.fullns);
    let full_indent = String::concat("    ", indent);
    
    let name = emitTypeKey(ant.tkey, false, nctx);
    let enum_name = String::concat(name, "_entries");

    let base = String::concat("enum ", enum_name, " {%n;");
    let field_names = fields.map<String>(fn(f_entry) => String::concat(full_indent, name, "_", emitIdentifier(f_entry.name)));
    return String::concat(indent, base, String::joinAll(",%n;", field_names), "%n;", indent, "};%n;");
}

function emitTypeInfo(info: CPPAssembly::TypeInfo, ant: Option<CPPAssembly::AbstractNominalTypeDecl>, ctx: Context, indent: String): String {
    let nctx = if(ant)@some then ctx.updateCurrentNamespace($ant.declaredInNS, $ant.fullns) else ctx;
    let full_indent = String::concat("    ", indent);

    let name = removeCppPrefix(emitTypeKey(info.typekey, false, nctx));
    
    %% For now only entities and datatype entities have fields, thus needing a vtable
    let hasfields = if(ant)@none then false 
        else if($ant?<CPPAssembly::EntityTypeDecl> || $ant?<CPPAssembly::DatatypeMemberEntityTypeDecl>) then true else false;

    let tinfo_name = String::concat(name, "Type");

    let base = String::concat(indent, "__CoreCpp::TypeInfoBase ", tinfo_name, " = {%n;");
    let id = String::concat(base, full_indent, ".type_id = ", String::fromCString(info.id.toCString()), ",%n;");
    let typesize = String::concat(id, full_indent, ".type_size = ", String::fromCString(info.typesize.toCString()), ", %n;");
    let slotsize = String::concat(typesize, full_indent, ".slot_size = ", String::fromCString(info.slotsize.toCString()), ",%n;");
    let ptrmask = String::concat(slotsize, full_indent, ".ptr_mask = ", emitEnclosedParen(info.ptrmask), ",%n;");
    let typekey = String::concat(ptrmask, full_indent, ".typekey = ", emitEnclosedParen(info.typekey.value), ",%n;");
    let vtable = if(hasfields) then String::concat(typekey, full_indent, ".vtable = ", String::concat(name, "_vtable"), "%n;")
        else String::concat(typekey, full_indent, ".vtable = nullptr%n;");

    return String::concat(vtable, indent, "};%n;");
}

function emitAbstractNominalTypeDecl(ant: CPPAssembly::AbstractNominalTypeDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    %% The entries who need a vtable should manually do it
    match(ant)@ {
        CPPAssembly::EntityTypeDecl => { return emitEntityTypeDecl($ant, declaredIn, ctx, indent); }
        | CPPAssembly::DatatypeMemberEntityTypeDecl => { return emitDatatypeMemberEntityDecl($ant, declaredIn, ctx, indent); }
        | CPPAssembly::PrimitiveConceptTypeDecl => { return emitPrimtiveConceptTypeDecl($ant, ctx, indent); }
        | CPPAssembly::ConstructableTypeDecl => { return emitConstructableTypeDecl($ant, ctx, indent); }
        | CPPAssembly::DatatypeTypeDecl => { return ""; } %% Dont emit anything for datatype - the members contain what we care about
        | CPPAssembly::EnumTypeDecl => { return emitEnumTypeDecl($ant, ctx, indent); }
        | _ => { abort; }
    }
}

function emitSomeTypeDecl(std: CPPAssembly::SomeTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(std.declaredInNS, std.fullns);
    
    let full_indent = String::concat("    ", indent);
    let sometype = emitTypeKey(std.tkey, false, nctx);
    let ttype = emitTypeSignature(std.oftype, true, nctx);

    let std_tinfo = emitTypeInfo(nctx.asm.typeinfos.get(std.tkey), some(std), nctx, indent);

    let value = String::concat(sometype, " {%n;", full_indent, ttype, " value;%n;", indent);
    return String::concat(std_tinfo, indent, "struct ", value, "};%n;");
}

function emitMapEntryTypeDecl(mtd: CPPAssembly::MapEntryTypeDecl, ctx: Context, indent: String): String {
    abort; %% TODO: Not Implemented!   
}

function emitConstructableTypeDecl(ctd: CPPAssembly::ConstructableTypeDecl, ctx: Context, indent: String): String {
    match(ctd)@ {
        CPPAssembly::SomeTypeDecl => { return emitSomeTypeDecl($ctd, ctx, indent); }
        | CPPAssembly::MapEntryTypeDecl => { return emitMapEntryTypeDecl($ctd, ctx, indent); }
    }
}

%% Note: Only supports options currently
function emitPrimtiveConceptTypeDecl(pc: CPPAssembly::PrimitiveConceptTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(pc.declaredInNS, pc.fullns);
    
    let full_indent = String::concat("    ", indent);
    let tkey = emitTypeKey(pc.tkey, false, nctx);
    let k = String::fromCString((nctx.asm.typeinfos.get(pc.tkey).slotsize - 1n).toCString()); %% Slot size includes "2" ptr to typeinfo, so we ignore
    let sometkey = emitTypeSignature(pc@<CPPAssembly::OptionTypeDecl>.someType, false, nctx);

    let pc_tinfo = emitTypeInfo(nctx.asm.typeinfos.get(pc.tkey), some(pc), nctx, indent);

    let def = String::concat(indent, "class ", tkey, " : public __CoreCpp::Boxed<", k, ">{%n;");
    let visibility = String::concat(pc_tinfo, def, indent, "public:%n;");

    let defaultc = String::concat(full_indent, tkey, "() noexcept = default;%n;");
    let assign = String::concat(full_indent, tkey, "(const ", tkey, "&) noexcept = default;%n;");
    let copy = String::concat(full_indent, tkey, "& operator=(const ", tkey, "&) noexcept = default;%n;%n;");

    let indenttkey = String::concat(full_indent, tkey);

    let somecons = if(k === "0") then "" 
        else if(k === "1") then String::concat(indenttkey, "(__CoreCpp::TypeInfoBase* ti, ", sometkey," d) noexcept : Boxed(ti, *reinterpret_cast<uintptr_t*>(&d)) {};%n;")
        else String::concat(indenttkey, "(__CoreCpp::TypeInfoBase* ti, ", sometkey ," d) noexcept : Boxed(ti, *reinterpret_cast<uintptr_t(*)[", k,"]>(&d)) {};%n;");
    let nonecons = String::concat(indenttkey, "(__CoreCpp::TypeInfoBase* ti) noexcept : Boxed(ti) {};%n;%n;");

    let someaccessor = String::concat(full_indent, sometkey, " some() noexcept { return *reinterpret_cast<", sometkey,"*>(&this->data); }%n;");

    let cons = String::concat(defaultc, assign, copy, somecons, nonecons);
    return String::concat(visibility, cons, someaccessor, indent, "};%n;");
}

recursive function emitFuncForwardDeclarations(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);

    let subns_fwddecls = nsdecl.subns.reduce<String>("", fn(acc, nsname, subns) => {
        let ns = String::concat(indent, "namespace ", String::fromCString(nsname), " {%n;");
        return String::concat(ns, emitFuncForwardDeclarations[recursive](subns, ctx, full_indent), indent, "}%n;");
    });

    %% Emit our method and func fwd decls
    let nsfunc_fwddecls = nsdecl.nsfuncs.reduce<String>(subns_fwddecls, fn(acc, ikey) => {
        return String::concat(acc, emitFunctionForwardDeclaration(ctx.asm.nsfuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, indent));
    });

    let typefunc_fwddecls = nsdecl.typefuncs.reduce<String>(nsfunc_fwddecls, fn(acc, ikey) => {
        return String::concat(acc, emitFunctionForwardDeclaration(ctx.asm.typefuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, indent));
    });

    %% Eventually will need to modify this to allow other method types
    let method_fwddecls = nsdecl.staticmethods.reduce<String>(typefunc_fwddecls, fn(acc, mtkey) => {
        return String::concat(acc, emitMethodForwardDeclaration(ctx.asm.staticmethods.get(mtkey.0), mtkey.1, ctx, indent));
    });

    return String::concat(method_fwddecls, indent);
}

recursive function emitNamespaceDecl(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    %% Emit namespace 
    let ns = String::concat(indent, "namespace ", String::fromCString(nsdecl.nsname), " {%n;");
    let full_indent = String::concat("    ", indent);

    %% Fwd decls for all funcs in current namespace
    let fwddecls = String::concat(ns, emitFuncForwardDeclarations(nsdecl, ctx, full_indent));

    %% Emit sub-namespace declarations
    let subns = nsdecl.subns.reduce<String>(fwddecls, fn(acc, name, decl) => {
        return String::concat(acc, emitNamespaceDecl[recursive](decl, ctx, full_indent));
    });

    %% Emit functions in current namespace
    let nsfuncs = nsdecl.nsfuncs.reduce<String>(subns , fn(acc, ikey) => {
        return String::concat(acc, emitFunctionDecl(ctx.asm.nsfuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, full_indent)); 
    });

    let typefuncs = nsdecl.typefuncs.reduce<String>(nsfuncs, fn(acc, ikey) => {
        return String::concat(acc, emitFunctionDecl(ctx.asm.typefuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, full_indent)); 
    });

    return String::concat(typefuncs, indent, "}%n;");
}

%%
%% Emits forward decls of Ref and Tagged types
%%
function emitNamespaceDeclFwdDecls(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    let ns = String::concat(indent, "namespace ", String::fromCString(nsdecl.nsname), " {%n;");

    let subns = nsdecl.subns
        .reduce<String>(ns, fn(acc, name, decl) => {
            return String::concat(acc, emitNamespaceDeclFwdDecls[recursive](decl, ctx, full_indent));
    });

    let fwddecls = nsdecl.alltypes
        .filter(pred(tk) => ctx.asm.typeinfos.get(tk).tag !== CPPAssembly::Tag#Value)
        .reduce<String>(subns, fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let fwddecl = emitAbstractNominalForwardDeclaration(ant, ctx, full_indent); 
            return String::concat(acc, fwddecl);
    });

    return String::concat(fwddecls, "}%n;");
}

%%
%% Emits all necessary types given nsdecl (their concrete definitions)
%%
function emitNamespaceDeclTypes(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    let ns = String::concat(indent, "namespace ", String::fromCString(nsdecl.nsname), " {%n;");

    let subns = nsdecl.subns
        .reduce<String>(ns, fn(acc, name, decl) => {
            return String::concat(acc, emitNamespaceDeclTypes[recursive](decl, ctx, full_indent));
    });

    %% Value types
    let values = nsdecl.alltypes
        .filter(pred(tk) => ctx.asm.typeinfos.get(tk).tag === CPPAssembly::Tag#Value)
        .reduce<String>(String::concat(subns, "//%n;// Value Type Definitions%n;//%n;"), fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let def = emitAbstractNominalTypeDecl(ant, tk, ctx, full_indent);
            return String::concat(acc, def);
    });

    %% Ref and Tagged types
    let other = nsdecl.alltypes
        .filter(pred(tk) => ctx.asm.typeinfos.get(tk).tag !== CPPAssembly::Tag#Value)
        .reduce<String>(String::concat(values, "//%n;// Ref and Tagged Type Definitions%n;//%n;"), fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let def = emitAbstractNominalTypeDecl(ant, tk, ctx, full_indent);
            return String::concat(acc, def);
    });

    return String::concat(other, indent, "}%n;");
}

function emitAssembly(asm: CPPAssembly::Assembly): String {    
    let ctx: Context = Context{ asm, CPPAssembly::NamespaceKey::from('Tmp'), List<CString>{''} }; %% No known namespace yet

    let primitive_typeinfos = asm.typeinfos.reduce<String>("//%n;// Primitive Types%n;//%n;", fn(acc, tk, ti) => {
        return if(asm.isPrimtitiveType(tk)) then String::concat(acc, emitTypeInfo(ti, none, ctx, "")) else acc;
    }); 

    %% Non-value type forward decls
    let fwddecls = asm.nsdecls
        .reduce<String>(String::concat(primitive_typeinfos, "//%n;// Ref and Tagged Type Forward Declarations%n;//%n;"),
        fn(acc, nsname, nsdecl) => {
            return String::concat(acc, emitNamespaceDeclFwdDecls(nsdecl, ctx, ""));
    });

    %% Defintion of Value and Non-value types
    let types = asm.nsdecls.reduce<String>(fwddecls, fn(acc, nsname, nsdecl) => {
        return String::concat(acc, emitNamespaceDeclTypes(nsdecl, ctx, ""));
    });

    let ns_emission = asm.nsdecls.reduce<String>(String::concat(types, "//%n;// Emitted Functions%n;//%n;"), fn(acc, nsname, nsdecl) => {
        return String::concat(acc, emitNamespaceDecl[recursive](nsdecl, ctx, ""));
    });

    %% TODO: Other non namespace functions

    %% For CCharBuf and Unicode... will need to emit builtin functions explicitly

    return String::join("%n;", ns_emission, "%n;");
}