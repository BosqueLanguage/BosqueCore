namespace CPPEmitter;

%% CPP Pre-defined backend
namespace PathStack {
    function emitPathStackCreate(): CString {
        return 'PathStack ps = PathStack::create();';
    }

    function emitPathStackLeft(): CString {
        return 'ps.left();';
    }

    function emitPathStackRight(): CString {
        return 'ps.right();';
    }

    function emitPathStackUp(): CString {
        return 'ps.up();';
    }
}

namespace CCharBuffer {
    %% Emit c++ for buffer creation here
}

namespace UnicodeCharBuffer {
    %% Emit c++ for buffer creation here
}

entity Context {
    field asm: CPPAssembly::Assembly;
    field fullns_key: CPPAssembly::NamespaceKey; %% Main::Foo::Bar::...
    field fullns_list: List<CString>; %% ['Main', 'Foo', 'Bar', ...]

    method updateCurrentNamespace(new_ns: CPPAssembly::NamespaceKey, new_nsname: List<CString>): Context {
        return Context{ this.asm, new_ns, new_nsname };
    }
}

%% Could remove these two and just call emitTypeKey... but I suspect we will eventually need to handle
%% lambda and elist explicitly (so fornow these are fine)
function emitTypeSignatureBase(ts: CPPAssembly::TypeSignature, ctx: Context): CString {
    %% Core becomes implicit in the ir so we have to add it. Perhaps could modify the ir itself to avoid this? dont want to break any other stuff tho
    return if(ctx.asm.pconcepts.has(ts.tkeystr)) then emitTypeKeyBase(CPPAssembly::TypeKey::from(CString::concat('Core::', ts.tkeystr.value)), ctx) 
        else emitTypeKeyBase(ts.tkeystr, ctx);    
}

function emitTypeSignatureParamFieldType(ts: CPPAssembly::TypeSignature, ctx: Context): CString {
    return emitTypeKeyParamField(ts.tkeystr, ctx);
}


%% Temporary invalid string we replace just before emission (with our special unicode tᖺis)
function emitSpecialThis(): CString {
    return '!!!';
}

%% replaces '<', '>', and comma in that order
function getSpecialTemplates(): (|CString, CString, CString|) {
    return (|'$!', '##', '!$'|);
}

%% Replaces templates '<', '>', and comma with temporary invalid characters to be replaced just before emission
function emitSpecialTemplate(name: CString): CString {
    let st = getSpecialTemplates();
    let base = name.replaceAllStringOccurrences(' ', '');
    let first = base.replaceAllStringOccurrences('<', st.0);
    let second = first.replaceAllStringOccurrences(',', st.1);
    let third = second.replaceAllStringOccurrences('>', st.2);

    return third;
}

%% We dont want this prefix when emitting typeinfo for primitives
function removeCppPrefix(s: CString): CString {
    return if(s.startsWithString('__CoreCpp::')) then s.removePrefixString('__CoreCpp::') else s;
}

function emitTypeKeyBase(tk: CPPAssembly::TypeKey, ctx: Context): CString {
    return emitResolvedNamespace(ctx.fullns_list, emitSpecialTemplate(tk.value)); 
}

function emitTypeKeyParamField(tk: CPPAssembly::TypeKey, ctx: Context): CString {
    let resolved = emitResolvedNamespace(ctx.fullns_list, emitSpecialTemplate(tk.value));

    if(!ctx.asm.typeinfos.has(tk)) {
        abort;
    }

    let tinfo = ctx.asm.typeinfos.get(tk);

    switch(tinfo.tag) {
        CPPAssembly::Tag#Value => { return resolved; }
        | CPPAssembly::Tag#Ref => { return CString::concat(resolved, '*'); }
        | CPPAssembly::Tag#Tagged => { abort; } %% Not fully confident on how to handle this quite yet
    }
}

function emitIdentifier(ident: CPPAssembly::Identifier): CString {
    return emitSpecialTemplate(ident.value);
}

function emitVarIdentifier(vident: CPPAssembly::VarIdentifier): CString {
    if(vident.value === 'this') {
        return emitSpecialThis();
    }
    return emitSpecialTemplate(vident.value);
}

function emitInvokeKey(ik: CPPAssembly::InvokeKey, ctx: Context): CString {
    return emitResolvedNamespace(ctx.fullns_list, emitSpecialTemplate(ik.value)); 
}

function emitNamespaceKey(nsk: CPPAssembly::NamespaceKey): CString {
    return nsk.value;
}

%%
%% Given a namespace key (like Main::Foo::Bar), remove all matching prefix strings
%% giving resolved namespace for given scope
%%
function emitResolvedNamespace(fullns_list: List<CString>, fullns: CString): CString {
    return fullns_list.reduce<CString>(fullns, fn(acc, s) => {
        if(acc.startsWithString(s)) {
            let nopre = acc.removePrefixString(s);
            if(nopre.startsWithString('::')) {
                return nopre.removePrefixString('::');
            }
            return nopre;
        }
        return acc;
    });
}

function emitLiteralSimpleExpression(exp: CPPAssembly::LiteralSimpleExpression): CString {
    %% We may want to make this matching a tad nicer, although not too bad as is 
    switch(exp.etype.tkeystr.value) {
        '__CoreCpp::Int' => { return CString::concat(exp.value, '_i'); }
        | '__CoreCpp::BigInt' => { return CString::concat(exp.value, '_I'); } 
        | '__CoreCpp::Nat' => { return CString::concat(exp.value, '_n'); }
        | '__CoreCpp::BigNat' => { return CString::concat(exp.value, '_N'); }
        | '__CoreCpp::Float' => { return CString::concat(exp.value, '_f'); }
        | 'bool' => { return exp.value; }
        | _ => { abort; }
    }
}

%% TODO: Still call the Option<T> constructor, but pass in nones typeinfo and __CoreCpp::None as data
function emitLiteralNoneExpression(exp: CPPAssembly::LiteralNoneExpression): CString {
    return 'UINT64_MAX';
}

function emitAccessVariableExpression(exp: CPPAssembly::AccessVariableExpression): CString {
    %% May need some work with type
    return emitVarIdentifier(exp.vname);
}

function emitReturnSingleStatement(ret: CPPAssembly::ReturnSingleStatement, ctx: Context, indent: CString): CString {
    let exp = emitExpression(ret.value, ctx);

    let full_indent: CString = CString::concat(indent, '    ');
    return CString::concat(full_indent, 'return ', exp, ';%n;');
}

recursive function emitBinAddExpression(add: CPPAssembly::BinAddExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](add.lhs, ctx);
    let rhs = emitExpression[recursive](add.rhs, ctx);

    return CString::concat('(', lhs, ' + ', rhs, ')');
}

recursive function emitBinSubExpression(sub: CPPAssembly::BinSubExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](sub.lhs, ctx);
    let rhs = emitExpression[recursive](sub.rhs, ctx);

    return CString::concat('(', lhs, ' - ', rhs, ')');
}

recursive function emitBinDivExpression(div: CPPAssembly::BinDivExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](div.lhs, ctx);
    let rhs = emitExpression[recursive](div.rhs, ctx);

    return CString::concat('(', lhs, ' / ', rhs, ')');
}

recursive function emitBinMultExpression(mult: CPPAssembly::BinMultExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](mult.lhs, ctx);
    let rhs = emitExpression[recursive](mult.rhs, ctx);

    return CString::concat('(', lhs, ' * ', rhs, ')');
}

recursive function emitBinaryArithExpression(e: CPPAssembly::BinaryArithExpression, ctx: Context): CString {
    match(e)@ {
        CPPAssembly::BinAddExpression => { return emitBinAddExpression[recursive]($e, ctx); }
        | CPPAssembly::BinSubExpression => { return emitBinSubExpression[recursive]($e, ctx); }
        | CPPAssembly::BinDivExpression => { return emitBinDivExpression[recursive]($e, ctx); }
        | CPPAssembly::BinMultExpression => { return emitBinMultExpression[recursive]($e, ctx); }
    }
}

recursive function emitPrefixNotOpExpression(notop: CPPAssembly::PrefixNotOpExpression, ctx: Context): CString {
    let expr = emitExpression[recursive](notop.expr, ctx);
    return CString::concat('!', expr);
}

recursive function emitPrefixNegateOpExpression(negop: CPPAssembly::PrefixNegateOpExpression, ctx: Context): CString {
    let expr = emitExpression[recursive](negop.expr, ctx);
    return CString::concat('-', expr);
}

recursive function emitPrefixPlusOpExpression(plusop: CPPAssembly::PrefixPlusOpExpression, ctx: Context): CString {
    return emitExpression[recursive](plusop.expr, ctx);
}

recursive function emitUnaryExpression(e: CPPAssembly::UnaryExpression, ctx: Context): CString {
    match(e)@ {
        CPPAssembly::PrefixNotOpExpression => { return emitPrefixNotOpExpression[recursive]($e, ctx); }
        | CPPAssembly::PrefixNegateOpExpression => { return emitPrefixNegateOpExpression[recursive]($e, ctx); }
        | CPPAssembly::PrefixPlusOpExpression => { return emitPrefixPlusOpExpression[recursive]($e, ctx); }
    }
}

recursive function emitNumericEqExpression(e: CPPAssembly::NumericEqExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return CString::concat('(', lhs, ' == ', rhs, ')');   
}

recursive function emitNumericNeqExpression(e: CPPAssembly::NumericNeqExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return CString::concat('(', lhs, ' != ', rhs, ')');   
}

recursive function emitNumericLessExpression(e: CPPAssembly::NumericLessExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return CString::concat('(', lhs, ' < ', rhs, ')');   
}

recursive function emitNumericLessEqExpression(e: CPPAssembly::NumericLessEqExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return CString::concat('(', lhs, ' <= ', rhs, ')');   
}

recursive function emitNumericGreaterExpression(e: CPPAssembly::NumericGreaterExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return CString::concat('(', lhs, ' > ', rhs, ')');   
}

recursive function emitNumericGreaterEqExpression(e: CPPAssembly::NumericGreaterEqExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return CString::concat('(', lhs, ' >= ', rhs, ')');   
}

recursive function emitBinaryNumericExpression(e: CPPAssembly::BinaryNumericExpression, ctx: Context): CString {
    match(e)@ {
        CPPAssembly::NumericEqExpression => { return emitNumericEqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericNeqExpression => { return emitNumericNeqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericLessExpression => { return emitNumericLessExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericLessEqExpression => { return emitNumericLessEqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericGreaterExpression => { return emitNumericGreaterExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericGreaterEqExpression => { return emitNumericGreaterEqExpression[recursive]($e, ctx); }
    }
}

recursive function emitBinLogicAndExpression(e: CPPAssembly::BinLogicAndExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);   

    return CString::concat('(', lhs, ' && ', rhs, ')');
}

recursive function emitBinLogicOrExpression(e: CPPAssembly::BinLogicOrExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);   

    return CString::concat('(', lhs, ' || ', rhs, ')');
}

recursive function emitBinLogicImpliesExpression(e: CPPAssembly::BinLogicImpliesExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);  

    let implies: CString = CString::concat('!', lhs, ' || ', rhs);
    return CString::concat('(', implies ,')');
}

recursive function emitBinLogicIFFExpression(e: CPPAssembly::BinLogicIFFExpression, ctx: Context): CString {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx); 
    let nlhs: CString = CString::concat('!', lhs);
    let nrhs: CString = CString::concat('!', rhs);

    let first: CString = CString::concat('(', lhs, ' && ', rhs, ')');
    let second: CString = CString::concat('(', nlhs, ' && ', nrhs, ')');

    return CString::concat('(', first, ' || ', second, ')');
}

recursive function emitBinLogicExpression(e: CPPAssembly::BinLogicExpression, ctx: Context): CString {
    match(e)@ {
        CPPAssembly::BinLogicAndExpression => { return emitBinLogicAndExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicOrExpression => { return emitBinLogicOrExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicImpliesExpression => { return emitBinLogicImpliesExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicIFFExpression => { return emitBinLogicIFFExpression[recursive]($e, ctx); }
    }
}

recursive function emitLogicActionAndExpression(e: CPPAssembly::LogicActionAndExpression, ctx: Context): CString {
    let args = e.args.map<CString>(fn(expr) => emitExpression[recursive](expr, ctx));
    return CString::concat('(', CString::joinAll(' && ', args), ')');
}

recursive function emitLogicActionOrExpression(e: CPPAssembly::LogicActionOrExpression, ctx: Context): CString {
    let args = e.args.map<CString>(fn(expr) => emitExpression[recursive](expr, ctx));
    return CString::concat('(', CString::joinAll(' || ', args), ')');
}

function emitArgumentValue(av: Option<CPPAssembly::ArgumentValue>, i: Nat, params: List<CPPAssembly::ParameterDecl>, ctx: Context): CString {
    if(av)@none {
        let param = params.get(i).defaultval;
        if(param)@none {
            abort; %% Should be impossible
        }
        else {
            return emitExpression[recursive]($param, ctx);
        }
    }
    else {
        let arg = $av;
        let expr = emitExpression[recursive](arg.exp, ctx);
        match(arg)@ {
            CPPAssembly::NamedArgumentValue => { return expr; } 
            | CPPAssembly::PositionalArgumentValue => { return expr; }
            | _ => { abort; }
        }
    }
}

function resolveDefaultParams(al: List<CString>, params: List<CPPAssembly::ParameterDecl>): List<CString> {
    return al.map<CString>(fn(arg) => { 
        if(arg.startsWithString('$')) {
            let ident = arg.removePrefixString('$');

            %% This is a bit hacky but works for getting default val idx
            let idx = params.mapIdx<Nat>(fn(param, ii) => {
                if(emitIdentifier(param.pname) === ident) {
                    return ii;
                }
                return 0n;
            }).sum();

            return al.get(idx);
        }
        return arg; 
    });
}

function emitArgumentList(al: CPPAssembly::ArgumentList, params: List<CPPAssembly::ParameterDecl>, ctx: Context): CString {
    let emit_al = al.args.mapIdx<CString>(fn(arg, ii) => emitArgumentValue(arg, ii, params, ctx));
    
    return CString::joinAll(', ', resolveDefaultParams[recursive](emit_al, params));
}

function emitCallNamespaceFunctionExpression(e: CPPAssembly::CallNamespaceFunctionExpression, ctx: Context): CString { 
    let resolvedns = emitResolvedNamespace(ctx.fullns_list, e.ns.value); 
    let ident = e.ikey.value;

    let name: CString = if(ident.startsWithString(e.ns.value)) then ident.removePrefixString(e.ns.value) else ident;
    let resolvedName: CString = if(name.startsWithString('::')) then name.removePrefixString('::') else name;

    let nsfunc = ctx.asm.nsfuncs.get(e.ikey); 
    let args = emitArgumentList(e.args, nsfunc.params, ctx); 

    let specialName = emitSpecialTemplate(resolvedName);
    if(resolvedns !== '') {
        return CString::concat(resolvedns, '::', specialName ,'(', args, ')');
    }
    return CString::concat(specialName, '(', args, ')');
}

function emitCallTypeFunctionExpression(e: CPPAssembly::CallTypeFunctionExpression, ctx: Context): CString { 
    let ttype = emitTypeSignatureBase(e.ttype, ctx);
    let resolvedDeclType = emitTypeSignatureBase(e.resolvedDeclType, ctx);
    let typefunc = ctx.asm.typefuncs.get(e.ikey);
    let completeikey = typefunc.completeikey.value;
    let args = emitArgumentList(e.args, typefunc.params, ctx); 

    let tfuncns = typefunc.declaredInNS.value;
    let name: CString = if(completeikey.startsWithString(tfuncns)) then completeikey.removePrefixString(tfuncns) else completeikey;
    let resolvedName: CString = if(name.startsWithString('::')) then name.removePrefixString('::') else name;

    let resolvedns = emitResolvedNamespace(ctx.fullns_list, typefunc.declaredInNS.value);
    if(resolvedns !== '') {
        return CString::concat(resolvedns, '::', resolvedName, '(', args, ')');
    }
    return CString::concat(resolvedName, '(', args, ')');
}

function emitPostfixAccessFromName(op: CPPAssembly::PostfixAccessFromName, ctx: Context): CString {
    let ident = emitIdentifier(op.name);

    let op_tinfo = ctx.asm.typeinfos.get(op.declaredInType.tkeystr);
    switch(op_tinfo.tag) {
        CPPAssembly::Tag#Value => { return CString::concat('.', ident); }
        | CPPAssembly::Tag#Ref => { return CString::concat('->', ident); }
        | CPPAssembly::Tag#Tagged => { abort; } %% TODO: Need to handle virtual lookups (and add our little vtable to backend that emits)
    }
}

function emitPostfixInvokeStatic(op: CPPAssembly::PostfixInvokeStatic, expr: CString, ctx: Context): CString {
    let ik = emitInvokeKey(op.resolvedTrgt, ctx);
    let tk = emitTypeKeyBase(op.resolvedType.tkeystr, ctx);

    var args: CString;
    var name: CString;
    if(ctx.asm.staticmethods.has(op.resolvedTrgt)) {
        let trgt = ctx.asm.staticmethods.get(op.resolvedTrgt);
        name = trgt.name;
        args = emitArgumentList(op.args, trgt.params, ctx);
    }
    else {
        abort; %% TODO: Add support for Override, Abstract, and Virtual methods!
    }

    %% Remove abstract nominal we were in
    var resolvedInvoke: CString;
    if(ik.startsWithString(tk)) {
        let tmp = ik.removePrefixString(tk);
        if(tmp.startsWithString('::')) {
            resolvedInvoke = tmp.removePrefixString('::');
        }
        else {
            resolvedInvoke = tmp;
        } 
    }
    else {
        resolvedInvoke = ik;
    }

    let specialName = emitSpecialTemplate(resolvedInvoke);
    if(args === '') {
        return CString::concat(specialName, '(', expr, ')');
    }
    else {
         return CString::concat(specialName, '(', expr, ', ', args, ')');       
    }
}

%% Emitting invalid '!true/false!' allows us to prevent naming conflicts and gives a matchable pattern that we can
%% replace with 'true/false'
function emitITestType(it: CPPAssembly::ITestType, baseType: CPPAssembly::TypeSignature, ctx: Context): CString {
    %% For now we only support ITests where both types are concrete
    if(ctx.asm.isNominalTypeConcrete(it.ttype.tkeystr) && ctx.asm.isNominalTypeConcrete(baseType.tkeystr)) {
        let areTypesSame = ctx.asm.areTypesSame(it.ttype, baseType);
        return if(it.isnot) then (if(!areTypesSame) then '!true!' else '!false!')
            else if(areTypesSame) then '!true!' else '!false!';
    }
    else {
        abort; %% TODO: ITests on concepts not yet supported!
    }
}

function emitITestSome(it: CPPAssembly::ITestSome, baseType: CPPAssembly::TypeSignature, ctx: Context): CString {
    return CString::concat('.typeinfo != &NoneType');
}

function emitITestAsTest(it: CPPAssembly::ITest, baseType: CPPAssembly::TypeSignature, ctx: Context): CString {
    match(it)@ {
        CPPAssembly::ITestType => { return emitITestType($it, baseType, ctx); }
        | CPPAssembly::ITestSome => { return emitITestSome($it, baseType, ctx); }
        | _ => { abort; } %% TODO: Not Implemented!
    }
}

function emitPostfixOp(pop: CPPAssembly::PostfixOp, ctx: Context): CString {
    let rootExp = emitExpression(pop.rootExp, ctx);
    let ops = pop.ops.mapIdx<CString>(fn(op, ii) => {
        match(op)@ {
            CPPAssembly::PostfixAccessFromName => {
                if (ii == 0n) {
                    return CString::concat(rootExp, emitPostfixAccessFromName($op, ctx));
                }
                return emitPostfixAccessFromName($op, ctx);
            }
            | CPPAssembly::PostfixInvokeStatic => { return emitPostfixInvokeStatic($op, rootExp, ctx); }
            | CPPAssembly::PostfixIsTest => { return emitITestAsTest($op.ttest, $op.baseType, ctx); }
        }
    });

    let res = CString::joinAll('', ops);

    %% This could be a bit clunky - is there anywhere else we need to perform this substitution?
    return if(res.containsString('!false!')) then 'false' else if(res.containsString('!true!')) then 'true' else res;
}

%%
%% We should try to forcefully create the constructor for Option<T> where the tinfo pointer points to Some<T>,
%% but the actual constructor is not Some<T>{...} but rather Option<T>{&Some<T>Type, ...}
%%

%% Needs to call constructor for our Boxed<K> type, not too sure how to construct the args
function emitConstructorPrimarySpecialSomeExpression(cpsse: CPPAssembly::ConstructorPrimarySpecialSomeExpression, ctx: Context): CString {
    let t = getSpecialTemplates();
    let ttype = if(ctx.asm.isPrimtitiveType(cpsse.ofttype.tkeystr)) then cpsse.ofttype.tkeystr.value.removePrefixString('__CoreCpp::') 
        else emitTypeSignatureBase(cpsse.ofttype, ctx);
    let widenedtype = CString::concat('Core::Option', t.0, ttype, t.2);
    let tinfoptr = CString::concat('&', ttype, 'Type, ');

    %% This is quite naieve as we only support one argument and it does not map well to using the getter here
    if(cpsse.args.args.size() == 0n) {
        abort;
    }
    let arg = cpsse.args.args.get(0n);
    if(arg)@none {
        abort;
    }
    else {
        let tmparg = CString::concat( '(', emitExpression($arg.exp, ctx), ').get()');
        let data = CString::concat('(uint64_t[]){', tmparg, '}');
        return CString::concat(widenedtype, '{', tinfoptr, data, '}');
    }
}

function emitConstructorPrimarySpecialOkExpression(cpsoe: CPPAssembly::ConstructorPrimarySpecialOkExpression, ctx: Context): CString {
    abort; %% TODO: Not implemented!
}

function emitConstructorPrimarySpecialFailExpression(cpsfe: CPPAssembly::ConstructorPrimarySpecialFailExpression, ctx: Context): CString {
    abort; %% TODO: Not Implemented!
}

function emitConstructorPrimarySpecialConstructableExpression(exp: CPPAssembly::ConstructorPrimarySpecialConstructableExpression, ctx: Context): CString {    
    match(exp)@ {
        CPPAssembly::ConstructorPrimarySpecialSomeExpression => { return emitConstructorPrimarySpecialSomeExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialOkExpression => { return emitConstructorPrimarySpecialOkExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialFailExpression => { return emitConstructorPrimarySpecialFailExpression($exp, ctx); }
    }
 }

%%
%% TODO: Once the GC is integrated we will need to call our special GC allocate on ref type objects instead of the default
%% constructor like we do now. Currently they call 'new'
%%
function emitConstructorStdExpression(exp: CPPAssembly::ConstructorStdExpression, ctx: Context): CString {
    %% Eventually might want to rework emitArgumentList to support constructors too 
    let emitargs =  CString::joinAll(', ', exp.args.args.mapIdx<CString>(fn(av, ii) => {
        if(av)@none {
            if(!ctx.asm.entities.has(exp.ctype.tkeystr)) {
                abort;
            }
            let e = ctx.asm.entities.get(exp.ctype.tkeystr);
            let member_defval = e.fields.get(ii).defaultval;
            if(member_defval)@none {
                abort; %% Default value detected in transform, yet none provided for emission
            }
            else {
                return emitExpression[recursive]($member_defval, ctx);
            }
        }
        else {
            let arg = $av;
            let argexp = emitExpression[recursive](arg.exp, ctx);
            match(arg)@ {
                CPPAssembly::NamedArgumentValue => { return argexp; } 
                | CPPAssembly::PositionalArgumentValue => { return argexp; }
                | _ => { abort; }
            }
        }
    }));

    let resolved_type = emitResolvedNamespace(ctx.fullns_list, exp.ctype.tkeystr.value);
    let specialName = emitSpecialTemplate(resolved_type);

    if(!ctx.asm.typeinfos.has(exp.ctype.tkeystr)) {
        abort;
    }

    if(ctx.asm.typeinfos.get(exp.ctype.tkeystr).tag === CPPAssembly::Tag#Ref) {
        return CString::concat('new ', specialName, '{ ', emitargs, ' }'); %% We use new solely to keep the code compiling before GC integration
    }
    return CString::concat(specialName, '{ ', emitargs, ' }'); 
}

function emitIfExpression(exp: CPPAssembly::IfExpression, ctx: Context): CString {
    let texp = emitExpression(exp.texp, ctx);
    let thenexp = emitExpression(exp.thenexp, ctx);
    let elseexp = emitExpression(exp.elseexp, ctx);

    match(exp) {
        CPPAssembly::IfSimpleExpression => { return CString::concat(texp, ' ? ', thenexp, ' : ', elseexp); }
        | _ => { abort; } %% TODO: Not Implemented
    }
}

function emitExpression(e: CPPAssembly::Expression, ctx: Context): CString {
    match(e)@ {
        CPPAssembly::BinaryArithExpression => { return emitBinaryArithExpression[recursive]($e, ctx); }
        | CPPAssembly::BinaryNumericExpression => { return emitBinaryNumericExpression[recursive]($e, ctx); }
        | CPPAssembly::UnaryExpression => { return emitUnaryExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicExpression => { return emitBinLogicExpression[recursive]($e, ctx); }
        | CPPAssembly::LogicActionAndExpression => { return emitLogicActionAndExpression[recursive]($e, ctx); }
        | CPPAssembly::LogicActionOrExpression => { return emitLogicActionOrExpression[recursive]($e, ctx); }
        | CPPAssembly::LiteralNoneExpression => { return emitLiteralNoneExpression($e); }
        | CPPAssembly::LiteralSimpleExpression => { return emitLiteralSimpleExpression($e); }
        | CPPAssembly::AccessVariableExpression => { return emitAccessVariableExpression($e); }
        | CPPAssembly::CallNamespaceFunctionExpression => { return emitCallNamespaceFunctionExpression($e, ctx); }
        | CPPAssembly::CallTypeFunctionExpression => { return emitCallTypeFunctionExpression($e, ctx); }
        | CPPAssembly::PostfixOp => { return emitPostfixOp($e, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialConstructableExpression => { return emitConstructorPrimarySpecialConstructableExpression($e, ctx); }
        | CPPAssembly::ConstructorStdExpression => { return emitConstructorStdExpression($e, ctx); }
        | CPPAssembly::IfExpression => { return emitIfExpression($e, ctx); }
        | _ => { abort; }
    }
}

function emitVariableInitializationStatement(stmt: CPPAssembly::VariableInitializationStatement, ctx: Context, indent: CString): CString {
    let name = emitIdentifier(stmt.name);
    let stype = emitTypeSignatureBase(stmt.vtype, ctx);
    let tmp =  emitExpression(stmt.exp, ctx);

    %% This could break for pconcepts that arent options, fine for now
    let exp = if(ctx.asm.pconcepts.has(stmt.vtype.tkeystr) && stmt.exp?<CPPAssembly::LiteralNoneExpression>) 
        then CString::concat(stype, '{&NoneType, (uint64_t[]){', tmp, '}}')

        else tmp;
    let specialName = emitSpecialTemplate(stype);

    let full_indent: CString = CString::concat(indent, '    ', specialName);
    return CString::concat(full_indent, ' ', name, ' = ', exp, ';');
}

function emitBlockStatement(block: CPPAssembly::BlockStatement, ctx: Context, indent: CString): CString {
    let stmts = block.statements.map<CString>(fn(stmt) => emitStatement(stmt, ctx, indent));
    return CString::joinAll('%n;', stmts);
}

function emitIfSimpleStatement(stmt: CPPAssembly::IfSimpleStatement, ctx: Context, indent: CString): CString {
    let expr = emitExpression(stmt.cond, ctx);
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);

    let ifstmt = CString::concat(indent, 'if( ', expr, ' ) {%n;');
    return CString::concat(ifstmt, trueBlock, indent, '}');
}

function emitIfTestStatement(stmt: CPPAssembly::IfTestStatement, ctx: Context, indent: CString): CString {
    let itest = emitITestAsTest(stmt.itest, stmt.cond.etype, ctx);
    let expr = if(itest === '!false!') then 'false' else 
        (if(itest === 'true') then 'true' else CString::concat(emitExpression(stmt.cond, ctx), itest));
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);

    let ifstmt = CString::concat(indent, 'if( ', expr, ' ) {%n;');
    return CString::concat(ifstmt, trueBlock, indent, '}');
}

function emitIfBinderStatement(stmt: CPPAssembly::IfStatement, ctx: Context, indent: CString): CString {
    abort; %% TODO: Not Implemented!    
}

function emitIfStatement(stmt: CPPAssembly::IfStatement, ctx: Context, indent: CString): CString {
    let full_indent = CString::concat('    ', indent); 

    match(stmt)@ { 
        CPPAssembly::IfSimpleStatement => { return emitIfSimpleStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfTestStatement => { return emitIfTestStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfBinderStatement => { return emitIfBinderStatement($stmt, ctx, full_indent); }
    }
}

function emitIfElseSimpleStatement(stmt: CPPAssembly::IfElseSimpleStatement, ctx: Context, indent: CString): CString {
    let expr = emitExpression(stmt.cond, ctx);
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);
    let falseBlock = emitBlockStatement(stmt.falseBlock, ctx, indent);
    let elseBlockText = CString::concat(indent, 'else {%n;', falseBlock, indent, '}%n;');
    
    let ifstmt = CString::concat(indent, 'if( ', expr, ' ) {%n;'); 
    return CString::concat(ifstmt, trueBlock, indent, '}%n;', elseBlockText);
}

function emitIfElseTestStatement(stmt: CPPAssembly::IfElseTestStatement, ctx: Context, indent: CString): CString {
    let itest = emitITestAsTest(stmt.itest, stmt.cond.etype, ctx);
    let expr = if(itest === '!false!') then 'false' else 
        (if(itest === 'true') then 'true' else CString::concat(emitExpression(stmt.cond, ctx), itest));
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);
    let falseBlock = emitBlockStatement(stmt.falseBlock, ctx, indent);
    let elseBlockText = CString::concat(indent, 'else {%n;', falseBlock, indent, '}%n;');
    
    let ifstmt = CString::concat(indent, 'if( ', expr, ' ) {%n;'); 
    return CString::concat(ifstmt, trueBlock, indent, '}%n;', elseBlockText);
}

function emitIfElseBinderStatement(stmt: CPPAssembly::IfElseBinderStatement, ctx: Context, ident: CString): CString {
    abort; %% TODO: Not Implemented!
}

function emitIfElseStatement(stmt: CPPAssembly::IfElseStatement, ctx: Context, indent: CString): CString {
    let full_indent = CString::concat('    ', indent); 
    
    match(stmt)@ {
        CPPAssembly::IfElseSimpleStatement => { return emitIfElseSimpleStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfElseTestStatement => { return emitIfElseTestStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfElseBinderStatement => { return emitIfElseBinderStatement($stmt, ctx, full_indent); }
    }
}

function emitIfElifElseStatement(stmt: CPPAssembly::IfElifElseStatement, ctx: Context, indent: CString): CString {
    let full_indent = CString::concat('    ', indent); 
    let ifcond = CString::concat(full_indent, 'if(', emitExpression(stmt.ifcond, ctx), ') {%n;');
    let ifbody = CString::concat(emitBlockStatement(stmt.ifflow, ctx, full_indent), full_indent, '}%n;');
    let ifblock = CString::concat(ifcond, ifbody);
    let elseblock = CString::concat(full_indent, 'else {%n;', emitBlockStatement(stmt.elseflow, ctx, full_indent), full_indent, '}%n;');

    let elifs_list = stmt.condflow.map<CString>(fn(elifs) => {
        let cond = emitExpression(elifs.0, ctx);
        let body = emitBlockStatement(elifs.1, ctx, full_indent);

        let elif_stmt = CString::concat(full_indent, 'else if(', cond, ') {%n;');
        return CString::concat(elif_stmt, body, full_indent, '}%n;');
    });
    let elifs = CString::joinAll('', elifs_list);

    return CString::concat(ifcond, ifbody, elifs, elseblock);
}

function emitStatement(stmt: CPPAssembly::Statement, ctx: Context, indent: CString): CString {
    match(stmt)@ {
        CPPAssembly::VariableInitializationStatement => { return emitVariableInitializationStatement($stmt, ctx, indent); }
        | CPPAssembly::ReturnSingleStatement => { return emitReturnSingleStatement($stmt, ctx, indent); }
        | CPPAssembly::IfStatement => { return emitIfStatement($stmt, ctx, indent); }
        | CPPAssembly::IfElseStatement => { return emitIfElseStatement($stmt, ctx, indent); }
        | CPPAssembly::IfElifElseStatement => { return emitIfElifElseStatement($stmt, ctx, indent); }
        | _ => { abort; }
    }
}

function emitBuiltinBodyImplementation(body: CPPAssembly::BuiltinBodyImplementation, ctx: Context, indent: CString): CString {
    switch(body.builtin) {
        's_float_power' => { return CString::concat(indent, '    ', 'return __CoreCpp::Float(powf64(a.get(), b.get()));%n;'); }
        | 's_float_sqrt' => { return CString::concat(indent, '    ', 'return __CoreCpp::Float(sqrtf64(a.get()));%n;'); }
        | _ => { abort; } %% TODO: Not implemented
    }
}

function emitStandardBodyImplementation(body: CPPAssembly::StandardBodyImplementation, ctx: Context, indent: CString): CString {
    return CString::joinAll('%n;', body.statements.map<CString>(fn(stmt) => emitStatement(stmt, ctx, indent)));
}

function emitBodyImplementation(body: CPPAssembly::BodyImplementation, ctx: Context, indent: CString): CString {
    match(body)@ {
        %% CPPAssembly::AbstractBodyImplementation => { abort; }
        %% | CPPAssembly::PredicateUFBodyImplementation => { abort; }
        CPPAssembly::BuiltinBodyImplementation => { return emitBuiltinBodyImplementation($body, ctx, indent); }
        %% | CPPAssembly::SynthesisBodyImplementation => { abort; }
        %% | CPPAssembly::ExpressionBodyImplementation => { abort; }
        | CPPAssembly::StandardBodyImplementation => { return emitStandardBodyImplementation($body, ctx, indent); }
        | _ => { abort; }
    }
}

function emitParameters(params: List<CPPAssembly::ParameterDecl>, ctx: Context): CString {
    let all_params = params.map<CString>(fn(param) => {
        let ptype = emitTypeSignatureParamFieldType(param.ptype, ctx);
        let resolved_ptype = emitResolvedNamespace(ctx.fullns_list, ptype);

        let pident = emitIdentifier(param.pname);
        let specialName = emitSpecialTemplate(pident);
        return CString::concat(resolved_ptype, ' ', specialName);
    });

    return CString::joinAll(', ', all_params);
}

%% Determine whether to emit this param as const this* or this
function emitThisType(tk: CPPAssembly::TypeKey, ctx: Context): CString {
    let resolved_type = emitResolvedNamespace(ctx.fullns_list, tk.value);

    if(!ctx.asm.typeinfos.has(tk)) {
        abort;
    }

    if(ctx.asm.typeinfos.get(tk).tag === CPPAssembly::Tag#Ref) {
        return CString::concat('const ', resolved_type, '*');
    }
    return resolved_type;
}

function emitMethodDecl(m: CPPAssembly::MethodDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: CString): CString {
    let nctx = ctx.updateCurrentNamespace(m.declaredInNS, m.fullns);
    
    let name = m.ikey.value.removePrefixString(declaredIn.value).removePrefixString('::');
    let params = emitParameters(m.params, nctx);
    let rtype = emitTypeSignatureBase(m.resultType, ctx);
    let this_type = emitThisType(declaredIn, nctx);    
    let specialName = emitSpecialTemplate(name);
    
    let pre = if(rtype !== 'bool') then CString::concat(indent, 'const ', rtype, ' ', specialName)
        else CString::concat(indent, rtype, ' ', specialName);
    let specialThis = emitSpecialTemplate(this_type);

    var params_impl: CString;
    if(params === '') {
        params_impl = CString::concat('(', specialThis, ' ', emitSpecialThis(), ') noexcept');
    }
    else {
        let base = CString::concat('(', specialThis, ' ');
        params_impl = CString::concat(base, emitSpecialThis(), ', ', params, ') noexcept');           
    }

    return CString::concat(pre, params_impl, ' {%n;', emitBodyImplementation(m.body, nctx, indent), indent, '}%n;');
}

%% Type funcs are fully resolved before cpp emission so we can group them with nsfuncs
function emitFunctionDecl(func: CPPAssembly::AbstractInvokeDecl, ctx: Context, indent: CString): CString {
    let isTypeFunc = ctx.asm.typefuncs.has(func.ikey);
    let ikey = if(isTypeFunc) then ctx.asm.typefuncs.get(func.ikey).completeikey else func.ikey;   
    let ns = if(isTypeFunc) then ctx.asm.typefuncs.get(func.ikey).completens else func.fullns;
    let nctx = ctx.updateCurrentNamespace(func.declaredInNS, ns);

    let name = emitInvokeKey(ikey, nctx);
    let specialName = emitSpecialTemplate(name);
    let params = emitParameters(func.params, nctx);
    let rtype = emitTypeSignatureBase(func.resultType, ctx); 

    let pre: CString = CString::concat(indent, rtype, ' ', specialName );
    let params_impl: CString = CString::concat('(', params, ') noexcept ');

    return CString::concat(pre, params_impl, ' {%n;', emitBodyImplementation(func.body, nctx, indent), indent, '}%n;');
}

%*
function emitMemberFieldDecl(member: CPPAssembly::MemberFieldDecl, ctx: Context, indent: CString): CString {
    let name = emitIdentifier(member.name);
    let mtype = emitTypeSignatureParamFieldType(member.declaredType, ctx);
    return CString::concat(indent, mtype, ' ', name, ';%n;');
}
*%

function emitSaturatedFieldInfo(sfi: CPPAssembly::SaturatedFieldInfo, ctx: Context, indent: CString): CString {
    let ftype = emitTypeSignatureParamFieldType(sfi.ftype, ctx);
    let fname = emitIdentifier(sfi.fname);
    return CString::concat(indent, ftype, ' ', fname, ';%n;');
}

function emitEntityTypeDecl(e: CPPAssembly::EntityTypeDecl, tk: CString, ctx: Context, indent: CString): CString {
    let nctx = ctx.updateCurrentNamespace(e.declaredInNS, e.fullns);
    let resolved_tk = emitResolvedNamespace(nctx.fullns_list, tk);
    let specialName = emitSpecialTemplate(resolved_tk);

    let entries = e.saturatedBFieldInfo.reduce<CString>(CString::concat(indent, 'struct ', specialName, ' { %n;'), 
        fn(acc, entry) => {
            return CString::concat(acc, emitSaturatedFieldInfo(entry, nctx, CString::concat('    ', indent)));
    });

    return CString::concat(entries, indent, '};%n;');
}

function emitDatatypeMemberEntityDecl(dm: CPPAssembly::DatatypeMemberEntityTypeDecl, ctx: Context, indent: CString): CString {
    let nctx = ctx.updateCurrentNamespace(dm.declaredInNS, dm.fullns);
    let resolved_tk = emitResolvedNamespace(nctx.fullns_list, dm.tkey.value); 
    let specialName = emitSpecialTemplate(resolved_tk);

    let fields = dm.saturatedBFieldInfo.reduce<CString>(CString::concat(indent, 'struct ', specialName, '{ %n;'), 
        fn(acc, entry) => {
            return CString::concat(acc, emitSaturatedFieldInfo(entry, nctx, CString::concat('    ', indent)));
    });

    return CString::concat(fields, indent, '};%n;');
}

function emitAbstractNominalForwardDeclaration(e: CPPAssembly::AbstractNominalTypeDecl, ctx: Context, indent: CString): CString {
    let nctx = ctx.updateCurrentNamespace(e.declaredInNS, e.fullns);
    let resolvedName = emitResolvedNamespace(nctx.fullns_list, e.tkey.value);
    let specialName = emitSpecialTemplate(resolvedName);

    return CString::concat(indent, 'struct ', specialName, ';%n;');
}

function emitMethodForwardDeclaration(m: CPPAssembly::MethodDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: CString): CString {
    let nctx = ctx.updateCurrentNamespace(m.declaredInNS, m.fullns);

    if(m)@<CPPAssembly::MethodDeclStatic> {
        let pre = m.ikey.value.removePrefixString(declaredIn.value).removePrefixString('::');
        let rtype = emitTypeSignatureBase(m.resultType, nctx);
        let this_type = emitThisType(declaredIn, nctx);
        let params = emitParameters(m.params, nctx);

        let specialThis = emitSpecialTemplate(this_type);
        let specialName = emitSpecialTemplate(pre);

        let first = if(rtype !== 'bool') then CString::concat(indent, 'const ', rtype, ' ', specialName, '(')
            else CString::concat(indent, rtype, ' ', specialName, '(');

        if(params === '') {
            return CString::concat(first, specialThis, ' ', emitSpecialThis(), params, ') noexcept;%n;');
        }
        else {
            let base = CString::concat(first, specialThis, ' ');
            return CString::concat(base, emitSpecialThis(), ', ', params, ') noexcept;%n;');           
        }
    }
    abort; %% TODO: Support other method types!
}

function emitFunctionForwardDeclaration(decl: CPPAssembly::AbstractInvokeDecl, ctx: Context, ident: CString): CString {
    let isTypeFunc = ctx.asm.typefuncs.has(decl.ikey);
    let ikey = if(isTypeFunc) then ctx.asm.typefuncs.get(decl.ikey).completeikey else decl.ikey;   
    let ns = if(isTypeFunc) then ctx.asm.typefuncs.get(decl.ikey).completens else decl.fullns;
    let nctx = ctx.updateCurrentNamespace(decl.declaredInNS, ns);

    let pre = emitInvokeKey(ikey, nctx);
    let rtype = emitTypeSignatureBase(decl.resultType, ctx); 
    let params = emitParameters(decl.params, nctx);
    let specialName = emitSpecialTemplate(pre);

    let first = CString::concat(ident, rtype, ' ', specialName );
    return CString::concat(first, '(', params, ') noexcept;%n;');
}

%%
%% TODO: Need to add lookup methods for these vtables and give this some thought. A lot of this code is repetitive or could be
%% cleaned up pretty signifigantly. We currently emit a vtable entry for all fields, not just those who are derived. (this may need changed)
%%

function generateVTableEntry(entry: CPPAssembly::MemberFieldDecl, resolved_name: CString, enum_name: CString, idx: Nat, ctx: Context, indent: CString): CString {
    if(!ctx.asm.typeinfos.has(entry.declaredType.tkeystr)) {
        abort;
    }
    let tinfo = ctx.asm.typeinfos.get(entry.declaredType.tkeystr);

    let id = tinfo.id.toCString();
    let entrytype = CString::concat(enum_name, '::', resolved_name, '_', emitIdentifier(entry.name));
    let byteoffset = (idx * 8n).toCString(); %% Woudlnt be a bad idea to make these 8 byte alignment a const

    let base = CString::concat('{ ', id, ', ', entrytype, ', ', byteoffset);
    return CString::concat(indent, base, ' }');
}

function generateVTable(ant: CPPAssembly::AbstractNominalTypeDecl, fields: List<CPPAssembly::MemberFieldDecl>, ctx: Context, indent: CString): CString {
    let full_indent = CString::concat('    ', indent);
    
    let resolved_name = emitResolvedNamespace(ant.fullns, ant.tkey.value);
    let specialName = emitSpecialTemplate(resolved_name);

    let enum_name = CString::concat(specialName, '_entries');
    let vtable_name = CString::concat(specialName, '_vtable');

    let base = CString::concat('const __CoreCpp::FieldOffsetInfo ', vtable_name, '[] = ', '{%n;');
    let field_names = fields.mapIdx<CString>(fn(f_entry, ii) => generateVTableEntry(f_entry, specialName, enum_name, ii, ctx, full_indent));
    return CString::concat(indent, base, CString::joinAll(',%n;', field_names), '%n;', indent, '};%n;'); 
}

%% Might need to be a bit careful with the naming here, perhaps some funny unicode magic again
function generateEntriesEnum(ant: CPPAssembly::AbstractNominalTypeDecl, fields: List<CPPAssembly::MemberFieldDecl>, indent: CString): CString {
    let full_indent = CString::concat('    ', indent);
    
    let resolved_name = emitResolvedNamespace(ant.fullns, ant.tkey.value);
    let specialName = emitSpecialTemplate(resolved_name);

    let enum_name = CString::concat(specialName, '_entries');

    let base = CString::concat('enum ', enum_name, ' {%n;');
    let field_names = fields.map<CString>(fn(f_entry) => CString::concat(full_indent, specialName, '_', emitIdentifier(f_entry.name)));
    return CString::concat(indent, base, CString::joinAll(',%n;', field_names), '%n;', indent, '};%n;');
}

function emitTypeInfo(info: CPPAssembly::TypeInfo, ant: Option<CPPAssembly::AbstractNominalTypeDecl>, hasfields: Bool, indent: CString): CString {
    let full_indent = CString::concat('    ', indent);

    let infotk = removeCppPrefix(info.typekey.value);
    let resolved_name = if(ant)@none then infotk else emitResolvedNamespace($ant.fullns, infotk);
    let specialName = emitSpecialTemplate(resolved_name);

    let tinfo_name = CString::concat(specialName, 'Type');

    let base = CString::concat(indent, '__CoreCpp::TypeInfoBase ', tinfo_name, ' = {%n;');
    let id = CString::concat(base, full_indent, '.type_id = ', info.id.toCString(), ',%n;');
    let typesize = CString::concat(id, full_indent, '.type_size = ', info.typesize.toCString(), ', %n;');
    let slotsize = CString::concat(typesize, full_indent, '.slot_size = ', info.slotsize.toCString(), ',%n;');
    let ptrmask = CString::concat(slotsize, full_indent, '.ptr_mask = "', info.ptrmask, '",%n;');
    let typekey = CString::concat(ptrmask, full_indent, '.typekey = "', info.typekey.value, '",%n;');
    let vtable = if(hasfields) then CString::concat(typekey, full_indent, '.vtable = ', CString::concat(specialName, '_vtable'), '%n;')
        else CString::concat(typekey, full_indent, '.vtable = nullptr%n;');

    return CString::concat(vtable, indent, '};%n;');
}

function emitAbstractNominalTypeDecl(ant: CPPAssembly::AbstractNominalTypeDecl, fields: List<CPPAssembly::MemberFieldDecl>, body: CString, ctx: Context, indent: CString): CString {
    let ant_enum = generateEntriesEnum(ant, fields, indent);
    let vtable = generateVTable(ant, fields, ctx, indent);
    if(!ctx.asm.typeinfos.has(ant.tkey)) {
        abort;
    }
    let tinfo = emitTypeInfo(ctx.asm.typeinfos.get(ant.tkey), some(ant), false, indent);
    let staticmethods = ant.staticmethods.reduce<CString>('', fn(acc, m) => { 
        return CString::concat(acc, emitMethodDecl(ctx.asm.staticmethods.get(m), ant.tkey, ctx, indent));
    });
    
    return CString::concat(ant_enum, vtable, tinfo, body, staticmethods);
}

function emitPrimtiveConceptTypeDecl(pc: CPPAssembly::PrimitiveConceptTypeDecl, ctx: Context, indent: CString): CString {
    let tkey = emitTypeKeyBase(pc.tkey, ctx);
    let def = CString::concat('class ', emitTypeKeyBase(pc.tkey, ctx));
    if(!ctx.asm.typeinfos.has(pc.tkey)) {
        abort;
    }
    let k = ctx.asm.typeinfos.get(pc.tkey).slotsize;
    let boxed = CString::concat('__CoreCpp::Boxed', '<', k.toCString(), '>'); 
    
    let constructor = CString::concat('public:%n;', indent, tkey, '(__CoreCpp::TypeInfoBase* ti, uint64_t* data) : ', boxed, '(ti, data) {}%n;');
    return CString::concat(def, ' : public ', boxed, '{%n;', constructor, '};%n;');
}

function emitForwardDeclarationBody(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: CString): CString {    
    let entity_fwddecls = nsdecl.entities.reduce<CString>('', fn(acc, tk) => {
        return CString::concat(acc, emitAbstractNominalForwardDeclaration(ctx.asm.entities.get(tk)@<CPPAssembly::AbstractNominalTypeDecl>, ctx, indent));
    });

    let datamember_fwddecls = nsdecl.datamembers.reduce<CString>(entity_fwddecls, fn(acc, tk) => {
        return CString::concat(acc, emitAbstractNominalForwardDeclaration(ctx.asm.datamembers.get(tk)@<CPPAssembly::AbstractNominalTypeDecl>, ctx, indent));
    });

    %% Emit our method and func fwd decls
    let nsfunc_fwddecls = nsdecl.nsfuncs.reduce<CString>(datamember_fwddecls, fn(acc, ikey) => {
        return CString::concat(acc, emitFunctionForwardDeclaration(ctx.asm.nsfuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, indent));
    });

    let typefunc_fwddecls = nsdecl.typefuncs.reduce<CString>(nsfunc_fwddecls, fn(acc, ikey) => {
        return CString::concat(acc, emitFunctionForwardDeclaration(ctx.asm.typefuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, indent));
    });

    %% Eventually will need to modify this to allow other method types
    let method_fwddecls = nsdecl.staticmethods.reduce<CString>(typefunc_fwddecls, fn(acc, mtkey) => {
        return CString::concat(acc, emitMethodForwardDeclaration(ctx.asm.staticmethods.get(mtkey.0), mtkey.1, ctx, indent));
    });

    return method_fwddecls;
}

recursive function emitForwardDeclarations(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: CString): CString {
    %% Emit namespace 
    let ns = CString::concat(indent, 'namespace ', nsdecl.nsname, ' {%n;');
    let full_indent = CString::concat('    ', indent);

    return CString::concat(ns, emitForwardDeclarationBody(nsdecl, ctx, full_indent), indent, '}%n;');
}

recursive function emitNamespaceDecl(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: CString): CString {
    %% Emit namespace 
    let ns = CString::concat(indent, 'namespace ', nsdecl.nsname, ' {%n;');
    let full_indent = CString::concat('    ', indent);

    let pconcepts = nsdecl.pconcepts.reduce<CString>(ns, fn(acc, tk) => {
        let tinfo = emitTypeInfo(ctx.asm.typeinfos.get(tk), none, false, full_indent);
        return CString::concat(acc, tinfo, emitPrimtiveConceptTypeDecl(ctx.asm.pconcepts.get(tk), ctx, full_indent));
    });

    %% Ensure no conflicts when accessing functions from other ns (might need to recursively explore other deeper ns)
    let subns_fwddecls = nsdecl.subns.reduce<CString>(pconcepts, fn(acc, name, subns) => {
        return CString::concat(acc, emitForwardDeclarations(subns, ctx, full_indent));
    });

    %% Fwd decls for all in current namespace
    let curns_fwddecls = CString::concat(subns_fwddecls, emitForwardDeclarationBody(nsdecl, ctx, full_indent));

    %% Emit sub-namespace declarations
    let subns = nsdecl.subns.reduce<CString>(curns_fwddecls, fn(acc, name, decl) => {
        return CString::concat(acc, emitNamespaceDecl[recursive](decl, ctx, full_indent));
    });

    %% All entities && their typeinfo
    let entities = nsdecl.entities.reduce<CString>(subns, fn(acc, tk) => {
        let e = ctx.asm.entities.get(tk);
        let emit_entity = emitEntityTypeDecl(e, tk.value, ctx, full_indent);
        return CString::concat(acc, emitAbstractNominalTypeDecl(e@<CPPAssembly::AbstractNominalTypeDecl>, e.fields, emit_entity, ctx, full_indent));
    });

    let datamembers = nsdecl.datamembers.reduce<CString>(entities, fn(acc, tk) => {
        let dm = ctx.asm.datamembers.get(tk);
        let emit_dm = emitDatatypeMemberEntityDecl(dm, ctx, full_indent);
        return CString::concat(acc, emitAbstractNominalTypeDecl(dm@<CPPAssembly::AbstractNominalTypeDecl>, dm.fields, emit_dm, ctx, full_indent));
    });

    %% Emit functions in current namespace
    let nsfuncs = nsdecl.nsfuncs.reduce<CString>(datamembers, fn(acc, ikey) => {
        return CString::concat(acc, emitFunctionDecl(ctx.asm.nsfuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, full_indent)); 
    });

    let typefuncs = nsdecl.typefuncs.reduce<CString>(nsfuncs, fn(acc, ikey) => {
        return CString::concat(acc, emitFunctionDecl(ctx.asm.typefuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, full_indent)); 
    });

    return CString::concat(typefuncs, indent, '}%n;');
}

function emitAssembly(asm: CPPAssembly::Assembly): String {    
    let ctx: Context = Context{ asm, CPPAssembly::NamespaceKey::from('Tmp'), List<CString>{''} }; %% No known namespace yet
 
    let primitive_typeinfos = asm.typeinfos.reduce<CString>('', fn(acc, tk, ti) => {
        return if(asm.isPrimtitiveType(tk)) then CString::concat(acc, emitTypeInfo(ti, none, false, '')) else acc;
    });

    %%
    %% We COULD get a bit spicy and emit pconcepts where T is a primitive here...
    %%

    let ns_emission = asm.nsdecls.reduce<CString>(primitive_typeinfos, fn(acc, nsname, nsdecl) => {
        return CString::concat(acc, emitNamespaceDecl[recursive](nsdecl, ctx, ''));
    });

    %% TODO: Other non namespace functions

    %% For CCharBuf and Unicode... will need to emit builtin functions explicitly

    let asstring = String::fromCString(ns_emission);
    let replace_this = String::fromCString(emitSpecialThis());

    let st = getSpecialTemplates();
    let replace_templates = (|String::fromCString(st.0), String::fromCString(st.1), String::fromCString(st.2)|);

    let first = asstring.replaceAllStringOccurrences(replace_templates.0, "ᐸ");
    let second = first.replaceAllStringOccurrences(replace_templates.1, "ᐧ");
    let third = second.replaceAllStringOccurrences(replace_templates.2, "ᐳ");
    let final = third.replaceAllStringOccurrences(replace_this, "tᖺis");

    return String::join("%n;", final, "%n;");
}