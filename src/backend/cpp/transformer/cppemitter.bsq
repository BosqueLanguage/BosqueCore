namespace CPPEmitter;

%% CPP Pre-defined backend
namespace PathStack {
    function emitPathStackCreate(): String {
        return "PathStack ps = PathStack::create();";
    }

    function emitPathStackLeft(): String {
        return "ps.left();";
    }

    function emitPathStackRight(): String {
        return "ps.right();";
    }

    function emitPathStackUp(): String {
        return "ps.up();";
    }
}

namespace CCharBuffer {
    %% Emit c++ for buffer creation here
}

namespace UnicodeCharBuffer {
    %% Emit c++ for buffer creation here
}

entity Context {
    field asm: CPPAssembly::Assembly;
    field fullns_key: CPPAssembly::NamespaceKey;
    field fullns_list: List<CString>;

    method updateCurrentNamespace(new_ns: CPPAssembly::NamespaceKey, new_nsname: List<CString>): Context {
        return this[fullns_key = new_ns, fullns_list = new_nsname ];
    }
}

function natToString(nat: Nat): String {
    return String::fromCString(nat.toCString());
}

function emitEnclosedParen(s: CString): String {
    if(s === '') {
        return "nullptr";
    }
    return String::fromCString(CString::concat('"', s, '"'));
}

function emitTypeKeyValue(tk: CPPAssembly::TypeKey): String {
    return String::fromCString(tk.value);
}

function emitInvokeKeyValue(ik: CPPAssembly::InvokeKey): String {
    return String::fromCString(ik.value);
}

function emitIdentifierValue(i: CPPAssembly::Identifier): String {
    return String::fromCString(i.value);
}

function emitVarIdentifierValue(vi: CPPAssembly::VarIdentifier): String {
    return String::fromCString(vi.value);
}

function emitSpecialThis(): String {
    return "𝐭𝐡𝐢𝐬";
}    

function emitThisReference(): String {
    return String::concat("&", emitSpecialThis());
}

%% Probably should name this better
function generateAccess(tk: CPPAssembly::TypeKey, ctx: Context): String {
    let tag = ctx.asm.typeinfos.tryGet(tk)@some.tag;
    switch(tag) {
        | CPPAssembly::Tag#Value => { return "."; }
        | CPPAssembly::Tag#Ref => { return "->"; }
        | CPPAssembly::Tag#Tagged => { return "."; } 
    }
}

%% Might want to get this running without the need for explicit access_ref
function getAccessor(basetk: CPPAssembly::TypeKey, accessingtk: CPPAssembly::TypeKey, ctx: Context): String {
    let accessor = generateAccess(basetk, ctx);
    return if(ctx.asm.typeinfos.get(accessingtk).tag === CPPAssembly::Tag#Ref) 
        then String::concat(accessor, "access_ref")
        else String::concat(accessor, "access");
}

function removeCommonPrefix(name: String, prefix: String): String {
    if(!name.startsWithString(prefix)) {
        return "";
    }
    return name.removePrefixString(prefix);
}

function emitBindVar(bname: CPPAssembly::VarIdentifier, convert: String, converttype: String, exp: String): String { 
    let name = emitVarIdentifier(bname); 
    let tbindtype = String::concat("[[maybe_unused]] ", converttype, " ");
    return String::concat(tbindtype, name, " = ", exp, convert, "; ");
}

function findFieldOffset(tk: CPPAssembly::TypeKey, fname: CPPAssembly::Identifier, ctx: Context): Nat {
    return ctx.asm.lookupNominalTypeDeclaration(tk).saturatedBFieldInfo
        .reduce<(|Nat, Bool|)>(fn(acc, f) => {
            if(acc.1 === false) {
                let found = fname.value === f.fname.value;
                let size = if(found) then 0n else ctx.asm.typeinfos.get(f.ftype.tkeystr).slotsize;
                return (|acc.0 + size, found|);
            }
            else {
                return acc;
            }
        }, (|0n, false|)).0;
}

function canUseDirectFieldAccess(act: CPPAssembly::AbstractConceptTypeDecl, fname: CPPAssembly::Identifier, ctx: Context): Bool, Nat {
    if(act.subtypes.size() == 0n) {
        return false, 0n;
    }
    
    let baseidx = findFieldOffset(act.subtypes.front(), fname, ctx);
    let allsubtypessame = act.subtypes.reduce<Bool>(fn(acc, subtype) => {
        return baseidx == findFieldOffset(subtype, fname, ctx);
    }, false);

    return allsubtypessame, baseidx;
}

%% We dont want __CoreCpp prefix when emitting typeinfo field for primitives
function removeCppPrefix(s: String): String {
    return if(s.startsWithString("__CoreCpp::")) then s.removePrefixString("__CoreCpp::") else s;
}

function convertCStringList(l: List<CString>): List<String> {
    return l.map<String>(fn(e) => String::fromCString(e));
}

function emitResolvedTemplates(tk: Option<CPPAssembly::TypeKey>, ik: Option<CPPAssembly::InvokeKey>, ctx: Context): String {
    if(tk?some && tk@some.value.startsWithString('(|')) { %% Handle elists explicitly
        return emitSpecialTemplate(String::fromCString(tk@some.value));
    }

    %% Handle Type Funcs explicitly as their InvokeKey is missing the "Core::" prefix
    let isTypeFunc = if(ik)@some then ctx.asm.typefuncs.has($ik) else false;
    
    var resolvedik: Option<CPPAssembly::InvokeKey>;
    match(ik) {
        | Some<CPPAssembly::InvokeKey> => { resolvedik = if(isTypeFunc) 
            then some(ctx.asm.typefuncs.get(ik@some).ikey) 
            else ik; }
        | None => { resolvedik = ik; }
    }

    var declaredInNS: String;
    match(tk) {
        | Some<CPPAssembly::TypeKey> => { 
            let ntk = tk@some;
            if(ctx.asm.primitives.has(ntk)) {
                %% CString and String are not defined in __CoreCpp
                let t = String::fromCString(ntk.value);
                if(t === "CString" || t === "String") {
                    return String::concat("Core::", t);
                }

                return t;
            }

            declaredInNS = emitNamespaceKey(ctx.asm.lookupNominalTypeDeclaration(ntk).declaredInNS); 
        }
        | None => { 
            declaredInNS = emitNamespaceKey(ctx.asm.tryLookupInvokeImplDeclaration(ik@some)@some.declaredInNS); 
        }
    }

    let key = if(tk)@some then emitTypeKeyValue($tk) else emitInvokeKeyValue(resolvedik@some);
    if(key.startsWithString("__CoreCpp")) {  
        return key;
    }
    else { 
        let ns = String::concat(declaredInNS, "::");
        let resolvedkey = if(ns.startsWithString("Core") && !key.startsWithString("Core")) 
            then String::concat("Core::", key)
            else key;
        let noprekey = removeCommonPrefix(resolvedkey, ns);
        let template = emitSpecialTemplate(noprekey);
        
        return if(template === "") then String::concat(ns, noprekey) 
            else String::concat(ns, template);
    }
}

function emitSpecialTemplate(name: String): String {
    if(name.startsWithString("__CoreCpp")) {
        return name;
    }
    
    return name
        .replaceAllStringOccurrences(" ", "")
        .replaceAllStringOccurrences("(|", "丨")
        .replaceAllStringOccurrences("|)", "丨")
        .replaceAllStringOccurrences("<", "ᐸ")
        .replaceAllStringOccurrences(",", "ᐧ")
        .replaceAllStringOccurrences(">", "ᐳ")
        .replaceAllStringOccurrences("::", "ᘏ");
}

function convertLambdaTypeSignature(lts: CPPAssembly::LambdaTypeSignature, ctx: Context): String {
    let resolved = emitResolvedNamespace(ctx.fullns_list, emitTypeKeyValue(lts.tkeystr));

    let replace = emitSpecialTemplate(resolved.replaceAllStringOccurrences("->", "$"))
        .replaceAllStringOccurrences("(", "_")
        .replaceAllStringOccurrences(")", "_");

    return String::concat("λ", replace);
}

%%
%% TODO: We need to go through all instances where emitTypeSignature is called and 
%% replace T/F with dontCheckTag or checkTag boolean constants
%%
function emitTypeSignature(ts: CPPAssembly::TypeSignature, shouldCheckTag: Bool, ctx: Context): String {
    if(ts)@<CPPAssembly::EListTypeSignature> {
        if(!shouldCheckTag) {
            return emitSpecialTemplate(String::fromCString($ts.tkeystr.value));
        }

        let argssizes = $ts.entries.map<String>(fn(e) => {
            let tinfo = ctx.asm.typeinfos.get(e.tkeystr);
            return if(tinfo.tag !== CPPAssembly::Tag#Ref) then String::fromCString(tinfo.slotsize.toCString())
                else "1";
        });
        let argstemplate = String::concat("<", String::joinAll(", ", argssizes), ">");
        let n = String::fromCString($ts.entries.size().toCString());

        return String::concat("__CoreCpp::Tuple", n, argstemplate);
    }
    if(ts)@<CPPAssembly::LambdaTypeSignature> {
        return convertLambdaTypeSignature($ts, ctx);
    }
    else {
        return emitTypeKey(ts.tkeystr, shouldCheckTag, ctx);
    }
}

function emitTypeKey(tk: CPPAssembly::TypeKey, shouldCheckTag: Bool, ctx: Context): String {
    let emit = emitResolvedNamespace(ctx.fullns_list, emitResolvedTemplates(some(tk), none, ctx)); 

    if(shouldCheckTag) {
        let tinfo = ctx.asm.typeinfos.tryGet(tk)@some;

        switch(tinfo.tag) {
            | CPPAssembly::Tag#Value => { return emit; }
            | CPPAssembly::Tag#Ref => { return String::concat(emit, "*"); }
            | CPPAssembly::Tag#Tagged => { return emit; }
        }
    }
    return emit;
}

function emitIdentifier(i: CPPAssembly::Identifier): String {
    return emitSpecialTemplate(emitIdentifierValue(i));
}

function emitVarIdentifier(vi: CPPAssembly::VarIdentifier): String {
    let vival = emitVarIdentifierValue(vi);
    if(vival === "this") {
        return emitSpecialThis();
    }
    elif (vival === "$this") {
        return String::concat("$", emitSpecialThis());
    }
    else {
        return emitSpecialTemplate(vival);
    }
}

function emitInvokeKey(ik: CPPAssembly::InvokeKey, ctx: Context): String {
    return emitResolvedNamespace(ctx.fullns_list, emitResolvedTemplates(none, some(ik), ctx)); 
}

function generateMethodName(m: CPPAssembly::InvokeKey, declaredIn: CPPAssembly::TypeKey, ctx: Context): String {
    let mdecl = ctx.asm.lookupNominalTypeDeclaration(declaredIn);
    let mdeclname = emitTypeKey(declaredIn, false, ctx);
    let updatedname = if(mdeclname.startsWithString("__CoreCpp::"))
        then removeCppPrefix(mdeclname)
        else mdeclname;

    %% Internal types like our char buffers do not contain 'Core' in their typekey
    var removeDeclaredIn: CString;
    if(m.value.startsWithString(declaredIn.value)) {
        removeDeclaredIn = m.value.removePrefixString(declaredIn.value).removePrefixString('::');
    }
    else {
        removeDeclaredIn = m.value.removePrefixString(mdecl.name).removePrefixString('::');
    }

    %% If we are not in core but calling internal primitive method (i.e. nat to cstring) attach core prefix
    let isInternalEntityMethodInvoke: Bool = 
        ctx.asm.lookupNominalTypeDeclaration(declaredIn)?<CPPAssembly::InternalEntityTypeDecl> 
        && ctx.fullns_list.front() !== 'Core'
        && !updatedname.startsWithString("Core");

    let basename = String::fromCString(removeDeclaredIn);
    let final = if(isInternalEntityMethodInvoke)
        then String::concat("Core::", updatedname, "ᘏ", emitSpecialTemplate(basename))
        else String::concat(updatedname, "ᘏ", emitSpecialTemplate(basename));

    return final;
}

function emitNamespaceKey(nsk: CPPAssembly::NamespaceKey): String {
    return String::fromCString(nsk.value);
}

%% For constructing concepts
function generateAccessorForSpecialTypeConstructor(constype: CPPAssembly::TypeSignature, ttype: CPPAssembly::TypeSignature, 
    eexp: String, ctx: Context): String {
        let econstype = emitTypeSignature(constype, false, ctx);
        let ettype = String::concat(removeCppPrefix(emitTypeSignature(ttype, false, ctx)), "Type");
        
        %% Since our collections are just alias for underlying data structure we dont need to emit explicit constructors 
        if(ctx.asm.lookupNominalTypeDeclaration(constype.tkeystr))<CPPAssembly::ListTypeDecl> {
            return eexp;
        }
        if(ctx.asm.lookupNominalTypeDeclaration(constype.tkeystr))<CPPAssembly::MapTypeDecl> {
            return eexp;
        }
        if(ctx.asm.lookupNominalTypeDeclaration(constype.tkeystr))<CPPAssembly::CRopeTypeDecl> {
            return eexp;
        }
        if(ctx.asm.lookupNominalTypeDeclaration(constype.tkeystr))<CPPAssembly::UnicodeRopeTypeDecl> {
            return eexp;
        }
        
        return if(eexp === "") then String::concat(econstype, "( &", ettype, " )")
            else String::concat(econstype, "( &", ettype, ", ", eexp, " )");
        
}

%% Given a namespace key (like Main::Foo::Bar), remove all matching prefix strings
function emitResolvedNamespace(fullns_list: List<CString>, fullns: String): String {
    return fullns_list.reduce<String>(fn(acc, s) => {
        let val = String::fromCString(s);
        if(acc.startsWithString(val)) {
            let nopre = acc.removePrefixString(val);
            if(nopre.startsWithString("::")) {
                return nopre.removePrefixString("::");
            }
            else {
                return nopre;
            }
        }
        else {
            return acc;
        }
    }, fullns);
}

function emitLiteralSimpleExpression(exp: CPPAssembly::LiteralSimpleExpression): String {
    let val = String::fromCString(exp.value);
    let etype = String::fromCString(exp.etype.tkeystr.value);
    switch(etype) {
        | "__CoreCpp::Int" => { return String::concat(val, "_i"); }
        | "__CoreCpp::BigInt" => { return String::concat(val, "_I"); } 
        | "__CoreCpp::Nat" => { return String::concat(val, "_n"); }
        | "__CoreCpp::BigNat" => { return String::concat(val, "_N"); }
        | "__CoreCpp::Float" => { return String::concat(val, "_f"); }
        | "__CoreCpp::Bool" => { return val; }
        | _ => { abort; }
    }
}

function emitLiteralNoneExpression(exp: CPPAssembly::LiteralNoneExpression, ctx: Context): String {
    return "INTPTR_MAX";
}

function emitAccessVariableExpression(exp: CPPAssembly::AccessVariableExpression, ctx: Context): String {
    return emitVarIdentifier(exp.vname);
}

function emitReturnSingleStatement(ret: CPPAssembly::ReturnSingleStatement, ctx: Context, indent: String): String {
    let exp = emitExpression(ret.value, ctx);

    let full_indent: String = String::concat(indent, "    ");
    return String::concat(full_indent, "return ", exp, ";%n;");
}

recursive function emitBinAddExpression(add: CPPAssembly::BinAddExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](add.lhs, ctx);
    let rhs = emitExpression[recursive](add.rhs, ctx);

    return String::concat("(", lhs, " + ", rhs, ")");
}

recursive function emitBinSubExpression(sub: CPPAssembly::BinSubExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](sub.lhs, ctx);
    let rhs = emitExpression[recursive](sub.rhs, ctx);

    return String::concat("(", lhs, " - ", rhs, ")");
}

recursive function emitBinDivExpression(div: CPPAssembly::BinDivExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](div.lhs, ctx);
    let rhs = emitExpression[recursive](div.rhs, ctx);

    return String::concat("(", lhs, " / ", rhs, ")");
}

recursive function emitBinMultExpression(mult: CPPAssembly::BinMultExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](mult.lhs, ctx);
    let rhs = emitExpression[recursive](mult.rhs, ctx);

    return String::concat("(", lhs, " * ", rhs, ")");
}

recursive function emitBinaryArithExpression(e: CPPAssembly::BinaryArithExpression, ctx: Context): String {
    match(e)@ {
        | CPPAssembly::BinAddExpression => { return emitBinAddExpression[recursive]($e, ctx); }
        | CPPAssembly::BinSubExpression => { return emitBinSubExpression[recursive]($e, ctx); }
        | CPPAssembly::BinDivExpression => { return emitBinDivExpression[recursive]($e, ctx); }
        | CPPAssembly::BinMultExpression => { return emitBinMultExpression[recursive]($e, ctx); }
    }
}

recursive function emitPrefixNotOpExpression(notop: CPPAssembly::PrefixNotOpExpression, ctx: Context): String {
    let expr = emitExpression[recursive](notop.expr, ctx);
    return String::concat("!(", expr, ")");
}

recursive function emitPrefixNegateOpExpression(negop: CPPAssembly::PrefixNegateOpExpression, ctx: Context): String {
    let expr = emitExpression[recursive](negop.expr, ctx);
    return String::concat("-", expr);
}

recursive function emitPrefixPlusOpExpression(plusop: CPPAssembly::PrefixPlusOpExpression, ctx: Context): String {
    return emitExpression[recursive](plusop.expr, ctx);
}

recursive function emitUnaryExpression(e: CPPAssembly::UnaryExpression, ctx: Context): String {
    match(e)@ {
        | CPPAssembly::PrefixNotOpExpression => { return emitPrefixNotOpExpression[recursive]($e, ctx); }
        | CPPAssembly::PrefixNegateOpExpression => { return emitPrefixNegateOpExpression[recursive]($e, ctx); }
        | CPPAssembly::PrefixPlusOpExpression => { return emitPrefixPlusOpExpression[recursive]($e, ctx); }
    }
}

recursive function emitNumericEqExpression(e: CPPAssembly::NumericEqExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " == ", rhs, ")");   
}

recursive function emitNumericNeqExpression(e: CPPAssembly::NumericNeqExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " != ", rhs, ")");   
}

recursive function emitNumericLessExpression(e: CPPAssembly::NumericLessExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " < ", rhs, ")");   
}

recursive function emitNumericLessEqExpression(e: CPPAssembly::NumericLessEqExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " <= ", rhs, ")");   
}

recursive function emitNumericGreaterExpression(e: CPPAssembly::NumericGreaterExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " > ", rhs, ")");   
}

recursive function emitNumericGreaterEqExpression(e: CPPAssembly::NumericGreaterEqExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);

    return String::concat("(", lhs, " >= ", rhs, ")");   
}

recursive function emitBinaryNumericExpression(e: CPPAssembly::BinaryNumericExpression, ctx: Context): String {
    match(e)@ {
        | CPPAssembly::NumericEqExpression => { return emitNumericEqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericNeqExpression => { return emitNumericNeqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericLessExpression => { return emitNumericLessExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericLessEqExpression => { return emitNumericLessEqExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericGreaterExpression => { return emitNumericGreaterExpression[recursive]($e, ctx); }
        | CPPAssembly::NumericGreaterEqExpression => { return emitNumericGreaterEqExpression[recursive]($e, ctx); }
    }
}

recursive function emitBinLogicAndExpression(e: CPPAssembly::BinLogicAndExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);   

    return String::concat("(", lhs, " && ", rhs, ")");
}

recursive function emitBinLogicOrExpression(e: CPPAssembly::BinLogicOrExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);   

    return String::concat("(", lhs, " || ", rhs, ")");
}

recursive function emitBinLogicImpliesExpression(e: CPPAssembly::BinLogicImpliesExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx);  

    let implies: String = String::concat("!(", lhs, ") || ", rhs);
    return String::concat("(", implies ,")");
}

recursive function emitBinLogicIFFExpression(e: CPPAssembly::BinLogicIFFExpression, ctx: Context): String {
    let lhs = emitExpression[recursive](e.lhs, ctx);
    let rhs = emitExpression[recursive](e.rhs, ctx); 
    let nlhs: String = String::concat("!(", lhs, ")");
    let nrhs: String = String::concat("!(", rhs, ")");

    let first: String = String::concat("(", lhs, " && ", rhs, ")");
    let second: String = String::concat("(", nlhs, " && ", nrhs, ")");

    return String::concat("(", first, " || ", second, ")");
}

recursive function emitBinLogicExpression(e: CPPAssembly::BinLogicExpression, ctx: Context): String {
    match(e)@ {
        | CPPAssembly::BinLogicAndExpression => { return emitBinLogicAndExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicOrExpression => { return emitBinLogicOrExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicImpliesExpression => { return emitBinLogicImpliesExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicIFFExpression => { return emitBinLogicIFFExpression[recursive]($e, ctx); }
    }
}

function emitArguments(al: List<CPPAssembly::Expression>, ctx: Context): String {
    let emit_al = al.map<String>(fn(arg) => emitExpression(arg, ctx));
    return String::joinAll(", ", emit_al);
}

function emitCallNamespaceFunctionExpression(e: CPPAssembly::CallNamespaceFunctionExpression, ctx: Context): String { 
    let name = emitInvokeKey(e.ikey, ctx);
    let nsfunc = ctx.asm.nsfuncs.get(e.ikey); 
    let args = emitArguments(e.args, ctx); 

    return String::concat(name, "(", args, ")");
}

function emitCallTypeFunctionExpression(e: CPPAssembly::CallTypeFunctionExpression, ctx: Context): String { 
    let typefunc = ctx.asm.typefuncs.get(e.ikey);
    let name = emitInvokeKey(typefunc.ikey, ctx);
    let args = emitArguments(e.args, ctx); 

    return String::concat(name, "(", args, ")");
}

function emitCallTypeFunctionSpecialExpression(e: CPPAssembly::CallTypeFunctionSpecialExpression, ctx: Context): String {
%*
    let typefunc = ctx.asm.typefuncs.get(e.ikey);
    let name = emitInvokeKey(typefunc.ikey, ctx);
    let args = emitArguments(e.args, ctx); 
*%
    %%
    %% TODO: name and exp and how to properly emit
    %%

    return "";
}

function emitPostfixAccessFromName(op: CPPAssembly::PostfixAccessFromName, ctx: Context): String {
    let op_tinfo = ctx.asm.typeinfos.get(op.declaredInType.tkeystr);
    let base_tinfo = ctx.asm.typeinfos.get(op.baseType.tkeystr);
    let ident = emitIdentifier(op.name);

    %% We dont want to try to do ".value" on a collection/type (they just emit as the underlying datastructure)
    if(ctx.asm.collections.has(op.baseType.tkeystr) || ctx.asm.stringoftypedecls.has(op.baseType.tkeystr)) {
        return "";
    }

    if(ctx.asm.isNominalTypeConcept(op.baseType.tkeystr)) {
        let e = ctx.asm.lookupNominalTypeDeclaration(op.baseType.tkeystr)@<CPPAssembly::AbstractConceptTypeDecl>;
        let canresolve, offset = canUseDirectFieldAccess(e, op.name, ctx);
        let fieldaccessor = generateAccess(op.ftype.tkeystr, ctx);
        let fieldaccess = String::concat(fieldaccessor, ident);
        let accessType = getAccessor(op.baseType.tkeystr, op.ftype.tkeystr, ctx);
        
        if(canresolve) {
            %% Subtype here does not matter as all agree on this fields position
            let anysubtype = emitTypeKey(e.subtypes.front(), false, ctx);
            return String::concat(accessType, "<", anysubtype, ">()", fieldaccess);
        }
        else {
            let ftype = emitTypeSignature(op.ftype, true, ctx);
            let declaredInType = emitTypeSignature(op.declaredInType, false, ctx);
            let enumentry = String::concat(", ", declaredInType, "_entries::", declaredInType, "_", ident);
            let args = String::concat(declaredInType, "Type.vtable)", fieldaccess);
            return String::concat(accessType, "vlookup<", ftype, enumentry, ">(", args); 
        }
    }
    else {
        let accessor = generateAccess(op.baseType.tkeystr, ctx);
        return String::concat(accessor, ident);
    }
}

%% Probably just struct.field = val
function emitPostfixAssignFields(op: CPPAssembly::PostfixAssignFields, rootexp: String, ctx: Context): String {
    return "";
}

%% Assumes access type is elist (I believe this is the only type accessable via postfix index)
function generateAccessFromIndex(idx: Nat, accessing: CPPAssembly::TypeSignature, ctx: Context): String {
    let accessed = emitTypeSignature(accessing, true, ctx);
    let accessidx = natToString(idx);

    return String::concat(".access<", accessed, ", ", accessidx, ">()");
}

function emitPostfixAccessFromIndex(op: CPPAssembly::PostfixAccessFromIndex, acc: String, ctx: Context): String {
    let idx = Nat::fromCString(op.idx);
    let accesstype = op.baseType@<CPPAssembly::EListTypeSignature>.entries.get(idx);
    let access = generateAccessFromIndex(idx, accesstype, ctx);

    return String::concat(acc, access);
}

function emitPostfixInvokeStatic(op: CPPAssembly::PostfixInvokeStatic, rootexp: String, ctx: Context): String {
    let args = emitArguments(op.args, ctx);

    %% The "this" arguemnt does not exist in explicitify so we handle the coersion here (we manually added it for cpp emission)
    var thisarg: String;
    if(!ctx.asm.areTypesSame(op.baseType, op.resolvedType)) {
        let roottinfo = ctx.asm.typeinfos.get(op.baseType.tkeystr);
        let slotsize = if(roottinfo.tag === CPPAssembly::Tag#Tagged) then roottinfo.slotsize - 1n else roottinfo.slotsize;
        let eexp = if(slotsize == 0n) then "" else rootexp;

        thisarg = generateAccessorForSpecialTypeConstructor(op.resolvedType, op.baseType, eexp, ctx);
    }
    else {
        thisarg = rootexp;
    } 

    let name = generateMethodName(op.resolvedTrgt, op.resolvedType.tkeystr, ctx);
    if(args === "") {
        return String::concat(name, "(", thisarg, ")");
    }
    else {
        return String::concat(name, "(", thisarg, ", ", args, ")");       
    }
}

function emitPostfixAccessSomeValue(op: CPPAssembly::PostfixAccessSomeValue, acc: String, baseType: CPPAssembly::TypeSignature, ctx: Context): String {
    return String::concat(acc, ".value"); 
}

recursive function conceptProvidesConcept(lhs: CPPAssembly::AbstractConceptTypeDecl, rhs: CPPAssembly::TypeSignature, ctx: Context): Bool {
    %% Walk subtypes of lhs to find if any provide rhs
    let providesRHS = lhs.subtypes.reduce<Bool>( 
        fn(acc, subtype) => {
            if(ctx.asm.isNominalTypeConcrete(subtype)) {
                let lhs = ctx.asm.lookupNominalTypeDeclaration(subtype)@<CPPAssembly::AbstractEntityTypeDecl>;
                return lhs.saturatedProvides.someOf(pred(st) => st.tkeystr === rhs.tkeystr);
            }
            else {
                let lhs = ctx.asm.lookupNominalTypeDeclaration(subtype)@<CPPAssembly::AbstractConceptTypeDecl>;
                return conceptProvidesConcept[recursive](lhs, rhs, ctx);
            }
        }, 
        false
    );

    return providesRHS;
}

function emitBooleanBasedOnCondition(cond: Bool): String {
    return if(cond)
        then "true"
        else "false";
}

function emitBooleanWithMaybeUnusedVariable(cond: Bool, arg: String): String {
    return if(cond)
        then String::concat("__CoreCpp::True(", arg, ")")
        else String::concat("__CoreCpp::False(", arg, ")");
}

function emitITestType(it: CPPAssembly::ITestType, baseType: CPPAssembly::TypeSignature, acc: String, ctx: Context): String {
    if(ctx.asm.isNominalTypeConcrete(it.ttype.tkeystr) && ctx.asm.isNominalTypeConcrete(baseType.tkeystr)) {
        let areTypesSame = ctx.asm.areTypesSame(it.ttype, baseType);
        return if(it.isnot) 
            then emitBooleanBasedOnCondition(!areTypesSame)
            else emitBooleanBasedOnCondition(areTypesSame);
    }
    else {
        let accessor = String::concat(generateAccess(baseType.tkeystr, ctx), "typeinfo");
        if(ctx.asm.isNominalTypeConcrete(it.ttype.tkeystr)) {
            let ttype = emitTypeSignature(it.ttype, false, ctx);
            return if(it.isnot) 
                then String::concat(acc, accessor, " != &", ttype, "Type")
                else String::concat(acc, accessor, " == &", ttype, "Type");
        }
        else {
            let lhs = ctx.asm.lookupNominalTypeDeclaration(baseType.tkeystr)@<CPPAssembly::AbstractConceptTypeDecl>;
            if(conceptProvidesConcept(lhs, it.ttype, ctx)) {
                return emitBooleanWithMaybeUnusedVariable(!it.isnot, acc);
            }
            else {
                return emitBooleanWithMaybeUnusedVariable(it.isnot, acc);
            }
        }
    }
}

function emitITestSome(it: CPPAssembly::ITestSome, baseType: CPPAssembly::TypeSignature, acc: String, ctx: Context): String {
    let accessor = String::concat(generateAccess(baseType.tkeystr, ctx), "typeinfo");
    return if(it.isnot) 
        then String::concat(acc, accessor, " == &NoneType") 
        else String::concat(acc, accessor, " != &NoneType");
}

function emitITestNone(it: CPPAssembly::ITestNone, baseType: CPPAssembly::TypeSignature, acc: String, ctx: Context): String {
    let accessor = String::concat(generateAccess(baseType.tkeystr, ctx), "typeinfo");
    return if(it.isnot) 
        then String::concat(acc, accessor, " != &NoneType") 
        else String::concat(acc, accessor, " == &NoneType");
}

function emitITestAsTest(it: CPPAssembly::ITest, baseType: CPPAssembly::TypeSignature, acc: String, ctx: Context): String {
    match(it)@ {
        | CPPAssembly::ITestType => { return emitITestType($it, baseType, acc, ctx); }
        | CPPAssembly::ITestNone => { return emitITestNone($it, baseType, acc, ctx); }
        | CPPAssembly::ITestSome => { return emitITestSome($it, baseType, acc, ctx); }
        | CPPAssembly::ITestOk => { abort; }
        | CPPAssembly::ITestFail => { abort; }
    }
}

function emitITestAsConvertNone(isnot: Bool, fromtype: CPPAssembly::TypeKey, ctx: Context): (|String, String|) {
    if(isnot) {
        return emitITestAsConvertSome(false, fromtype, ctx);
    }
    else { %% I dont love this but it works
        return (|String::concat(getAccessor(fromtype, CPPAssembly::TypeKey::from('__CoreCpp::None'), ctx), "none()"), "__CoreCpp::None" |);
    }
}

function emitITestAsConvertSome(isnot: Bool, fromtype: CPPAssembly::TypeKey, ctx: Context): (|String, String|) {
    let ant = ctx.asm.lookupNominalTypeDeclaration(fromtype);
    
    if(ant)@<CPPAssembly::OptionTypeDecl> {
        if(isnot) {
            return emitITestAsConvertNone(false, fromtype, ctx);
        }
        else {
            return (|String::concat(getAccessor(fromtype, $ant.someType.tkeystr, ctx), "<", emitTypeSignature($ant.someType, true, ctx), ">().value"),
                emitTypeSignature($ant.oftype, true, ctx)|);
        }
    }
    else {
        abort; %% Only options are supported for now
    }
}

function emitITestAsConvertType(isnot: Bool, fromtype: CPPAssembly::TypeKey, totype: CPPAssembly::TypeKey, ctx: Context): (|String, String|) { 
    let ttype = if(isnot) then fromtype else totype;
    let emittotype = emitTypeKey(ttype, false, ctx);

    %% We want to make sure we return the totype as a possible field here(our access method handles ref case)
    return if(fromtype.value === ttype.value) then (|"", emitTypeKey(ttype, true, ctx)|) 
        else (|String::concat(getAccessor(fromtype, totype, ctx), "<", emittotype, ">()"), emitTypeKey(ttype, true, ctx)|);
}

function emitITestAsConvert(isnot: Bool, itc: CPPAssembly::ITest, fromtype: CPPAssembly::TypeKey, totype: Option<CPPAssembly::TypeKey>, ctx: Context): (|String, String|) { %% Convert, Emitted type
    match(itc)@ {
        | CPPAssembly::ITestType => { 
            let ntotype = if(totype)none then $itc.ttype.tkeystr else totype@some; %% For postfix itest convert case
            return emitITestAsConvertType(isnot, fromtype, ntotype, ctx); 
        }
        | CPPAssembly::ITestNone => { return emitITestAsConvertNone(isnot, fromtype, ctx); }
        | CPPAssembly::ITestSome => { return emitITestAsConvertSome(isnot, fromtype, ctx); }
        | CPPAssembly::ITestOk => { abort; }
        | CPPAssembly::ITestFail => { abort; }
    }
}

function emitPostfixOp(pop: CPPAssembly::PostfixOp, ctx: Context): String {
    let rootExp = emitExpression(pop.rootExp, ctx);
    let rootType = emitTypeSignature(pop.rootExp.etype, false, ctx);

    return pop.ops.reduce<String>(fn(acc, op) => {
        match(op)@ {
            | CPPAssembly::PostfixAccessFromName => { return String::concat(acc, emitPostfixAccessFromName($op, ctx)); }
            | CPPAssembly::PostfixAccessFromIndex => { return emitPostfixAccessFromIndex($op, acc, ctx); }
            | CPPAssembly::PostfixIsTest => { return emitITestAsTest($op.ttest, $op.baseType, acc, ctx); }
            | CPPAssembly::PostfixAsConvert => { return String::concat(acc, emitITestAsConvert($op.ttest.isnot, $op.ttest, $op.baseType.tkeystr, none, ctx).0); }
            | CPPAssembly::PostfixInvokeStatic => { return emitPostfixInvokeStatic($op, acc, ctx); } 
            | CPPAssembly::PostfixAssignFields => { return emitPostfixAssignFields($op, acc, ctx); }
            | CPPAssembly::PostfixBoolConstant => { return if($op.value === true) then "true" else "false"; }
            | CPPAssembly::PostfixAccessSomeValue => { return emitPostfixAccessSomeValue($op, acc, pop.rootExp.etype, ctx); }
        }
    }, rootExp);
}

function emitConstructorPrimarySpecialSomeExpression(cpsse: CPPAssembly::ConstructorPrimarySpecialSomeExpression, ctx: Context): String {
    let value = emitExpression(cpsse.value, ctx);
    let sometype = emitTypeSignature(cpsse.ctype, false, ctx);

    return String::concat(sometype, "( ", value, ")");
}

function emitConstructorPrimarySpecialOkExpression(cpsoe: CPPAssembly::ConstructorPrimarySpecialOkExpression, ctx: Context): String {
    abort; %% TODO: Not implemented!
}

function emitConstructorPrimarySpecialFailExpression(cpsfe: CPPAssembly::ConstructorPrimarySpecialFailExpression, ctx: Context): String {
    abort; %% TODO: Not Implemented!
}

function emitConstructorPrimarySpecialMapEntryExpression(cpsmee: CPPAssembly::ConstructorPrimarySpecialMapEntryExpression, ctx: Context): String {
    let key = emitExpression(cpsmee.key, ctx);
    let value = emitExpression(cpsmee.value, ctx);
    let metype = emitTypeSignature(cpsmee.ctype, false, ctx);

    return String::concat(metype, "( ", key, ",", value, " )");
}

function emitConstructorPrimarySpecialConstructableExpression(exp: CPPAssembly::ConstructorPrimarySpecialConstructableExpression, ctx: Context): String {    
    match(exp)@ {
        | CPPAssembly::ConstructorPrimarySpecialSomeExpression => { return emitConstructorPrimarySpecialSomeExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialOkExpression => { return emitConstructorPrimarySpecialOkExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialFailExpression => { return emitConstructorPrimarySpecialFailExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialMapEntryExpression => { return emitConstructorPrimarySpecialMapEntryExpression($exp, ctx); }
    }
}

function generateGCAlloc(ti: CPPAssembly::TypeInfo): String {
    return String::concat("alloc", natToString(ti.slotsize));
}

function callGCAlloc(ti: CPPAssembly::TypeInfo, constype: String, cons: String): String {
    let alloc = generateGCAlloc(ti);
    let body = String::concat(constype, ", ", alloc, ", &", constype, "Type");
    
    return String::concat("𝐀𝐥𝐥𝐨𝐜𝐓𝐲𝐩𝐞( ", body, ", (", cons, ") )");
}

function emitConstructorStdExpression(exp: CPPAssembly::ConstructorStdExpression, ctx: Context): String {
    let emitargs = emitArguments(exp.args, ctx); 
    let name = emitTypeSignature(exp.ctype, false, ctx);
    let tinfo = ctx.asm.typeinfos.get(exp.ctype.tkeystr);
    let ant = ctx.asm.lookupNominalTypeDeclaration(exp.ctype.tkeystr);

    var cons: String;
    if(ant)@<CPPAssembly::DatatypeMemberEntityTypeDecl> { 
        if($ant.saturatedBFieldInfo.size() == 0n) { %% Boxed<0> case
            cons = "";
        }
        else {
            cons = String::concat(name, "( ", emitargs, " )");
        }
    }
    else {
        cons = String::concat(name, "( ", emitargs, " )");
    }

    if(tinfo.tag === CPPAssembly::Tag#Ref) {
        return String::concat(callGCAlloc(tinfo, name, cons)); 
    }
    return cons;
}

function emitConstructorEListExpression(exp: CPPAssembly::ConstructorEListExpression, ctx: Context): String {
    if(exp.args.size() > 4n) {
        abort; %% Tuples of size > 4 not supported yet
    }
    let ceetype = emitTypeSignature(exp.etype, true, ctx);
    let args = String::joinAll(", ", exp.args.map<String>(fn(e) => emitExpression(e, ctx))); 

    return String::concat(ceetype, "(", args, ")");
}

function emitConstructorPrimaryListExpression(exp: CPPAssembly::ConstructorPrimaryListExpression, ctx: Context): String {
    let args = emitArguments(exp.args, ctx);
    let ns = "Core::ListOps::"; %% So long as lists impl stays in Core::ListOps this will hold 

    let name = emitSpecialTemplate(removeCppPrefix(String::fromCString(exp.elemtype.tkeystr.value)));
    let ofttype = String::concat("ᐸ", name, "ᐳ");
    switch(exp.args.size()) {
        | 0n => { return String::concat(ns, "s_list_create_empty", ofttype, "()"); }
        | 1n => { return String::concat(ns, "s_list_create_1", ofttype, "(", args, ")"); }
        | 2n => { return String::concat(ns, "s_list_create_2", ofttype, "(", args, ")"); }
        | 3n => { return String::concat(ns, "s_list_create_3", ofttype, "(", args, ")"); }
        | 4n => { return String::concat(ns, "s_list_create_4", ofttype, "(", args, ")"); }
        | 5n => { return String::concat(ns, "s_list_create_5", ofttype, "(", args, ")"); }
        | 6n => { return String::concat(ns, "s_list_create_6", ofttype, "(", args, ")"); }
        | _ =>  { abort; }
    }
}

function emitConstructorPrimaryMapExpression(exp: CPPAssembly::ConstructorPrimaryMapExpression, ctx: Context): String {
    let args = emitArguments(exp.args, ctx);
    let ns = "Core::MapOps::"; %% So long as maps impl stays in Core::MapOps this will hold 
    
    let ktype = String::fromCString(exp.keytype.tkeystr.value);
    let vtype = String::fromCString(exp.valuetype.tkeystr.value);
    
    let resolvedktype = removeCppPrefix(ktype);
    let resolvedvtype = removeCppPrefix(vtype);
    
    let template = String::concat("ᐸ", resolvedktype, "ᐧ", resolvedvtype, "ᐳ");

    switch(exp.args.size()) {
        | 0n =>   { return String::concat(ns, "s_map_create_empty", template, "()"); }
        | 1n => { return String::concat(ns, "s_map_create_1", template, "(", args, ")"); }
        | 2n => { return String::concat(ns, "s_map_create_2", template, "(", args, ")"); } 
        | _ => { abort; }
    }
}

function emitConstructorPrimaryCollectionSingletonExpression(exp: CPPAssembly::ConstructorPrimaryCollectionSingletonsExpression, ctx: Context): String {
    match(exp)@ {
        | CPPAssembly::ConstructorPrimaryListExpression => { return emitConstructorPrimaryListExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimaryMapExpression => { return emitConstructorPrimaryMapExpression($exp, ctx); }
    }
}

function emitConstructorPrimaryExpression(exp: CPPAssembly::ConstructorPrimaryExpression, ctx: Context): String {
    match(exp)@ {
        | CPPAssembly::ConstructorStdExpression => { return emitConstructorStdExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimarySpecialConstructableExpression => { return emitConstructorPrimarySpecialConstructableExpression($exp, ctx); }
        | CPPAssembly::ConstructorPrimaryCollectionSingletonsExpression => { return emitConstructorPrimaryCollectionSingletonExpression($exp, ctx); }
    }
}

function emitConstructorExpression(exp: CPPAssembly::ConstructorExpression, ctx: Context): String {
    match(exp)@ {
        | CPPAssembly::ConstructorPrimaryExpression => { return emitConstructorPrimaryExpression($exp, ctx); }
        | CPPAssembly::ConstructorEListExpression => { return emitConstructorEListExpression($exp, ctx); }
    }
}

function emitIfTestExpression(exp: CPPAssembly::IfTestExpression, i: String, t: String, e: String, ctx: Context): String {
    let itest = String::concat(i, emitITestAsTest(exp.itest, exp.texp.etype, "", ctx)); %% Likely doesnt work if the itest is just bool

    let ite = String::concat(itest, " ? (", t, ") : (", e, ")");
    return String::concat("( ", ite, " )");
}

%% TODO: Both this and convert maybe special case will need to handle abstract concepts
function getSubtypeCount(tk: CPPAssembly::TypeKey, ctx: Context): Nat, CPPAssembly::AbstractNominalTypeDecl {
    let concretetype = ctx.asm.lookupNominalTypeDeclaration(tk);
    if(concretetype)@<CPPAssembly::DatatypeTypeDecl> {
        return $concretetype.associatedMemberEntityDecls.size(), concretetype;
    }
    else {
        return 0n, concretetype;
    }
}

%% Handles special case convert where we have two member entities 
function doConvertMaybeSpecialCase(isnot: Bool, itest: CPPAssembly::ITest, fromtype: CPPAssembly::TypeKey, totype: Option<CPPAssembly::TypeKey>, 
    ctx: Context): (|String, String|) {
        let n, concretetype = getSubtypeCount(fromtype, ctx);

        if(n == 2n) {
            let othermember = concretetype@<CPPAssembly::DatatypeTypeDecl>
                .associatedMemberEntityDecls.find(
                    pred(ets) => !ctx.asm.areTypesSame(ets, itest@<CPPAssembly::ITestType>.ttype)).tkeystr;

            return if(isnot === true) then emitITestAsConvert(false, itest, fromtype, some(othermember), ctx)
                else emitITestAsConvert(isnot, itest, fromtype, totype, ctx);         
        }
        else {
            return emitITestAsConvert(isnot, itest, fromtype, totype, ctx); 
        }
}

%% TODO: We should format this a bit better as these expressions get quite long
function emitIfBinderExpression(exp: CPPAssembly::IfBinderExpression, i: String, t: String, e: String, ctx: Context): String {
    let capture = String::concat("[&]() -> ", emitTypeKey(exp.etype.tkeystr, false, ctx), " { ");
    let etype = exp.texp.etype; 

    let itest = String::concat(i, emitITestAsTest(exp.itest, exp.texp.etype, "", ctx));

    let tconvert = doConvertMaybeSpecialCase(exp.itest.isnot, exp.itest, etype.tkeystr, none, ctx);
    let treassign = emitBindVar(exp.binder.srcname, tconvert.0, tconvert.1, i);
    let texp = String::concat(capture, treassign, "return ", t, "; }() ");

    let fconvert = doConvertMaybeSpecialCase(!exp.itest.isnot, exp.itest, etype.tkeystr, none, ctx);
    let freassign = emitBindVar(exp.binder.srcname, fconvert.0, fconvert.1, i);
    let fexp = String::concat(capture, freassign, "return ", e, "; }() ");

    let ibe = String::concat( itest, " ? (", texp, ") : (", fexp, ")");
    return String::concat( "( ", ibe, " )");
}

function emitIfExpression(exp: CPPAssembly::IfExpression, ctx: Context): String {
    let texp = emitExpression(exp.texp, ctx);
    let thenexp = emitExpression(exp.thenexp, ctx);
    let elseexp = emitExpression(exp.elseexp, ctx);

    match(exp)@ {
        | CPPAssembly::IfSimpleExpression => { 
            let ise = String::concat(texp, " ? (", thenexp, ") : (", elseexp, ")");
            return String::concat("( ", ise, " )");
        }
        | CPPAssembly::IfTestExpression => { return emitIfTestExpression($exp, texp, thenexp, elseexp, ctx); }
        | CPPAssembly::IfBinderExpression => { return emitIfBinderExpression($exp, texp, thenexp, elseexp, ctx); }
    }
}

function emitWidenedTypeExpression(exp: CPPAssembly::CoerceWidenTypeExpression, ctx: Context): String {
    let eexp = if(exp.exp?<CPPAssembly::LiteralNoneExpression>) then "" 
        else emitExpression(exp.exp, ctx);

    return generateAccessorForSpecialTypeConstructor(exp.trgttype, exp.srctype, eexp, ctx);
}

function emitNarrowedTypeExpression(exp: CPPAssembly::CoerceNarrowTypeExpression, ctx: Context): String {
    let tottype = emitTypeSignature(exp.trgttype, false, ctx);
    let emitexp = emitExpression(exp.exp, ctx);   

    if(ctx.asm.isNominalTypeConcept(exp.srctype.tkeystr)) {
        return String::concat(emitexp, getAccessor(exp.srctype.tkeystr, exp.trgttype.tkeystr, ctx), "<", tottype, ">()");
    }
    else {
        return emitexp;
    }
}

function emitSafeConvertExpression(exp: CPPAssembly::SafeConvertExpression, ctx: Context): String {
    let tottype = emitTypeSignature(exp.trgttype, false, ctx);

   return String::concat(emitExpression(exp.exp, ctx), getAccessor(exp.srctype.tkeystr, exp.trgttype.tkeystr, ctx), "<", tottype, ">()");
}

function emitCreateDirectExpression(exp: CPPAssembly::CreateDirectExpression, ctx: Context): String {
    let eexp = emitExpression(exp.exp, ctx); 

    return generateAccessorForSpecialTypeConstructor(exp.trgttype, exp.exp.etype, eexp, ctx);
}

function emitAccessEnumExpression(exp: CPPAssembly::AccessEnumExpression, ctx: Context): String {
    let enumtype = emitTypeSignature(exp.etype, false, ctx);
    let name = String::fromCString(exp.name);

    return String::concat(enumtype, "::", name);
}

function emitAccessStaticFieldExpression(exp: CPPAssembly::AccessStaticFieldExpression, ctx: Context): String {
    let typeconst = ctx.asm.typeconsts.get(exp.resolvedname);
    let ns = emitTypeSignature(typeconst.declaredInType, false, ctx);

    return String::concat(ns, "ᘏ", emitIdentifier(typeconst.name), "()");
}

function emitBinKeyEqExpression(exp: CPPAssembly::BinKeyEqExpression, opertype: String, ctx: Context): String {
    let lhs = emitExpression(exp.lhs, ctx);
    let rhs = emitExpression(exp.rhs, ctx);

    return String::concat("(", lhs, " == ", rhs, ")");
}

function emitBinKeyNotEqExpression(exp: CPPAssembly::BinKeyNotEqExpression, opertype: String, ctx: Context): String {
    let lhs = emitExpression(exp.lhs, ctx);
    let rhs = emitExpression(exp.rhs, ctx);

    return String::concat("(", lhs, " != ", rhs, ")");
}

function emitBinaryKeyEqExpression(exp: CPPAssembly::BinaryKeyEqExpression, ctx: Context): String {
    let opertype = emitTypeSignature(exp.opertype, false, ctx);
    match(exp)@ {
        | CPPAssembly::BinKeyEqNoneExpression => { abort; }
        | CPPAssembly::BinKeyNotEqNoneExpression => { abort; }
        | CPPAssembly::BinKeySomeEqExpression => { abort; }
        | CPPAssembly::BinKeyEqExpression => { return emitBinKeyEqExpression($exp, opertype, ctx); }
        | CPPAssembly::BinKeyNotEqExpression => { return emitBinKeyNotEqExpression($exp, opertype, ctx); }
    }
}

function emitKeyCmpEqualExpression(exp: CPPAssembly::KeyCmpEqualExpression, ctx: Context): String {
    let lhs = emitExpression(exp.lhs, ctx);
    let rhs = emitExpression(exp.rhs, ctx);

    return String::concat(lhs, " == ", rhs);
}

function emitKeyCmpLessExpression(exp: CPPAssembly::KeyCmpLessExpression, ctx: Context): String {
    let lhs = emitExpression(exp.lhs, ctx);
    let rhs = emitExpression(exp.rhs, ctx);

    return String::concat(lhs, " < ", rhs);
}

function emitLambdaParameters(p: List<CPPAssembly::LambdaParameterSignature>, ctx: Context): String {
    let params = p.map<String>(fn(param) => {
        let pname = emitIdentifier(param.pname);
        let ptype = emitTypeSignature(param.ptype, true, ctx);

        return String::concat(ptype, " ", pname);
    }); 

    return String::joinAll(", ", params);
}

%%
%% TODO: body is not going to be formatted correctly - still functionally correct but ugly
%%
function emitConstructorLambdaExpression(exp: CPPAssembly::ConstructorLambdaExpression, ctx: Context): String {
    let body = String::concat("{ ", emitBodyImplementation(exp.body, ctx, ""), " }");
    let lambda = exp.etype@<CPPAssembly::LambdaTypeSignature>;
    let params = emitLambdaParameters(lambda.params, ctx);
    let rtype = emitTypeSignature(lambda.resultType, true, ctx);
    %% Likely need to do some explicit handling of isPredLambda case

    return String::concat("[&](", params, ") -> ", rtype, body);
}

function emitLambdaInvokeExpression(exp: CPPAssembly::LambdaInvokeExpression, ctx: Context): String {
    let args = emitArguments(exp.argsinfo.args, ctx);
    let name = emitIdentifier(exp.fname);

    %% Probably will need to construct a namespace specifier here (likely from exp.lambda)
    return String::concat(name, "( ", args, " )");
}

function emitLiteralCCharExpression(exp: CPPAssembly::LiteralCCharExpression): String {
    return String::concat("'", String::fromCChar(exp.value), "'");
}

function emitLiteralUnicodeCharExpression(exp: CPPAssembly::LiteralUnicodeCharExpression): String {
    return String::concat("U'", String::fromUnicodeChar(exp.value), "'");
}

function emitLiteralCRegexExpression(exp: CPPAssembly::LiteralCRegexExpression): String {
    return "";
}

function emitLiteralRegexExpression(exp: CPPAssembly::LiteralRegexExpression): String {
    return "";
}

%% Just a typedef of CString
function emitLiteralTypeDeclValueExpression(exp: CPPAssembly::LiteralTypeDeclValueExpression, ctx: Context): String {
    return emitExpression(exp.value, ctx);
}

function emitCStringAsLiteral(s: CString): String {
    let formatted = s.replaceAllStringOccurrences('%n;', '\n');
    
    return String::fromCString(CString::concat('"', formatted,'"'));
}

%%
%% TODO: We need some way to properly reflect this max size in both the
%% cppruntime files and the actual emitter itself.
%%

function emitLiteralCStringExpression(exp: CPPAssembly::LiteralCStringExpression): String {
    let strsize = exp.value.size();
    let baseargs = String::concat("0, ", natToString(strsize), ", str");
    let base = String::concat("Core::CRopeOps::s_crope_create(__CoreCpp::cbufferFromStringLiteral(", baseargs, "))");

    let maxCCharBufferSize = 8n;

    let constructor = Algorithm::while<(|Nat, String|)>((|maxCCharBufferSize, base|), 
        pred(cons) => cons.0 < strsize, 
        fn(cons) => {
            let append_base = String::concat("Core::CRopeOps::s_crope_append(", cons.1, ", __CoreCpp::cbufferFromStringLiteral(");
            let args = String::concat(natToString(cons.0), ", ", natToString(strsize - cons.0), ", str");
            return cons.0 + maxCCharBufferSize, String::concat(append_base, args, "))");
    }).1;

    return String::concat("[]() -> Core::CRope { const __CoreCpp::CChar* str = reinterpret_cast<const __CoreCpp::CChar*>(", 
        emitCStringAsLiteral(exp.value), "); return ", constructor, "; }()");
}

function emitLiteralStringExpression(exp: CPPAssembly::LiteralStringExpression): String {
    let strsize = exp.value.size();
    let baseargs = String::concat("0, ", natToString(strsize), ", str");
    let base = String::concat("Core::UnicodeRopeOps::s_unicoderope_create(__CoreCpp::ubufferFromStringLiteral(", baseargs, "))");

    let maxCCharBufferSize = 8n;

    let constructor = Algorithm::while<(|Nat, String|)>((|maxCCharBufferSize, base|), 
        pred(cons) => cons.0 < strsize, 
        fn(cons) => {
            let append_base = String::concat("Core::UnicodeRopeOps::s_unicoderope_append(", cons.1, ", __CoreCpp::ubufferFromStringLiteral(");
            let args = String::concat(natToString(cons.0), ", ", natToString(strsize - cons.0), ", str");
            return cons.0 + maxCCharBufferSize, String::concat(append_base, args, "))");
    }).1;

    return String::concat("[]() -> Core::UnicodeRope { const __CoreCpp::UnicodeChar* str = reinterpret_cast<const __CoreCpp::UnicodeChar*>(", 
        emitCStringAsLiteral(exp.value), "); return ", constructor, "; }()");
}

function emitAccessNamespaceConstantExpression(exp: CPPAssembly::AccessNamespaceConstantExpression, ctx: Context): String {
    let name = emitIdentifier(exp.name);
    let ns = emitNamespaceKey(exp.ns);
    let resolvedns = emitResolvedNamespace(ctx.fullns_list, ns);

    if(resolvedns === "") {
        return String::concat(resolvedns, name, "()");
    }
    else {
        return String::concat(resolvedns, "::", name, "()");
    }
}

function emitMapEntryConstructorExpression(exp: CPPAssembly::MapEntryConstructorExpression, ctx: Context): String {
    let key = emitExpression(exp.kexp, ctx);
    let value = emitExpression(exp.vexp, ctx);
    let metype = emitTypeSignature(exp.etype, false, ctx);

    return String::concat(metype, "( ", key, ", ", value, " )");
}

function emitExpression(e: CPPAssembly::Expression, ctx: Context): String {
    match(e)@ {
        | CPPAssembly::LiteralNoneExpression => { return emitLiteralNoneExpression($e, ctx); }
        | CPPAssembly::LiteralSimpleExpression => { return emitLiteralSimpleExpression($e); }
        | CPPAssembly::LiteralCCharExpression => { return emitLiteralCCharExpression($e); }
        | CPPAssembly::LiteralUnicodeCharExpression => { return emitLiteralUnicodeCharExpression($e); }
        | CPPAssembly::LiteralCStringExpression => { return emitLiteralCStringExpression($e); }
        | CPPAssembly::LiteralStringExpression => { return emitLiteralStringExpression($e); }
        | CPPAssembly::LiteralCRegexExpression => { return emitLiteralCRegexExpression($e); }
        | CPPAssembly::LiteralRegexExpression => { return emitLiteralRegexExpression($e); }
        | CPPAssembly::LiteralTypeDeclValueExpression => { return emitLiteralTypeDeclValueExpression($e, ctx); }
        | CPPAssembly::AccessNamespaceConstantExpression => { return emitAccessNamespaceConstantExpression($e, ctx); }
        | CPPAssembly::AccessStaticFieldExpression => { return emitAccessStaticFieldExpression($e, ctx); } 
        | CPPAssembly::AccessEnumExpression => { return emitAccessEnumExpression($e, ctx); }
        | CPPAssembly::AccessVariableExpression => { return emitAccessVariableExpression($e, ctx); }
        | CPPAssembly::AccessCapturedVariableExpression => { return emitVarIdentifier($e.vname); }
        | CPPAssembly::ConstructorExpression => { return emitConstructorExpression($e, ctx); }
        | CPPAssembly::ConstructorPrimaryExpression => { return emitConstructorPrimaryExpression($e, ctx); }
        %%| CPPAssembly::ConstructorPrimaryCollectionSingletonsExpression => { abort; } 
        %%| CPPAssembly::ConstructorTypeDeclExpression => { abort; }
        %%| CPPAssembly::ConstructorTypeDeclStringExpression => { abort; } 
        | CPPAssembly::ConstructorLambdaExpression => { return emitConstructorLambdaExpression($e, ctx); }
        | CPPAssembly::LambdaInvokeExpression => { return emitLambdaInvokeExpression($e, ctx); } 
        | CPPAssembly::CallNamespaceFunctionExpression => { return emitCallNamespaceFunctionExpression($e, ctx); }
        | CPPAssembly::CallTypeFunctionExpression => { return emitCallTypeFunctionExpression($e, ctx); }
        | CPPAssembly::CallTypeFunctionSpecialExpression => { return emitCallTypeFunctionSpecialExpression($e, ctx); }
        %%| CPPAssembly::CallRefInvokeStaticResolveExpression => { abort; }
        %%| CPPAssembly::CallRefInvokeVirtualExpression => { abort; } 
        %%| CPPAssembly::TypeDeclPrimitiveFieldAccessExpression => { abort; }
        | CPPAssembly::CoerceWidenTypeExpression => { return emitWidenedTypeExpression($e, ctx); }
        | CPPAssembly::CoerceNarrowTypeExpression => { return emitNarrowedTypeExpression($e, ctx); }
        | CPPAssembly::SafeConvertExpression => { return emitSafeConvertExpression($e, ctx); }
        | CPPAssembly::CreateDirectExpression => { return emitCreateDirectExpression($e, ctx); }
        | CPPAssembly::PostfixOp => { return emitPostfixOp($e, ctx); }
        | CPPAssembly::UnaryExpression => { return emitUnaryExpression[recursive]($e, ctx); }
        | CPPAssembly::BinaryArithExpression => { return emitBinaryArithExpression[recursive]($e, ctx); }
        | CPPAssembly::BinaryKeyEqExpression => { return emitBinaryKeyEqExpression($e, ctx); }
        %%| CPPAssembly::BinaryKeyCmpEqualExpression => { abort; }
        %%| CPPAssembly::BinaryKeyCmpLessExpression => { abort; }
        | CPPAssembly::KeyCmpEqualExpression => { return emitKeyCmpEqualExpression($e, ctx); }
        | CPPAssembly::KeyCmpLessExpression => { return emitKeyCmpLessExpression($e, ctx); }  
        | CPPAssembly::BinaryNumericExpression => { return emitBinaryNumericExpression[recursive]($e, ctx); }
        | CPPAssembly::BinLogicExpression => { return emitBinLogicExpression[recursive]($e, ctx); }
        | CPPAssembly::MapEntryConstructorExpression => { return emitMapEntryConstructorExpression($e, ctx); }
        | CPPAssembly::IfExpression => { return emitIfExpression($e, ctx); }
        | _ => { abort; }
    }
}

function emitVariableInitializationStatement(stmt: CPPAssembly::VariableInitializationStatement, ctx: Context, indent: String): String {
    let name = emitIdentifier(stmt.name);
    let stype = emitTypeSignature(stmt.vtype, true, ctx);
    let exp = emitExpression(stmt.exp, ctx);

    let full_indent: String = String::concat(indent, "    ", stype);
    return String::concat(full_indent, " ", name, " = ", exp, ";");
}

function emitVariableAssignmentStatement(stmt: CPPAssembly::VariableAssignmentStatement, ctx: Context, indent: String): String {
    let name = emitIdentifier(stmt.name);
    let exp = emitExpression(stmt.exp, ctx);

    return String::concat(indent, "    ", name, " = ", exp, ";");
}

function emitVariableDeclarationStatement(stmt: CPPAssembly::VariableDeclarationStatement, ctx: Context, indent: String): String {
    let name = emitIdentifier(stmt.name);
    let stype = emitTypeSignature(stmt.vtype, true, ctx);

    let full_indent: String = String::concat(indent, "    ", stype);
    return String::concat(full_indent, " ", name, ";");
}

function emitBlockStatement(block: CPPAssembly::BlockStatement, ctx: Context, indent: String): String {
    let stmts = block.statements.map<String>(fn(stmt) => emitStatement(stmt, ctx, indent));
    return String::joinAll("%n;", stmts);
}

function emitIfSimpleStatement(stmt: CPPAssembly::IfSimpleStatement, ctx: Context, indent: String): String {
    let expr = emitExpression(stmt.cond, ctx);
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);

    let ifstmt = String::concat(indent, "if( ", expr, " ) {%n;");
    return String::concat(ifstmt, trueBlock, indent, "}");
}

function emitIfTestStatement(stmt: CPPAssembly::IfTestStatement, ctx: Context, indent: String): String {
    let expr = emitExpression(stmt.cond, ctx);
    let itest = String::concat(expr, emitITestAsTest(stmt.itest, stmt.cond.etype, "", ctx));
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);

    let ifstmt = String::concat(indent, "if( ", itest, " ) {%n;");
    return String::concat(ifstmt, trueBlock, indent, "}");
}

function emitIfBinderStatement(stmt: CPPAssembly::IfBinderStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    
    let expr = emitExpression(stmt.cond, ctx);
    let itest = String::concat(expr, emitITestAsTest(stmt.itest, stmt.cond.etype, "", ctx));
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);

    let bname = emitVarIdentifier(stmt.binder.srcname);
    let convert = doConvertMaybeSpecialCase(stmt.itest.isnot, stmt.itest, stmt.cond.etype.tkeystr, none, ctx);
    let reasign = String::concat(bname, " = ", expr, convert.0);

    let tbassign = String::concat(full_indent, "[[maybe_unused]] ", convert.1, " ", reasign, ";%n;");

    let ifstmt = String::concat(indent, "if( ", itest, " ) {%n;");
    return String::concat(ifstmt, tbassign, trueBlock, indent, "}%n;");
}

function emitIfStatement(stmt: CPPAssembly::IfStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 

    match(stmt)@ { 
        | CPPAssembly::IfSimpleStatement => { return emitIfSimpleStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfTestStatement => { return emitIfTestStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfBinderStatement => { return emitIfBinderStatement($stmt, ctx, full_indent); }
    }
}

%% May want to remove some o the repetitive code in the 3 flavours of ifelse
function emitIfElseSimpleStatement(stmt: CPPAssembly::IfElseSimpleStatement, ctx: Context, indent: String): String {
    let expr = emitExpression(stmt.cond, ctx);
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);
    let falseBlock = emitBlockStatement(stmt.falseBlock, ctx, indent);
    let elseBlockText = String::concat(indent, "else {%n;", falseBlock, indent, "}%n;");
    
    let ifstmt = String::concat(indent, "if( ", expr, " ) {%n;"); 
    return String::concat(ifstmt, trueBlock, indent, "}%n;", elseBlockText);
}

function emitIfElseTestStatement(stmt: CPPAssembly::IfElseTestStatement, ctx: Context, indent: String): String {
    let expr = emitExpression(stmt.cond, ctx);
    let itest = String::concat(expr, emitITestAsTest(stmt.itest, stmt.cond.etype, "", ctx));
    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);
    let falseBlock = emitBlockStatement(stmt.falseBlock, ctx, indent);
    let elseBlockText = String::concat(indent, "else {%n;", falseBlock, indent, "}%n;");
    
    let ifstmt = String::concat(indent, "if( ", itest, " ) {%n;"); 
    return String::concat(ifstmt, trueBlock, indent, "}%n;", elseBlockText);
}

%% This does not work if we do something like if(...)@!type, the else block should bind to the type
function emitIfElseBinderStatement(stmt: CPPAssembly::IfElseBinderStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    
    let expr = emitExpression(stmt.cond, ctx);
    let etype = stmt.cond.etype;
    let itest = String::concat(expr, emitITestAsTest(stmt.itest, etype, "", ctx));

    let tconvert = doConvertMaybeSpecialCase(stmt.itest.isnot, stmt.itest, stmt.cond.etype.tkeystr, none, ctx); 
    let treassign = String::concat(full_indent, emitBindVar(stmt.binder.srcname, tconvert.0, tconvert.1, expr), "%n;");

    let fconvert = doConvertMaybeSpecialCase(!stmt.itest.isnot, stmt.itest, stmt.cond.etype.tkeystr, none, ctx);
    let freassign = String::concat(full_indent, emitBindVar(stmt.binder.srcname, fconvert.0, fconvert.1, expr), "%n;");

    let trueBlock = emitBlockStatement(stmt.trueBlock, ctx, indent);
    let falseBlock = emitBlockStatement(stmt.falseBlock, ctx, indent);
    let elseBlockText = String::concat(indent, "else {%n;", freassign, falseBlock, indent, "}%n;");
    
    let ifstmt = String::concat(indent, "if( ", itest, " ) {%n;"); 
    return String::concat(ifstmt, treassign, trueBlock, indent, "}%n;", elseBlockText);
}

function emitIfElseStatement(stmt: CPPAssembly::IfElseStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 
    
    match(stmt)@ {
        | CPPAssembly::IfElseSimpleStatement => { return emitIfElseSimpleStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfElseTestStatement => { return emitIfElseTestStatement($stmt, ctx, full_indent); }
        | CPPAssembly::IfElseBinderStatement => { return emitIfElseBinderStatement($stmt, ctx, full_indent); }
    }
}

function emitIfElifElseStatement(stmt: CPPAssembly::IfElifElseStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 
    let ifcond = String::concat(full_indent, "if(", emitExpression(stmt.ifcond, ctx), ") {%n;");
    let ifbody = String::concat(emitBlockStatement(stmt.ifflow, ctx, full_indent), full_indent, "}%n;");
    let ifblock = String::concat(ifcond, ifbody);
    let elseblock = String::concat(full_indent, "else {%n;", emitBlockStatement(stmt.elseflow, ctx, full_indent), full_indent, "}%n;");

    let elifs_list = stmt.condflow.map<String>(fn(elifs) => {
        let cond = emitExpression(elifs.0, ctx);
        let body = emitBlockStatement(elifs.1, ctx, full_indent);

        let elif_stmt = String::concat(full_indent, "else if(", cond, ") {%n;");
        return String::concat(elif_stmt, body, full_indent, "}%n;");
    });
    let elifs = String::joinAll("", elifs_list);

    return String::concat(ifcond, ifbody, elifs, elseblock);
}

function emitAbortStatement(stmt: CPPAssembly::AbortStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);

    return String::concat(full_indent, "𝐚𝐛𝐨𝐫𝐭;");
}

function emitAssertStatement(stmt: CPPAssembly::AssertStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    let cond = emitExpression(stmt.cond, ctx);

    return String::concat(full_indent, "𝐚𝐬𝐬𝐞𝐫𝐭(", cond, ");");
} 

function tryGenerateBindType(bind: Option<CPPAssembly::BinderInfo>, expr: String, fromtype: CPPAssembly::TypeKey, totype: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    if(bind)@none {
        return "";
    }
    else {
        let bname = emitVarIdentifier($bind.srcname);
        let convert = emitITestAsConvertType(false, fromtype, totype, ctx); 
        let bindtype = String::concat("[[maybe_unused]] ", convert.1, " ");
        let reassign = String::concat(bindtype, bname, " = ", expr, convert.0, ";%n;");

        return String::concat(full_indent, reassign);
    }
}

function emitMatchStatement(stmt: CPPAssembly::MatchStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 
    let fullfull_indent = String::concat("    ", full_indent);

    let expr = emitExpression(stmt.sval, ctx);
    let accessor = generateAccess(stmt.sval.etype.tkeystr, ctx);
    let sval = String::concat(expr, accessor, "typeinfo == &");

    let matchflow = stmt.matchflow.mapIdx<String>(fn(mf, ii) => {
        let bind = tryGenerateBindType(stmt.bindInfo, expr, stmt.sval.etype.tkeystr, mf.0.tkeystr, ctx, full_indent);
        let block = String::concat(bind, emitBlockStatement(mf.1, ctx, full_indent), full_indent, "}%n;");
        let ts = removeCppPrefix(emitTypeSignature(mf.0, false, ctx));

        if(ii == 0n) {
            return String::concat(full_indent, "if(", sval, ts, "Type) {%n;", block);
        }
        else {
            %% Match everything case
            if(mf.0.tkeystr === stmt.sval.etype.tkeystr) {
                return String::concat(full_indent, "else if(true) {%n;", block);               
            }
            else {
                return String::concat(full_indent, "else if(", sval, ts, "Type) {%n;", block);
            }
        }
    });

    let matches = String::joinAll("", matchflow);
    let failure = String::concat(full_indent, "else {%n;", fullfull_indent, "𝐚𝐛𝐨𝐫𝐭;%n;", full_indent, "}%n;");
    return String::concat(matches, failure);
}

function emitSwitchStatement(stmt: CPPAssembly::SwitchStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent); 
    let fullfull_indent = String::concat("    ", full_indent);

    let sval = emitExpression(stmt.sval, ctx);

    let switchflow = stmt.switchflow.mapIdx<String>(fn(sf, ii) => {
        let block = String::concat(emitBlockStatement(sf.1, ctx, full_indent), full_indent, "}%n;");
        let exp = if(sf.0)none then "true" else String::concat(sval, " == ", emitExpression(sf.0@some, ctx)); 

        if(ii == 0n) {
            return String::concat(full_indent, "if( ", exp, " ) {%n;", block);
        }
        else {
            return String::concat(full_indent, "else if( ", exp, " ) {%n;", block);
        }
    });

    let matches = String::joinAll("", switchflow);
    let failure = String::concat(full_indent, "else {%n;", fullfull_indent, "𝐚𝐛𝐨𝐫𝐭;%n;", full_indent, "}%n;");
    return String::concat(matches, failure);
}

function emitVariableMultiInitilizationExplicitStatement(vmie: CPPAssembly::VariableMultiInitializationExplicitStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat(indent, "    ");
    let stmts = vmie.decls.mapIdx<String>(fn(decl, ii) => {
        let name = emitIdentifier(decl.0);
        let tsig = emitTypeSignature(decl.1, true, ctx);
        let exp = emitExpression(vmie.exps.get(ii), ctx);

        return String::concat(indent, tsig, " ", name, " = ", exp);
    });

    return String::joinAll(";%n;", stmts);
}

%% This assumes implicit multiple initialization is done using elist
function emitVariableMultiInitilizationImplicitStatement(vmii: CPPAssembly::VariableMultiInitializationImplicitStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat(indent, "    ");
    let fullfull_indent = String::concat(full_indent,  "    ");
    let exp = emitExpression(vmii.exp, ctx);
    let etype = emitTypeSignature(vmii.exp.etype, true, ctx);
    let rhsinit = String::concat(fullfull_indent, etype, " elist = ", exp, ";%n;");

    %% (| decls, assignment, elist index |)
    let decls = vmii.decls
        .reduce<(|String, String, Nat|)>(fn(acc, decl) => {
            let name = emitIdentifier(decl.0);
            let stype = String::concat("[[maybe_unused]] ", emitTypeSignature(decl.1, true, ctx));

            let edecl = String::concat(acc.0, full_indent, stype, " ", name, ";%n;");

            let access = generateAccessFromIndex(acc.2, decl.1, ctx);
            let assignment = String::concat(acc.1, fullfull_indent, name, " = elist", access, ";%n;");

            return edecl, assignment, acc.2 + 1n;
        }, (|"", String::concat(full_indent, "{%n;", rhsinit), 0n|));

    return String::concat(decls.0, decls.1, full_indent, "}%n;");
}

function emitReturnMultiStatement(rms: CPPAssembly::ReturnMultiStatement, ctx: Context, indent: String): String {
    let full_indent = String::concat(indent, "    ");
    
    let elsig = emitTypeSignature(rms.elsig, true, ctx);
    let exps = rms.exps.map<String>(fn(e) => emitExpression(e, ctx));
    let eexps = String::joinAll(", ", exps);

    return String::concat(full_indent, "return ", elsig, "(", eexps, ");");
}

function emitStatement(stmt: CPPAssembly::Statement, ctx: Context, indent: String): String {
    match(stmt)@ {
        | CPPAssembly::EmptyStatement => { return ""; }
        | CPPAssembly::VariableDeclarationStatement => { return emitVariableDeclarationStatement($stmt, ctx, indent); }
        %%| CPPAssembly::VariableMultiDeclarationStatement => { abort; }
        | CPPAssembly::VariableInitializationStatement => { return emitVariableInitializationStatement($stmt, ctx, indent); }
        | CPPAssembly::VariableMultiInitializationExplicitStatement => { return emitVariableMultiInitilizationExplicitStatement($stmt, ctx, indent); }
        | CPPAssembly::VariableMultiInitializationImplicitStatement => { return emitVariableMultiInitilizationImplicitStatement($stmt, ctx, indent); }
        | CPPAssembly::VariableAssignmentStatement => { return emitVariableAssignmentStatement($stmt, ctx, indent); }
        %%| CPPAssembly::VariableMultiInitializationExplicitStatement => { abort; }
        %%| CPPAssembly::VariableMultiAssignmentImplicitStatement => { abort; }
        %%| CPPAssembly::VariableRetypeStatement => { abort; }
        %%| CPPAssembly::ReturnVoidStatement => { abort; }
        | CPPAssembly::ReturnSingleStatement => { return emitReturnSingleStatement($stmt, ctx, indent); }
        | CPPAssembly::ReturnMultiStatement => { return emitReturnMultiStatement($stmt, ctx, indent); }
        | CPPAssembly::IfStatement => { return emitIfStatement($stmt, ctx, indent); }
        | CPPAssembly::IfElseStatement => { return emitIfElseStatement($stmt, ctx, indent); }
        | CPPAssembly::IfElifElseStatement => { return emitIfElifElseStatement($stmt, ctx, indent); }
        | CPPAssembly::SwitchStatement => { return emitSwitchStatement($stmt, ctx, indent); }
        | CPPAssembly::MatchStatement => { return emitMatchStatement($stmt, ctx, indent); }
        | CPPAssembly::AbortStatement => { return emitAbortStatement($stmt, ctx, indent); }
        | CPPAssembly::AssertStatement => { return emitAssertStatement($stmt, ctx, indent); }
        %%| CPPAssembly::ValidateStatement => { abort; }
        %%| CPPAssembly::DebugStatement => { abort; }
        %%| CPPAssembly::VoidRefCallStatement => { abort; }
        %%| CPPAssembly::UpdateDirectStatement => { abort; }
        %%| CPPAssembly::UpdateIndirectStatement => { abort; }
        | CPPAssembly::BlockStatement => { return emitBlockStatement($stmt, ctx, indent); }
     }
}

function emitBuiltinBodyImplementation(body: CPPAssembly::BuiltinBodyImplementation, ctx: Context, indent: String): String {
    switch(String::fromCString(body.builtin)) {
        | "s_float_pow" => { return String::concat(indent, "    ", "return __CoreCpp::Float(powf64(a.get(), b.get()));%n;"); }
        | "s_float_sqrt" => { return String::concat(indent, "    ", "return __CoreCpp::Float(sqrtf64(a.get()));%n;"); }
        | "ccharbuffer_create_empty" => { return String::concat(indent, "    return __CoreCpp::CCharBuffer::create_empty();%n;"); }
        | "ccharbuffer_create_1" => { return String::concat(indent, "    return __CoreCpp::CCharBuffer::create_3(c1);%n;"); }
        | "ccharbuffer_create_2" => { return String::concat(indent, "    return __CoreCpp::CCharBuffer::create_3(c1, c2);%n;"); }
        | "ccharbuffer_create_3" => { return String::concat(indent, "    return __CoreCpp::CCharBuffer::create_3(c1, c2, c3);%n;"); }
        | "ccharbuffer_create_4" => { return String::concat(indent, "    return __CoreCpp::CCharBuffer::create_3(c1, c2, c3, c4);%n;"); }
        | "ccharbuffer_create_5" => { return String::concat(indent, "    return __CoreCpp::CCharBuffer::create_3(c1, c2, c3, c4, c5);%n;"); }
        | "ccharbuffer_create_6" => { return String::concat(indent, "    return __CoreCpp::CCharBuffer::create_3(c1, c2, c3, c4, c5, c6);%n;"); }
        | "ccharbuffer_create_7" => { return String::concat(indent, "    return __CoreCpp::CCharBuffer::create_3(c1, c2, c3, c4, c5, c6, c7);%n;"); }
        | "ccharbuffer_create_8" => { return String::concat(indent, "    return __CoreCpp::CCharBuffer::create_3(c1, c2, c3, c4, c5, c6, c7, c8);%n;"); }
        | "ccharbuffer_size" => { return String::concat(indent, "    return cb.size;%n;"); }
        | "ccharbuffer_maxsize" => { return String::concat(indent, "    return __CoreCpp::Nat(__CoreCpp::maxCCharBufferSize);%n;"); }
        | "ccharbuffer_equal" => { return String::concat(indent, "    return __CoreCpp::cbufferEqual(cb1, cb2);%n;"); }
        | "ccharbuffer_less" => { return String::concat(indent, "    return __CoreCpp::cbufferLess(cb1, cb2);%n;"); }
        | "ccharbuffer_remove" => { return String::concat(indent, "    return __CoreCpp::cbufferRemove(cb, pre);%n;"); }
        | "ccharbuffer_isprefix" => { return String::concat(indent, "    return __CoreCpp::cbufferIsPrefix(cb, pre);%n;"); }
        | "nat_to_ccharbuffer" => { return String::concat(indent, "    return __CoreCpp::cbufferFromNat(v);%n;"); }
        | "ccharbuffer_merge" => { return String::concat(indent, "    return __CoreCpp::cbufferMerge(cb1, cb2);%n;"); }
        | "ccharbuffer_remainder" => { return String::concat(indent, "    return __CoreCpp::cbufferRemainder(cb, split);%n;"); }
        | "unicodecharbuffer_create_empty" => { return String::concat(indent, "    return __CoreCpp::UnicodeCharBuffer::create_empty();%n;"); }
        | "unicodecharbuffer_create_1" => { return String::concat(indent, "    return __CoreCpp::UnicodeCharBuffer::create_3(c1);%n;"); }
        | "unicodecharbuffer_create_2" => { return String::concat(indent, "    return __CoreCpp::UnicodeCharBuffer::create_3(c1, c2);%n;"); }
        | "unicodecharbuffer_create_3" => { return String::concat(indent, "    return __CoreCpp::UnicodeCharBuffer::create_3(c1, c2, c3);%n;"); }
        | "unicodecharbuffer_create_4" => { return String::concat(indent, "    return __CoreCpp::UnicodeCharBuffer::create_3(c1, c2, c3, c4);%n;"); }
        | "unicodecharbuffer_create_5" => { return String::concat(indent, "    return __CoreCpp::UnicodeCharBuffer::create_3(c1, c2, c3, c4, c5);%n;"); }
        | "unicodecharbuffer_create_6" => { return String::concat(indent, "    return __CoreCpp::UnicodeCharBuffer::create_3(c1, c2, c3, c4, c5, c6);%n;"); }
        | "unicodecharbuffer_create_7" => { return String::concat(indent, "    return __CoreCpp::UnicodeCharBuffer::create_3(c1, c2, c3, c4, c5, c6, c7);%n;"); }
        | "unicodecharbuffer_create_8" => { return String::concat(indent, "    return __CoreCpp::UnicodeCharBuffer::create_3(c1, c2, c3, c4, c5, c6, c7, c8);%n;"); }
        | "unicodecharbuffer_size" => { return String::concat(indent, "    return ub.size;%n;"); }
        | "unicodecharbuffer_maxsize" => { return String::concat(indent, "    return __CoreCpp::Nat(__CoreCpp::maxUnicodeCharBufferSize);%n;"); }
        | "unicodecharbuffer_equal" => { return String::concat(indent, "    return __CoreCpp::ubufferEqual(ub1, ub2);%n;"); }
        | "nat_to_unicodecharbuffer" => { return String::concat(indent, "    return __CoreCpp::ubufferFromNat(v);%n;"); }
        | "unicodecharbuffer_merge" => { return String::concat(indent, "    return __CoreCpp::ubufferMerge(ub1, ub2);%n;"); }
        | "unicodecharbuffer_remainder" => { return String::concat(indent, "    return __CoreCpp::ubufferRemainder(ub, split);%n;"); }        
        | "cstring_concat2" => { return String::concat(indent, "    return Core::CRopeOps::s_crope_concat2(s1, s2);%n;"); }
        | "cstring_empty" => { return String::concat(indent, "    return Core::CRopeOps::s_crope_empty(s);%n;"); }
        | "cstring_remove_prefix_string" => { return String::concat(indent, "    return Core::CRopeOps::s_crope_remove_prefix_crope(s, prefix);%n;"); }
        | "cstring_prepend" => { return String::concat(indent, "    return Core::CRopeOps::s_crope_prepend(s, prefix);%n;"); }
        | "cstring_starts_with_string" => { return String::concat(indent, "    return Core::CRopeOps::s_crope_starts_with_crope(s, prefix);%n;"); }
        | "crope_starts_with_crope" => { return String::concat(indent, "    return __CoreCpp::startsWithCRope(r, pre);%n;"); }
        | "crope_iterator_initialize" => { return String::concat(indent, "    return __CoreCpp::CRopeIterator{ r };%n;"); }
        | "crope_iterator_next" => { return String::concat(indent, "    return ", emitSpecialThis(), ".next();%n;"); }
        | "crope_iterator_hasnext" => { return String::concat(indent, "    return ", emitSpecialThis(), ".hasNext();%n;"); }
        | "string_concat2" => { return String::concat(indent, "    return Core::CRopeOps::s_unicoderope_concat2(s1, s2);%n;"); }
        | "string_empty" => { return String::concat(indent, "    return Core::CRopeOps::s_unicoderope_empty(s);%n;"); }
        | "s_nat_to_cstring" => { return String::concat(indent, "    return Core::CRopeOps::s_nat_to_crope(v);%n;"); }
        | "s_algo_while" => { return String::concat(indent, "    return 𝐰𝐡𝐢𝐥𝐞(s, guard, op);%n;"); }
        | _ => { abort; } %% TODO: Not implemented
    }
}

function emitStandardBodyImplementation(body: CPPAssembly::StandardBodyImplementation, ctx: Context, indent: String): String {
    return String::joinAll("%n;", body.statements.map<String>(fn(stmt) => emitStatement(stmt, ctx, indent)));
}

function emitBodyImplementation(body: CPPAssembly::BodyImplementation, ctx: Context, indent: String): String {
    match(body)@ {
        %% CPPAssembly::AbstractBodyImplementation => { abort; }
        %% | CPPAssembly::PredicateUFBodyImplementation => { abort; }
        | CPPAssembly::BuiltinBodyImplementation => { return emitBuiltinBodyImplementation($body, ctx, indent); }
        %% | CPPAssembly::SynthesisBodyImplementation => { abort; }
        | CPPAssembly::ExpressionBodyImplementation => { 
            return String::concat("return ", emitExpression($body.exp, ctx), ";"); 
        }
        | CPPAssembly::StandardBodyImplementation => { return emitStandardBodyImplementation($body, ctx, indent); }
        | _ => { abort; }
    }
}

%% If we detect lambda parameters we need to return their signature and emit as a template type
function emitParameters(params: List<CPPAssembly::ParameterDecl>, ctx: Context): String, String {
    let all_params = params.map<String>(fn(param) => {
        let ptype = emitTypeSignature(param.ptype, true, ctx);
        let pident = emitIdentifier(param.pname);
        let needsRValueRef = if(param.ptype)<CPPAssembly::LambdaTypeSignature> 
            then String::concat("_", pident, "&&") else "";

        return String::concat(ptype, needsRValueRef, " ", pident);
    });

    let lambdatypes = params
        .filter(pred(p) => p.ptype?<CPPAssembly::LambdaTypeSignature>)
        .reduce<List<String>>(fn(acc, param) => {
            let name = emitIdentifier(param.pname);
            return acc.pushBack(String::concat("typename ", emitTypeSignature(param.ptype, true, ctx), "_", name));
    }, List<String>{});

    return String::joinAll(", ", all_params), String::joinAll(", ", lambdatypes);
}

function genLambdaTemplate(templates: String, indent: String): String {
    return if(templates !== "")
        then String::concat(indent, "template <", templates, ">%n;") 
        else "";
}

function emitThisType(tk: CPPAssembly::TypeKey, ctx: Context): String {
    let resolved_type = emitTypeKey(tk, false, ctx);

    if(ctx.asm.typeinfos.get(tk).tag === CPPAssembly::Tag#Ref) {
        return String::concat("[[maybe_unused]] ", resolved_type, "*");
    }
    return String::concat("[[maybe_unused]] ", resolved_type);
}

function emitPreConditions(preconds: List<CPPAssembly::PreConditionDecl>, ctx: Context, indent: String): String {    
    return preconds.reduce<String>(fn(acc, pc) => {
        return String::concat(indent, "𝐫𝐞𝐪𝐮𝐢𝐫𝐞𝐬(", emitExpression(pc.exp, ctx), ");%n;");
    }, "");
}

function emitThisForType(declaredIn: CPPAssembly::TypeKey, ctx: Context): String {
    return if(ctx.asm.lookupNominalTypeDeclaration(declaredIn))<CPPAssembly::CRopeIteratorTypeDecl>
        then emitThisReference()
        else emitSpecialThis();
}

function emitMethodDecl(m: CPPAssembly::MethodDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(m.declaredInNS, m.fullns);
    let full_indent = String::concat("    ", indent);

    let ethis = emitThisForType(declaredIn, ctx);

    let name = generateMethodName(m.ikey, declaredIn, nctx);
    let params, templates = emitParameters(m.params, nctx);
    let rtype = emitTypeSignature(m.resultType, true, ctx);
    let this_type = emitThisType(declaredIn, nctx);    

    let template = genLambdaTemplate(templates, indent); 
    let pre = String::concat(template, indent, rtype, " ", name);

    var params_impl: String;
    if(params === "") {
        params_impl = String::concat("(", this_type, " ", ethis, ") noexcept");
    }
    else {
        let base = String::concat("(", this_type, " ");
        params_impl = String::concat(base, ethis, ", ", params, ") noexcept");           
    }

    let body = emitBodyImplementation(m.body, nctx, indent);
    let preconds = emitPreConditions(m.preconditions, nctx, full_indent);
%%  let postconds = emitPostConditions(m.postconditions);

    let fullbody = String::concat(preconds, body);

    return String::concat(pre, params_impl, " {%n;", fullbody, indent, "}%n;");
}

function emitMethods(ant: CPPAssembly::AbstractNominalTypeDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let staticmethods = ant.staticmethods
        .reduce<String>(fn(acc, ik) => {
            return String::concat(acc, emitMethodDecl(ctx.asm.staticmethods.get(ik), declaredIn, ctx, indent));
    }, "");

    %%
    %% TODO: Virtual, Abstract, and Override methods
    %%

    return staticmethods;
}

%% Type funcs are fully resolved before cpp emission so we can group them with nsfuncs
function emitFunctionDecl(func: CPPAssembly::FunctionInvokeDecl, ctx: Context, indent: String): String {
    let ikey = func.ikey;   
    let ns = func.fullns;
    let nctx = ctx.updateCurrentNamespace(func.declaredInNS, ns);
    let full_indent = String::concat("    ", indent);

    var name = emitInvokeKey(ikey, nctx);
    let params, templates = emitParameters(func.params, nctx);
    let rtype = emitTypeSignature(func.resultType, true, nctx); 

    let template = genLambdaTemplate(templates, indent);
    let pre: String = String::concat(template, indent, rtype, " ", name );
    let params_impl: String = String::concat("(", params, ") noexcept ");

    let body = emitBodyImplementation(func.body, nctx, indent);
    let preconds = emitPreConditions(func.preconditions, nctx, full_indent);
%%  let postconds = emitPostConditions(func.postconditions);

    let fullbody = String::concat(preconds, body);

    return String::concat(pre, params_impl, " {%n;", fullbody, indent, "}%n;");
}

function emitSaturatedFieldInfo(sfi: CPPAssembly::SaturatedFieldInfo, ctx: Context, indent: String): String {
    let ftype = emitTypeSignature(sfi.ftype, true, ctx);
    let fname = emitIdentifier(sfi.fname);

    return String::concat(indent, ftype, " ", fname, ";%n;");
}

function emitEntityTypeDecl(e: CPPAssembly::EntityTypeDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(e.declaredInNS, e.fullns);
    let tkey = emitTypeKey(declaredIn, false, nctx);

    let e_enum = generateEntriesEnum(e@<CPPAssembly::AbstractNominalTypeDecl>, e.fields, ctx, indent);
    let e_vtable = generateVTable(e@<CPPAssembly::AbstractNominalTypeDecl>, e.fields, ctx, indent);
    let e_tinfo = emitTypeInfo(ctx.asm.typeinfos.get(e.tkey), some(e), ctx, indent);

    let base = String::concat(e_enum, e_vtable, e_tinfo);

    let entries = e.saturatedBFieldInfo.reduce<String>( fn(acc, entry) => {
            return String::concat(acc, emitSaturatedFieldInfo(entry, nctx, String::concat("    ", indent)));
    }, String::concat(base, indent, "struct ", tkey, " { %n;"));

    return String::concat(entries, indent, "};%n;");
}

function emitDatatypeMemberEntityDecl(dm: CPPAssembly::DatatypeMemberEntityTypeDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(dm.declaredInNS, dm.fullns);
    let tkey = emitTypeKey(dm.tkey, false, nctx); 

    let dm_enum = generateEntriesEnum(dm@<CPPAssembly::AbstractNominalTypeDecl>, dm.fields, ctx, indent);
    let dm_vtable = generateVTable(dm@<CPPAssembly::AbstractNominalTypeDecl>, dm.fields, ctx, indent);
    let dm_tinfo = emitTypeInfo(ctx.asm.typeinfos.get(dm.tkey), some(dm), ctx, indent);

    let base = String::concat(dm_enum, dm_vtable, dm_tinfo);

    let fields = dm.saturatedBFieldInfo.reduce<String>(fn(acc, entry) => {
            return String::concat(acc, emitSaturatedFieldInfo(entry, nctx, String::concat("    ", indent)));
    }, String::concat(base, indent, "struct ", tkey, "{ %n;"));

    return String::concat(fields, indent, "};%n;");
}

function emitDatatypeTypeDecl(dt: CPPAssembly::DatatypeTypeDecl, ctx: Context, indent: String): String {
    let dm_enum = generateEntriesEnum(dt@<CPPAssembly::AbstractNominalTypeDecl>, dt.fields, ctx, indent);
    let dm_vtable = generateVTable(dt@<CPPAssembly::AbstractNominalTypeDecl>, dt.fields, ctx, indent);
    let dm_tinfo = ctx.asm.typeinfos.get(dt.tkey);
    
    return String::concat(dm_enum, dm_vtable, emitTypeInfo(dm_tinfo, some(dt@<CPPAssembly::AbstractNominalTypeDecl>), ctx, indent));
}

function emitConceptTypeDecl(ctd: CPPAssembly::ConceptTypeDecl, ctx: Context, indent: String): String {
    let ctd_enum = generateEntriesEnum(ctd@<CPPAssembly::AbstractNominalTypeDecl>, ctd.fields, ctx, indent);
    let ctd_vtable = generateVTable(ctd@<CPPAssembly::AbstractNominalTypeDecl>, ctd.fields, ctx, indent);
    let ctd_tinfo = ctx.asm.typeinfos.get(ctd.tkey);
    
    return String::concat(ctd_enum, ctd_vtable, emitTypeInfo(ctd_tinfo, some(ctd@<CPPAssembly::AbstractNominalTypeDecl>), ctx, indent));   
}

function emitEnumTypeDecl(etd: CPPAssembly::EnumTypeDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);

    let etd_tinfo = emitTypeInfo(ctx.asm.typeinfos.get(etd.tkey), some(etd), ctx, indent);

    let base = String::concat(indent, "enum class ", String::fromCString(etd.name), " {%n;");
    let entries = etd.members.map<String>(fn(e) => String::concat(full_indent, String::fromCString(e)));
    let wentries = String::concat(base, String::joinAll(",%n;", entries), "%n;", indent, "};%n;");

    return String::concat(etd_tinfo, wentries);
}

function emitAbstractNominalForwardDeclaration(e: CPPAssembly::AbstractNominalTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(e.declaredInNS, e.fullns);
    let tkey = emitTypeKey(e.tkey, false, nctx);

    if(e)@<CPPAssembly::AbstractConceptTypeDecl> { %% Emit our concepts typedefs with our fwd decls (their vtables and type info can just go with their subtypes)
        let k = String::fromCString((nctx.asm.typeinfos.get($e.tkey).slotsize - 1n).toCString()); %% Slot size includes "2" ptr to typeinfo, so we ignore
        return String::concat(indent, "typedef __CoreCpp::Boxed<", k, "> ", emitTypeKey($e.tkey, false, nctx), ";%n;");
    }

    %% CRope Iterators only exist in cpp runtime files
    if(e)<CPPAssembly::CRopeIteratorTypeDecl> {
        return "";
    }

    if(e)@<CPPAssembly::TypedeclStringOfTypeDecl> {
        return emitTypedeclStringOfTypeDeclDef(e@<CPPAssembly::TypedeclStringOfTypeDecl>, ctx, indent);
    }

    if(e)@<CPPAssembly::CollectionTypeDecl> {
        return emitCollectionTypeDeclDef($e, ctx, indent); 
    }

    return String::concat(indent, "struct ", tkey, ";%n;");
}

function emitMethodForwardDeclaration(m: CPPAssembly::MethodDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(m.declaredInNS, m.fullns);

    let ethis = emitThisForType(declaredIn, ctx);
    
    if(m)@<CPPAssembly::MethodDeclStatic> {
        let name = generateMethodName(m.ikey, declaredIn, nctx);
        let rtype = emitTypeSignature(m.resultType, true, nctx);
        let this_type = emitThisType(declaredIn, nctx);
        let params, templates = emitParameters(m.params, nctx);
        let template = genLambdaTemplate(templates, indent);

        let first = String::concat(indent, rtype, " ", name, "(");

        if(params === "") {
            let tmp = String::concat(template, first);
            return String::concat(tmp, this_type, " ", ethis, params, ") noexcept;%n;");
        }
        else {
            let base = String::concat(first, this_type, " ");
            return String::concat(template, base, ethis, ", ", params, ") noexcept;%n;");           
        }
    }
    else {
        abort; %% TODO: Support other method types!
    }
}

function emitFunctionForwardDeclaration(decl: CPPAssembly::AbstractInvokeDecl, ctx: Context, ident: String): String {
    let ns = decl.fullns;
    let nctx = ctx.updateCurrentNamespace(decl.declaredInNS, ns);

    let ikey = emitInvokeKey(decl.ikey, nctx);
    let rtype = emitTypeSignature(decl.resultType, true, nctx); 
    let params, templates = emitParameters(decl.params, nctx);

    let template = genLambdaTemplate(templates, ident);
    let first = String::concat(template, ident, rtype, " ", ikey);
    return String::concat(first, "(", params, ") noexcept;%n;");
}

function generateVTableEntry(entry: CPPAssembly::MemberFieldDecl, resolved_name: String, enum_name: String, idx: Nat, ctx: Context, indent: String): String {
    let tinfo = ctx.asm.typeinfos.tryGet(entry.declaredType.tkeystr);

    var id: String;
    if(tinfo)@none { %% elist case
        %% Since elists are our special case we should likely reserve a specific id for all elists (say 0n)
        id = String::fromCString(0n.toCString()); 
    }
    else {
        id = String::fromCString($tinfo.id.toCString());
    }

    let entrytype = String::concat(enum_name, "::", resolved_name, "_", emitIdentifier(entry.name));
    let byteoffset = String::fromCString((idx * 8n).toCString()); %% Woudlnt be a bad idea to make these 8 byte alignment a const

    let base = String::concat("{ ", id, ", ", entrytype, ", ", byteoffset);
    return String::concat(indent, base, " }");
}

function generateVTable(ant: CPPAssembly::AbstractNominalTypeDecl, fields: List<CPPAssembly::MemberFieldDecl>, ctx: Context, indent: String): String {
    if(fields.size() == 0n) {
        return "";
    }
    
    let nctx = ctx.updateCurrentNamespace(ant.declaredInNS, ant.fullns);
    let full_indent = String::concat("    ", indent);
    
    let name = emitTypeKey(ant.tkey, false, nctx);
    let enum_name = String::concat(name, "_entries");
    let vtable_name = String::concat(name, "_vtable");

    let base = String::concat("const __CoreGC::FieldOffsetInfo ", vtable_name, "[] = ", "{%n;");
    let field_names = fields.mapIdx<String>(fn(f_entry, ii) => generateVTableEntry(f_entry, name, enum_name, ii, ctx, full_indent));
    return String::concat(indent, base, String::joinAll(",%n;", field_names), "%n;", indent, "};%n;"); 
}

function generateEntriesEnum(ant: CPPAssembly::AbstractNominalTypeDecl, fields: List<CPPAssembly::MemberFieldDecl>, ctx: Context, indent: String): String {
    if(fields.size() == 0n) {
        return "";
    }
    
    let nctx = ctx.updateCurrentNamespace(ant.declaredInNS, ant.fullns);
    let full_indent = String::concat("    ", indent);
    
    let name = emitTypeKey(ant.tkey, false, nctx);
    let enum_name = String::concat(name, "_entries");

    let base = String::concat("enum ", enum_name, " : uintptr_t {%n;");
    let field_names = fields.map<String>(fn(f_entry) => String::concat(full_indent, name, "_", emitIdentifier(f_entry.name)));
    return String::concat(indent, base, String::joinAll(",%n;", field_names), "%n;", indent, "};%n;");
}

function convertTagEnumEntries(e: CPPAssembly::Tag): String {
    switch(e) {
        | CPPAssembly::Tag#Value => { return "Value"; }
        | CPPAssembly::Tag#Ref => { return "Ref"; }
        | CPPAssembly::Tag#Tagged => { return "Tagged"; }    
   }
}

function emitTypeInfo(info: CPPAssembly::TypeInfo, ant: Option<CPPAssembly::AbstractNominalTypeDecl>, ctx: Context, indent: String): String {
    let nctx = if(ant)@some then ctx.updateCurrentNamespace($ant.declaredInNS, $ant.fullns) else ctx;
    let full_indent = String::concat("    ", indent);

    let name = removeCppPrefix(emitTypeKey(info.typekey, false, nctx));
    var needsvtable: Bool;
    if(ant)@none { %% We should only need to generate a vtable for concepts
        needsvtable = false;
    }
    else {
        let e = ctx.asm.lookupNominalTypeDeclaration($ant.tkey);
        if((e?<CPPAssembly::ConceptTypeDecl> || e?<CPPAssembly::DatatypeTypeDecl>) && e.saturatedBFieldInfo.size() > 0n) {
            needsvtable = true; 
        }
        else {
            needsvtable = false;
        }
    }

    let tinfo_name = String::concat(name, "Type");

    let base = String::concat(indent, "__CoreGC::TypeInfoBase ", tinfo_name, " = {%n;");
    let id = String::concat(base, full_indent, ".type_id = ", String::fromCString(info.id.toCString()), ",%n;");
    let typesize = String::concat(id, full_indent, ".type_size = ", String::fromCString(info.typesize.toCString()), ", %n;");
    let slotsize = String::concat(typesize, full_indent, ".slot_size = ", String::fromCString(info.slotsize.toCString()), ",%n;");
    let tag = String::concat(slotsize, full_indent, ".tag = __CoreGC::Tag::", convertTagEnumEntries(info.tag), ",%n;");
    let ptrmask = String::concat(tag, full_indent, ".ptr_mask = ", emitEnclosedParen(info.ptrmask), ",%n;");
    let typekey = String::concat(ptrmask, full_indent, ".typekey = ", emitEnclosedParen(info.typekey.value), ",%n;");
    let vtable = if(needsvtable) then String::concat(typekey, full_indent, ".vtable = ", String::concat(name, "_vtable"), "%n;")
        else String::concat(typekey, full_indent, ".vtable = nullptr%n;");

    return String::concat(vtable, indent, "};%n;");
}

function emitSomeTypeDecl(std: CPPAssembly::SomeTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(std.declaredInNS, std.fullns); 
    let full_indent = String::concat("    ", indent);

    let sometype = emitTypeKey(std.tkey, false, nctx);
    let ttype = emitTypeSignature(std.oftype, true, nctx);

    let std_tinfo = emitTypeInfo(nctx.asm.typeinfos.get(std.tkey), some(std@<CPPAssembly::AbstractNominalTypeDecl>), nctx, indent);

    let value = String::concat(sometype, " {%n;", full_indent, ttype, " value;%n;", indent);
    return String::concat(std_tinfo, indent, "struct ", value, "};%n;");
}

function emitMapEntryTypeDecl(mtd: CPPAssembly::MapEntryTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(mtd.declaredInNS, mtd.fullns);
    let full_indent = String::concat("    ", indent);

    let mtdtype = emitTypeKey(mtd.tkey, false, nctx);
    let ktype = emitTypeSignature(mtd.ktype, true, nctx);
    let vtype = emitTypeSignature(mtd.vtype, true, nctx);

    let mtd_tinfo = nctx.asm.typeinfos.get(mtd.tkey);
    let e_mtd_tinfo = emitTypeInfo(mtd_tinfo, some(mtd), nctx, indent);

    let base = String::concat(indent, "struct ", mtdtype, " {%n;");
    let key = String::concat(full_indent, ktype, " key;%n;");
    let value = String::concat(full_indent, vtype, " value;%n;");
    let def = String::concat(base, key, value, indent, "};%n;");

    return String::concat(e_mtd_tinfo, def);

}

function emitCRopeIteratorTypeDecl(crittd: CPPAssembly::CRopeIteratorTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(crittd.declaredInNS, crittd.fullns);
    let tk = emitTypeKey(crittd.tkey, false, nctx);

    return String::concat(indent, "typedef __CoreCpp::CRopeIterator ", tk, ";%n;");
}

function emitConstructableTypeDecl(ctd: CPPAssembly::ConstructableTypeDecl, ctx: Context, indent: String): String {
    match(ctd)@ {
        | CPPAssembly::SomeTypeDecl => { return emitSomeTypeDecl($ctd, ctx, indent); }
        | CPPAssembly::MapEntryTypeDecl => { return emitMapEntryTypeDecl($ctd, ctx, indent); }
        | CPPAssembly::CRopeIteratorTypeDecl => { return emitCRopeIteratorTypeDecl($ctd, ctx, indent); }
    }
}

function emitTypedeclStringOfTypeDeclDef(tdstd: CPPAssembly::TypedeclStringOfTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(tdstd.declaredInNS, tdstd.fullns);

    let tdstdtype = emitTypeKey(tdstd.tkey, false, nctx);
    return String::concat(indent, "typedef Core::CString ", tdstdtype, ";%n;");
}

function emitCollectionTypeDeclDef(ctd: CPPAssembly::CollectionTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(ctd.declaredInNS, ctd.fullns);

    if(ctd)@<CPPAssembly::CRopeTypeDecl> {
        let ropedef = String::concat(indent, "typedef CRopeOps::Rope ", emitTypeKey(ctd.tkey, false, nctx), ";%n;");
        let cstring_alias = String::concat(indent, "typedef CRope CString;%n;");

        return String::concat(ropedef, cstring_alias);
    }
    if(ctd)@<CPPAssembly::UnicodeRopeTypeDecl> {
        let ropedef = String::concat(indent, "typedef UnicodeRopeOps::Rope ", emitTypeKey(ctd.tkey, false, nctx), ";%n;");
        let string_alias = String::concat(indent, "typedef UnicodeRope String;%n;");

        return String::concat(ropedef, string_alias);
    }
    if(ctd)@<CPPAssembly::ListTypeDecl> {
        let ttype = emitTypeSignature($ctd.oftype, false, nctx);
        let resolvedttype = emitSpecialTemplate(removeCppPrefix(ttype));

        return String::concat(indent, "typedef ListOps::Treeᐸ", resolvedttype, "ᐳ ", emitTypeKey(ctd.tkey, false, nctx), ";%n;");
    }
    if(ctd)@<CPPAssembly::MapTypeDecl> {
        let ktype = emitTypeSignature($ctd.ktype, false, nctx);
        let vtype = emitTypeSignature($ctd.vtype, false, nctx);
        let resolvedktype = emitSpecialTemplate(removeCppPrefix(ktype));
        let resolvedvtype = emitSpecialTemplate(removeCppPrefix(vtype));

        let treealias = emitTypeKey($ctd.tkey, false, nctx);
        let mapdef = String::concat("typedef MapOps::Treeᐸ", resolvedktype, "ᐧ", resolvedvtype, "ᐳ ");
        return String::concat(indent, mapdef, treealias, ";%n;");
    }
   
    abort; %% Non supported collection type!
}

function emitPrimitiveEntityTypeDecl(petd: CPPAssembly::PrimitiveEntityTypeDecl, ctx: Context, indent: String): String {
    %%
    %% Currently the cpp emitter has no proper support for regex 
    %% so we will emit as void
    %%
    if(petd.tkey.value === 'CRegex') {
        return String::concat(indent, "typedef void CRegex;%n;");
    }
    elif(petd.tkey.value === 'Regex') {
        return String::concat(indent, "typedef void Regex;%n;");
    }
    else {
        %% Only Regex needs explicit representation right now, others exist in runtime files
        return "";
    }
}

%% Stringof and Collections are emitted with forward decls, so typeinfo only is needed to prevent lookup failures
function emitTypedeclStringOfTypeDeclImpl(tdstd: CPPAssembly::TypedeclStringOfTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(tdstd.declaredInNS, tdstd.fullns);

    %%
    %% TODO: We will need to handle the ofcheck here! right now we 
    %% assume all regex pass
    %%

    let tdstd_tinfo = nctx.asm.typeinfos.get(tdstd.tkey);
    let e_tdstd_tinfo = emitTypeInfo(tdstd_tinfo, some(tdstd), nctx, indent);

    return e_tdstd_tinfo;
}

function emitCollectionTypeDeclImpl(ctd: CPPAssembly::CollectionTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(ctd.declaredInNS, ctd.fullns);

    let ctd_tinfo = nctx.asm.typeinfos.get(ctd.tkey);
    let ectd_tinfo = emitTypeInfo(ctd_tinfo, some(ctd), nctx, indent);

    return ectd_tinfo;
}

function emitAbstractNominalTypeDecl(ant: CPPAssembly::AbstractNominalTypeDecl, declaredIn: CPPAssembly::TypeKey, ctx: Context, indent: String): String {
    match(ant)@ {
        | CPPAssembly::EntityTypeDecl => { return emitEntityTypeDecl($ant, declaredIn, ctx, indent); }
        | CPPAssembly::DatatypeMemberEntityTypeDecl => { return emitDatatypeMemberEntityDecl($ant, declaredIn, ctx, indent); }
        | CPPAssembly::PrimitiveConceptTypeDecl => { return emitPrimtiveConceptTypeDecl($ant, ctx, indent); }
        | CPPAssembly::ConstructableTypeDecl => { return emitConstructableTypeDecl($ant, ctx, indent); }
        | CPPAssembly::CollectionTypeDecl => { return emitCollectionTypeDeclImpl($ant, ctx, indent); } 
        | CPPAssembly::DatatypeTypeDecl => { return emitDatatypeTypeDecl($ant, ctx, indent); } 
        | CPPAssembly::ConceptTypeDecl => { return emitConceptTypeDecl($ant, ctx, indent); }
        | CPPAssembly::EnumTypeDecl => { return emitEnumTypeDecl($ant, ctx, indent); }
        | CPPAssembly::TypedeclStringOfTypeDecl => { return emitTypedeclStringOfTypeDeclImpl($ant, ctx, indent); }
        | CPPAssembly::PrimitiveEntityTypeDecl => { return emitPrimitiveEntityTypeDecl($ant, ctx, indent); } 
    }
}

function getConstDeclBase(declaredType: CPPAssembly::TypeSignature, resolvedname: String, ctx: Context): String, String {    
    let rtype = emitTypeSignature(declaredType, true, ctx);

    return rtype, emitSpecialTemplate(emitResolvedNamespace(ctx.fullns_list, resolvedname)); 
}

function emitNamespaceConstDecl(cnsd: CPPAssembly::NamespaceConstDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(cnsd.declaredInNS, cnsd.fullns);

    let exp = emitExpression(cnsd.value, nctx);
    let rtype, fullname = getConstDeclBase(cnsd.declaredType, cnsd.resolvedname, nctx);

    let pre = String::concat(indent, "inline ", rtype, " ", fullname, "() { return ");
    return String::concat(pre, exp, "; }%n;");
}

%% These two are good cantidates for force inline
function emitConstMemberDecl(cmd: CPPAssembly::ConstMemberDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(cmd.declaredInNS, cmd.fullns);
    
    let exp = emitExpression(cmd.value, nctx);
    let rtype, fullname = getConstDeclBase(cmd.declaredType, cmd.resolvedname, nctx);

    let pre = String::concat(indent, "inline ", rtype, " ", fullname, "() { return ");
    return String::concat(pre, exp, "; }%n;");
}

function emitConstMemberForwardDecl(cmd: CPPAssembly::ConstMemberDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(cmd.declaredInNS, cmd.fullns);
    
    let rtype, fullname = getConstDeclBase(cmd.declaredType, cmd.resolvedname, nctx);   
    
    return String::concat(indent, "inline ", rtype, " ", fullname, "();%n;");
}

function emitNamespaceConstForwardDecl(cnsd: CPPAssembly::NamespaceConstDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(cnsd.declaredInNS, cnsd.fullns);
    
    let rtype, fullname = getConstDeclBase(cnsd.declaredType, cnsd.resolvedname, nctx);   
    
    return String::concat(indent, "inline ", rtype, " ", fullname, "();%n;");
}

function emitPrimtiveConceptTypeDecl(pc: CPPAssembly::PrimitiveConceptTypeDecl, ctx: Context, indent: String): String {
    let nctx = ctx.updateCurrentNamespace(pc.declaredInNS, pc.fullns); 
    return emitTypeInfo(nctx.asm.typeinfos.get(pc.tkey), some(pc@<CPPAssembly::AbstractNominalTypeDecl>), nctx, indent);
}

recursive function emitFuncForwardDeclarations(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);

    let subns_fwddecls = nsdecl.subns.reduce<String>(fn(acc, nsname, subns) => {
        let ns = String::concat(indent, "namespace ", String::fromCString(nsname), " {%n;");
        return String::concat(acc, ns, emitFuncForwardDeclarations[recursive](subns, ctx, full_indent), indent, "}%n;");
    }, "");

    %% Emit our method and func fwd decls
    let nsfunc_fwddecls = nsdecl.nsfuncs.reduce<String>(fn(acc, ikey) => {
        return String::concat(acc, emitFunctionForwardDeclaration(ctx.asm.nsfuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, indent));
    }, subns_fwddecls);

    let typefunc_fwddecls = nsdecl.typefuncs.reduce<String>(fn(acc, ikey) => {
        return String::concat(acc, emitFunctionForwardDeclaration(ctx.asm.typefuncs.get(ikey)@<CPPAssembly::AbstractInvokeDecl>, ctx, indent));
    }, nsfunc_fwddecls);

    return typefunc_fwddecls;
}

recursive function emitNamespaceDecl(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    %% Emit namespace 
    let ns = String::concat(indent, "namespace ", String::fromCString(nsdecl.nsname), " {%n;");
    let full_indent = String::concat("    ", indent);

    %% Emit sub-namespace declarations
    let subns = nsdecl.subns.reduce<String>(fn(acc, name, decl) => {
        return String::concat(acc, emitNamespaceDecl[recursive](decl, ctx, full_indent));
    }, ns);

    let nsconsts_fwddecls = nsdecl.nsconsts
        .reduce<String>(fn(acc, s) => {
            let nsc = ctx.asm.nsconsts.get(s);
            let def = emitNamespaceConstForwardDecl(nsc, ctx, full_indent);
            return String::concat(acc, def);
        },
        String::concat(subns, "//%n;// Constants%n;//%n;")
    );

    let typeconsts_fwddecls = nsdecl.typeconsts
        .reduce<String>(fn(acc, s) => {
            let tc = ctx.asm.typeconsts.get(s);
            let def = emitConstMemberForwardDecl(tc, ctx, full_indent);
            return String::concat(acc, def);
    }, nsconsts_fwddecls);

    let nsconsts = nsdecl.nsconsts
        .reduce<String>(fn(acc, s) => {
            let tc = ctx.asm.nsconsts.get(s);
            let def = emitNamespaceConstDecl(tc, ctx, full_indent);
            return String::concat(acc, def);
        },
        String::concat(typeconsts_fwddecls, "//%n;// Constants%n;//%n;")
    );

    %% Will need nsdecl consts too, this is just ConstMemberDecls 
    let typeconsts = nsdecl.typeconsts
        .reduce<String>(fn(acc, s) => {
            let tc = ctx.asm.typeconsts.get(s);
            let def = emitConstMemberDecl(tc, ctx, full_indent);
            return String::concat(acc, def);
    }, nsconsts);

    %% Emit methods after all type defintions to prevent types not being fully defined but used
    let methods = nsdecl.alltypes
        .reduce<String>(fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let func = emitMethods(ant, tk, ctx, full_indent);
            return String::concat(acc, func);
    }, typeconsts);

    %% Emit functions in current namespace
    let nsfuncs = nsdecl.nsfuncs.reduce<String>(fn(acc, ikey) => {
        let func = ctx.asm.nsfuncs.get(ikey)@<CPPAssembly::FunctionInvokeDecl>;
        let efunc = emitFunctionDecl(func, ctx, full_indent);
        return String::concat(acc, efunc); 
    }, methods);

    let typefuncs = nsdecl.typefuncs.reduce<String>(fn(acc, ikey) => {
        let func = ctx.asm.typefuncs.get(ikey)@<CPPAssembly::FunctionInvokeDecl>;
        let efunc = emitFunctionDecl(func, ctx, full_indent);
        return String::concat(acc, efunc); 
    }, nsfuncs);

    return String::concat(typefuncs, indent, "}%n;");
}

%%
%% Emits forward decls of Ref and Tagged types
%%
function emitNamespaceDeclFwdDecls(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    let ns = String::concat(indent, "namespace ", String::fromCString(nsdecl.nsname), " {%n;");

    let subns_fwddecls = nsdecl.subns
        .reduce<String>(fn(acc, name, decl) => {
            return String::concat(acc, emitNamespaceDeclFwdDecls[recursive](decl, ctx, full_indent));
    }, "");

    let ant_fwddecls = nsdecl.alltypes
        .filter(pred(tk) => !ctx.asm.collections.has(tk) && !ctx.asm.stringoftypedecls.has(tk) && !ctx.asm.enums.has(tk) && !ctx.asm.primitives.has(tk))
        .reduce<String>(fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let fwddecl = emitAbstractNominalForwardDeclaration(ant, ctx, full_indent); 
            return String::concat(acc, fwddecl);
    }, "");

    return String::concat(ns, ant_fwddecls, subns_fwddecls, indent, "}%n;");
}

%% These types depend on another forward decl being already declared
function emitDependantNamespaceDeclFwdDecls(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    let ns = String::concat(indent, "namespace ", String::fromCString(nsdecl.nsname), " {%n;");

    %% Might want to turn some of this repeated logic into a function (we do this in many places)
    let ctds = nsdecl.collections
        .reduce<String>(fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let fwddecl = emitAbstractNominalForwardDeclaration(ant, ctx, full_indent); 
            return String::concat(acc, fwddecl);
    }, "");

    return String::concat(ns, ctds, indent, "}%n;");
}

function emitDependantOnDependantNamespaceDeclFwdDecls(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    let ns = String::concat(indent, "namespace ", String::fromCString(nsdecl.nsname), " {%n;");
    
    let stds = nsdecl.stringoftypedecls
        .reduce<String>(fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let fwddecl = emitAbstractNominalForwardDeclaration(ant, ctx, full_indent); 
            return String::concat(acc, fwddecl);
    }, "");

    return String::concat(ns, stds, indent, "}%n;");
}

%%
%% Emits all necessary types given nsdecl (their concrete definitions)
%%
function emitNamespaceDeclTypes(nsdecl: CPPAssembly::NamespaceDecl, ctx: Context, indent: String): String {
    let full_indent = String::concat("    ", indent);
    let ns = String::concat(indent, "namespace ", String::fromCString(nsdecl.nsname), " {%n;");

    %% Emit enums first
    let enums = nsdecl.alltypes
        .filter(pred(tk) => ctx.asm.enums.has(tk))
        .reduce<String>(fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let def = emitAbstractNominalTypeDecl(ant, tk, ctx, full_indent);
            return String::concat(acc, def);
    }, String::concat(ns, "//%n;// Value Type Definitions%n;//%n;"));

    %% Value types
    let values = nsdecl.alltypes
        .filter(pred(tk) => ctx.asm.typeinfos.get(tk).tag === CPPAssembly::Tag#Value && !ctx.asm.enums.has(tk) && !ctx.asm.collections.has(tk) && !ctx.asm.primitives.has(tk))
        .reduce<String>(fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let def = emitAbstractNominalTypeDecl(ant, tk, ctx, full_indent);
            return String::concat(acc, def);
    }, enums);

    %% Ref and Tagged types
    let other = nsdecl.alltypes
        .filter(pred(tk) => ctx.asm.typeinfos.get(tk).tag !== CPPAssembly::Tag#Value)
        .reduce<String>(fn(acc, tk) => {
            let ant = ctx.asm.lookupNominalTypeDeclaration(tk);
            let def = emitAbstractNominalTypeDecl(ant, tk, ctx, full_indent);
            return String::concat(acc, def);
    }, String::concat(values, "//%n;// Ref and Tagged Type Definitions%n;//%n;"));

    %% Only support static methods for now
    let method_fwddecls = nsdecl.staticmethods
        .reduce<String>(fn(acc, mtkey) => {
            return String::concat(acc, emitMethodForwardDeclaration(ctx.asm.staticmethods.get(mtkey.0), mtkey.1, ctx, full_indent));
    }, String::concat(other, "//%n;// All Methods%n;//%n;"));

    let subns = nsdecl.subns
        .reduce<String>(fn(acc, name, decl) => {
            return String::concat(acc, emitNamespaceDeclTypes[recursive](decl, ctx, full_indent));
    }, method_fwddecls);

    return String::concat(subns, indent, "}%n;");
}

function emitAssembly(asm: CPPAssembly::Assembly): String {    
    let ctx: Context = Context{ asm, CPPAssembly::NamespaceKey::from('Tmp'), List<CString>{''} }; %% No known namespace yet

    let primitive_typeinfos = asm.typeinfos.reduce<String>(fn(acc, tk, ti) => {
        return if(asm.isPrimtitiveType(tk) && tk.value !== 'CString' && tk.value !== 'String') 
            then String::concat(acc, emitTypeInfo(ti, none, ctx, "")) 
            else acc;
    }, "//%n;// Primitive Types%n;//%n;"); 

    let primitives = asm.primitives
        .reduce<String>(fn(acc, tk, petd) => {
            let def = emitAbstractNominalTypeDecl(petd, tk, ctx, "");
            return String::concat(acc, def);
        },
        primitive_typeinfos
    );

    %% Non-value type forward decls
    let fwddecls = asm.nsdecls
        .reduce<String>(fn(acc, nsname, nsdecl) => {
            return String::concat(acc, emitNamespaceDeclFwdDecls(nsdecl, ctx, ""));
    }, String::concat(primitives, "//%n;// Ref and Tagged Type Forward Declarations (and collections)%n;//%n;"));

    %% I dont love the repetition here - might need some thought and redesign
    let dfwddecls = asm.nsdecls
        .reduce<String>(fn(acc, nsname, nsdecl) => {
            return String::concat(acc, emitDependantNamespaceDeclFwdDecls(nsdecl, ctx, ""));
    }, fwddecls);

    let ddfwddecls = asm.nsdecls
        .reduce<String>(fn(acc, nsname, nsdecl) => {
            return String::concat(acc, emitDependantOnDependantNamespaceDeclFwdDecls(nsdecl, ctx, ""));
    }, dfwddecls);

    %% Defintion of Value and Non-value types
    let types = asm.nsdecls.reduce<String>(fn(acc, nsname, nsdecl) => {
        return String::concat(acc, emitNamespaceDeclTypes(nsdecl, ctx, ""));
    }, ddfwddecls);

    %% Function forward decls
    let funcfwddecls = asm.nsdecls
        .reduce<String>(fn(acc, nsname, nsdecl) => {
            let ns = String::concat("", "namespace ", String::fromCString(nsname), " {%n;");
            return String::concat(acc, ns, emitFuncForwardDeclarations(nsdecl, ctx, "    "), "}%n;");
        }, String::concat(types, "//%n;// Namespace/Type Function Forward Declarations%n;//%n;"));


    let ns_emission = asm.nsdecls.reduce<String>(fn(acc, nsname, nsdecl) => {
        return String::concat(acc, emitNamespaceDecl[recursive](nsdecl, ctx, ""));
    }, "//%n;// Emitted Functions/Methods%n;//%n;");

    %% Various size allocators needed for the GC
    var allocs, allocslist, allocmap = asm.typeinfos
        .reduce<(|String, List<String>, Map<Nat, String>|)>(fn(acc, tk, ti) => {
            if(acc.2.has(ti.slotsize) || ti.slotsize == 0n) {
                return acc;
            }
            
            let name = generateGCAlloc(ti);
            let decl = String::concat("GCAllocator ", name);
            let cons = String::concat(decl, "(", natToString(ti.typesize), ", REAL_ENTRY_SIZE(", natToString(ti.typesize), "), collect);%n;");

            return String::concat(acc.0, cons), acc.1.pushBack(String::concat("&", name)), acc.2.insert(ti.slotsize, name);
        }, (|"", List<String>{}, Map<Nat, String>{}|));
    let nallocslist = String::concat("GCAllocator* allocs[", natToString(allocmap.size()), "] = {", String::joinAll(", ", allocslist), "};%n;%n;");

    let gcinfo = String::concat(allocs, nallocslist);

    %% Checking for equality on our ropes needs to be overloaded in global namespace
    var overloads: String = "";
    if(ctx.asm.typeinfos.has(CPPAssembly::TypeKey::from('CRope'))) {
        overloads = String::concat(overloads, "__CoreCpp::Bool operator==(const Core::CString& lhs, const Core::CString& rhs) { return Core::CRopeOps::s_crope_equal(lhs, rhs); }%n;");
        overloads = String::concat(overloads, "__CoreCpp::Bool operator<(const Core::CString& lhs, const Core::CString& rhs) { return Core::CRopeOps::s_crope_less(lhs, rhs); }%n;");
    }
    if(ctx.asm.typeinfos.has(CPPAssembly::TypeKey::from('UnicodeRope'))) {
        overloads = String::concat(overloads, "__CoreCpp::Bool operator==(const Core::String& lhs, const Core::String& rhs) { return Core::UnicodeRopeOps::s_unicoderope_equal(lhs, rhs); }%n;");
        %%overloads = String::concat(overloads, "__CoreCpp::Bool operator<(const Core::String& lhs, const Core::String& rhs) { return Core::UnicodeRopeOps::s_unicoderope_less(lhs, rhs); };%n;");   
    }

    %% We use this bold src so we can split our header and src files into two strings in analyzecpp
    return String::concat(funcfwddecls, overloads, "𝐬𝐫𝐜", gcinfo, ns_emission);
}