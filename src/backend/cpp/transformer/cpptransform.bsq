namespace CPPEmitter;

const reftypeThreshold: Nat = 4n;
const slotSizeInBits: Nat = 8n;

%% Transform Bosque names into cpp representation
namespace CPPTransformNameManager {
    function convertNamespaceKey(nskey: BSQAssembly::NamespaceKey): CPPAssembly::NamespaceKey {
        return CPPAssembly::NamespaceKey::from(nskey.value);
    }

    function convertInvokeKey(ikey: BSQAssembly::InvokeKey): CPPAssembly::InvokeKey {
        return CPPAssembly::InvokeKey::from(ikey.value);
    }

    function convertTypeKey(tk: BSQAssembly::TypeKey): CPPAssembly::TypeKey {
        switch(tk.value) {
            'None' => { return CPPAssembly::TypeKey::from('__CoreCpp::None'); }
            | 'Bool' => { return CPPAssembly::TypeKey::from('__CoreCpp::Bool'); }
            | 'Nat' => { return CPPAssembly::TypeKey::from('__CoreCpp::Nat'); }
            | 'Int' => { return CPPAssembly::TypeKey::from('__CoreCpp::Int'); }
            | 'BigNat' => { return CPPAssembly::TypeKey::from('__CoreCpp::BigNat'); }
            | 'BigInt' => { return CPPAssembly::TypeKey::from('__CoreCpp::BigInt'); }
            | 'Float' => { return CPPAssembly::TypeKey::from('__CoreCpp::Float'); }
            | 'CChar' => { return CPPAssembly::TypeKey::from('__CoreCpp::CChar'); }
            | 'UnicodeChar' => { return CPPAssembly::TypeKey::from('__CoreCpp::UnicodeChar'); }
            | 'CCharBuffer' => { return CPPAssembly::TypeKey::from('__CoreCpp::CCharBuffer'); }
            | 'UnicodeCharBuffer' => { return CPPAssembly::TypeKey::from('__CoreCpp::UnicodeCharBuffer'); }
            | _ => { return CPPAssembly::TypeKey::from(tk.value); } 
        }
    }

    %% Necessary when generating typeinfos for containers
    function revertTypeKey(tk: CPPAssembly::TypeKey): BSQAssembly::TypeKey {
        switch(tk.value) {
            'None' => { return BSQAssembly::TypeKey::from('None'); }
            | '__CoreCpp::Bool' => { return BSQAssembly::TypeKey::from('Bool'); }
            | '__CoreCpp::Nat' => { return BSQAssembly::TypeKey::from('Nat'); }
            | '__CoreCpp::Int' => { return BSQAssembly::TypeKey::from('Int'); }
            | '__CoreCpp::BigNat' => { return BSQAssembly::TypeKey::from('BigNat'); }
            | '__CoreCpp::BigInt' => { return BSQAssembly::TypeKey::from('BigInt'); }
            | '__CoreCpp::Float' => { return BSQAssembly::TypeKey::from('Float'); }
            | '__CoreCpp::CChar' => { return BSQAssembly::TypeKey::from('CChar'); }
            | '__CoreCpp::UnicodeChar' => { return BSQAssembly::TypeKey::from('UnicodeChar'); }
            | '__CoreCpp::CCharBuffer' => { return BSQAssembly::TypeKey::from('CCharBuffer'); }
            | '__CoreCpp::UnicodeCharBuffer' => { return BSQAssembly::TypeKey::from('UnicodeCharBuffer'); }
            | _ => { return BSQAssembly::TypeKey::from(tk.value); }
        }
    }

    function convertIdentifier(ident: BSQAssembly::Identifier): CPPAssembly::Identifier {
        return CPPAssembly::Identifier::from(ident.value);
    }

    function convertVarIdentifier(vident: BSQAssembly::VarIdentifier): CPPAssembly::VarIdentifier {
        return CPPAssembly::VarIdentifier::from(vident.value);
    }

    function convertNominalTypeSignature(nts: BSQAssembly::NominalTypeSignature): CPPAssembly::NominalTypeSignature {
        return CPPAssembly::NominalTypeSignature{ convertTypeKey(nts.tkeystr) };
    }

    function createNamespaceDecl(name: CString): CPPAssembly::NamespaceDecl {
        let subns =             Map<CString, CPPAssembly::NamespaceDecl>{};
        let nsconsts =          List<String>{};
        let typeconsts =        List<String>{};
        let nsfuncs =           List<CPPAssembly::InvokeKey>{};
        let typefuncs =         List<CPPAssembly::InvokeKey>{};
        let constructables =    List<CPPAssembly::TypeKey>{};
        let collections =       List<CPPAssembly::TypeKey>{};
        let entities =          List<CPPAssembly::TypeKey>{};
        let datamembers =       List<CPPAssembly::TypeKey>{};
        let datatypes =         List<CPPAssembly::TypeKey>{};
        let concepts =          List<CPPAssembly::TypeKey>{};
        let pconcepts =         List<CPPAssembly::TypeKey>{};
        let staticmethods =     List<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>{};
        let virtmethods =       List<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>{};
        let absmethods =        List<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>{};
        let overmethods =       List<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>{};
        let enums =             List<CPPAssembly::TypeKey>{};
        let typedecls =         List<CPPAssembly::TypeKey>{};
        let stringoftypedecls = List<CPPAssembly::TypeKey>{};
        let alltypes =          List<CPPAssembly::TypeKey>{};

        return CPPAssembly::NamespaceDecl{ 
            name, subns, nsconsts, typeconsts, nsfuncs, typefuncs, constructables, collections, 
            entities, datamembers, datatypes, concepts, pconcepts, staticmethods, virtmethods, 
            absmethods, overmethods, enums, typedecls, stringoftypedecls, alltypes 
        };
    }

    %% If ns decl does not exist for name insert, otherwise continue recursing until fullns is empty
    recursive function getNamespaceDeclMapping(fullns: List<CString>, nsdecls: Map<CString, CPPAssembly::NamespaceDecl>, insertion: fn(CPPAssembly::NamespaceDecl) -> CPPAssembly::NamespaceDecl): Map<CString, CPPAssembly::NamespaceDecl> {
        if(fullns.empty()) { %% Base case, we have recursed through all subdecls
            return nsdecls;
        }

        let ns_name = fullns.front();
        let remaining_ns_names = fullns.popFront().1;

        var cur_nsdecl: CPPAssembly::NamespaceDecl;
        if(nsdecls.has(ns_name)) {
            cur_nsdecl = nsdecls.get(ns_name);
        }
        else {
            cur_nsdecl = createNamespaceDecl(ns_name);
        }

        %% Recursively process remaining names
        let subns = getNamespaceDeclMapping[recursive](remaining_ns_names, cur_nsdecl.subns, insertion);
        let updated_nsdecl = cur_nsdecl[nsname=ns_name, subns=subns];

        if(remaining_ns_names.empty()) { %% Insert at most nested possible depth
            if(!nsdecls.has(ns_name)) {
                return nsdecls.insert(ns_name, insertion(updated_nsdecl));
            }
            else {
                let tmp_map = nsdecls.delete(ns_name);
                return tmp_map.insert(ns_name, insertion(updated_nsdecl));
            }            
        }

        %% We need to always update the nsdecls map as sub namespaces may change (this handles multiple nsdecls at same depth)
        if(!nsdecls.has(ns_name)) {
            return nsdecls.insert(ns_name, updated_nsdecl);
        }
        else {
            let tmp_map = nsdecls.delete(ns_name);
            return tmp_map.insert(ns_name, updated_nsdecl);
        }
    }

    recursive function repeatCString(str: CString, n: Nat, acc: CString): CString {
        if(n > 0n) {
            return repeatCString[recursive](str, n - 1n, CString::concat(acc, str));
        }
        return acc;
    }
}

entity TypeInfoContext {
    field tinfos: Map<CPPAssembly::TypeKey, CPPAssembly::TypeInfo>;
    field tid: Nat;

    method update(ntk: CPPAssembly::TypeKey, ntinfo: CPPAssembly::TypeInfo): TypeInfoContext { 
        return this[tinfos = $tinfos.insert(ntk, ntinfo), tid = $tid + 1n];
    }
}

entity FieldInfo {
    field typesize: Nat;
    field slotsize: Nat;
    field ptrmask: CString;

    method update(typesize: Nat, slotsize: Nat, ptrmask: CString): FieldInfo {
        return this[typesize = $typesize + typesize, slotsize = $slotsize + slotsize, ptrmask = CString::concat($ptrmask, ptrmask)];
    }
}

entity CPPTransformer {
    field bsqasm: BSQAssembly::Assembly;

    recursive method convertTypeSignature(tsig: BSQAssembly::TypeSignature): CPPAssembly::TypeSignature {
        let tk = CPPTransformNameManager::convertTypeKey(tsig.tkeystr);
        
        if(tsig)@<BSQAssembly::EListTypeSignature> {
            let args = $tsig.entries.map<CPPAssembly::TypeSignature>(fn(ts) => this.convertTypeSignature[recursive](ts));
            return CPPAssembly::EListTypeSignature{ tk, args };
        }
        if(tsig)@<BSQAssembly::LambdaTypeSignature> {
            let params = $tsig.params.map<CPPAssembly::LambdaParameterSignature>(fn(lps) => 
                CPPAssembly::LambdaParameterSignature { 
                    CPPTransformNameManager::convertIdentifier(lps.pname), this.convertTypeSignature[recursive](lps.ptype)
                }
            );
            let resultType = this.convertTypeSignature[recursive]($tsig.resultType);

            return CPPAssembly::LambdaTypeSignature{ tk, $tsig.isPredLambda, params, resultType };
        }
        else {
            return CPPAssembly::NominalTypeSignature{ tk };
        }
    }

    method shouldBeRef(tkey: Option<BSQAssembly::TypeKey>, tsig: Option<BSQAssembly::TypeSignature>): Bool {
        var tk: BSQAssembly::TypeKey;
        if(tsig)@some {
            let ntsig = $tsig;
            if(ntsig)@<BSQAssembly::EListTypeSignature> {
                return false;
            }
            tk = ntsig.tkeystr;
        }
        else {
            tk = tkey@some;
        }
        
        let fields = this.bsqasm.lookupNominalTypeDeclaration(tk).saturatedBFieldInfo;
        let primitiveAndBelowThresh = fields.reduce<(|Bool, Nat|)>((|true, 0n|), fn(acc, f) => {
            let ftype = f.ftype;
            if(ftype)@<BSQAssembly::EListTypeSignature> {
                return true, acc.1 + $ftype.entries.size();
            }

            return (acc.0 && (this.bsqasm.isPrimtitiveType(ftype.tkeystr) || this.bsqasm.enums.has(ftype.tkeystr))), acc.1 + 1n;
        });

        if(primitiveAndBelowThresh.1 > reftypeThreshold || !primitiveAndBelowThresh.0) {
            return true;
        }

        return false;
    }

    %% We will have to manually determine if we are tagged 
    method determineTag(tkey: Option<BSQAssembly::TypeKey>, tsig: Option<BSQAssembly::TypeSignature>): CPPAssembly::Tag {
        if(this.shouldBeRef(tkey, tsig)) {
            return CPPAssembly::Tag#Ref;
        }
        return CPPAssembly::Tag#Value;
    }

    recursive method processBinaryArgs(lhs: BSQAssembly::Expression, rhs: BSQAssembly::Expression): CPPAssembly::Expression, CPPAssembly::Expression {
        let cpplhs = this.transformExpressionToCpp[recursive](lhs);
        let cpprhs = this.transformExpressionToCpp[recursive](rhs);

        return cpplhs, cpprhs;
    }

    recursive method transformBinAddExpressionToCpp(expr: BSQAssembly::BinAddExpression): CPPAssembly::BinAddExpression {
        let lexpr, rexpr = this.processBinaryArgs[recursive](expr.lhs, expr.rhs);
        return CPPAssembly::BinAddExpression{ lexpr.etype, lexpr, rexpr };
    }

    recursive method transformBinSubExpressionToCpp(expr: BSQAssembly::BinSubExpression): CPPAssembly::BinSubExpression {
        let lexpr, rexpr = this.processBinaryArgs[recursive](expr.lhs, expr.rhs);
        return CPPAssembly::BinSubExpression{ lexpr.etype, lexpr, rexpr };
    }

    recursive method transformBinDivExpressionToCpp(expr: BSQAssembly::BinDivExpression): CPPAssembly::BinDivExpression {
        let lexpr, rexpr = this.processBinaryArgs[recursive](expr.lhs, expr.rhs);
        return CPPAssembly::BinDivExpression{ lexpr.etype, lexpr, rexpr };
    }

    recursive method transformBinMultExpressionToCpp(expr: BSQAssembly::BinMultExpression): CPPAssembly::BinMultExpression {
        let lexpr, rexpr = this.processBinaryArgs[recursive](expr.lhs, expr.rhs);
        return CPPAssembly::BinMultExpression{ lexpr.etype, lexpr, rexpr };
    }

    method transformLiteralNoneExpression(expr: BSQAssembly::LiteralNoneExpression): CPPAssembly::LiteralNoneExpression {
        let etype = this.convertTypeSignature(expr.etype);
        return CPPAssembly::LiteralNoneExpression{ etype };
    }

    method transformLiteralSimpleExpression(expr: BSQAssembly::LiteralSimpleExpression): CPPAssembly::LiteralSimpleExpression {
        let val = expr.value;
        let exprtype = this.convertTypeSignature(expr.etype);

        %% May be cleaner to handle in cppemit
        if(val.endsWithString('i')) {
            return CPPAssembly::LiteralSimpleExpression{ exprtype, val.removeSuffixString('i') };
        }
        elif(val.endsWithString('I')) {
            return CPPAssembly::LiteralSimpleExpression{ exprtype, val.removeSuffixString('I') };
        }
        elif(val.endsWithString('n')) {
            return CPPAssembly::LiteralSimpleExpression{ exprtype, val.removeSuffixString('n') };
        }
        elif(val.endsWithString('N')) {
            return CPPAssembly::LiteralSimpleExpression{ exprtype, val.removeSuffixString('N') };
        }
        elif(val.endsWithString('f')) {
            return CPPAssembly::LiteralSimpleExpression{ exprtype, val.removeSuffixString('f') };
        }
        else { %% Fall through, may need explicit handling in future
            return CPPAssembly::LiteralSimpleExpression{ exprtype, val };
        }
    }

    method transformAccessVariableExpression(expr: BSQAssembly::AccessVariableExpression): CPPAssembly::AccessVariableExpression {
        let vname = CPPTransformNameManager::convertVarIdentifier(expr.vname);
        let vtype = this.convertTypeSignature(expr.etype);
        let layouttype = this.convertTypeSignature(expr.layouttype);

        return CPPAssembly::AccessVariableExpression { vtype, vname, layouttype };
    }

    recursive method transformUnaryExpression(uexpr: BSQAssembly::UnaryExpression): CPPAssembly::UnaryExpression {
        let expr = this.transformExpressionToCpp[recursive](uexpr.exp);

        match(uexpr)@ {
            BSQAssembly::PrefixNotOpExpression => { return CPPAssembly::PrefixNotOpExpression{ expr.etype, expr }; }
            | BSQAssembly::PrefixNegateOpExpression => { return CPPAssembly::PrefixNegateOpExpression{ expr.etype, expr }; }
            | BSQAssembly::PrefixPlusOpExpression => { return CPPAssembly::PrefixPlusOpExpression{ expr.etype, expr }; }
        }
    }

    %% I think we can simplify this and remove the transform functions, just match our bsqasm type then return transform type
    recursive method transformBinaryArithExpression(binarith: BSQAssembly::BinaryArithExpression): CPPAssembly::BinaryArithExpression {
        match(binarith)@ {
            BSQAssembly::BinAddExpression => { return this.transformBinAddExpressionToCpp[recursive]($binarith); }
            | BSQAssembly::BinSubExpression => { return this.transformBinSubExpressionToCpp[recursive]($binarith); }           
            | BSQAssembly::BinDivExpression => { return this.transformBinDivExpressionToCpp[recursive]($binarith); }
            | BSQAssembly::BinMultExpression => { return this.transformBinMultExpressionToCpp[recursive]($binarith); }
        }
    }

    recursive method transformBinaryNumericCompareExpression(expr: BSQAssembly::BinaryNumericExpression): CPPAssembly::BinaryNumericExpression {
        let cpplhs, cpprhs = this.processBinaryArgs[recursive](expr.lhs, expr.rhs);

        let cpptype = this.convertTypeSignature(expr.etype);
        match(expr)@ {
            BSQAssembly::NumericEqExpression => { return CPPAssembly::NumericEqExpression { cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::NumericNeqExpression => { return CPPAssembly::NumericNeqExpression{ cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::NumericLessExpression => { return CPPAssembly::NumericLessExpression{ cpptype, cpplhs, cpprhs}; }
            | BSQAssembly::NumericLessEqExpression => { return CPPAssembly::NumericLessEqExpression{ cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::NumericGreaterExpression => { return CPPAssembly::NumericGreaterExpression{ cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::NumericGreaterEqExpression => { return CPPAssembly::NumericGreaterEqExpression{ cpptype, cpplhs, cpprhs }; }
        }
    }

    recursive method transformBinLogicExpression(expr: BSQAssembly::BinLogicExpression): CPPAssembly::BinLogicExpression {
        let cpplhs, cpprhs = this.processBinaryArgs[recursive](expr.lhs, expr.rhs);
        let cpptype = this.convertTypeSignature(expr.etype);

        match(expr)@ {
            BSQAssembly::BinLogicAndExpression => { return CPPAssembly::BinLogicAndExpression{ cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::BinLogicOrExpression => { return CPPAssembly::BinLogicOrExpression{ cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::BinLogicImpliesExpression => { return CPPAssembly::BinLogicImpliesExpression{ cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::BinLogicIFFExpression => { return CPPAssembly::BinLogicIFFExpression{ cpptype, cpplhs, cpprhs }; }
        }
    }

    recursive method transformLogicActionAndExpression(expr: BSQAssembly::LogicActionAndExpression): CPPAssembly::LogicActionAndExpression {
        let args = expr.args.map<CPPAssembly::Expression>(fn(e) => this.transformExpressionToCpp(e));
        let cpptype = this.convertTypeSignature(expr.etype);

        return CPPAssembly::LogicActionAndExpression{cpptype, args};
    }

    recursive method transformLogicActionOrExpression(expr: BSQAssembly::LogicActionOrExpression): CPPAssembly::LogicActionOrExpression {
        let args = expr.args.map<CPPAssembly::Expression>(fn(e) => this.transformExpressionToCpp(e));
        let cpptype = this.convertTypeSignature(expr.etype);

        return CPPAssembly::LogicActionOrExpression{cpptype, args};
    }

    method transformArguments(al: Option<List<BSQAssembly::Expression>>): List<CPPAssembly::Expression> { 
        if(al)@none {
            return List<CPPAssembly::Expression>{};
        }
        else {
            let args = $al.map<CPPAssembly::Expression>(fn(arg) => this.transformExpressionToCpp(arg));
            return args;
        }
    }

    method transformCallNamespaceFunctionExpression(expr: BSQAssembly::CallNamespaceFunctionExpression): CPPAssembly::CallNamespaceFunctionExpression {
        let ts = this.convertTypeSignature(expr.etype);
        let ikey = CPPTransformNameManager::convertInvokeKey(expr.ikey);
        let ns = CPPTransformNameManager::convertNamespaceKey(expr.ns);
        let args = this.transformArguments(expr.argsinfo.resolvedargs);
        let fullns = expr.fullns;

        return CPPAssembly::CallNamespaceFunctionExpression{ ts, ikey, ns, fullns, args };
    }

    method transformCallTypeFunctionExpression(expr: BSQAssembly::CallTypeFunctionExpression): CPPAssembly::CallTypeFunctionExpression {
        let ts = this.convertTypeSignature(expr.etype);
        let ikey = CPPTransformNameManager::convertInvokeKey(expr.ikey);
        let ttype = CPPTransformNameManager::convertNominalTypeSignature(expr.ttype);
        let resolvedDeclType = CPPTransformNameManager::convertNominalTypeSignature(expr.resolvedDeclType);
        let args = this.transformArguments(expr.argsinfo.resolvedargs);

        return CPPAssembly::CallTypeFunctionExpression{ ts, ikey, ttype, resolvedDeclType, args };
    }

    method transformCallTypeFunctionSpecialExpression(expr: BSQAssembly::CallTypeFunctionSpecialExpression): CPPAssembly::CallTypeFunctionSpecialExpression {
        let ts = this.convertTypeSignature(expr.etype);
        let ikey = CPPTransformNameManager::convertInvokeKey(expr.ikey);
        let ttype = CPPTransformNameManager::convertNominalTypeSignature(expr.ttype);
        let resolvedDeclType = CPPTransformNameManager::convertNominalTypeSignature(expr.resolvedDeclType);
        let name = CPPTransformNameManager::convertIdentifier(expr.name);
        let exp = this.transformExpressionToCpp(expr.exp);

        return CPPAssembly::CallTypeFunctionSpecialExpression{ ts, ikey, ttype, resolvedDeclType, name, exp };
    }

    method transformPostfixAccessFromName(op: BSQAssembly::PostfixAccessFromName, baseType: CPPAssembly::TypeSignature): CPPAssembly::PostfixAccessFromName {
        let name = CPPTransformNameManager::convertIdentifier(op.name);
        let declaredInType = CPPTransformNameManager::convertNominalTypeSignature(op.declaredInType);
        let ftype = this.convertTypeSignature(op.ftype);

        return CPPAssembly::PostfixAccessFromName{ baseType, name, declaredInType, ftype };
    }

    method transformPostfixInvokeStatic(op: BSQAssembly::PostfixInvokeStatic, baseType: CPPAssembly::TypeSignature): CPPAssembly::PostfixInvokeStatic {
        let resolvedType = CPPTransformNameManager::convertNominalTypeSignature(op.resolvedType);
        let resolvedTrgt = CPPTransformNameManager::convertInvokeKey(op.resolvedTrgt);
        let args = this.transformArguments(op.argsinfo.resolvedargs);

        return CPPAssembly::PostfixInvokeStatic{ baseType, resolvedType, resolvedTrgt, args };
    }

    method transformPostfixAssignFields(op: BSQAssembly::PostfixAssignFields, baseType: CPPAssembly::TypeSignature): CPPAssembly::PostfixAssignFields {
        let declOnType = this.convertTypeSignature(op.declOnType)@<CPPAssembly::NominalTypeSignature>;
        let updates = op.updates.map<(|CPPAssembly::NominalTypeSignature, CPPAssembly::Identifier, CPPAssembly::NominalTypeSignature, CPPAssembly::Expression|)>(
            fn(upd) => {
                let declaredInType = this.convertTypeSignature(upd.0);
                let fname = CPPTransformNameManager::convertIdentifier(upd.1);
                let ftype = this.convertTypeSignature(upd.2);
                let update = this.transformExpressionToCpp(upd.3);

                return declaredInType@<CPPAssembly::NominalTypeSignature>, fname, ftype@<CPPAssembly::NominalTypeSignature>, update;
            }
        );

        return CPPAssembly::PostfixAssignFields{ baseType, declOnType, updates };
    }

    method transformITestType(it: BSQAssembly::ITestType, isnot: Bool): CPPAssembly::ITestType {
        let ttype = this.convertTypeSignature(it.ttype);
        return CPPAssembly::ITestType{ isnot, ttype };    
    }

    method transformITestSome(isnot: Bool): CPPAssembly::ITestSome {
        return CPPAssembly::ITestSome{ isnot };
    }

    method transformITestNone(isnot: Bool): CPPAssembly::ITestNone {
        return CPPAssembly::ITestNone{ isnot };
    }

    %% TODO: Support for ITest as convert
    method transformITestAsTest(itest: BSQAssembly::ITest): CPPAssembly::ITest {
        let isnot = itest.isnot;
        match(itest)@ {
            BSQAssembly::ITestType => { return this.transformITestType($itest, isnot); }
            | BSQAssembly::ITestNone => { return this.transformITestNone(isnot); }
            | BSQAssembly::ITestSome => { return this.transformITestSome(isnot); }
            | BSQAssembly::ITestOk => { abort; }
            | BSQAssembly::ITestFail => { abort; }
        }
    }

    method transformPostfixOpImpl(op: BSQAssembly::PostfixOperation): CPPAssembly::PostfixOperation {
        let baseType = this.convertTypeSignature(op.baseType);
        match(op)@ {
            BSQAssembly::PostfixAccessFromName => { return this.transformPostfixAccessFromName($op, baseType); }
            | BSQAssembly::PostfixProjectFromNames => { abort; }
            | BSQAssembly::PostfixAccessFromIndex => { return CPPAssembly::PostfixAccessFromIndex{ baseType, $op.idxk }; }
            | BSQAssembly::PostfixIsTest => { return CPPAssembly::PostfixIsTest{ baseType, this.transformITestAsTest($op.ttest) }; }
            | BSQAssembly::PostfixAsConvert => { return CPPAssembly::PostfixAsConvert{ baseType, this.transformITestAsTest($op.ttest) }; }
            | BSQAssembly::PostfixAssignFields => { return this.transformPostfixAssignFields($op, baseType); }
            | BSQAssembly::PostfixInvokeStatic => { return this.transformPostfixInvokeStatic($op, baseType); }
            | BSQAssembly::PostfixInvokeVirtual => { abort; }
            | BSQAssembly::PostfixLiteralKeyAccess => { abort; }
            | BSQAssembly::PostfixBoolConstant => { return CPPAssembly::PostfixBoolConstant{ baseType, $op.value }; }
            | BSQAssembly::PostfixNop => { abort; }
            | BSQAssembly::PostfixAbort => { abort; }
            | BSQAssembly::PostfixWidenConvert => { abort; }
            | BSQAssembly::PostfixAccessSomeValue => { return CPPAssembly::PostfixAccessSomeValue{ baseType }; }
            | BSQAssembly::PostfixLiteralNoneValue => { abort; }
        }
    }

    method transformPostfixOp(pop: BSQAssembly::PostfixOp): CPPAssembly::PostfixOp {
        let etype = this.convertTypeSignature(pop.etype);
        let rootExp = this.transformExpressionToCpp(pop.rootExp);
        let ops = pop.ops.map<CPPAssembly::PostfixOperation>(fn(op) => {
            return this.transformPostfixOpImpl(op);
        });

        return CPPAssembly::PostfixOp{ etype, rootExp, ops };
    }

    method transformConstructorPrimarySpecialMapEntryExpression(cpsmee: BSQAssembly::ConstructorPrimarySpecialMapEntryExpression): CPPAssembly::ConstructorPrimarySpecialMapEntryExpression {
        let etype = this.convertTypeSignature(cpsmee.etype);
        let ctype = CPPTransformNameManager::convertNominalTypeSignature(cpsmee.ctype);

        let key = this.transformExpressionToCpp(cpsmee.key);
        let value = this.transformExpressionToCpp(cpsmee.value);

        let keytype = this.convertTypeSignature(cpsmee.keytype);
        let valuetype = this.convertTypeSignature(cpsmee.valuetype);

        %% To prevent conflicts with other special constructors key and value location
        %% are flipped :/
        return CPPAssembly::ConstructorPrimarySpecialMapEntryExpression{ etype, ctype, value, key, keytype, valuetype };
    }

    method transformConstructorPrimarySpecialSomeExpression(cpsse: BSQAssembly::ConstructorPrimarySpecialSomeExpression): CPPAssembly::ConstructorPrimarySpecialSomeExpression {
        let etype = this.convertTypeSignature(cpsse.etype);
        let ctype = CPPTransformNameManager::convertNominalTypeSignature(cpsse.ctype);

        let value = this.transformExpressionToCpp(cpsse.value);
        let ofttype = this.convertTypeSignature(cpsse.ofttype);
        
        return CPPAssembly::ConstructorPrimarySpecialSomeExpression{ etype, ctype, value, ofttype };
    }

    method transformConstructorPrimarySpecialOkExpression(cpsoe: BSQAssembly::ConstructorPrimarySpecialOkExpression): CPPAssembly::ConstructorPrimarySpecialOkExpression {
        abort; %% TODO: Not Implemented
    }   

    method transformConstructorPrimarySpecialFailExpression(cpsfe: BSQAssembly::ConstructorPrimarySpecialFailExpression): CPPAssembly::ConstructorPrimarySpecialFailExpression {
        abort; %% TODO: Not Implemented
    }

    method transformConstructorPrimarySpecialConstructableExpression(cpsce: BSQAssembly::ConstructorPrimarySpecialConstructableExpression): CPPAssembly::ConstructorPrimarySpecialConstructableExpression {
        match(cpsce)@ {
            BSQAssembly::ConstructorPrimarySpecialSomeExpression => { return this.transformConstructorPrimarySpecialSomeExpression($cpsce); }
            | BSQAssembly::ConstructorPrimarySpecialOkExpression => { return this.transformConstructorPrimarySpecialOkExpression($cpsce); }
            | BSQAssembly::ConstructorPrimarySpecialFailExpression => { return this.transformConstructorPrimarySpecialFailExpression($cpsce); }
            | BSQAssembly::ConstructorPrimarySpecialMapEntryExpression => { return this.transformConstructorPrimarySpecialMapEntryExpression($cpsce); }    
        }
    }

    method transformConstructorStdExpression(e: BSQAssembly::ConstructorStdExpression): CPPAssembly::ConstructorStdExpression {
        let etype = this.convertTypeSignature(e.etype);
        let ctype = CPPTransformNameManager::convertNominalTypeSignature(e.ctype); 
        let args = this.transformArguments(e.argsinfo.resolvedargs);
        return CPPAssembly::ConstructorStdExpression{ etype, ctype, e.fullns, args };
    } 

    method transformConstructorEListExpression(cee: BSQAssembly::ConstructorEListExpression): CPPAssembly::ConstructorEListExpression {
        let etype = this.convertTypeSignature(cee.etype);
        let args = cee.args.map<CPPAssembly::Expression>(fn(e) => this.transformExpressionToCpp(e)); 

        return CPPAssembly::ConstructorEListExpression{ etype, args };
    }

    method transformConstructorPrimaryListExpression(cple: BSQAssembly::ConstructorPrimaryListExpression): CPPAssembly::ConstructorPrimaryListExpression {
        let etype = this.convertTypeSignature(cple.etype);
        let ctype = CPPTransformNameManager::convertNominalTypeSignature(cple.ctype);
        let elemtype = this.convertTypeSignature(cple.elemtype);
        let args = cple.args.map<CPPAssembly::Expression>(fn(arg) => this.transformExpressionToCpp(arg.exp));

        return CPPAssembly::ConstructorPrimaryListExpression{ etype, ctype, elemtype, args };
    }

    method transformConstructorPrimaryMapExpression(cpme: BSQAssembly::ConstructorPrimaryMapExpression): CPPAssembly::ConstructorPrimaryMapExpression {
        let etype = this.convertTypeSignature(cpme.etype);
        let ctype = CPPTransformNameManager::convertNominalTypeSignature(cpme.ctype);
        let elemtype = this.convertTypeSignature(cpme.elemtype);
        let args = cpme.args.map<CPPAssembly::Expression>(fn(arg) => this.transformExpressionToCpp(arg.exp));
        let keytype = this.convertTypeSignature(cpme.keytype);
        let valuetype = this.convertTypeSignature(cpme.valuetype);

        return CPPAssembly::ConstructorPrimaryMapExpression{ etype, ctype, elemtype, args, keytype, valuetype };
    }

    method transformConstructorPrimaryCollectionSingletonsExpression(cpcse: BSQAssembly::ConstructorPrimaryCollectionSingletonsExpression): CPPAssembly::ConstructorPrimaryCollectionSingletonsExpression {
        match(cpcse)@ {
            BSQAssembly::ConstructorPrimaryListExpression => { return this.transformConstructorPrimaryListExpression($cpcse); }
            | BSQAssembly::ConstructorPrimaryMapExpression => { return this.transformConstructorPrimaryMapExpression($cpcse); }
        }
    }

    method transformConstructorPrimaryExpression(cpe: BSQAssembly::ConstructorPrimaryExpression): CPPAssembly::ConstructorPrimaryExpression {
        match(cpe)@ {
            BSQAssembly::ConstructorStdExpression => { return this.transformConstructorStdExpression($cpe); }
            | BSQAssembly::ConstructorPrimarySpecialConstructableExpression => { return this.transformConstructorPrimarySpecialConstructableExpression($cpe); }
            | BSQAssembly::ConstructorPrimaryCollectionSingletonsExpression => { return this.transformConstructorPrimaryCollectionSingletonsExpression($cpe); }
            | BSQAssembly::ConstructorTypeDeclExpression => { abort; }
            | BSQAssembly::ConstructorTypeDeclStringExpression => { abort; }
        }
    }

    method transformConstructorExpression(ce: BSQAssembly::ConstructorExpression): CPPAssembly::ConstructorExpression {
        match(ce)@ {
            BSQAssembly::ConstructorPrimaryExpression => { return this.transformConstructorPrimaryExpression($ce); }
            | BSQAssembly::ConstructorEListExpression => { return this.transformConstructorEListExpression($ce); }
        }
    }

    method transformIfExpression(exp: BSQAssembly::IfExpression): CPPAssembly::IfExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let texp = this.transformExpressionToCpp(exp.texp);

        let thenexp = this.transformExpressionToCpp(exp.thenexp);
        let elseexp = this.transformExpressionToCpp(exp.elseexp);

        match(exp)@ {
            BSQAssembly::IfSimpleExpression => { return CPPAssembly::IfSimpleExpression{ etype, texp, thenexp, elseexp }; }
            | BSQAssembly::IfTestExpression => { return CPPAssembly::IfTestExpression{ etype, texp, thenexp, elseexp, this.transformITestAsTest($exp.itest) }; }
            | BSQAssembly::IfBinderExpression => { return CPPAssembly::IfBinderExpression{ etype, texp, thenexp, elseexp, this.transformITestAsTest($exp.itest), this.transformBinderInfo($exp.binder) };}
        }
    }

    method transformCoerceWidenTypeExpression(exp: BSQAssembly::CoerceWidenTypeExpression): CPPAssembly::CoerceWidenTypeExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let expr = this.transformExpressionToCpp(exp.exp);
        let srctype = CPPTransformNameManager::convertNominalTypeSignature(exp.srctype);
        let trgttype = CPPTransformNameManager::convertNominalTypeSignature(exp.trgttype);

        return CPPAssembly::CoerceWidenTypeExpression{ etype, expr, srctype, trgttype };
    }

    method transformCoerceNarrowTypeExpression(exp: BSQAssembly::CoerceNarrowTypeExpression): CPPAssembly::CoerceNarrowTypeExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let expr = this.transformExpressionToCpp(exp.exp);
        let srctype = CPPTransformNameManager::convertNominalTypeSignature(exp.srctype);
        let trgttype = CPPTransformNameManager::convertNominalTypeSignature(exp.trgttype);

        return CPPAssembly::CoerceNarrowTypeExpression{ etype, expr, srctype, trgttype };
    }

    method transformSafeConvertExpression(exp: BSQAssembly::SafeConvertExpression): CPPAssembly::SafeConvertExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let expr = this.transformExpressionToCpp(exp.exp);
        let srctype = CPPTransformNameManager::convertNominalTypeSignature(exp.srctype);
        let trgttype = CPPTransformNameManager::convertNominalTypeSignature(exp.trgttype);

        return CPPAssembly::SafeConvertExpression{ etype, expr, srctype, trgttype };
    }

    method transformCreateDirectExpression(exp: BSQAssembly::CreateDirectExpression): CPPAssembly::CreateDirectExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let expr = this.transformExpressionToCpp(exp.exp);
        let srctype = CPPTransformNameManager::convertNominalTypeSignature(exp.srctype);
        let trgttype = CPPTransformNameManager::convertNominalTypeSignature(exp.trgttype);

        return CPPAssembly::CreateDirectExpression{ etype, expr, srctype, trgttype };
    }

    method transformAccessEnumExpression(exp: BSQAssembly::AccessEnumExpression): CPPAssembly::AccessEnumExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let stype = CPPTransformNameManager::convertNominalTypeSignature(exp.stype);

        return CPPAssembly::AccessEnumExpression{ etype, stype, exp.name };   
    }

    method transformAccessStaticFieldExpression(exp: BSQAssembly::AccessStaticFieldExpression): CPPAssembly::AccessStaticFieldExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let stype = CPPTransformNameManager::convertNominalTypeSignature(exp.stype);

        let resolvedname = String::concat(String::fromCString(exp.stype.tkeystr.value), "ᘏ", String::fromCString(exp.name.value))
            .replaceAllStringOccurrences(" ", "");

        return CPPAssembly::AccessStaticFieldExpression{ etype, stype, resolvedname };
    }

    method transformBinaryKeyEqExpression(exp: BSQAssembly::BinaryKeyEqExpression): CPPAssembly::BinaryKeyEqExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let opertype = this.convertTypeSignature(exp.opertype);
        
        match(exp)@ {
            BSQAssembly::BinKeyEqNoneExpression => { return CPPAssembly::BinKeyEqNoneExpression{ etype, opertype, this.transformExpressionToCpp($exp.exp) }; }
            | BSQAssembly::BinKeyNotEqNoneExpression => { return CPPAssembly::BinKeyNotEqNoneExpression{ etype, opertype, this.transformExpressionToCpp($exp.exp) }; }
            | BSQAssembly::BinKeySomeEqExpression => { 
                return CPPAssembly::BinKeySomeEqExpression{ 
                    etype, opertype, this.transformExpressionToCpp($exp.eqoption), this.transformExpressionToCpp($exp.eqval) }; }
            | BSQAssembly::BinKeyNotSomeEqExpression => { 
                return CPPAssembly::BinKeyNotSomeEqExpression{ 
                    etype, opertype, this.transformExpressionToCpp($exp.eqoption), this.transformExpressionToCpp($exp.eqval) }; }
            | BSQAssembly::BinKeyEqExpression => { 
                return CPPAssembly::BinKeyEqExpression{ 
                    etype, opertype, this.transformExpressionToCpp($exp.lhs), this.transformExpressionToCpp($exp.rhs) }; }
            | BSQAssembly::BinKeyNotEqExpression => { 
                return CPPAssembly::BinKeyNotEqExpression{ 
                    etype, opertype, this.transformExpressionToCpp($exp.lhs), this.transformExpressionToCpp($exp.rhs) }; }
        }
    }

    method transformKeyCmpEqualExpression(exp: BSQAssembly::KeyCmpEqualExpression): CPPAssembly::KeyCmpEqualExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let ktype = this.convertTypeSignature(exp.ktype);
        let opertype = this.convertTypeSignature(exp.opertype);
        let lhs = this.transformExpressionToCpp(exp.lhs);
        let rhs = this.transformExpressionToCpp(exp.rhs);

        return CPPAssembly::KeyCmpEqualExpression{ etype, ktype, opertype, lhs, rhs };
    }

    method transformKeyCmpLessExpression(exp: BSQAssembly::KeyCmpLessExpression): CPPAssembly::KeyCmpLessExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let ktype = this.convertTypeSignature(exp.ktype);
        let opertype = this.convertTypeSignature(exp.opertype);
        let lhs = this.transformExpressionToCpp(exp.lhs);
        let rhs = this.transformExpressionToCpp(exp.rhs);

        return CPPAssembly::KeyCmpLessExpression{ etype, ktype, opertype, lhs, rhs };
    }

    method transformConstructorLambdaExpression(exp: BSQAssembly::ConstructorLambdaExpression): CPPAssembly::ConstructorLambdaExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let body = this.transformBodyToCpp(exp.body);

        return CPPAssembly::ConstructorLambdaExpression{ etype, body };
    }

    method transformLambdaInvokeArgumentInfo(lia: BSQAssembly::LambdaInvokeArgumentInfo): CPPAssembly::LambdaInvokeArgumentInfo {
        let name = CPPTransformNameManager::convertIdentifier(lia.name);
        let args = lia.resolvedargs@some.map<CPPAssembly::Expression>(fn(arg) => this.transformExpressionToCpp(arg));

        return CPPAssembly::LambdaInvokeArgumentInfo{ name, args };
    }

    method transformLambdaInvokeExpression(exp: BSQAssembly::LambdaInvokeExpression): CPPAssembly::LambdaInvokeExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let lambda = this.convertTypeSignature(exp.lambda);
        let fname = CPPTransformNameManager::convertIdentifier(exp.fname);
        let argsinfo = this.transformLambdaInvokeArgumentInfo(exp.argsinfo);

        return CPPAssembly::LambdaInvokeExpression{ etype, exp.isCapturedLambda, lambda@<CPPAssembly::LambdaTypeSignature>, fname, argsinfo };
    }

    method transformAccessCapturedVariableExpression(exp: BSQAssembly::AccessCapturedVariableExpression): CPPAssembly::AccessCapturedVariableExpression {
        let etype = this.convertTypeSignature(exp.etype);       
        let vname = CPPTransformNameManager::convertVarIdentifier(exp.vname);

        return CPPAssembly::AccessCapturedVariableExpression{ etype, vname };
    }
 
    method transformLiteralCStringExpression(exp: BSQAssembly::LiteralCStringExpression): CPPAssembly::LiteralCStringExpression {
        let etype = this.convertTypeSignature(exp.etype);
        return CPPAssembly::LiteralCStringExpression{ etype, exp.value };
    }

    method transformLiteralStringExpression(exp: BSQAssembly::LiteralStringExpression): CPPAssembly::LiteralStringExpression {
        let etype = this.convertTypeSignature(exp.etype);       
        return CPPAssembly::LiteralStringExpression{ etype, exp.value };
    }

    method transformLiteralCCharExpression(exp: BSQAssembly::LiteralCCharExpression): CPPAssembly::LiteralCCharExpression {
        let etype = this.convertTypeSignature(exp.etype); 
        return CPPAssembly::LiteralCCharExpression{ etype, exp.value };
    }

    method transformLiteralUnicodeCharExpression(exp: BSQAssembly::LiteralUnicodeCharExpression): CPPAssembly::LiteralUnicodeCharExpression {
        let etype = this.convertTypeSignature(exp.etype);
        return CPPAssembly::LiteralUnicodeCharExpression{ etype, exp.value };
    }

    method transformLiteralCRegexExpression(exp: BSQAssembly::LiteralCRegexExpression): CPPAssembly::LiteralCRegexExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let re = exp.smtlib;

        return CPPAssembly::LiteralCRegexExpression{ etype, re };
    }

    method transformLiteralRegexExpression(exp: BSQAssembly::LiteralRegexExpression): CPPAssembly::LiteralRegexExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let re = exp.smtlib;

        return CPPAssembly::LiteralRegexExpression{ etype, re };
    }

    method transformLiteralTypeDeclValueExpression(exp: BSQAssembly::LiteralTypeDeclValueExpression): CPPAssembly::LiteralTypeDeclValueExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let value = this.transformExpressionToCpp(exp.value);
        let constype = this.convertTypeSignature(exp.constype)@<CPPAssembly::NominalTypeSignature>;

        return CPPAssembly::LiteralTypeDeclValueExpression{ etype, value, constype };
    }

    method transformAccessNamespaceConstantExpression(exp: BSQAssembly::AccessNamespaceConstantExpression): CPPAssembly::AccessNamespaceConstantExpression {
        let etype = this.convertTypeSignature(exp.etype);
        let ns = CPPTransformNameManager::convertNamespaceKey(exp.ns);
        let name = CPPTransformNameManager::convertIdentifier(exp.name);

        return CPPAssembly::AccessNamespaceConstantExpression{ etype, ns, name };
    }

    method transformMapEntryConstructorExpression(exp: BSQAssembly::MapEntryConstructorExpression): CPPAssembly::MapEntryConstructorExpression {
        let etype = this.convertTypeSignature(exp.etype);       
        let kexp = this.transformExpressionToCpp(exp.kexp);
        let vexp = this.transformExpressionToCpp(exp.vexp);

        return CPPAssembly::MapEntryConstructorExpression{ etype, kexp, vexp };
    }

    recursive method transformExpressionToCpp(expr: BSQAssembly::Expression): CPPAssembly::Expression {
        match(expr)@ {
            BSQAssembly::LiteralNoneExpression => { return this.transformLiteralNoneExpression($expr); }
            | BSQAssembly::LiteralSimpleExpression => { return this.transformLiteralSimpleExpression($expr); }
            | BSQAssembly::LiteralCCharExpression => { return this.transformLiteralCCharExpression($expr); }
            | BSQAssembly::LiteralUnicodeCharExpression => { return this.transformLiteralUnicodeCharExpression($expr); }
            | BSQAssembly::LiteralCStringExpression => { return this.transformLiteralCStringExpression($expr); }
            | BSQAssembly::LiteralStringExpression => { return this.transformLiteralStringExpression($expr); }
            | BSQAssembly::LiteralCCharExpression => { return this.transformLiteralCCharExpression($expr); }
            | BSQAssembly::LiteralUnicodeCharExpression => { return this.transformLiteralUnicodeCharExpression($expr); }
            | BSQAssembly::LiteralCRegexExpression => { return this.transformLiteralCRegexExpression($expr); }
            | BSQAssembly::LiteralRegexExpression => { return this.transformLiteralRegexExpression($expr); }
            | BSQAssembly::LiteralTypeDeclValueExpression => { return this.transformLiteralTypeDeclValueExpression($expr); }
            | BSQAssembly::AccessNamespaceConstantExpression => { return this.transformAccessNamespaceConstantExpression($expr); }
            | BSQAssembly::AccessStaticFieldExpression => { return this.transformAccessStaticFieldExpression($expr); }
            | BSQAssembly::AccessEnumExpression => { return this.transformAccessEnumExpression($expr); }
            | BSQAssembly::AccessVariableExpression => { return this.transformAccessVariableExpression($expr); }
            | BSQAssembly::AccessCapturedVariableExpression => { return this.transformAccessCapturedVariableExpression($expr); }
            | BSQAssembly::ConstructorExpression => { return this.transformConstructorExpression($expr); }
            | BSQAssembly::ConstructorPrimaryExpression => { return this.transformConstructorPrimaryExpression($expr); }
            | BSQAssembly::ConstructorPrimaryCollectionSingletonsExpression => { abort; }
            | BSQAssembly::ConstructorTypeDeclExpression => { abort; }
            | BSQAssembly::ConstructorTypeDeclStringExpression => { abort; }
            | BSQAssembly::ConstructorLambdaExpression => { return this.transformConstructorLambdaExpression($expr); }
            | BSQAssembly::LetExpression => { abort; }
            | BSQAssembly::LambdaInvokeExpression => { return this.transformLambdaInvokeExpression($expr); }
            | BSQAssembly::CallNamespaceFunctionExpression => { return this.transformCallNamespaceFunctionExpression($expr); } 
            | BSQAssembly::CallTypeFunctionExpression => { return this.transformCallTypeFunctionExpression($expr); }
            | BSQAssembly::CallTypeFunctionSpecialExpression => { return this.transformCallTypeFunctionSpecialExpression($expr); }
            | BSQAssembly::CallRefInvokeStaticResolveExpression => { abort; }
            | BSQAssembly::CallRefInvokeVirtualExpression => { abort; }
            | BSQAssembly::LogicActionAndExpression => { return this.transformLogicActionAndExpression[recursive]($expr); }
            | BSQAssembly::LogicActionOrExpression => { return this.transformLogicActionOrExpression[recursive]($expr); }
            | BSQAssembly::TypeDeclPrimitiveFieldAccessExpression => { abort; }
            | BSQAssembly::CoerceWidenTypeExpression => { return this.transformCoerceWidenTypeExpression($expr); }   
            | BSQAssembly::CoerceNarrowTypeExpression => { return this.transformCoerceNarrowTypeExpression($expr); }
            | BSQAssembly::SafeConvertExpression => { return this.transformSafeConvertExpression($expr); }
            | BSQAssembly::CreateDirectExpression => { return this.transformCreateDirectExpression($expr); }
            | BSQAssembly::PostfixOp => { return this.transformPostfixOp($expr); }
            | BSQAssembly::UnaryExpression => { return this.transformUnaryExpression[recursive]($expr); }
            | BSQAssembly::BinaryArithExpression => { return this.transformBinaryArithExpression[recursive]($expr); }
            | BSQAssembly::BinaryKeyEqExpression => { return this.transformBinaryKeyEqExpression($expr); }
            | BSQAssembly::KeyCmpEqualExpression => { return this.transformKeyCmpEqualExpression($expr); }
            | BSQAssembly::KeyCmpLessExpression => { return this.transformKeyCmpLessExpression($expr); } 
            | BSQAssembly::BinaryNumericExpression => { return this.transformBinaryNumericCompareExpression[recursive]($expr); }
            | BSQAssembly::BinLogicExpression => { return this.transformBinLogicExpression[recursive]($expr); }
            | BSQAssembly::MapEntryConstructorExpression => { return this.transformMapEntryConstructorExpression($expr); }
            | BSQAssembly::IfExpression => { return this.transformIfExpression($expr); }
        }
    }

    recursive method transformReturnSingleStatementToCpp(ret: BSQAssembly::ReturnSingleStatement): CPPAssembly::ReturnSingleStatement {
        let rtype = this.convertTypeSignature(ret.rtype); 
        let rexp = this.transformExpressionToCpp[recursive](ret.value);

        return CPPAssembly::ReturnSingleStatement{rtype, rexp};
    }

    recursive method transformVariableInitializationStatementToCpp(stmt: BSQAssembly::VariableInitializationStatement): CPPAssembly::VariableInitializationStatement {
        let name = CPPTransformNameManager::convertIdentifier(stmt.name);
        let stype = this.convertTypeSignature(stmt.vtype);
        let cppexpr = this.transformExpressionToCpp[recursive](stmt.exp);

        return CPPAssembly::VariableInitializationStatement{ name, stype, cppexpr };
    }

    method transformBlockStatement(block: BSQAssembly::BlockStatement): CPPAssembly::BlockStatement {
        let stmts = block.statements.map<CPPAssembly::Statement>(fn(stmt) => this.transformStatementToCpp(stmt));
        return CPPAssembly::BlockStatement{ stmts, block.isScoping };
    }

    method transformBinderInfo(binder: BSQAssembly::BinderInfo): CPPAssembly::BinderInfo {
        let srcname = CPPTransformNameManager::convertVarIdentifier(binder.srcname);
        let refineonfollow = binder.refineonfollow;

        return CPPAssembly::BinderInfo{ srcname, refineonfollow };
    }

    method transformIfBinderStatement(stmt: BSQAssembly::IfBinderStatement, cond: CPPAssembly::Expression, tb: CPPAssembly::BlockStatement): CPPAssembly::IfBinderStatement {
        let itest = this.transformITestAsTest(stmt.itest);
        let binder = this.transformBinderInfo(stmt.binder);

        return CPPAssembly::IfBinderStatement{ cond, tb, itest, binder };
    }

    recursive method transformIfStatement(stmt: BSQAssembly::IfStatement): CPPAssembly::IfStatement {
        let cond = this.transformExpressionToCpp[recursive](stmt.texp);
        let trueBlock = this.transformBlockStatement(stmt.trueBlock);

        match(stmt)@ {
            BSQAssembly::IfSimpleStatement => { return CPPAssembly::IfSimpleStatement{ cond, trueBlock }; }
            | BSQAssembly::IfTestStatement => { return CPPAssembly::IfTestStatement{ cond, trueBlock, this.transformITestAsTest($stmt.itest) }; }
            | BSQAssembly::IfBinderStatement => { return this.transformIfBinderStatement($stmt, cond, trueBlock); }
        }
    }

    method transformIfElseBinderStatement(stmt: BSQAssembly::IfElseBinderStatement, cond: CPPAssembly::Expression, tb: CPPAssembly::BlockStatement, fb: CPPAssembly::BlockStatement): CPPAssembly::IfElseBinderStatement {
        let itest = this.transformITestAsTest(stmt.itest);
        let binder = this.transformBinderInfo(stmt.binder);       
    
        return CPPAssembly::IfElseBinderStatement{ cond, tb, fb, itest, binder };
    }

    recursive method transformIfElseStatement(stmt: BSQAssembly::IfElseStatement): CPPAssembly::IfElseStatement {
        let cond = this.transformExpressionToCpp[recursive](stmt.texp);
        let trueBlock = this.transformBlockStatement(stmt.trueBlock);
        let falseBlock = this.transformBlockStatement(stmt.falseBlock);

        match(stmt)@ {
            BSQAssembly::IfElseSimpleStatement => { return CPPAssembly::IfElseSimpleStatement{ cond, trueBlock, falseBlock }; }
            | BSQAssembly::IfElseTestStatement => { return CPPAssembly::IfElseTestStatement{ cond, trueBlock, falseBlock, this.transformITestAsTest($stmt.itest) }; }
            | BSQAssembly::IfElseBinderStatement => { return this.transformIfElseBinderStatement($stmt, cond, trueBlock, falseBlock); } %% TODO: Not Implemented
        }
    }

    recursive method transformIfElifElseStatement(stmt: BSQAssembly::IfElifElseStatement): CPPAssembly::IfElifElseStatement {
        let ifcond = this.transformExpressionToCpp[recursive](stmt.ifcond);
        let ifflow = this.transformBlockStatement(stmt.ifflow);
        let elseflow = this.transformBlockStatement(stmt.elseflow);

        let condflow = stmt.condflow.map<(|CPPAssembly::Expression, CPPAssembly::BlockStatement|)>(fn(block) => 
            (|this.transformExpressionToCpp[recursive](block.0), this.transformBlockStatement(block.1)|));
    
        return CPPAssembly::IfElifElseStatement{ ifcond, ifflow, condflow, elseflow };
    }

    method transformAbortStatement(stmt: BSQAssembly::AbortStatement): CPPAssembly::AbortStatement {
        return CPPAssembly::AbortStatement{ };
    }

    method transformAssertStatement(stmt: BSQAssembly::AssertStatement): CPPAssembly::AssertStatement {
        let exp = this.transformExpressionToCpp(stmt.cond);

        return CPPAssembly::AssertStatement{ exp };
    }

    method transformMatchStatement(stmt: BSQAssembly::MatchStatement): CPPAssembly::MatchStatement {
        let sval = this.transformExpressionToCpp(stmt.sval);
        let bindinfo = if(stmt.bindInfo)none then none 
            else some(this.transformBinderInfo(stmt.bindInfo@some));
        let matchflow = stmt.matchflow.map<(|CPPAssembly::TypeSignature, CPPAssembly::BlockStatement|)>( fn(mf) => {
            return (|this.convertTypeSignature(mf.0), this.transformBlockStatement(mf.1)|);
        });
        
        return CPPAssembly::MatchStatement { sval, bindinfo, matchflow, stmt.mustExhaustive };
    }

    method transformSwitchStatement(stmt: BSQAssembly::SwitchStatement): CPPAssembly::SwitchStatement {
        let sval = this.transformExpressionToCpp(stmt.sval);
        let switchflow = stmt.switchflow.map<(|Option<CPPAssembly::Expression>, CPPAssembly::BlockStatement|)>( fn(sf) => {
            return (|if(sf.0)none then none else some(this.transformExpressionToCpp(sf.0@some)), 
                this.transformBlockStatement(sf.1)|);
        });
        
        %% Not sure if this is needed for emission 
        let optypes = stmt.optypes.map<CPPAssembly::TypeSignature>(fn(t) => this.convertTypeSignature(t));

        return CPPAssembly::SwitchStatement { sval, switchflow, stmt.mustExhaustive, optypes };
    }

    method transformVariableAssignmentStatement(stmt: BSQAssembly::VariableAssignmentStatement): CPPAssembly::VariableAssignmentStatement {
        let name = CPPTransformNameManager::convertIdentifier(stmt.name);
        let vtype = this.convertTypeSignature(stmt.vtype);
        let exp = this.transformExpressionToCpp(stmt.exp);

        return CPPAssembly::VariableAssignmentStatement{ name, vtype, exp };
    }

    method transformVariableDeclarationStatement(stmt: BSQAssembly::VariableDeclarationStatement): CPPAssembly::VariableDeclarationStatement {
        let name = CPPTransformNameManager::convertIdentifier(stmt.name);
        let vtype = this.convertTypeSignature(stmt.vtype);

        return CPPAssembly::VariableDeclarationStatement{ name, vtype };
    }

    method transformVariableMultiInitilizationExplicitStatement(vmie: BSQAssembly::VariableMultiInitializationExplicitStatement): CPPAssembly::VariableMultiInitializationExplicitStatement {
        let decls = vmie.decls.map<(|CPPAssembly::Identifier, CPPAssembly::TypeSignature|)>(fn(decl) => {
            let cppidentifier = CPPTransformNameManager::convertIdentifier(decl.0);
            let cpptsig = this.convertTypeSignature(decl.1);

            return cppidentifier, cpptsig;
        });
        let exps = vmie.exps.map<CPPAssembly::Expression>(fn(e) => this.transformExpressionToCpp(e));

        return CPPAssembly::VariableMultiInitializationExplicitStatement{ decls, exps };
    }

    method transformVariableMultiInitilizationImplicitStatement(vmii: BSQAssembly::VariableMultiInitializationImplicitStatement): CPPAssembly::VariableMultiInitializationImplicitStatement {
        let decls = vmii.decls.map<(|CPPAssembly::Identifier, CPPAssembly::TypeSignature|)>(fn(decl) => {
            let cppidentifier = CPPTransformNameManager::convertIdentifier(decl.0);
            let cpptsig = this.convertTypeSignature(decl.1);

            return cppidentifier, cpptsig;
        });
        let exp = this.transformExpressionToCpp(vmii.exp);

        return CPPAssembly::VariableMultiInitializationImplicitStatement{ decls, exp };
    }

    method transformReturnMultiStatement(rms: BSQAssembly::ReturnMultiStatement): CPPAssembly::ReturnMultiStatement {
        let elsig = this.convertTypeSignature(rms.elsig)@<CPPAssembly::EListTypeSignature>;
        let rtypes = rms.rtypes.map<CPPAssembly::TypeSignature>(fn(ts) => this.convertTypeSignature(ts));
        let exps = rms.exps.map<CPPAssembly::Expression>(fn(e) => this.transformExpressionToCpp(e));

        return CPPAssembly::ReturnMultiStatement{ elsig, rtypes, exps };
    }

    method transformStatementToCpp(stmt: BSQAssembly::Statement): CPPAssembly::Statement {
        match(stmt)@ {
            BSQAssembly::EmptyStatement => { return CPPAssembly::EmptyStatement{ }; }
            | BSQAssembly::VariableDeclarationStatement => { return this.transformVariableDeclarationStatement($stmt); }
            | BSQAssembly::VariableMultiDeclarationStatement => { abort; }
            | BSQAssembly::VariableInitializationStatement => { return this.transformVariableInitializationStatementToCpp($stmt); }
            | BSQAssembly::VariableMultiInitializationExplicitStatement => { return this.transformVariableMultiInitilizationExplicitStatement($stmt); }
            | BSQAssembly::VariableMultiInitializationImplicitStatement => { return this.transformVariableMultiInitilizationImplicitStatement($stmt); }
            | BSQAssembly::VariableAssignmentStatement => { return this.transformVariableAssignmentStatement($stmt); }
            | BSQAssembly::VariableMultiAssignmentExplicitStatement => { abort; }
            | BSQAssembly::VariableMultiAssignmentImplicitStatement => { abort; }
            | BSQAssembly::VariableRetypeStatement => { abort; }
            | BSQAssembly::ReturnVoidStatement => { abort; }
            | BSQAssembly::ReturnSingleStatement => { return this.transformReturnSingleStatementToCpp[recursive]($stmt); }
            | BSQAssembly::ReturnMultiStatement => { return this.transformReturnMultiStatement($stmt); }
            | BSQAssembly::IfStatement => { return this.transformIfStatement[recursive]($stmt); }
            | BSQAssembly::IfElseStatement => { return this.transformIfElseStatement[recursive]($stmt); }
            | BSQAssembly::IfElifElseStatement => { return this.transformIfElifElseStatement[recursive]($stmt); }
            | BSQAssembly::SwitchStatement => { return this.transformSwitchStatement($stmt); }
            | BSQAssembly::MatchStatement => { return this.transformMatchStatement($stmt); }
            | BSQAssembly::AbortStatement => { return this.transformAbortStatement($stmt); }
            | BSQAssembly::AssertStatement => { return this.transformAssertStatement($stmt); } 
            | BSQAssembly::ValidateStatement => { abort; }
            | BSQAssembly::DebugStatement => { abort; }
            | BSQAssembly::VoidRefCallStatement => { abort; }
            | BSQAssembly::UpdateDirectStatement => { abort; }
            | BSQAssembly::UpdateIndirectStatement => { abort; }
            | BSQAssembly::BlockStatement => { return this.transformBlockStatement($stmt); }
            | BSQAssembly::BinderBlockStatement => { abort; }
        }
    }

    method transformStatementListToCpp(stmts: List<BSQAssembly::Statement>): List<CPPAssembly::Statement> {
        let tailop = stmts.back();

        %% Need to match tailop to get return, not implemented for now

        return stmts.map<CPPAssembly::Statement>(fn(stmt) => this.transformStatementToCpp(stmt));
    }

    method transformDefaultVal(val: Option<BSQAssembly::Expression>): Option<CPPAssembly::Expression> {
        match(val)@ {
            None => { return none; }
            | _ => { return some(this.transformExpressionToCpp[recursive]($val.value)); }
        }
    }

    method transformParameterDecl(decl: List<BSQAssembly::InvokeParameterDecl>): List<CPPAssembly::ParameterDecl> {
        return decl.map<CPPAssembly::ParameterDecl>(fn(pdecl) => {
            return CPPAssembly::ParameterDecl{ 
                CPPTransformNameManager::convertIdentifier(pdecl.pname), 
                this.convertTypeSignature(pdecl.ptype),
                this.transformDefaultVal(pdecl.defaultval)
            };
        });
    }

    method transformBodyToCpp(body: BSQAssembly::BodyImplementation): CPPAssembly::BodyImplementation {
        match(body)@ {
            BSQAssembly::AbstractBodyImplementation => { abort; }
            | BSQAssembly::PredicateUFBodyImplementation => { abort; }
            | BSQAssembly::BuiltinBodyImplementation => { return CPPAssembly::BuiltinBodyImplementation{ $body.builtin }; }
            | BSQAssembly::SynthesisBodyImplementation => { abort; } 
            | BSQAssembly::ExpressionBodyImplementation => { 
                return CPPAssembly::ExpressionBodyImplementation{ this.transformExpressionToCpp($body.exp) }; 
            } 
            | BSQAssembly::StandardBodyImplementation => { 
                let cppstmts = this.transformStatementListToCpp($body.statements);
                return CPPAssembly::StandardBodyImplementation{ cppstmts };
            }
        }
    }

    method transformAbstractInvokeDecl(decl: BSQAssembly::AbstractInvokeDecl): (|CPPAssembly::NamespaceKey, List<CString>, CString, CPPAssembly::InvokeKey,
        List<CPPAssembly::ParameterDecl>, CPPAssembly::TypeSignature, CPPAssembly::BodyImplementation|) {
        return
            (|CPPTransformNameManager::convertNamespaceKey(decl.declaredInNS), decl.fullns, decl.name.value, 
            CPPTransformNameManager::convertInvokeKey(decl.ikey), this.transformParameterDecl(decl.params),
            this.convertTypeSignature(decl.resultType), this.transformBodyToCpp(decl.body)|);
    }

    method transformStaticMethodDecl(m: BSQAssembly::MethodDeclStatic): CPPAssembly::MethodDeclStatic {
        let base = this.transformAbstractInvokeDecl(m);
        return CPPAssembly::MethodDeclStatic{ base.0, base.1, base.2, base.3, base.4, base.5, base.6 };
    }

    %% Virtual, abstract, and override methods should not emit for now
    method transformVirtualMethodDecl(m: BSQAssembly::MethodDeclVirtual): CPPAssembly::MethodDeclVirtual {
        let base = this.transformAbstractInvokeDecl(m);
        return CPPAssembly::MethodDeclVirtual{ base.0, base.1, base.2, base.3, base.4, base.5, base.6 };
    }

    method transformAbstractMethodDecl(m: BSQAssembly::MethodDeclAbstract): CPPAssembly::MethodDeclAbstract {
        let base = this.transformAbstractInvokeDecl(m);
        return CPPAssembly::MethodDeclAbstract{ base.0, base.1, base.2, base.3, base.4, base.5, base.6 };
    }

    method transformOverrideMethodDecl(m: BSQAssembly::MethodDeclOverride): CPPAssembly::MethodDeclOverride {
        let base = this.transformAbstractInvokeDecl(m);
        return CPPAssembly::MethodDeclOverride{ base.0, base.1, base.2, base.3, base.4, base.5, base.6 };
    }

    method transformNamespaceFunctionDeclToCpp(decl: BSQAssembly::NamespaceFunctionDecl): CPPAssembly::NamespaceFunctionDecl {
        let base = this.transformAbstractInvokeDecl(decl);
        return CPPAssembly::NamespaceFunctionDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6 };
    }  

    method transformTypeFunctionDeclToCpp(decl: BSQAssembly::TypeFunctionDecl): CPPAssembly::TypeFunctionDecl {
        let base = this.transformAbstractInvokeDecl(decl);
        return CPPAssembly::TypeFunctionDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6 };
    } 

    method transformNamespaceConstDeclToCpp(decl: BSQAssembly::NamespaceConstDecl): CPPAssembly::NamespaceConstDecl {
        let declaredInNS = CPPTransformNameManager::convertNamespaceKey(decl.declaredInNS);
        let basename = CPPTransformNameManager::convertIdentifier(decl.name);
        let resolvedname = String::concat(String::fromCString(declaredInNS.value), String::fromCString(decl.name.value))
            .replaceAllStringOccurrences(" ", "");
        let declaredType = this.convertTypeSignature(decl.declaredType);
        let value = this.transformExpressionToCpp(decl.value);

        return CPPAssembly::NamespaceConstDecl{ declaredInNS, decl.fullns, basename, resolvedname, declaredType, value };
    }

    method transformConstMemberDeclToCpp(decl: BSQAssembly::ConstMemberDecl): CPPAssembly::ConstMemberDecl {
        let declaredInNS = CPPTransformNameManager::convertNamespaceKey(decl.declaredInNS);
        let basename = CPPTransformNameManager::convertIdentifier(decl.name);
        let resolvedname = String::concat(String::fromCString(decl.declaredInType.tkeystr.value), "ᘏ", String::fromCString(decl.name.value))
            .replaceAllStringOccurrences(" ", "");
        let declaredInType = CPPTransformNameManager::convertNominalTypeSignature(decl.declaredInType);
        let declaredType = this.convertTypeSignature(decl.declaredType);
        let value = this.transformExpressionToCpp(decl.value);

        return CPPAssembly::ConstMemberDecl{ declaredInNS, decl.fullns, basename, resolvedname, declaredInType, declaredType, value };
    }

    method transformMemberFieldDecl(fields: List<BSQAssembly::SaturatedFieldInfo>, m: BSQAssembly::AbstractNominalTypeDecl, mfields: List<BSQAssembly::MemberFieldDecl>): List<CPPAssembly::MemberFieldDecl> {
        return fields.mapIdx<CPPAssembly::MemberFieldDecl>(fn(f, ii) => {
            let declaredInNS = CPPTransformNameManager::convertNamespaceKey(m.declaredInNS);
            let name = CPPTransformNameManager::convertIdentifier(f.fname);
            let declaredInType = CPPTransformNameManager::convertNominalTypeSignature(f.declaredInType);
            let declaredType = this.convertTypeSignature(f.ftype);
            var defaultval: Option<CPPAssembly::Expression>;
            if(f.hasdefault && ii < mfields.size()) {
                let tmp = mfields.get(ii).defaultValue;
                if(tmp)@@none {
                    abort;
                }
                defaultval = some(this.transformExpressionToCpp(tmp));
            }
            else {
                defaultval = none;
            }
            return CPPAssembly::MemberFieldDecl{ declaredInNS, m.fullns, name, declaredInType, declaredType, defaultval };
        });
    }

    %% Useful for determining sizes of our constructable types
    method getCorrectSizeAndMask(ti: FieldInfo): CString, Nat, Nat { %% (|ptrmask, slotsize, typesize|)
        var ptrmask = ti.ptrmask;
        var slotsize = ti.slotsize;
        var typesize = ti.typesize;

        if(slotsize > reftypeThreshold) {
            ptrmask = '1';
            slotsize = 1n;
            typesize = 1n * slotSizeInBits;
        }

        return ptrmask, slotsize, typesize;
    }

    %% Explore all subtypes and find largest possible field slot size (generating subtype tinfo when necessary)
    method findLargestSubtypeAndTag(cur: BSQAssembly::AbstractConceptTypeDecl, tic: TypeInfoContext): Nat, CPPAssembly::Tag, TypeInfoContext {
        let basetag = this.determineTag(some(cur.tkey), none);
        return cur.subtypes.reduce<(|Nat, CPPAssembly::Tag, TypeInfoContext|)>((|0n, basetag, tic|), fn(acc, subtk) => {              
            let subant = this.bsqasm.lookupNominalTypeDeclaration(subtk);

            if(subant)@<BSQAssembly::AbstractEntityTypeDecl> {
                let finfo, ntic = this.generateFieldInfo(none, some(subtk), true, acc.2);
                var size = finfo.slotsize;

                %% Just a pointer so only one slot
                let subtypetag = this.determineTag(some($subant.tkey), none);
                if(subtypetag === CPPAssembly::Tag#Ref) {
                    size = 1n;
                }

                %% If all subtypes are not of the same tag we must return tagged 
                var tag = acc.1;
                if(tag !== CPPAssembly::Tag#Tagged && subtypetag !== tag) {
                    tag = CPPAssembly::Tag#Tagged;
                }

                if(size > acc.0) {
                    return size, tag, ntic;
                }
                return acc.0, tag, ntic;
            }

            return this.findLargestSubtypeAndTag[recursive](subant@<BSQAssembly::AbstractConceptTypeDecl>, acc.2);
        });
    }

    recursive method generateEListInfo(elist: BSQAssembly::EListTypeSignature, tic: TypeInfoContext): FieldInfo, TypeInfoContext {
        return elist.entries
            .reduce<(|FieldInfo, TypeInfoContext|)>((|FieldInfo{ 0n, 0n, '' }, tic|), 
                fn(acc, f) => {
                    %% If elist contains elist we should explore its entries BEFORE trying to generate field info
                    if(f)@<BSQAssembly::EListTypeSignature> {
                        return this.generateEListInfo[recursive]($f, acc.1);
                    }

                    var finfo, ntic = this.generateFieldInfo(some(f), none, false, acc.1);
                    let tag = if(this.shouldBeRef(none, some(f))) 
                        then CPPAssembly::Tag#Ref 
                        else CPPAssembly::Tag#Value;
                    if(tag === CPPAssembly::Tag#Ref) {
                        finfo = FieldInfo{ 8n, 1n, '1' };
                    }

                    return acc.0.update(finfo.typesize, finfo.slotsize, finfo.ptrmask), ntic;
                }
            );
    }

    recursive method generateFieldInfo(tsig: Option<BSQAssembly::TypeSignature>, tkey: Option<BSQAssembly::TypeKey>, 
        findingLargestField: Bool, tic: TypeInfoContext): FieldInfo, TypeInfoContext {
            var resolvedtkey: BSQAssembly::TypeKey;
            if(tsig)@some { 
                let sometsig = $tsig;
                if(sometsig)@<BSQAssembly::EListTypeSignature> { %% Always check for elist first, isNominalTypeConcept/Concrete fails on elist tkey
                    return this.generateEListInfo($sometsig, tic);
                }
                resolvedtkey = sometsig.tkeystr;
            }
            else {
                resolvedtkey = tkey@some;
            }

            %% Primitives/Enums don't have saturated fields so return early
            if(this.bsqasm.isPrimtitiveType(resolvedtkey) || this.bsqasm.enums.has(resolvedtkey)) {
                let ptinfo, ntic = this.generateTypeInfo(resolvedtkey, tic);
                return FieldInfo{ ptinfo.typesize, ptinfo.slotsize, ptinfo.ptrmask }, ntic;
            }

            let ant = this.bsqasm.lookupNominalTypeDeclaration(resolvedtkey);
            return ant.saturatedBFieldInfo
                .reduce<(|FieldInfo, TypeInfoContext|)>((|FieldInfo{ 0n, 0n, '' }, tic|), fn(acc, finfo) => {
                    let ftype = finfo.ftype;
                    if(ftype)@<BSQAssembly::EListTypeSignature> {
                        let e, tic = this.generateEListInfo($ftype, acc.1);
                        return acc.0.update(e.typesize, e.slotsize, e.ptrmask), tic;
                    }

                    %% Contains enough slots for possible typeinfo ptr and data ptr
                    if(findingLargestField && this.bsqasm.isNominalTypeConcept(ftype.tkeystr)) {
                        return acc.0.update(16n, 2n, '00'), acc.1; %% [typeinfo ptr][dataptr]
                    }

                    let tinfo, ntic = this.generateTypeInfo(ftype.tkeystr, acc.1);
                    if(tinfo.tag === CPPAssembly::Tag#Ref) {
                        return acc.0.update(8n, 1n, '1'), ntic;
                    }
                    return acc.0.update(tinfo.typesize, tinfo.slotsize, tinfo.ptrmask), ntic;
                });
    }

    %%
    %% TODO: Eventually it would be a good idea to move the typeinfo generation
    %% logic off to its own file as to not clutter the transformer
    %%
    recursive method generateTypeInfo(typekey: BSQAssembly::TypeKey, tic: TypeInfoContext): CPPAssembly::TypeInfo, TypeInfoContext { 
            let cpptkey = CPPTransformNameManager::convertTypeKey(typekey);
            if(tic.tinfos.has(cpptkey)) {
                return tic.tinfos.get(cpptkey), tic;
            }
            
            %%
            %% NOTE: If we decide to make our char buffers support 16 characters this will break
            %%
            if(this.bsqasm.isPrimtitiveType(typekey)) {
                var matchedType: CPPAssembly::TypeInfo;
                switch(typekey) {
                    'None'<BSQAssembly::TypeKey> =>     { matchedType = CPPAssembly::TypeInfo{ tic.tid, 0n, 0n, '', cpptkey, CPPAssembly::Tag#Value }; }
                    | 'Bool'<BSQAssembly::TypeKey> =>   { matchedType = CPPAssembly::TypeInfo{ tic.tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value }; }
                    | 'Nat'<BSQAssembly::TypeKey> =>    { matchedType = CPPAssembly::TypeInfo{ tic.tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value }; }
                    | 'Int'<BSQAssembly::TypeKey> =>    { matchedType = CPPAssembly::TypeInfo{ tic.tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value }; }
                    | 'BigNat'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{ tic.tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value }; }
                    | 'BigInt'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{ tic.tid, 16n, 2n,'00', cpptkey, CPPAssembly::Tag#Value }; }
                    | 'Float'<BSQAssembly::TypeKey> =>  { matchedType = CPPAssembly::TypeInfo{ tic.tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value }; }
                    | 'CChar'<BSQAssembly::TypeKey> =>  { matchedType = CPPAssembly::TypeInfo{ tic.tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value }; }
                    | 'CCharBuffer'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{ tic.tid, 16n, 2n, '00', cpptkey, CPPAssembly::Tag#Value }; }
                    | 'UnicodeChar'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{ tic.tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value }; }
                    | 'UnicodeCharBuffer'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{tic.tid, 40n, 5n, '00000', cpptkey, CPPAssembly::Tag#Value }; }
                    | 'CString'<BSQAssembly::TypeKey> => { matchedType = this.generateTypeInfo(BSQAssembly::TypeKey::from('CRope'), tic).0; }
                    | 'String'<BSQAssembly::TypeKey> => { matchedType = this.generateTypeInfo(BSQAssembly::TypeKey::from('UnicodeRope'), tic).0; }
                    %%
                    %% TODO: Regex needs a proper representation! Right now we have it always accepting.
                    %% (This might become problematic in our oppass)
                    %%                    
                    | 'CRegex'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{ tic.tid, 0n, 0n, '', cpptkey, CPPAssembly::Tag#Value }; }
                    | 'Regex'<BSQAssembly::TypeKey> =>  { matchedType = CPPAssembly::TypeInfo{ tic.tid, 0n, 0n, '', cpptkey, CPPAssembly::Tag#Value }; }
                    | _ => { abort; } %% Not supported by cpp emitter yet!
                }

                return matchedType, tic.update(cpptkey, matchedType);
            }
             
            let ant = this.bsqasm.lookupNominalTypeDeclaration(typekey);
            if(this.bsqasm.isNominalTypeConcrete(typekey)) {            
                if(this.bsqasm.entities.has(typekey) || this.bsqasm.datamembers.has(typekey)) {
                    let finfo, ntic = this.generateFieldInfo(none, some(typekey), false, tic);
                    var einfo = CPPAssembly::TypeInfo{ ntic.tid, finfo.typesize, finfo.slotsize, finfo.ptrmask, cpptkey, this.determineTag(some(typekey), none) };
                    
                    return einfo, ntic.update(cpptkey, einfo);
                }
                elif(this.bsqasm.constructables.has(typekey)) { 
                    if(ant)@<BSQAssembly::SomeTypeDecl> {
                        let oftypeinfo, ntic = this.generateFieldInfo(some($ant.oftype), none, false, tic);
                        var sometinfo = CPPAssembly::TypeInfo{ ntic.tid, oftypeinfo.typesize, oftypeinfo.slotsize, oftypeinfo.ptrmask, cpptkey, CPPAssembly::Tag#Value }; 
 
                        let oftypemask, oftypeslots, oftypesize = this.getCorrectSizeAndMask(oftypeinfo);
                        sometinfo = CPPAssembly::TypeInfo{ ntic.tid, oftypesize, oftypeslots, oftypemask, cpptkey, CPPAssembly::Tag#Value }; 
                        
                        return sometinfo, ntic.update(cpptkey, sometinfo);
                    }
                    if(ant)@<BSQAssembly::MapEntryTypeDecl> {
                        let ktypeinfo, ntic = this.generateFieldInfo(some($ant.ktype), none, false, tic);
                        let vtypeinfo, nntic = this.generateFieldInfo(some($ant.vtype), none, false, ntic);

                        let ktypemask, ktypeslots, ktypesize = this.getCorrectSizeAndMask(ktypeinfo);
                        let vtypemask, vtypeslots, vtypesize = this.getCorrectSizeAndMask(vtypeinfo); 

                        let ptrmask = CString::concat(ktypemask, vtypemask);
                        let typesize = ktypesize + vtypesize;
                        let slotsize = ktypeslots + vtypeslots;

                        let metinfo = CPPAssembly::TypeInfo{ nntic.tid, typesize, slotsize, ptrmask, cpptkey, CPPAssembly::Tag#Value };

                        return metinfo, nntic.update(cpptkey, metinfo);
                    }

                    abort;
                }
                elif(this.bsqasm.collections.has(typekey)) { 
                    %% List<T> and Map<K, V> is just alias of Tree<T> and Tree<K, V> so 
                    %% we need to get Tree<T>'s and Tree<K, V>'s typeinfo 
                    if(ant)@<BSQAssembly::ListTypeDecl> {
                        let treetk = BSQAssembly::TypeKey::from(CString::concat('ListOps::Tree<', $ant.oftype.tkeystr.value, '>'));

                        let treeinfo, ntic = this.generateTypeInfo[recursive](treetk, tic);
                        let listinfo = CPPAssembly::TypeInfo{ ntic.tid, treeinfo.typesize, treeinfo.slotsize, treeinfo.ptrmask, cpptkey, treeinfo.tag };

                        return listinfo, ntic.update(cpptkey, listinfo);
                    }
                    if(ant)@<BSQAssembly::MapTypeDecl> {
                        let e_ktype = $ant.ktype.tkeystr.value;
                        let e_vtype = $ant.vtype.tkeystr.value;
                        let treetk = BSQAssembly::TypeKey::from(CString::concat('MapOps::Tree<', e_ktype, ', ', e_vtype, '>'));

                        let treeinfo, ntic = this.generateTypeInfo[recursive](treetk, tic);
                        let mapinfo = CPPAssembly::TypeInfo{ ntic.tid, treeinfo.typesize, treeinfo.slotsize, treeinfo.ptrmask, cpptkey, treeinfo.tag };

                        return mapinfo, ntic.update(cpptkey, mapinfo);
                    }
                    if(ant)@<BSQAssembly::CRopeTypeDecl> {
                        let ropetk = BSQAssembly::TypeKey::from('CRopeOps::Rope');

                        let ropeinfo, ntic = this.generateTypeInfo[recursive](ropetk, tic);
                        let cropeinfo = CPPAssembly::TypeInfo{ ntic.tid, ropeinfo.typesize, ropeinfo.slotsize, ropeinfo.ptrmask, cpptkey, ropeinfo.tag };

                        return cropeinfo, ntic.update(cpptkey, cropeinfo);
                    }
                    if(ant)@<BSQAssembly::UnicodeRopeTypeDecl> {
                        let ropetk = BSQAssembly::TypeKey::from('UnicodeRopeOps::Rope');

                        let ropeinfo, ntic = this.generateTypeInfo[recursive](ropetk, tic);
                        let unicoderopeinfo = CPPAssembly::TypeInfo{ ntic.tid, ropeinfo.typesize, ropeinfo.slotsize, ropeinfo.ptrmask, cpptkey, ropeinfo.tag };
                    
                        return unicoderopeinfo, ntic.update(cpptkey, unicoderopeinfo);
                    }

                    abort;
                }
                elif(this.bsqasm.stringoftypedecls.has(typekey)) {
                    %% StringOf is just an alias for CRope (Maybe need to handle UnicodeRope case?)
                    let crinfo, ntic = this.generateTypeInfo[recursive](BSQAssembly::TypeKey::from('CRope'), tic);                    
                    let std_tinfo = CPPAssembly::TypeInfo{ ntic.tid, crinfo.typesize, crinfo.slotsize, crinfo.ptrmask, cpptkey, crinfo.tag };

                    return std_tinfo, ntic.update(cpptkey, std_tinfo);
                }
                elif(this.bsqasm.enums.has(typekey)) { %% For now we will assume our enums cannot exceed 8 bytes 
                    let etdtinfo = CPPAssembly::TypeInfo{ tic.tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value };
                    return etdtinfo, tic.update(cpptkey, etdtinfo);
                }
                else {
                    abort; %% TODO: Type not supported for typeinfo emission!
                }
            }
            elif(this.bsqasm.isNominalTypeConcept(typekey)) {
                if(this.bsqasm.concepts.has(typekey) || this.bsqasm.datatypes.has(typekey)) {
                    %%
                    %% The placeholder typeinfo exists here to prevent infinite
                    %% self recursion on concepts containing themselfs as a field
                    %% in one of their subtypes (look at TypeSignature in body.bsq)
                    %%
                    let placeholder = CPPAssembly::TypeInfo{ tic.tid, 8n, 1n, '1', cpptkey, CPPAssembly::Tag#Ref };
                    let placeholder_tic = tic.update(cpptkey, placeholder);

                    let mfc, ntag, ntic = this.findLargestSubtypeAndTag(ant@<BSQAssembly::AbstractConceptTypeDecl>, placeholder_tic);
                    let ptrmask = CPPTransformNameManager::repeatCString('0', mfc, '2');
                    let matchedType = CPPAssembly::TypeInfo{ ntic.tid, 8n + (mfc * 8n), mfc + 1n, ptrmask, cpptkey, CPPAssembly::Tag#Tagged }; 
                    
                    let ntinfos = ntic.tinfos.delete(cpptkey);
                    let nntic = ntic[tinfos=ntinfos];
                    return matchedType, nntic.update(cpptkey, matchedType);
                }
                elif(this.bsqasm.pconcepts.has(typekey)) {
                    if(ant)@<BSQAssembly::OptionTypeDecl> {
                        let pcinfo, ntic = this.generateFieldInfo(some($ant.oftype), none, false, tic);
                        let ptrmask = CPPTransformNameManager::repeatCString('0', pcinfo.slotsize, '2');
                        let pctinfo = CPPAssembly::TypeInfo{ ntic.tid, 8n + pcinfo.typesize, 1n + pcinfo.slotsize, ptrmask, cpptkey, CPPAssembly::Tag#Tagged };

                        return pctinfo, ntic.update(cpptkey, pctinfo);
                    }
                    abort; %% TODO: Support for other primitive concepts! 
                }
                else {
                    abort; %% Not a concept
                }
            }
            else {
                abort; %% TODO: Type not supported for generating typeinfo!
            }
    }

    method transformSaturatedFieldInfo(sfi: BSQAssembly::SaturatedFieldInfo): CPPAssembly::SaturatedFieldInfo {
        return CPPAssembly::SaturatedFieldInfo { CPPTransformNameManager::convertNominalTypeSignature(sfi.declaredInType), 
            CPPTransformNameManager::convertIdentifier(sfi.fname), this.convertTypeSignature(sfi.ftype), sfi.hasdefault };
    }

    method transformAbstractNominalTypeDeclBase(ant: BSQAssembly::AbstractNominalTypeDecl): (|CPPAssembly::NamespaceKey, List<CString>, CPPAssembly::TypeKey, 
        CString, List<CPPAssembly::InvokeKey>, List<CPPAssembly::InvokeKey>, List<CPPAssembly::InvokeKey>, List<CPPAssembly::InvokeKey>, 
        List<CPPAssembly::NominalTypeSignature>, List<CPPAssembly::SaturatedFieldInfo>|) {

        let staticmethods = ant.staticmethods.map<CPPAssembly::InvokeKey>(fn(m) => CPPTransformNameManager::convertInvokeKey(m));
        let virtmethods = ant.virtmethods.map<CPPAssembly::InvokeKey>(fn(m) => CPPTransformNameManager::convertInvokeKey(m));
        let absmethods = ant.absmethods.map<CPPAssembly::InvokeKey>(fn(m) => CPPTransformNameManager::convertInvokeKey(m));
        let overmethods = ant.overmethods.map<CPPAssembly::InvokeKey>(fn(m) => CPPTransformNameManager::convertInvokeKey(m)); 

        let saturatedProvides = ant.saturatedProvides.map<CPPAssembly::NominalTypeSignature>(
            fn(e) => CPPTransformNameManager::convertNominalTypeSignature(e));
        let saturatedBFieldInfo = ant.saturatedBFieldInfo.map<CPPAssembly::SaturatedFieldInfo>(fn(e) => this.transformSaturatedFieldInfo(e));

        return (|CPPTransformNameManager::convertNamespaceKey(ant.declaredInNS), ant.fullns, CPPTransformNameManager::convertTypeKey(ant.tkey),
            ant.name, staticmethods, virtmethods, absmethods, overmethods, saturatedProvides, saturatedBFieldInfo|);
    }

    method transformAbstractConceptTypeDeclBase(act: BSQAssembly::AbstractConceptTypeDecl): (|CPPAssembly::NamespaceKey, List<CString>, CPPAssembly::TypeKey, 
        CString, List<CPPAssembly::InvokeKey>, List<CPPAssembly::InvokeKey>, List<CPPAssembly::InvokeKey>, List<CPPAssembly::InvokeKey>, 
        List<CPPAssembly::NominalTypeSignature>, List<CPPAssembly::SaturatedFieldInfo>, List<CPPAssembly::TypeKey>|) {
            let base = this.transformAbstractNominalTypeDeclBase(act@<BSQAssembly::AbstractNominalTypeDecl>);
            let subtypes = act.subtypes.map<CPPAssembly::TypeKey>(fn(tk) => CPPTransformNameManager::convertTypeKey(tk));
    
            return (|base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, subtypes|);
    }

    method transformDatatypeMemberToCpp(dm: BSQAssembly::DatatypeMemberEntityTypeDecl): CPPAssembly::DatatypeMemberEntityTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(dm@<BSQAssembly::AbstractNominalTypeDecl>);
        let fields = this.transformMemberFieldDecl(dm.saturatedBFieldInfo, dm, dm.fields);
        let parentTypeDecl = CPPTransformNameManager::convertNominalTypeSignature(dm.parentTypeDecl);

        return CPPAssembly::DatatypeMemberEntityTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, fields, parentTypeDecl }; 
    }

    method transformDatatypeToCpp(dt: BSQAssembly::DatatypeTypeDecl): CPPAssembly::DatatypeTypeDecl {
        let base = this.transformAbstractConceptTypeDeclBase(dt@<BSQAssembly::AbstractConceptTypeDecl>);
        let fields = this.transformMemberFieldDecl(dt.saturatedBFieldInfo, dt, dt.fields);
        let associatedMemberEntityDecls = dt.associatedMemberEntityDecls.map<CPPAssembly::NominalTypeSignature>(
            fn(e) => CPPTransformNameManager::convertNominalTypeSignature(e));

        return CPPAssembly::DatatypeTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, base.10, fields, associatedMemberEntityDecls }; 
    }

    method transformConceptTypeDeclToCpp(ctd: BSQAssembly::ConceptTypeDecl): CPPAssembly::ConceptTypeDecl {
        let base = this.transformAbstractConceptTypeDeclBase(ctd@<BSQAssembly::AbstractConceptTypeDecl>);
        let fields = this.transformMemberFieldDecl(ctd.saturatedBFieldInfo, ctd, ctd.fields);

        return CPPAssembly::ConceptTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, base.10, fields }; 
    }

    method transformSomeTypeDecl(std: BSQAssembly::SomeTypeDecl): CPPAssembly::SomeTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(std@<BSQAssembly::AbstractNominalTypeDecl>);
        return CPPAssembly::SomeTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, 
            this.convertTypeSignature(std.oftype) }; 
    }

    method transformMapEntryTypeDecl(metd: BSQAssembly::MapEntryTypeDecl): CPPAssembly::MapEntryTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(metd@<BSQAssembly::AbstractNominalTypeDecl>);       
        let ktype = this.convertTypeSignature(metd.ktype)@<CPPAssembly::NominalTypeSignature>;
        let vtype = this.convertTypeSignature(metd.vtype)@<CPPAssembly::NominalTypeSignature>;

        return CPPAssembly::MapEntryTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, ktype, vtype };
    }

    method transformConstructableTypeDecl(ctd: BSQAssembly::ConstructableTypeDecl): CPPAssembly::ConstructableTypeDecl {
        match(ctd)@ {
            BSQAssembly::SomeTypeDecl => { return this.transformSomeTypeDecl($ctd); }
            | BSQAssembly::MapEntryTypeDecl => { return this.transformMapEntryTypeDecl($ctd); }
            | _ => { abort; }
        }
    }

    method transformListTypeDecl(ltd: BSQAssembly::ListTypeDecl): CPPAssembly::ListTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(ltd@<BSQAssembly::AbstractNominalTypeDecl>);
        let oftype = this.convertTypeSignature(ltd.oftype);
        return CPPAssembly::ListTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, oftype };
    }

    method transformStackTypeDecl(std: BSQAssembly::StackTypeDecl): CPPAssembly::StackTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(std@<BSQAssembly::AbstractNominalTypeDecl>);
        let oftype = this.convertTypeSignature(std.oftype);
        return CPPAssembly::StackTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, oftype };
    }

    method transformQueueTypeDecl(qtd: BSQAssembly::QueueTypeDecl): CPPAssembly::QueueTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(qtd@<BSQAssembly::AbstractNominalTypeDecl>);
        let oftype = this.convertTypeSignature(qtd.oftype);
        return CPPAssembly::QueueTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, oftype };
    }

    method transformSetTypeDecl(std: BSQAssembly::SetTypeDecl): CPPAssembly::SetTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(std@<BSQAssembly::AbstractNominalTypeDecl>);
        let oftype = this.convertTypeSignature(std.oftype);
        return CPPAssembly::SetTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, oftype };
    }

    method transformMapTypeDecl(mtd: BSQAssembly::MapTypeDecl): CPPAssembly::MapTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(mtd@<BSQAssembly::AbstractNominalTypeDecl>);
        let oftype = this.convertTypeSignature(mtd.oftype);
        let ktype = CPPTransformNameManager::convertNominalTypeSignature(mtd.ktype);
        let vtype = this.convertTypeSignature(mtd.vtype);
        
        return CPPAssembly::MapTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, oftype, ktype, vtype };
    }

    method transformCollectionTypeDecl(ctd: BSQAssembly::CollectionTypeDecl): CPPAssembly::CollectionTypeDecl {
        match(ctd)@ {
            BSQAssembly::ListTypeDecl =>    { return this.transformListTypeDecl($ctd); }
            | BSQAssembly::CRopeTypeDecl => { return this.transformCRopeTypeDecl($ctd); }
            | BSQAssembly::UnicodeRopeTypeDecl => { return this.transformUnicodeRopeTypeDecl($ctd); }
            | BSQAssembly::StackTypeDecl => { return this.transformStackTypeDecl($ctd); }
            | BSQAssembly::QueueTypeDecl => { return this.transformQueueTypeDecl($ctd); }
            | BSQAssembly::SetTypeDecl =>   { return this.transformSetTypeDecl($ctd); }
            | BSQAssembly::MapTypeDecl =>   { return this.transformMapTypeDecl($ctd); }   
        }
    }

    method transformCRopeTypeDecl(crtd: BSQAssembly::CRopeTypeDecl): CPPAssembly::CRopeTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(crtd@<BSQAssembly::AbstractNominalTypeDecl>);
        let oftype = this.convertTypeSignature(crtd.oftype);
        return CPPAssembly::CRopeTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, oftype };
    }

    method transformUnicodeRopeTypeDecl(urtd: BSQAssembly::UnicodeRopeTypeDecl): CPPAssembly::UnicodeRopeTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(urtd@<BSQAssembly::AbstractNominalTypeDecl>);
        let oftype = this.convertTypeSignature(urtd.oftype);
        return CPPAssembly::UnicodeRopeTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, oftype };       
    }

    method transformEntityDeclToCpp(e: BSQAssembly::EntityTypeDecl): CPPAssembly::EntityTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(e@<BSQAssembly::AbstractNominalTypeDecl>);
        let fields = this.transformMemberFieldDecl(e.saturatedBFieldInfo, e, e.fields);

        return CPPAssembly::EntityTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, fields };
    }

    method transformOptionTypeDecl(opt: BSQAssembly::OptionTypeDecl): CPPAssembly::OptionTypeDecl {
        let base = this.transformAbstractConceptTypeDeclBase(opt@<BSQAssembly::AbstractConceptTypeDecl>);
        let ttype = this.convertTypeSignature(opt.oftype);
        let someType = this.convertTypeSignature(opt.someType);

        return CPPAssembly::OptionTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, base.10, ttype, someType };
    }

    method transformResultTypeDecl(rtd: BSQAssembly::ResultTypeDecl): CPPAssembly::ResultTypeDecl {
        abort; %% TODO: Not Implemented
    }

    method transformAPIResultTypeDecl(apirtd: BSQAssembly::APIResultTypeDecl): CPPAssembly::APIResultTypeDecl {
        abort; %% TODO: Not Implemented
    }

    method transformPrimitiveConceptDeclToCpp(pc: BSQAssembly::PrimitiveConceptTypeDecl): CPPAssembly::PrimitiveConceptTypeDecl {
        match(pc)@ {
            BSQAssembly::OptionTypeDecl =>      { return this.transformOptionTypeDecl($pc); }
            | BSQAssembly::ResultTypeDecl =>    { return this.transformResultTypeDecl($pc); }
            | BSQAssembly::APIResultTypeDecl => { return this.transformAPIResultTypeDecl($pc); }
        }
    }

    method transformTypedeclTypeDecl(tdtd: BSQAssembly::TypedeclTypeDecl): CPPAssembly::TypedeclTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(tdtd);
        let valuetype = this.convertTypeSignature(tdtd.valuetype)@<CPPAssembly::NominalTypeSignature>;

        return CPPAssembly::TypedeclTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, valuetype };
    }

    method transformTypedeclStringOfTypeDecl(stdtd: BSQAssembly::TypedeclStringOfTypeDecl): CPPAssembly::TypedeclStringOfTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(stdtd);
        let valuetype = this.convertTypeSignature(stdtd.valuetype)@<CPPAssembly::NominalTypeSignature>;
        let ofcheck = this.transformExpressionToCpp(stdtd.ofcheck);

        return CPPAssembly::TypedeclStringOfTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, valuetype, ofcheck };
    }

    method updateNSMethods(decl: CPPAssembly::NamespaceDecl, e: CPPAssembly::AbstractNominalTypeDecl): CPPAssembly::NamespaceDecl {
        let cppstaticmethods = e.staticmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, e.tkey|));
        let cppvirtmethods =   e.virtmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, e.tkey|));
        let cppabsmethods =    e.absmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, e.tkey|));
        let cppovermethods =   e.overmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, e.tkey|));
    
        let nstaticmethods = List<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>::concat(decl.staticmethods, cppstaticmethods);
        let nvirtmethods =   List<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>::concat(decl.virtmethods, cppvirtmethods);
        let nabsmethods =    List<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>::concat(decl.absmethods, cppabsmethods);
        let novermethods =   List<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>::concat(decl.overmethods, cppovermethods);
    
        return decl[staticmethods=nstaticmethods, virtmethods=nvirtmethods, absmethods=nabsmethods, overmethods=novermethods];
    }

    function convertBsqAsmToCpp(bsqasm: BSQAssembly::Assembly): CPPAssembly::Assembly {
        let transformer = CPPTransformer{ bsqasm };            

        let transformer_nsconsts = bsqasm.nsconsts.reduce<Map<String, CPPAssembly::NamespaceConstDecl>>(
            Map<String, CPPAssembly::NamespaceConstDecl>{}, fn(acc, cnsd) => {
                let cppcnsd = transformer.transformNamespaceConstDeclToCpp(cnsd);
                return acc.insert(cppcnsd.resolvedname, cppcnsd);
            });

        let transformer_nsdecls_nsconsts = transformer_nsconsts.reduce<Map<CString, CPPAssembly::NamespaceDecl>>( 
            Map<CString, CPPAssembly::NamespaceDecl>{}, fn(acc, name, cppcnsd) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppcnsd.fullns, acc,
                    fn(decl) => { 
                        let nnsconsts = decl.nsconsts.pushBack(name);
                        return decl[nsconsts=nnsconsts];
                    });
        });

        let transformer_typeconsts = bsqasm.typeconsts.reduce<Map<String, CPPAssembly::ConstMemberDecl>>(
            Map<String, CPPAssembly::ConstMemberDecl>{}, fn(acc, cmd) => {
                let cppcmd = transformer.transformConstMemberDeclToCpp(cmd);
                return acc.insert(cppcmd.resolvedname, cppcmd);
            });

        let transformer_nsdecls_typeconsts = transformer_typeconsts.reduce<Map<CString, CPPAssembly::NamespaceDecl>>( 
            transformer_nsdecls_nsconsts, fn(acc, name, cppcmd) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppcmd.fullns, acc,
                    fn(decl) => { 
                        let ntypeconsts = decl.typeconsts.pushBack(name);
                        return decl[typeconsts=ntypeconsts];
                    });
        });

        let transformer_nsfuncs = bsqasm.nsfuncs.reduce<Map<CPPAssembly::InvokeKey, CPPAssembly::NamespaceFunctionDecl>>(
            Map<CPPAssembly::InvokeKey, CPPAssembly::NamespaceFunctionDecl>{}, fn(acc, ikey, func) => {
                let cppdecl = transformer.transformNamespaceFunctionDeclToCpp(func);
                return acc.insert(cppdecl.ikey, cppdecl);
            });

        let transformer_nsdecls_nsfuncs = transformer_nsfuncs.reduce<Map<CString, CPPAssembly::NamespaceDecl>>( 
            transformer_nsdecls_typeconsts, fn(acc, cppikey, cppfunc) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppfunc.fullns, acc,
                    fn(decl) => { 
                        let nnsfuncs = decl.nsfuncs.pushBack(cppfunc.ikey);
                        return decl[nsfuncs=nnsfuncs];
                    });
        });

        let transformer_typefuncs = bsqasm.typefuncs.reduce<Map<CPPAssembly::InvokeKey, CPPAssembly::TypeFunctionDecl>>(
            Map<CPPAssembly::InvokeKey, CPPAssembly::TypeFunctionDecl>{}, fn(acc, ikey, tf) => {
                let cpptypefunc = transformer.transformTypeFunctionDeclToCpp(bsqasm.typefuncs.get(ikey));
                return acc.insert(cpptypefunc.ikey, cpptypefunc);
            });

        let transformer_nsdecls_typefuncs = transformer_typefuncs.reduce<Map<CString, CPPAssembly::NamespaceDecl>>( 
            transformer_nsdecls_nsfuncs, fn(acc, ikey, cppfunc) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppfunc.fullns, acc,
                    fn(decl) => { 
                        let ntypefuncs = decl.typefuncs.pushBack(ikey);
                        return decl[typefuncs=ntypefuncs];
                    });
        });

        let transformer_entities = bsqasm.entities.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::EntityTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::EntityTypeDecl>{}, fn(acc, tk, e) => {
                let cppentity = transformer.transformEntityDeclToCpp(e);
                return acc.insert(cppentity.tkey, cppentity);
            });

        let transformer_nsdecls_entities = transformer_entities.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_typefuncs, fn(acc, cpptk, cppe) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppe.fullns, acc,
                    fn(decl) => {
                        let nentities = decl.entities.pushBack(cpptk);
                        let nalltypes = decl.alltypes.pushBack(cpptk);
                        let ndecl = transformer.updateNSMethods(decl, cppe@<CPPAssembly::AbstractNominalTypeDecl>);
                        
                        return ndecl[entities=nentities, alltypes=nalltypes];
                    });
        });

        let transformer_datamembers = bsqasm.datamembers.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::DatatypeMemberEntityTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::DatatypeMemberEntityTypeDecl>{}, fn(acc, tk, datamember) => {
                let cppdatamember = transformer.transformDatatypeMemberToCpp(datamember);
                return acc.insert(cppdatamember.tkey, cppdatamember);
            });

        let transformer_nsdecls_datamembers = transformer_datamembers.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_entities, fn(acc, cpptk, cppdatamember) => {                 
                return CPPTransformNameManager::getNamespaceDeclMapping(cppdatamember.fullns, acc,
                    fn(decl) => {
                        let ndatamembers = decl.datamembers.pushBack(cpptk);
                        let nalltypes = decl.alltypes.pushBack(cpptk);
                        let ndecl = transformer.updateNSMethods(decl, cppdatamember@<CPPAssembly::AbstractNominalTypeDecl>);

                        return ndecl[datamembers=ndatamembers, alltypes=nalltypes];
                    });                     
            });

        let transformer_datatypes = bsqasm.datatypes.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::DatatypeTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::DatatypeTypeDecl>{}, fn(acc, tk, dtype) => {
                let cppdatatype = transformer.transformDatatypeToCpp(dtype);
                return acc.insert(cppdatatype.tkey, cppdatatype);
            });

        let transformer_nsdecls_datatypes = transformer_datatypes.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_datamembers, fn(acc, cpptk, cppdatatype) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppdatatype.fullns, acc,
                    fn(decl) => {
                        let ndatatypes = decl.datatypes.pushBack(cpptk);
                        let nalltypes = decl.alltypes.pushBack(cpptk);
                        let ndecl = transformer.updateNSMethods(decl, cppdatatype@<CPPAssembly::AbstractNominalTypeDecl>);
                        return ndecl[datatypes=ndatatypes, alltypes=nalltypes];
                    });                     
            });

        let transformer_pconcepts = bsqasm.pconcepts.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::PrimitiveConceptTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::PrimitiveConceptTypeDecl>{}, fn(acc, tk, pc) => {
                let cpppc = transformer.transformPrimitiveConceptDeclToCpp(pc);
                return acc.insert(cpppc.tkey, cpppc);
            });

        %% I could see name conflicts arising with emitting pconcepts at top of file, so we do in ns to be safe
        let transformer_nsdecls_pconcepts = transformer_pconcepts.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_datatypes, fn(acc, cpptk, cpppc) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cpppc.fullns, acc,
                    fn(decl) => {
                        let npconcepts = decl.pconcepts.pushBack(cpptk);
                        let nalltypes = decl.alltypes.pushBack(cpptk);
                        let ndecl = transformer.updateNSMethods(decl, cpppc@<CPPAssembly::AbstractNominalTypeDecl>);

                        return ndecl[pconcepts=npconcepts, alltypes=nalltypes];
                    });                     
            }); 

        let transformer_constructables = bsqasm.constructables.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::ConstructableTypeDecl>> (
            Map<CPPAssembly::TypeKey, CPPAssembly::ConstructableTypeDecl>{}, fn(acc, tk, ctd) => {
                let cppctd = transformer.transformConstructableTypeDecl(ctd);
                return acc.insert(cppctd.tkey, cppctd);
            });

        let transformer_nsdecls_constructables = transformer_constructables.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_pconcepts, fn(acc, cpptk, cppctd) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppctd.fullns, acc,
                    fn(decl) => {
                        let nconstructables = decl.constructables.pushBack(cpptk);
                        let nalltypes = decl.alltypes.pushBack(cpptk);
                        let ndecl = transformer.updateNSMethods(decl, cppctd@<CPPAssembly::AbstractNominalTypeDecl>);

                        return ndecl[constructables=nconstructables, alltypes=nalltypes];
                    });                     
            });

        let transformer_collections = bsqasm.collections.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::CollectionTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::CollectionTypeDecl>{}, fn(acc, tk, ctd) => { 
                let cppctd = transformer.transformCollectionTypeDecl(ctd);
                return acc.insert(cppctd.tkey, cppctd);
            });

        let transformer_nsdecls_collections = transformer_collections.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_constructables, fn(acc, cpptk, cppctd) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppctd.fullns, acc,
                    fn(decl) => {
                        let ncollections = decl.collections.pushBack(cpptk);
                        let nalltypes = decl.alltypes.pushBack(cpptk);
                        let ndecl = transformer.updateNSMethods(decl, cppctd@<CPPAssembly::AbstractNominalTypeDecl>);

                        return ndecl[collections=ncollections, alltypes=nalltypes];
                    });                     
            });

        let transformer_allfuncs = bsqasm.allfuncs.map<CPPAssembly::FunctionDecl>(fn(ikey) => {
            let cppikey = CPPTransformNameManager::convertInvokeKey(ikey);
            if(bsqasm.nsfuncs.has(ikey)) {
                let bsqfunc = bsqasm.nsfuncs.get(ikey);
                return CPPAssembly::FunctionDecl{ CPPTransformNameManager::convertNamespaceKey(bsqfunc.declaredInNS), 
                    bsqfunc.fullns, cppikey };
            }
            elif(bsqasm.typefuncs.has(ikey)) {
                let bsqfunc = bsqasm.typefuncs.get(ikey);
                return CPPAssembly::FunctionDecl{ CPPTransformNameManager::convertNamespaceKey(bsqfunc.declaredInNS), 
                    bsqfunc.fullns, cppikey };               
            }
            else {
                abort; 
            }
        });

        let transformer_enums = bsqasm.enums.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::EnumTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::EnumTypeDecl>{}, fn(acc, tk, etd) => {
                let base = transformer.transformAbstractNominalTypeDeclBase(bsqasm.enums.get(tk)@<BSQAssembly::AbstractNominalTypeDecl>);
                return acc.insert(base.2, CPPAssembly::EnumTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, etd.members });
        });

        let transformer_nsdecls_enums = transformer_enums.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_collections, fn(acc, cpptk, cppetd) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppetd.fullns, acc,
                    fn(decl) => {
                        let nenums = decl.enums.pushBack(cpptk);
                        let nalltypes = decl.alltypes.pushBack(cpptk);
                        return decl[enums=nenums, alltypes=nalltypes];
                    });                     
            }); 

        let transformer_typedecls = bsqasm.typedecls.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::TypedeclTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::TypedeclTypeDecl>{}, fn(acc, tk, tdtd) => {
                let cpptd = transformer.transformTypedeclTypeDecl(tdtd);
                return acc.insert(cpptd.tkey, cpptd);
        });

        let transformer_nsdecls_typedecls = transformer_typedecls.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_enums, fn(acc, cpptk, cpptdtd) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cpptdtd.fullns, acc,
                    fn(decl) => {
                        let ntypedecls = decl.typedecls.pushBack(cpptk);
                        let nalltypes = decl.alltypes.pushBack(cpptk);
                        return decl[typedecls=ntypedecls, alltypes=nalltypes];
                    });                     
            }); 

        let transformer_stringoftypedecls = bsqasm.stringoftypedecls.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::TypedeclStringOfTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::TypedeclStringOfTypeDecl>{}, fn(acc, tk, stdtd) => {
                let cppstdtd = transformer.transformTypedeclStringOfTypeDecl(stdtd);
                return acc.insert(cppstdtd.tkey, cppstdtd);
        });

        let transformer_nsdecls_stringoftypedecls = transformer_stringoftypedecls.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_typedecls, fn(acc, cpptk, cppstdtd) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppstdtd.fullns, acc,
                    fn(decl) => {
                        let nstringoftypedecls = decl.stringoftypedecls.pushBack(cpptk);
                        let nalltypes = decl.alltypes.pushBack(cpptk);
                        return decl[stringoftypedecls=nstringoftypedecls, alltypes=nalltypes];
                    });                     
            }); 

        let transformer_primitives = bsqasm.primtives.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::PrimitiveEntityTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::PrimitiveEntityTypeDecl>{}, fn(acc, tkey, pe) => {
                let base = transformer.transformAbstractNominalTypeDeclBase(bsqasm.primtives.get(tkey)@<BSQAssembly::AbstractNominalTypeDecl>);
                return acc.insert(base.2, CPPAssembly::PrimitiveEntityTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9 });
        });

        let transformer_nsdecls_primitives = transformer_primitives.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_stringoftypedecls, fn(acc, cpptk, cppetd) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppetd.fullns, acc,
                    fn(decl) => {
                        let nalltypes = decl.alltypes.pushBack(cpptk);
                        let ndecl = transformer.updateNSMethods(decl, cppetd@<CPPAssembly::AbstractNominalTypeDecl>);
                        
                        return ndecl[alltypes=nalltypes];
                    });                     
            }); 

        let transformer_staticmethods = bsqasm.staticmethods.reduce<Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclStatic>>(
            Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclStatic>{}, fn(acc, ikey, decl) => {
                return acc.insert(CPPTransformNameManager::convertInvokeKey(ikey), transformer.transformStaticMethodDecl(decl));
        });

        let transformer_virtmethods = bsqasm.virtmethods.reduce<Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclVirtual>>(
            Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclVirtual>{}, fn(acc, ikey, decl) => {
                return acc.insert(CPPTransformNameManager::convertInvokeKey(ikey), transformer.transformVirtualMethodDecl(decl));
        });

        let transformer_absmethods = bsqasm.absmethods.reduce<Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclAbstract>>(
            Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclAbstract>{}, fn(acc, ikey, decl) => {
                return acc.insert(CPPTransformNameManager::convertInvokeKey(ikey), transformer.transformAbstractMethodDecl(decl));
        });

        let transformer_overmethods = bsqasm.overmethods.reduce<Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclOverride>>(
            Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclOverride>{}, fn(acc, ikey, decl) => {
                return acc.insert(CPPTransformNameManager::convertInvokeKey(ikey), transformer.transformOverrideMethodDecl(decl));
        });

        let transformer_concepts = bsqasm.concepts.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::ConceptTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::ConceptTypeDecl>{}, fn(acc, tk, ctd) => {
                let cppctd = transformer.transformConceptTypeDeclToCpp(ctd);
                return acc.insert(cppctd.tkey, cppctd);
        });

        let transformer_nsdecls_concepts = transformer_concepts.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_primitives, fn(acc, cpptk, cppconcept) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppconcept.fullns, acc,
                    fn(decl) => {
                        let nconcepts = decl.concepts.pushBack(cpptk);
                        let nalltypes = decl.alltypes.pushBack(cpptk);
                        let ndecl = transformer.updateNSMethods(decl, cppconcept@<CPPAssembly::AbstractNominalTypeDecl>);

                        return ndecl[concepts=nconcepts, alltypes=nalltypes];
                    });                     
            });

        let transformer_allmethods = bsqasm.allmethods.map<CPPAssembly::InvokeKey>(fn(ikey) => {
            return CPPTransformNameManager::convertInvokeKey(ikey);
        });

        let generated_typeinfos_concrete = bsqasm.allconcretetypes
            .reduce<TypeInfoContext>( 
                TypeInfoContext{ Map<CPPAssembly::TypeKey, CPPAssembly::TypeInfo>{}, 1n }, fn(acc, tkey) => {
                    return transformer.generateTypeInfo(tkey, acc).1;
            });

        let generated_typeinfos_abstract = bsqasm.allabstracttypes
            .reduce<TypeInfoContext>( generated_typeinfos_concrete, fn(acc, tkey) => {
                return transformer.generateTypeInfo(tkey, acc).1;
        });

        return CPPAssembly::Assembly {
            nsdecls = transformer_nsdecls_concepts,
            nsconsts = transformer_nsconsts,
            typeconsts = transformer_typeconsts,
            allfuncs = transformer_allfuncs,
            nsfuncs = transformer_nsfuncs,
            typefuncs = transformer_typefuncs,
            staticmethods = transformer_staticmethods,
            virtmethods = transformer_virtmethods,
            absmethods = transformer_absmethods, %% Not fully implemented
            overmethods = transformer_overmethods, %% Not fully implemented
            enums = transformer_enums,
            typedecls = transformer_typedecls,
            stringoftypedecls = transformer_stringoftypedecls,
            primitives = transformer_primitives,
            constructables = transformer_constructables,
            collections = transformer_collections,
            entities = transformer_entities,
            datamembers = transformer_datamembers,
            datatypes = transformer_datatypes,
            pconcepts = transformer_pconcepts,
            concepts = transformer_concepts,
            allmethods = transformer_allmethods, %% Might need to do someting like the funcs, being able to get the ns is nice
            typeinfos = generated_typeinfos_abstract.tinfos
        };
    }
}