namespace CPPEmitter;

%% Transform Bosque names into cpp representation
namespace CPPTransformNameManager {
    function convertNamespaceKey(nskey: BSQAssembly::NamespaceKey): CPPAssembly::NamespaceKey {
        return CPPAssembly::NamespaceKey::from(nskey.value);
    }

    function convertInvokeKey(ikey: BSQAssembly::InvokeKey): CPPAssembly::InvokeKey {
        return CPPAssembly::InvokeKey::from(ikey.value);
    }

    function convertTypeKey(tk: BSQAssembly::TypeKey): CPPAssembly::TypeKey {
        switch(tk.value) {
            'None' => { return CPPAssembly::TypeKey::from('__CoreCpp::None'); }
            | 'Bool' => { return CPPAssembly::TypeKey::from('bool'); }
            | 'Nat' => { return CPPAssembly::TypeKey::from('__CoreCpp::Nat'); }
            | 'Int' => { return CPPAssembly::TypeKey::from('__CoreCpp::Int'); }
            | 'BigNat' => { return CPPAssembly::TypeKey::from('__CoreCpp::BigNat'); }
            | 'BigInt' => { return CPPAssembly::TypeKey::from('__CoreCpp::BigInt'); }
            | 'Float' => { return CPPAssembly::TypeKey::from('__CoreCpp::Float'); }
            | _ => { return CPPAssembly::TypeKey::from(tk.value); } 
        }
    }

    %% Necessary when generating typeinfos for containers
    function revertTypeKey(tk: CPPAssembly::TypeKey): BSQAssembly::TypeKey {
        switch(tk.value) {
            'None' => { return BSQAssembly::TypeKey::from('None'); }
            | 'bool' => { return BSQAssembly::TypeKey::from('Bool'); }
            | '__CoreCpp::Nat' => { return BSQAssembly::TypeKey::from('Nat'); }
            | '__CoreCpp::Int' => { return BSQAssembly::TypeKey::from('Int'); }
            | '__CoreCpp::BigNat' => { return BSQAssembly::TypeKey::from('BigNat'); }
            | '__CoreCpp::BigInt' => { return BSQAssembly::TypeKey::from('BigInt'); }
            | '__CoreCpp::Float' => { return BSQAssembly::TypeKey::from('Float'); }
            | _ => { return BSQAssembly::TypeKey::from(tk.value); }
        }
    }

    function convertTypeSignature(tsig: BSQAssembly::TypeSignature): CPPAssembly::TypeSignature {
        let tk = convertTypeKey(tsig.tkeystr);
        return CPPAssembly::NominalTypeSignature{ tk };
    }

    function convertIdentifier(ident: BSQAssembly::Identifier): CPPAssembly::Identifier {
        return CPPAssembly::Identifier::from(ident.value);
    }

    function convertVarIdentifier(vident: BSQAssembly::VarIdentifier): CPPAssembly::VarIdentifier {
        return CPPAssembly::VarIdentifier::from(vident.value);
    }

    function convertNominalTypeSignature(nts: BSQAssembly::NominalTypeSignature): CPPAssembly::NominalTypeSignature {
        return CPPAssembly::NominalTypeSignature{ convertTypeKey(nts.tkeystr) };
    }

    function createNamespaceDecl(name: CString): CPPAssembly::NamespaceDecl {
        let subns = Map<CString, CPPAssembly::NamespaceDecl>{};
        let nsfuncs = List<CPPAssembly::InvokeKey>{};
        let typefuncs = List<CPPAssembly::InvokeKey>{};
        let constructables = List<CPPAssembly::TypeKey>{};
        let entities = List<CPPAssembly::TypeKey>{};
        let datamembers = List<CPPAssembly::TypeKey>{};
        let datatypes = List<CPPAssembly::TypeKey>{};
        let pconcepts = List<CPPAssembly::TypeKey>{};
        let staticmethods = List<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>{};
        let virtmethods = List<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>{};
        let absmethods = List<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>{};
        let overmethods = List<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>{};
        let alltypes = List<CPPAssembly::TypeKey>{};

        return CPPAssembly::NamespaceDecl{ name, subns, nsfuncs, typefuncs, constructables, entities, 
            datamembers, datatypes, pconcepts, staticmethods, virtmethods, absmethods, overmethods, alltypes };
    }

    %% If ns decl does not exist for name insert, otherwise continue recursing until fullns is empty
    recursive function getNamespaceDeclMapping(fullns: List<CString>, nsdecls: Map<CString, CPPAssembly::NamespaceDecl>, insertion: fn(CPPAssembly::NamespaceDecl) -> CPPAssembly::NamespaceDecl): Map<CString, CPPAssembly::NamespaceDecl> {
        if(fullns.empty()) { %% Base case, we have recursed through all subdecls
            return nsdecls;
        }

        let ns_name = fullns.front();
        let remaining_ns_names = fullns.popFront().1;

        var cur_nsdecl: CPPAssembly::NamespaceDecl;
        if(nsdecls.has(ns_name)) {
            cur_nsdecl = nsdecls.get(ns_name);
        }
        else {
            cur_nsdecl = createNamespaceDecl(ns_name);
        }

        %% Recursively process remaining names
        let subns = getNamespaceDeclMapping[recursive](remaining_ns_names, cur_nsdecl.subns, insertion);
        let updated_nsdecl = CPPAssembly::NamespaceDecl { ns_name, subns, cur_nsdecl.nsfuncs, cur_nsdecl.typefuncs, cur_nsdecl.constructables, cur_nsdecl.entities, 
            cur_nsdecl.datamembers, cur_nsdecl.datatypes, cur_nsdecl.pconcepts, cur_nsdecl.staticmethods, cur_nsdecl.virtmethods, cur_nsdecl.absmethods, cur_nsdecl.overmethods, cur_nsdecl.alltypes };

        if(remaining_ns_names.empty()) { %% Insert at most nested possible depth
            if(!nsdecls.has(ns_name)) {
                return nsdecls.insert(ns_name, insertion(updated_nsdecl));
            }
            else {
                let tmp_map = nsdecls.delete(ns_name);
                return tmp_map.insert(ns_name, insertion(updated_nsdecl));
            }            
        }

        %% I THINK this is unreachable
        %% We need to always update the nsdecls map as sub namespaces may change (this handles multiple nsdecls at same depth)
        if(!nsdecls.has(ns_name)) {
            return nsdecls.insert(ns_name, updated_nsdecl);
        }
        else {
            let tmp_map = nsdecls.delete(ns_name);
            return tmp_map.insert(ns_name, updated_nsdecl);
        }
    }

    function shouldBeRef(fields: List<BSQAssembly::MemberFieldDecl>, asm: BSQAssembly::Assembly): Bool {
        let fieldsPrimitive = fields.reduce<Bool>(true, fn(acc, f) => acc && asm.isPrimtitiveType(f.declaredType.tkeystr));
        if(fields.size() > 4n || !fieldsPrimitive) {
            return true;
        }
        return false;
    }

    recursive function repeatCString(str: CString, n: Nat, acc: CString): CString {
        if(n > 0n) {
            return repeatCString[recursive](str, n - 1n, CString::concat(acc, str));
        }
        return acc;
    }
}

entity CPPTransformer {
    field bsqasm: BSQAssembly::Assembly;

    recursive method processBinaryArgs(lhs: BSQAssembly::Expression, rhs: BSQAssembly::Expression): CPPAssembly::Expression, CPPAssembly::Expression {
        let cpplhs = this.transformExpressionToCpp[recursive](lhs);
        let cpprhs = this.transformExpressionToCpp[recursive](rhs);

        return cpplhs, cpprhs;
    }

    recursive method transformBinAddExpressionToCpp(expr: BSQAssembly::BinAddExpression): CPPAssembly::BinAddExpression {
        let lexpr, rexpr = this.processBinaryArgs[recursive](expr.lhs, expr.rhs);
        return CPPAssembly::BinAddExpression{ lexpr.etype, lexpr, rexpr };
    }

    recursive method transformBinSubExpressionToCpp(expr: BSQAssembly::BinSubExpression): CPPAssembly::BinSubExpression {
        let lexpr, rexpr = this.processBinaryArgs[recursive](expr.lhs, expr.rhs);
        return CPPAssembly::BinSubExpression{ lexpr.etype, lexpr, rexpr };
    }

    recursive method transformBinDivExpressionToCpp(expr: BSQAssembly::BinDivExpression): CPPAssembly::BinDivExpression {
        let lexpr, rexpr = this.processBinaryArgs[recursive](expr.lhs, expr.rhs);
        return CPPAssembly::BinDivExpression{ lexpr.etype, lexpr, rexpr };
    }

    recursive method transformBinMultExpressionToCpp(expr: BSQAssembly::BinMultExpression): CPPAssembly::BinMultExpression {
        let lexpr, rexpr = this.processBinaryArgs[recursive](expr.lhs, expr.rhs);
        return CPPAssembly::BinMultExpression{ lexpr.etype, lexpr, rexpr };
    }

    method transformLiteralNoneExpression(expr: BSQAssembly::LiteralNoneExpression): CPPAssembly::LiteralNoneExpression {
        let etype = CPPTransformNameManager::convertTypeSignature(expr.etype);
        return CPPAssembly::LiteralNoneExpression{ etype };
    }

    method transformLiteralSimpleExpression(expr: BSQAssembly::LiteralSimpleExpression): CPPAssembly::LiteralSimpleExpression {
        let val = expr.value;
        let exprtype = CPPTransformNameManager::convertTypeSignature(expr.etype);

        %% May be cleaner to handle in cppemit
        if(val.endsWithString('i')) {
            return CPPAssembly::LiteralSimpleExpression{ exprtype, val.removeSuffixString('i') };
        }
        elif(val.endsWithString('I')) {
            return CPPAssembly::LiteralSimpleExpression{ exprtype, val.removeSuffixString('I') };
        }
        elif(val.endsWithString('n')) {
            return CPPAssembly::LiteralSimpleExpression{ exprtype, val.removeSuffixString('n') };
        }
        elif(val.endsWithString('N')) {
            return CPPAssembly::LiteralSimpleExpression{ exprtype, val.removeSuffixString('N') };
        }
        elif(val.endsWithString('f')) {
            return CPPAssembly::LiteralSimpleExpression{ exprtype, val.removeSuffixString('f') };
        }
        else { %% Fall through, may need explicit handling in future
            return CPPAssembly::LiteralSimpleExpression{ exprtype, val };
        }
    }

    method transformAccessVariableExpression(expr: BSQAssembly::AccessVariableExpression): CPPAssembly::AccessVariableExpression {
        let vname = CPPTransformNameManager::convertVarIdentifier(expr.vname);
        let vtype = CPPTransformNameManager::convertTypeSignature(expr.etype);
        let layouttype = CPPTransformNameManager::convertTypeSignature(expr.layouttype);

        return CPPAssembly::AccessVariableExpression { vtype, vname, layouttype };
    }

    recursive method transformUnaryExpression(uexpr: BSQAssembly::UnaryExpression): CPPAssembly::UnaryExpression {
        let expr = this.transformExpressionToCpp[recursive](uexpr.exp);

        match(uexpr)@ {
            BSQAssembly::PrefixNotOpExpression => { return CPPAssembly::PrefixNotOpExpression{ expr.etype, expr }; }
            | BSQAssembly::PrefixNegateOpExpression => { return CPPAssembly::PrefixNegateOpExpression{ expr.etype, expr }; }
            | BSQAssembly::PrefixPlusOpExpression => { return CPPAssembly::PrefixPlusOpExpression{ expr.etype, expr }; }
        }
    }

    %% I think we can simplify this and remove the transform functions, just match our bsqasm type then return transform type
    recursive method transformBinaryArithExpression(binarith: BSQAssembly::BinaryArithExpression): CPPAssembly::BinaryArithExpression {
        match(binarith)@ {
            BSQAssembly::BinAddExpression => { return this.transformBinAddExpressionToCpp[recursive]($binarith); }
            | BSQAssembly::BinSubExpression => { return this.transformBinSubExpressionToCpp[recursive]($binarith); }           
            | BSQAssembly::BinDivExpression => { return this.transformBinDivExpressionToCpp[recursive]($binarith); }
            | BSQAssembly::BinMultExpression => { return this.transformBinMultExpressionToCpp[recursive]($binarith); }
        }
    }

    recursive method transformBinaryNumericCompareExpression(expr: BSQAssembly::BinaryNumericExpression): CPPAssembly::BinaryNumericExpression {
        let cpplhs, cpprhs = this.processBinaryArgs[recursive](expr.lhs, expr.rhs);

        let cpptype = CPPTransformNameManager::convertTypeSignature(expr.etype);
        match(expr)@ {
            BSQAssembly::NumericEqExpression => { return CPPAssembly::NumericEqExpression { cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::NumericNeqExpression => { return CPPAssembly::NumericNeqExpression{ cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::NumericLessExpression => { return CPPAssembly::NumericLessExpression{ cpptype, cpplhs, cpprhs}; }
            | BSQAssembly::NumericLessEqExpression => { return CPPAssembly::NumericLessEqExpression{ cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::NumericGreaterExpression => { return CPPAssembly::NumericGreaterExpression{ cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::NumericGreaterEqExpression => { return CPPAssembly::NumericGreaterEqExpression{ cpptype, cpplhs, cpprhs }; }
        }
    }

    recursive method transformBinLogicExpression(expr: BSQAssembly::BinLogicExpression): CPPAssembly::BinLogicExpression {
        let cpplhs, cpprhs = this.processBinaryArgs[recursive](expr.lhs, expr.rhs);
        let cpptype = CPPTransformNameManager::convertTypeSignature(expr.etype);

        match(expr)@ {
            BSQAssembly::BinLogicAndExpression => { return CPPAssembly::BinLogicAndExpression{ cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::BinLogicOrExpression => { return CPPAssembly::BinLogicOrExpression{ cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::BinLogicImpliesExpression => { return CPPAssembly::BinLogicImpliesExpression{ cpptype, cpplhs, cpprhs }; }
            | BSQAssembly::BinLogicIFFExpression => { return CPPAssembly::BinLogicIFFExpression{ cpptype, cpplhs, cpprhs }; }
        }
    }

    recursive method transformLogicActionAndExpression(expr: BSQAssembly::LogicActionAndExpression): CPPAssembly::LogicActionAndExpression {
        let args = expr.args.map<CPPAssembly::Expression>(fn(e) => this.transformExpressionToCpp(e));
        let cpptype = CPPTransformNameManager::convertTypeSignature(expr.etype);

        return CPPAssembly::LogicActionAndExpression{cpptype, args};
    }

    recursive method transformLogicActionOrExpression(expr: BSQAssembly::LogicActionOrExpression): CPPAssembly::LogicActionOrExpression {
        let args = expr.args.map<CPPAssembly::Expression>(fn(e) => this.transformExpressionToCpp(e));
        let cpptype = CPPTransformNameManager::convertTypeSignature(expr.etype);

        return CPPAssembly::LogicActionOrExpression{cpptype, args};
    }

    method transformArgument(arg: BSQAssembly::ArgumentValue): CPPAssembly::ArgumentValue {
        let exp = this.transformExpressionToCpp[recursive](arg.exp);

        match(arg)@ {
            BSQAssembly::NamedArgumentValue => { return CPPAssembly::NamedArgumentValue{ 
                exp, CPPTransformNameManager::convertVarIdentifier($arg.name) }; }
            | BSQAssembly::PositionalArgumentValue => { return CPPAssembly::PositionalArgumentValue{ exp }; }
            | _ => { abort; } %% TODO: Not implemented
        }
    }

    method transformArgumentInfo(bsqargs: BSQAssembly::InvokeArgumentInfo): CPPAssembly::ArgumentList {
        let shuffled = bsqargs.shuffleinfo.mapIdx<Option<CPPAssembly::ArgumentValue>>(fn(e, ii) => {
            var cur_arg: CPPAssembly::ArgumentValue;
            if(ii >= bsqargs.args.args.size()) {
                return none;
            }
            else { %% Resolve shuffle value
                let shuffle_idx = e.0;
                if(shuffle_idx)@none {
                    let arg = bsqargs.args.args.get(ii);
                    return some(this.transformArgument(arg));
                }
                else {
                    let arg = bsqargs.args.args.get($shuffle_idx);
                    return some(this.transformArgument(arg));
                }
            }
        });
        return CPPAssembly::ArgumentList{ shuffled };   
    }
    
    %% This does not shuffle
    method transformArgumentList(al: BSQAssembly::ArgumentList): CPPAssembly::ArgumentList {
        return CPPAssembly::ArgumentList{ al.args.map<Option<CPPAssembly::ArgumentValue>>(fn(arg) => some(this.transformArgument(arg))) };
    }

    method transformCallNamespaceFunctionExpression(expr: BSQAssembly::CallNamespaceFunctionExpression): CPPAssembly::CallNamespaceFunctionExpression {
        let ts = CPPTransformNameManager::convertTypeSignature(expr.etype);
        let ikey = CPPTransformNameManager::convertInvokeKey(expr.ikey);
        let ns = CPPTransformNameManager::convertNamespaceKey(expr.ns);
        let args = this.transformArgumentInfo(expr.argsinfo);
        let fullns = expr.fullns; %% For looking up func we are calling
        %% let callingikey = expr.callingikey; %% Typefuncs (since they get grouped with nsfuncs due to type resolution)

        return CPPAssembly::CallNamespaceFunctionExpression{ ts, ikey, ns, fullns, args };
    }

    method transformCallTypeFunctionExpression(expr: BSQAssembly::CallTypeFunctionExpression): CPPAssembly::CallTypeFunctionExpression {
        let ts = CPPTransformNameManager::convertTypeSignature(expr.etype);
        let ikey = CPPTransformNameManager::convertInvokeKey(expr.ikey);
        let ttype = CPPTransformNameManager::convertNominalTypeSignature(expr.ttype);
        let resolvedDeclType = CPPTransformNameManager::convertNominalTypeSignature(expr.resolvedDeclType);
        let args = this.transformArgumentInfo(expr.argsinfo);

        return CPPAssembly::CallTypeFunctionExpression{ ts, ikey, ttype, resolvedDeclType, args };
    }

    method transformITestType(it: BSQAssembly::ITestType, isnot: Bool): CPPAssembly::ITestType {
        let ttype = CPPTransformNameManager::convertTypeSignature(it.ttype);
        return CPPAssembly::ITestType{ isnot, ttype };    
    }

    method transformITestSome(isnot: Bool): CPPAssembly::ITestSome {
        return CPPAssembly::ITestSome{ isnot };
    }

    %% TODO: Support for ITest as convert
    method transformITestAsTest(itest: BSQAssembly::ITest): CPPAssembly::ITest {
        let isnot = itest.isnot;
        match(itest)@ {
            BSQAssembly::ITestType => { return this.transformITestType($itest, isnot); }
            | BSQAssembly::ITestSome => { return this.transformITestSome(isnot); }
            | _ => { abort; } 
        }
    }

    method transformPostfixOpImpl(op: BSQAssembly::PostfixOperation): CPPAssembly::PostfixOperation {
        let baseType = CPPTransformNameManager::convertTypeSignature(op.baseType);
        match(op)@ {
            BSQAssembly::PostfixAccessFromName => {
                let name = CPPTransformNameManager::convertIdentifier($op.name);
                let declaredInType = CPPTransformNameManager::convertNominalTypeSignature($op.declaredInType);
                let ftype = CPPTransformNameManager::convertTypeSignature($op.ftype);

                return CPPAssembly::PostfixAccessFromName{ baseType, name, declaredInType, ftype };
            }
            | BSQAssembly::PostfixInvokeStatic => {
                let resolvedType = CPPTransformNameManager::convertNominalTypeSignature($op.resolvedType);
                let resolvedTrgt = CPPTransformNameManager::convertInvokeKey($op.resolvedTrgt);
                let args = this.transformArgumentInfo($op.argsinfo);

                return CPPAssembly::PostfixInvokeStatic{ baseType, resolvedType, resolvedTrgt, args };
            }
            | BSQAssembly::PostfixIsTest => { return CPPAssembly::PostfixIsTest{ baseType, this.transformITestAsTest($op.ttest) }; }
            | _ => { abort; } %% TODO: Not Implemented
        }
    }

    method transformPostfixOp(pop: BSQAssembly::PostfixOp): CPPAssembly::PostfixOp {
        let etype = CPPTransformNameManager::convertTypeSignature(pop.etype);
        let rootExp = this.transformExpressionToCpp(pop.rootExp);
        let ops = pop.ops.map<CPPAssembly::PostfixOperation>(fn(op) => {
            return this.transformPostfixOpImpl(op);
        });

        return CPPAssembly::PostfixOp{ etype, rootExp, ops };
    }

    method transformConstructorPrimaryExpressionBase(cpe: BSQAssembly::ConstructorPrimaryExpression): (| CPPAssembly::TypeSignature,
        CPPAssembly::ArgumentList, CPPAssembly::NominalTypeSignature |) {
            let etype = CPPTransformNameManager::convertTypeSignature(cpe.etype);
            let args = this.transformArgumentList(cpe.args);
            let ctype = CPPTransformNameManager::convertNominalTypeSignature(cpe.ctype);

            return (| etype, args, ctype|);
    }

    method transformConstructorPrimarySpecialSomeExpression(cpsse: BSQAssembly::ConstructorPrimarySpecialSomeExpression): CPPAssembly::ConstructorPrimarySpecialSomeExpression {
        let base = this.transformConstructorPrimaryExpressionBase(cpsse@<BSQAssembly::ConstructorPrimaryExpression>);
        let ofttype = CPPTransformNameManager::convertTypeSignature(cpsse.ofttype);

        return CPPAssembly::ConstructorPrimarySpecialSomeExpression{ base.0, base.1, base.2, ofttype };
    }

    method transformConstructorPrimarySpecialOkExpression(cpsoe: BSQAssembly::ConstructorPrimarySpecialOkExpression): CPPAssembly::ConstructorPrimarySpecialOkExpression {
        abort; %% TODO: Not Implemented
    }   

    method transformConstructorPrimarySpecialFailExpression(cpsfe: BSQAssembly::ConstructorPrimarySpecialFailExpression): CPPAssembly::ConstructorPrimarySpecialFailExpression {
        abort; %% TODO: Not Implemented
    }

    method transformConstructorPrimarySpecialConstructableExpression(cpsce: BSQAssembly::ConstructorPrimarySpecialConstructableExpression): CPPAssembly::ConstructorPrimarySpecialConstructableExpression {
        match(cpsce)@ {
            BSQAssembly::ConstructorPrimarySpecialSomeExpression => { return this.transformConstructorPrimarySpecialSomeExpression($cpsce); }
            | BSQAssembly::ConstructorPrimarySpecialOkExpression => { return this.transformConstructorPrimarySpecialOkExpression($cpsce); }
            | BSQAssembly::ConstructorPrimarySpecialFailExpression => { return this.transformConstructorPrimarySpecialFailExpression($cpsce); }
        }
    }

    method transformConstructorStdExpression(e: BSQAssembly::ConstructorStdExpression): CPPAssembly::ConstructorStdExpression {
        let base = this.transformConstructorPrimaryExpressionBase(e@<BSQAssembly::ConstructorPrimaryExpression>);        
        let shuffledargs = e.shuffleinfo.mapIdx<Option<CPPAssembly::ArgumentValue>>(fn(she, ii) => {
                var cur_arg: CPPAssembly::ArgumentValue;
                if(ii >= e.args.args.size()) {
                    return none;
                }
                else { %% Resolve shuffle value
                    let shuffle_idx = she.0;
                    if(shuffle_idx)@none {
                        let arg = base.1.args.get(ii);
                        if(arg)@!none {
                            return some($arg);
                        }
                        abort;
                    }
                    else {
                        let arg = base.1.args.get($shuffle_idx);
                        if(arg)@!none {
                            return some($arg);
                        }
                        abort;
                    }
                }
            });

        return CPPAssembly::ConstructorStdExpression{ base.0, CPPAssembly::ArgumentList{ shuffledargs }, base.2, e.fullns };
    } 

    method transformIfExpression(exp: BSQAssembly::IfExpression): CPPAssembly::IfExpression {
        let etype = CPPTransformNameManager::convertTypeSignature(exp.etype);
        let texp = this.transformExpressionToCpp(exp.texp);

        let coerced_thenexp = this.processCoerceTypeAsNeeded(exp.thenexp, exp.etype);
        let coerced_elseexp = this.processCoerceTypeAsNeeded(exp.elseexp, exp.etype);

        let thenexp = this.transformExpressionToCpp(coerced_thenexp);
        let elseexp = this.transformExpressionToCpp(coerced_elseexp);

        match(exp)@ {
            BSQAssembly::IfSimpleExpression => { return CPPAssembly::IfSimpleExpression{ etype, texp, thenexp, elseexp }; }
            | _ => { abort; } %% TODO: Not Implemented 
        }
    }

    %% Will be used when we are running Explicitify
    method transformCoerceWidenTypeExpression(exp: BSQAssembly::CoerceWidenTypeExpression): CPPAssembly::CoerceWidenTypeExpression {
        let etype = CPPTransformNameManager::convertTypeSignature(exp.etype);
        let expr = this.transformExpressionToCpp(exp.exp);
        let srctype = CPPTransformNameManager::convertNominalTypeSignature(exp.srctype);
        let trgttype = CPPTransformNameManager::convertNominalTypeSignature(exp.trgttype);

        return CPPAssembly::CoerceWidenTypeExpression{ etype, expr, srctype, trgttype };
    }

    %% Same here
    method transformCoerceNarrowTypeExpression(exp: BSQAssembly::CoerceNarrowTypeExpression): CPPAssembly::CoerceNarrowTypeExpression {
        let etype = CPPTransformNameManager::convertTypeSignature(exp.etype);
        let expr = this.transformExpressionToCpp(exp.exp);
        let srctype = CPPTransformNameManager::convertNominalTypeSignature(exp.srctype);
        let trgttype = CPPTransformNameManager::convertNominalTypeSignature(exp.trgttype);

        return CPPAssembly::CoerceNarrowTypeExpression{ etype, expr, srctype, trgttype };
    }

    recursive method transformExpressionToCpp(expr: BSQAssembly::Expression): CPPAssembly::Expression {
        match(expr)@ {
            BSQAssembly::BinaryArithExpression => { return this.transformBinaryArithExpression[recursive]($expr); }
            | BSQAssembly::BinaryNumericExpression => { return this.transformBinaryNumericCompareExpression[recursive]($expr); }
            | BSQAssembly::LiteralNoneExpression => { return this.transformLiteralNoneExpression($expr); }
            | BSQAssembly::LiteralSimpleExpression => { return this.transformLiteralSimpleExpression($expr); }
            | BSQAssembly::UnaryExpression => { return this.transformUnaryExpression[recursive]($expr); }
            | BSQAssembly::BinLogicExpression => { return this.transformBinLogicExpression[recursive]($expr); }
            | BSQAssembly::LogicActionAndExpression => { return this.transformLogicActionAndExpression[recursive]($expr); }
            | BSQAssembly::LogicActionOrExpression => { return this.transformLogicActionOrExpression[recursive]($expr); }
            | BSQAssembly::AccessVariableExpression => { return this.transformAccessVariableExpression($expr); }
            | BSQAssembly::CallNamespaceFunctionExpression => { return this.transformCallNamespaceFunctionExpression($expr); } 
            | BSQAssembly::CallTypeFunctionExpression => { return this.transformCallTypeFunctionExpression($expr); }
            | BSQAssembly::PostfixOp => { return this.transformPostfixOp($expr); }
            | BSQAssembly::ConstructorPrimarySpecialConstructableExpression => { return this.transformConstructorPrimarySpecialConstructableExpression($expr); }
            | BSQAssembly::ConstructorStdExpression => { return this.transformConstructorStdExpression($expr); }
            | BSQAssembly::IfExpression => { return this.transformIfExpression($expr); }
            | BSQAssembly::CoerceWidenTypeExpression => { return this.transformCoerceWidenTypeExpression($expr); }   
            | BSQAssembly::CoerceNarrowTypeExpression => { return this.transformCoerceNarrowTypeExpression($expr); }
            | _ => { abort; }
        }
    }

    recursive method transformReturnSingleStatementToCpp(ret: BSQAssembly::ReturnSingleStatement): CPPAssembly::ReturnSingleStatement {
        let rtype = CPPTransformNameManager::convertTypeSignature(ret.rtype); 
        let rexp = this.transformExpressionToCpp[recursive](ret.value);

        return CPPAssembly::ReturnSingleStatement{rtype, rexp};
    }

    %% Temporary
    method processCoerceTypeAsNeeded(e: BSQAssembly::Expression, into: BSQAssembly::TypeSignature): BSQAssembly::Expression {
        if(this.bsqasm.areTypesSame(e.etype, into)) {
            return e;
        }
        else {
            if(this.bsqasm.isSubtypeOf(e.etype, into)) {
                return BSQAssembly::CoerceWidenTypeExpression{ e.sinfo, into, e, e.etype@<BSQAssembly::NominalTypeSignature>, into@<BSQAssembly::NominalTypeSignature> };
            }
            else {
                return BSQAssembly::CoerceNarrowTypeExpression{ e.sinfo, into, e, e.etype@<BSQAssembly::NominalTypeSignature>, into@<BSQAssembly::NominalTypeSignature> };
            }
        }
    }

    recursive method transformVariableInitializationStatementToCpp(stmt: BSQAssembly::VariableInitializationStatement): CPPAssembly::VariableInitializationStatement {
        let name = CPPTransformNameManager::convertIdentifier(stmt.name);
        let stype = CPPTransformNameManager::convertTypeSignature(stmt.vtype);
        let coerced_expr = this.processCoerceTypeAsNeeded(stmt.exp, stmt.vtype);
        let cppexpr = this.transformExpressionToCpp[recursive](coerced_expr);

        return CPPAssembly::VariableInitializationStatement{ name, stype, cppexpr };
    }

    method transformBlockStatement(block: BSQAssembly::BlockStatement): CPPAssembly::BlockStatement {
        let stmts = block.statements.map<CPPAssembly::Statement>(fn(stmt) => this.transformStatementToCpp(stmt));
        return CPPAssembly::BlockStatement{ stmts, block.isScoping };
    }

    recursive method transformIfStatement(stmt: BSQAssembly::IfStatement): CPPAssembly::IfStatement {
        let cond = this.transformExpressionToCpp[recursive](stmt.texp);
        let trueBlock = this.transformBlockStatement(stmt.trueBlock);

        match(stmt)@ {
            BSQAssembly::IfSimpleStatement => { return CPPAssembly::IfSimpleStatement{ cond, trueBlock }; }
            | BSQAssembly::IfTestStatement => { return CPPAssembly::IfTestStatement{ cond, trueBlock, this.transformITestAsTest($stmt.itest) }; }
            | BSQAssembly::IfBinderStatement => { abort; } %% TODO: Not Implemented
        }
    }

    recursive method transformIfElseStatement(stmt: BSQAssembly::IfElseStatement): CPPAssembly::IfElseStatement {
        let cond = this.transformExpressionToCpp[recursive](stmt.texp);
        let trueBlock = this.transformBlockStatement(stmt.trueBlock);
        let falseBlock = this.transformBlockStatement(stmt.falseBlock);

        match(stmt)@ {
            BSQAssembly::IfElseSimpleStatement => { return CPPAssembly::IfElseSimpleStatement{ cond, trueBlock, falseBlock }; }
            | BSQAssembly::IfElseTestStatement => { return CPPAssembly::IfElseTestStatement{ cond, trueBlock, falseBlock, this.transformITestAsTest($stmt.itest) }; }
            | BSQAssembly::IfElseBinderStatement => { abort; } %% TODO: Not Implemented
        }
    }

    recursive method transformIfElifElseStatement(stmt: BSQAssembly::IfElifElseStatement): CPPAssembly::IfElifElseStatement {
        let ifcond = this.transformExpressionToCpp[recursive](stmt.ifcond);
        let ifflow = this.transformBlockStatement(stmt.ifflow);
        let elseflow = this.transformBlockStatement(stmt.elseflow);

        let condflow = stmt.condflow.map<(|CPPAssembly::Expression, CPPAssembly::BlockStatement|)>(fn(block) => 
            (|this.transformExpressionToCpp[recursive](block.0), this.transformBlockStatement(block.1)|));
    
        return CPPAssembly::IfElifElseStatement{ ifcond, ifflow, condflow, elseflow };
    }

    method transformStatementToCpp(stmt: BSQAssembly::Statement): CPPAssembly::Statement {
        match(stmt)@ {
            BSQAssembly::VariableInitializationStatement => { return this.transformVariableInitializationStatementToCpp($stmt); }
            | BSQAssembly::ReturnSingleStatement => { return this.transformReturnSingleStatementToCpp[recursive]($stmt); }
            | BSQAssembly::IfStatement => { return this.transformIfStatement[recursive]($stmt); }
            | BSQAssembly::IfElseStatement => { return this.transformIfElseStatement[recursive]($stmt); }
            | BSQAssembly::IfElifElseStatement => { return this.transformIfElifElseStatement[recursive]($stmt); }
            | _ => { abort; }
        }
    }

    method transformStatementListToCpp(stmts: List<BSQAssembly::Statement>): List<CPPAssembly::Statement> {
        let tailop = stmts.back();

        %% Need to match tailop to get return, not implemented for now

        return stmts.map<CPPAssembly::Statement>(fn(stmt) => this.transformStatementToCpp(stmt));
    }

    method transformDefaultVal(val: Option<BSQAssembly::Expression>): Option<CPPAssembly::Expression> {
        match(val)@ {
            None => { return none; }
            | _ => { return some(this.transformExpressionToCpp[recursive]($val.value)); }
        }
    }

    method transformParameterDecl(decl: List<BSQAssembly::InvokeParameterDecl>): List<CPPAssembly::ParameterDecl> {
        return decl.map<CPPAssembly::ParameterDecl>(fn(pdecl) => {
            return CPPAssembly::ParameterDecl{ 
                CPPTransformNameManager::convertIdentifier(pdecl.pname), 
                CPPTransformNameManager::convertTypeSignature(pdecl.ptype),
                this.transformDefaultVal(pdecl.defaultval)
            };
        });
    }

    method transformBodyToCpp(body: BSQAssembly::BodyImplementation): CPPAssembly::BodyImplementation {
        match(body)@ {
            BSQAssembly::StandardBodyImplementation => { 
                let cppstmts = this.transformStatementListToCpp($body.statements);
                return CPPAssembly::StandardBodyImplementation{ cppstmts };
            }
            | BSQAssembly::BuiltinBodyImplementation => { return CPPAssembly::BuiltinBodyImplementation{ $body.builtin }; }
            | _ => { abort; }
        }
    }

    method transformAbstractInvokeDecl(decl: BSQAssembly::AbstractInvokeDecl): (|CPPAssembly::NamespaceKey, List<CString>, CString, CPPAssembly::InvokeKey,
        List<CPPAssembly::ParameterDecl>, CPPAssembly::TypeSignature, CPPAssembly::BodyImplementation|) {
        return
            (|CPPTransformNameManager::convertNamespaceKey(decl.declaredInNS), decl.fullns, decl.name.value, 
            CPPTransformNameManager::convertInvokeKey(decl.ikey), this.transformParameterDecl(decl.params),
            CPPTransformNameManager::convertTypeSignature(decl.resultType), this.transformBodyToCpp(decl.body)|);
    }

    method transformStaticMethodDecl(m: BSQAssembly::MethodDeclStatic): CPPAssembly::MethodDeclStatic {
        let base = this.transformAbstractInvokeDecl(m);
        return CPPAssembly::MethodDeclStatic{ base.0, base.1, base.2, base.3, base.4, base.5, base.6 };
    }

    %% Virtual, abstract, and override methods should not emit for now
    method transformVirtualMethodDecl(m: BSQAssembly::MethodDeclVirtual): CPPAssembly::MethodDeclVirtual {
        let base = this.transformAbstractInvokeDecl(m);
        return CPPAssembly::MethodDeclVirtual{ base.0, base.1, base.2, base.3, base.4, base.5, base.6 };
    }

    method transformAbstractMethodDecl(m: BSQAssembly::MethodDeclAbstract): CPPAssembly::MethodDeclAbstract {
        let base = this.transformAbstractInvokeDecl(m);
        return CPPAssembly::MethodDeclAbstract{ base.0, base.1, base.2, base.3, base.4, base.5, base.6 };
    }

    method transformOverrideMethodDecl(m: BSQAssembly::MethodDeclOverride): CPPAssembly::MethodDeclOverride {
        let base = this.transformAbstractInvokeDecl(m);
        return CPPAssembly::MethodDeclOverride{ base.0, base.1, base.2, base.3, base.4, base.5, base.6 };
    }

    method transformNamespaceFunctionDeclToCpp(decl: BSQAssembly::NamespaceFunctionDecl): CPPAssembly::NamespaceFunctionDecl {
        let base = this.transformAbstractInvokeDecl(decl);
        return CPPAssembly::NamespaceFunctionDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6 };
    }  

    method transformTypeFunctionDeclToCpp(decl: BSQAssembly::TypeFunctionDecl): CPPAssembly::TypeFunctionDecl {
        let base = this.transformAbstractInvokeDecl(decl);
        return CPPAssembly::TypeFunctionDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, decl.completens, 
            CPPTransformNameManager::convertInvokeKey(decl.completeikey) };
    } 

    method transformMemberFieldDecl(fields: List<BSQAssembly::SaturatedFieldInfo>, m: BSQAssembly::AbstractNominalTypeDecl, mfields: List<BSQAssembly::MemberFieldDecl>): List<CPPAssembly::MemberFieldDecl> {
        return fields.mapIdx<CPPAssembly::MemberFieldDecl>(fn(f, ii) => {
            let declaredInNS = CPPTransformNameManager::convertNamespaceKey(m.declaredInNS);
            let name = CPPTransformNameManager::convertIdentifier(f.fname);
            let declaredInType = CPPTransformNameManager::convertNominalTypeSignature(f.declaredInType);
            let declaredType = CPPTransformNameManager::convertTypeSignature(f.ftype);
            var defaultval: Option<CPPAssembly::Expression>;
            if(f.hasdefault && ii < mfields.size()) {
                let tmp = mfields.get(ii).defaultValue;
                if(tmp)@@none {
                    abort;
                }
                defaultval = some(this.transformExpressionToCpp(tmp));
            }
            else {
                defaultval = none;
            }
            return CPPAssembly::MemberFieldDecl{ declaredInNS, m.fullns, name, declaredInType, declaredType, defaultval };
        });
    }

    %% Explore all subtypes and find largest possible field count
    method findMaxFieldCount(cur: BSQAssembly::AbstractConceptTypeDecl, bsqasm: BSQAssembly::Assembly): Nat {
        return cur.subtypes.reduce<Nat>(0n, fn(acc, subtk) => {
            if(bsqasm.entities.has(subtk)) {
                let fieldssize = bsqasm.entities.get(subtk).saturatedBFieldInfo.size();
                return if(fieldssize > acc) then fieldssize else acc;
            }
            elif(bsqasm.datamembers.has(subtk)) {
                let fieldssize = bsqasm.datamembers.get(subtk).saturatedBFieldInfo.size();
                return if(fieldssize > acc) then fieldssize else acc;
            }
            else {
                var subtype: BSQAssembly::AbstractConceptTypeDecl;
                if(bsqasm.concepts.has(subtk)){
                    subtype = bsqasm.concepts.get(subtk);
                }
                elif(bsqasm.datatypes.has(subtk)) {
                    subtype = bsqasm.datatypes.get(subtk);
                }
                else {
                    abort; %% Unsupported non-concrete type!
                }
                return this.findMaxFieldCount[recursive](subtype, bsqasm);
            }
        });
    }

    method generateNominalConcreteTypeInfo(fields_tinfo: List<(|CPPAssembly::TypeInfo, Map<CPPAssembly::TypeKey, CPPAssembly::TypeInfo>|)>, tid: Nat, tkey: CPPAssembly::TypeKey, tag: CPPAssembly::Tag, asm: BSQAssembly::Assembly): CPPAssembly::TypeInfo {
        return fields_tinfo.reduce<CPPAssembly::TypeInfo>(CPPAssembly::TypeInfo{ tid, 0n, 0n, '', tkey, tag }, fn(acc, tinfo) => {
            let bsqtkey = CPPTransformNameManager::revertTypeKey(tinfo.0.typekey);
            if(asm.isNominalTypeConcrete(bsqtkey) && !asm.isPrimtitiveType(bsqtkey)) { %% Pointer to other Concrete Nominal (non primitive) type
                if(tinfo.0.tag === CPPAssembly::Tag#Ref) {
                    return CPPAssembly::TypeInfo{ acc.id, acc.typesize + 8n, acc.slotsize + 1n, CString::concat(acc.ptrmask, '1'), acc.typekey, acc.tag };
                }
                return CPPAssembly::TypeInfo{ acc.id, acc.typesize + tinfo.0.typesize, acc.slotsize + tinfo.0.slotsize, CString::concat(acc.ptrmask, tinfo.0.ptrmask), acc.typekey, acc.tag };
            }
            %% Primitive type 
            return CPPAssembly::TypeInfo{ acc.id, acc.typesize + tinfo.0.typesize, acc.slotsize + tinfo.0.slotsize, CString::concat(acc.ptrmask, tinfo.0.ptrmask), acc.typekey, acc.tag };
        });
    }

    %%
    %% If 4 or less primitive only fields we make value. otherwise always ref/tagged. Need to imspect this code to ensure this invariant is held
    %%

    recursive method generateTypeInfo(typekey: BSQAssembly::TypeKey, tinfos: Map<CPPAssembly::TypeKey, CPPAssembly::TypeInfo>, tid: Nat, bsqasm: BSQAssembly::Assembly): CPPAssembly::TypeInfo, Map<CPPAssembly::TypeKey, CPPAssembly::TypeInfo> { 
        let cpptkey = CPPTransformNameManager::convertTypeKey(typekey);

        var matchedType: CPPAssembly::TypeInfo;
        if(tinfos.has(cpptkey)) {
            return tinfos.get(cpptkey), tinfos;
        }

        let cur_tid = tid;
        let next_tid = tid + 1n;

        if(bsqasm.isPrimtitiveType(typekey)) {
            switch(typekey) {
                'None'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{     next_tid, 0n, 0n, '', cpptkey, CPPAssembly::Tag#Value }; }
                | 'Bool'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{   next_tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value }; }
                | 'Nat'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{    next_tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value }; }
                | 'Int'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{    next_tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value }; }
                | 'BigNat'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{ next_tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value }; }
                | 'BigInt'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{ next_tid, 16n, 2n, '00', cpptkey, CPPAssembly::Tag#Value }; }
                | 'Float'<BSQAssembly::TypeKey> => { matchedType = CPPAssembly::TypeInfo{  next_tid, 8n, 1n, '0', cpptkey, CPPAssembly::Tag#Value }; }
                | _ => { abort; } %% Not supported by cpp emitter yet!
            }
        }
        elif(bsqasm.isNominalTypeConcrete(typekey)) {
            %% We can't compare tkey like primtives, so check if container has our tkey
            var fields_tinfo: List<(|CPPAssembly::TypeInfo, Map<CPPAssembly::TypeKey, CPPAssembly::TypeInfo>|)>;
            var tag: CPPAssembly::Tag;
            var tkey: CPPAssembly::TypeKey;
            if(bsqasm.entities.has(typekey)) {
                let e = bsqasm.entities.get(typekey);
                let isRef = CPPTransformNameManager::shouldBeRef(e.fields, bsqasm);
                fields_tinfo = e.saturatedBFieldInfo.map<(|CPPAssembly::TypeInfo, Map<CPPAssembly::TypeKey, CPPAssembly::TypeInfo>|)>(
                    fn(f_tkey) => this.generateTypeInfo[recursive](f_tkey.ftype.tkeystr, tinfos, cur_tid, bsqasm) );
                tag = if(isRef) then CPPAssembly::Tag#Ref else CPPAssembly::Tag#Value;
                tkey = CPPTransformNameManager::convertTypeKey(e.tkey);
            }
            elif(bsqasm.datamembers.has(typekey)) {
                let dm = bsqasm.datamembers.get(typekey);
                let isRef = CPPTransformNameManager::shouldBeRef(dm.fields, bsqasm);
                fields_tinfo = dm.saturatedBFieldInfo.map<(|CPPAssembly::TypeInfo, Map<CPPAssembly::TypeKey, CPPAssembly::TypeInfo>|)>(
                    fn(f_tkey) => this.generateTypeInfo[recursive](f_tkey.ftype.tkeystr, tinfos, cur_tid, bsqasm) );
                tag = if(isRef) then CPPAssembly::Tag#Ref else CPPAssembly::Tag#Value;
                tkey = CPPTransformNameManager::convertTypeKey(dm.tkey);
            }
            elif(bsqasm.constructables.has(typekey)) { 
                let cons = bsqasm.constructables.get(typekey);
                if(cons)@<BSQAssembly::SomeTypeDecl> { %% Only support Some<T> for now (are always value too)
                    let someinfo = this.generateTypeInfo[recursive]($cons.oftype.tkeystr, tinfos, cur_tid, bsqasm).0;
                    var named_someinfo = CPPAssembly::TypeInfo{ someinfo.id, someinfo.typesize, someinfo.slotsize, someinfo.ptrmask, cpptkey, CPPAssembly::Tag#Value }; 

                    %% We need to return early as all work was done in calculating someinfo
                    return (| named_someinfo, tinfos.insert(cpptkey, named_someinfo) |);
                }
                abort;
            }
            else {
                abort; %% TODO: Type not supported for typeinfo emission!
            }

            matchedType = this.generateNominalConcreteTypeInfo(fields_tinfo, next_tid, tkey, tag, bsqasm);
        }
        elif(bsqasm.isNominalTypeConcept(typekey)) {
            var maxFieldCount: Nat;
            if(bsqasm.concepts.has(typekey)) {
                maxFieldCount = this.findMaxFieldCount(bsqasm.concepts.get(typekey)@<BSQAssembly::AbstractConceptTypeDecl>, bsqasm);
            }
            elif(bsqasm.datatypes.has(typekey)) { 
                maxFieldCount = this.findMaxFieldCount(bsqasm.datatypes.get(typekey)@<BSQAssembly::AbstractConceptTypeDecl>, bsqasm);
            }
            elif(bsqasm.pconcepts.has(typekey)) {
                let pc = bsqasm.pconcepts.get(typekey);
                if(pc)@<BSQAssembly::OptionTypeDecl> { %% I "think" sometype would be best here
                    let pcinfo = this.generateTypeInfo[recursive]($pc.someType.tkeystr, tinfos, cur_tid, bsqasm).0;
                    let named_pcinfo = CPPAssembly::TypeInfo{ pcinfo.id, 8n + pcinfo.typesize, 1n + pcinfo.slotsize, CString::concat('2', pcinfo.ptrmask), cpptkey, CPPAssembly::Tag#Tagged };

                    %% Same as calculating Some<T> typeinfo
                    return (| named_pcinfo, tinfos.insert(cpptkey, named_pcinfo) |);
                }
                else {
                    abort; %% TODO: Support for other primitive concepts! 
                }
            }
            else {
                abort; %% Not a concept
            }

            %% ptrmask == 2 means we store typeinfo, fill rest with zeros so gc ignores
            let ptr_mask = CPPTransformNameManager::repeatCString('0', maxFieldCount, '2');
            matchedType = CPPAssembly::TypeInfo{ next_tid, 8n + (maxFieldCount * 8n), maxFieldCount + 1n, ptr_mask, CPPTransformNameManager::convertTypeKey(typekey), CPPAssembly::Tag#Tagged }; 
        }
        else {
            abort; %% TODO: Type not supported for generating typeinfo!
        }

        return matchedType, tinfos.insert(cpptkey, matchedType);
    }

    method transformSaturatedFieldInfo(sfi: BSQAssembly::SaturatedFieldInfo): CPPAssembly::SaturatedFieldInfo {
        return CPPAssembly::SaturatedFieldInfo { CPPTransformNameManager::convertNominalTypeSignature(sfi.declaredInType), 
            CPPTransformNameManager::convertIdentifier(sfi.fname), CPPTransformNameManager::convertTypeSignature(sfi.ftype), sfi.hasdefault };
    }

    method transformAbstractNominalTypeDeclBase(ant: BSQAssembly::AbstractNominalTypeDecl): (|CPPAssembly::NamespaceKey, List<CString>, CPPAssembly::TypeKey, 
        CString, List<CPPAssembly::InvokeKey>, List<CPPAssembly::InvokeKey>, List<CPPAssembly::InvokeKey>, List<CPPAssembly::InvokeKey>, 
        List<CPPAssembly::NominalTypeSignature>, List<CPPAssembly::SaturatedFieldInfo>|) {

        let staticmethods = ant.staticmethods.map<CPPAssembly::InvokeKey>(fn(m) => CPPTransformNameManager::convertInvokeKey(m));
        let virtmethods = ant.virtmethods.map<CPPAssembly::InvokeKey>(fn(m) => CPPTransformNameManager::convertInvokeKey(m));
        let absmethods = ant.absmethods.map<CPPAssembly::InvokeKey>(fn(m) => CPPTransformNameManager::convertInvokeKey(m));
        let overmethods = ant.overmethods.map<CPPAssembly::InvokeKey>(fn(m) => CPPTransformNameManager::convertInvokeKey(m)); 

        let saturatedProvides = ant.saturatedProvides.map<CPPAssembly::NominalTypeSignature>(
            fn(e) => CPPTransformNameManager::convertNominalTypeSignature(e));
        let saturatedBFieldInfo = ant.saturatedBFieldInfo.map<CPPAssembly::SaturatedFieldInfo>(fn(e) => this.transformSaturatedFieldInfo(e));

        return (|CPPTransformNameManager::convertNamespaceKey(ant.declaredInNS), ant.fullns, CPPTransformNameManager::convertTypeKey(ant.tkey),
            ant.name, staticmethods, virtmethods, absmethods, overmethods, saturatedProvides, saturatedBFieldInfo|);
    }

    method transformAbstractConceptTypeDeclBase(act: BSQAssembly::AbstractConceptTypeDecl): (|CPPAssembly::NamespaceKey, List<CString>, CPPAssembly::TypeKey, 
        CString, List<CPPAssembly::InvokeKey>, List<CPPAssembly::InvokeKey>, List<CPPAssembly::InvokeKey>, List<CPPAssembly::InvokeKey>, 
        List<CPPAssembly::NominalTypeSignature>, List<CPPAssembly::SaturatedFieldInfo>, List<CPPAssembly::TypeKey>|) {
            let base = this.transformAbstractNominalTypeDeclBase(act@<BSQAssembly::AbstractNominalTypeDecl>);
            let subtypes = act.subtypes.map<CPPAssembly::TypeKey>(fn(tk) => CPPTransformNameManager::convertTypeKey(tk));
    
            return (|base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, subtypes|);
    }

    method transformDatatypeMemberToCpp(dm: BSQAssembly::DatatypeMemberEntityTypeDecl): CPPAssembly::DatatypeMemberEntityTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(dm@<BSQAssembly::AbstractNominalTypeDecl>);
        let fields = this.transformMemberFieldDecl(dm.saturatedBFieldInfo, dm, dm.fields);
        let parentTypeDecl = CPPTransformNameManager::convertNominalTypeSignature(dm.parentTypeDecl);

        return CPPAssembly::DatatypeMemberEntityTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, fields, parentTypeDecl }; 
    }

    method transformDatatypeToCpp(dt: BSQAssembly::DatatypeTypeDecl): CPPAssembly::DatatypeTypeDecl {
        let base = this.transformAbstractConceptTypeDeclBase(dt@<BSQAssembly::AbstractConceptTypeDecl>);
        let fields = this.transformMemberFieldDecl(dt.saturatedBFieldInfo, dt, dt.fields);
        let associatedMemberEntityDecls = dt.associatedMemberEntityDecls.map<CPPAssembly::NominalTypeSignature>(
            fn(e) => CPPTransformNameManager::convertNominalTypeSignature(e));

        return CPPAssembly::DatatypeTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, base.10, fields, associatedMemberEntityDecls }; 
    }

    method transformSomeTypeDecl(std: BSQAssembly::SomeTypeDecl): CPPAssembly::SomeTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(std@<BSQAssembly::AbstractNominalTypeDecl>);
        return CPPAssembly::SomeTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, 
            CPPTransformNameManager::convertTypeSignature(std.oftype) }; 
    }

    method transformMapEntryTypeDecl(metd: BSQAssembly::MapEntryTypeDecl): CPPAssembly::MapEntryTypeDecl {
        abort; %% TODO: Not Implemented!
    }

    method transformConstructableTypeDecl(ctd: BSQAssembly::ConstructableTypeDecl): CPPAssembly::ConstructableTypeDecl {
        match(ctd)@ {
            BSQAssembly::SomeTypeDecl => { return this.transformSomeTypeDecl($ctd); }
            | BSQAssembly::MapEntryTypeDecl => { return this.transformMapEntryTypeDecl($ctd); }
            | _ => { abort; }
        }
    }

    method transformEntityDeclToCpp(e: BSQAssembly::EntityTypeDecl): CPPAssembly::EntityTypeDecl {
        let base = this.transformAbstractNominalTypeDeclBase(e@<BSQAssembly::AbstractNominalTypeDecl>);
        let fields = this.transformMemberFieldDecl(e.saturatedBFieldInfo, e, e.fields);

        return CPPAssembly::EntityTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, fields };
    }

    method transformOptionTypeDecl(opt: BSQAssembly::OptionTypeDecl): CPPAssembly::OptionTypeDecl {
        let base = this.transformAbstractConceptTypeDeclBase(opt@<BSQAssembly::AbstractConceptTypeDecl>);
        let ttype = CPPTransformNameManager::convertTypeSignature(opt.oftype);
        let someType = CPPTransformNameManager::convertTypeSignature(opt.someType);

        return CPPAssembly::OptionTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9, base.10, ttype, someType };
    }

    method transformResultTypeDecl(rtd: BSQAssembly::ResultTypeDecl): CPPAssembly::ResultTypeDecl {
        abort; %% TODO: Not Implemented
    }

    method transformAPIResultTypeDecl(apirtd: BSQAssembly::APIResultTypeDecl): CPPAssembly::APIResultTypeDecl {
        abort; %% TODO: Not Implemented
    }

    method transformPrimitiveConceptDeclToCpp(pc: BSQAssembly::PrimitiveConceptTypeDecl): CPPAssembly::PrimitiveConceptTypeDecl {
        match(pc)@ {
            BSQAssembly::OptionTypeDecl => { return this.transformOptionTypeDecl($pc); }
            | BSQAssembly::ResultTypeDecl => { return this.transformResultTypeDecl($pc); }
            | BSQAssembly::APIResultTypeDecl => { return this.transformAPIResultTypeDecl($pc); }
        }
    }

    function convertBsqAsmToCpp(bsqasm: BSQAssembly::Assembly): CPPAssembly::Assembly {
        let transformer = CPPTransformer{ bsqasm };            

        %%
        %% Wouldnt be a bad idea to try and group some of this ns decl insertion logic into a method,
        %% as some of this code is getting a tad too repetitive
        %%

        let transformer_nsfuncs = bsqasm.nsfuncs.reduce<Map<CPPAssembly::InvokeKey, CPPAssembly::NamespaceFunctionDecl>>(
            Map<CPPAssembly::InvokeKey, CPPAssembly::NamespaceFunctionDecl>{}, fn(acc, ikey, func) => {
                let cppdecl = transformer.transformNamespaceFunctionDeclToCpp(func);
                return acc.insert(cppdecl.ikey, cppdecl);
            });

        let transformer_nsdecls_nsfuncs = transformer_nsfuncs.reduce<Map<CString, CPPAssembly::NamespaceDecl>>( 
            Map<CString, CPPAssembly::NamespaceDecl>{}, fn(acc, cppikey, cppfunc) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppfunc.fullns, acc,
                    fn(decl) => { 
                        let new_nsfuncs = decl.nsfuncs.pushBack(cppfunc.ikey);
                        return CPPAssembly::NamespaceDecl{ decl.nsname, decl.subns, new_nsfuncs, decl.typefuncs, decl.constructables, decl.entities, 
                            decl.datamembers, decl.datatypes, decl.pconcepts, decl.staticmethods, decl.virtmethods, decl.absmethods, decl.overmethods,
                            decl.alltypes };
                    });
        });

        let transformer_typefuncs = bsqasm.typefuncs.reduce<Map<CPPAssembly::InvokeKey, CPPAssembly::TypeFunctionDecl>>(
            Map<CPPAssembly::InvokeKey, CPPAssembly::TypeFunctionDecl>{}, fn(acc, ikey, tf) => {
                let cpptypefunc = transformer.transformTypeFunctionDeclToCpp(bsqasm.typefuncs.get(ikey));
                let cppikey = CPPTransformNameManager::convertInvokeKey(ikey);
                return acc.insert(cppikey, cpptypefunc);
            });

        let transformer_nsdecls_typefuncs = transformer_typefuncs.reduce<Map<CString, CPPAssembly::NamespaceDecl>>( 
            transformer_nsdecls_nsfuncs, fn(acc, ikey, cppfunc) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppfunc.completens, acc,
                    fn(decl) => { 
                        let new_typefuncs = decl.typefuncs.pushBack(ikey);
                        return CPPAssembly::NamespaceDecl{ decl.nsname, decl.subns, decl.nsfuncs, new_typefuncs, decl.constructables, decl.entities, 
                            decl.datamembers, decl.datatypes, decl.pconcepts, decl.staticmethods, decl.virtmethods, decl.absmethods, decl.overmethods,
                            decl.alltypes };
                    });
        });

        let transformer_entities = bsqasm.entities.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::EntityTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::EntityTypeDecl>{}, fn(acc, tk, e) => {
                let cpptk = CPPTransformNameManager::convertTypeKey(tk);
                let cppentity = transformer.transformEntityDeclToCpp(e);
                return acc.insert(cpptk, cppentity);
            });

        let transformer_nsdecls_entities = transformer_entities.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_typefuncs, fn(acc, cpptk, cppe) => {
                let cppstaticmethods = cppe.staticmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, cpptk|));
                let cppvirtmethods = cppe.virtmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, cpptk|));
                let cppabsmethods = cppe.absmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, cpptk|));
                let cppovermethods = cppe.overmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, cpptk|));

                return CPPTransformNameManager::getNamespaceDeclMapping(cppe.fullns, acc,
                    fn(decl) => {
                        let new_entities = decl.entities.pushBack(cpptk);
                        let new_alltypes = decl.alltypes.pushBack(cpptk);
                        return CPPAssembly::NamespaceDecl{ decl.nsname, decl.subns, decl.nsfuncs, decl.typefuncs, decl.constructables, new_entities,
                            decl.datamembers, decl.datatypes, decl.pconcepts, cppstaticmethods, cppvirtmethods, cppabsmethods, cppovermethods,
                            new_alltypes };
                    });
        });

        let transformer_datamembers = bsqasm.datamembers.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::DatatypeMemberEntityTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::DatatypeMemberEntityTypeDecl>{}, fn(acc, tk, datamember) => {
                let cppdatamember = transformer.transformDatatypeMemberToCpp(datamember);
                return acc.insert(cppdatamember.tkey, cppdatamember);
            });

        let transformer_nsdecls_datamembers = transformer_datamembers.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_entities, fn(acc, cpptk, cppdatamember) => {
                let cppstaticmethods = cppdatamember.staticmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, cpptk|));
                let cppvirtmethods = cppdatamember.virtmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, cpptk|));
                let cppabsmethods = cppdatamember.absmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, cpptk|));
                let cppovermethods = cppdatamember.overmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, cpptk|));                
                 
                return CPPTransformNameManager::getNamespaceDeclMapping(cppdatamember.fullns, acc,
                    fn(decl) => {
                        let new_datamembers = decl.datamembers.pushBack(cpptk);
                        let new_alltypes = decl.alltypes.pushBack(cpptk);
                        return CPPAssembly::NamespaceDecl{ decl.nsname, decl.subns, decl.nsfuncs, decl.typefuncs, decl.constructables, decl.entities,
                            new_datamembers, decl.datatypes, decl.pconcepts, cppstaticmethods, cppvirtmethods, cppabsmethods, cppovermethods,
                            new_alltypes };
                    });                     
            });

        let transformer_datatypes = bsqasm.datatypes.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::DatatypeTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::DatatypeTypeDecl>{}, fn(acc, tk, dtype) => {
                let cppdatatype = transformer.transformDatatypeToCpp(dtype);
                return acc.insert(cppdatatype.tkey, cppdatatype);
            });

        let transformer_nsdecls_datatypes = transformer_datatypes.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_datamembers, fn(acc, cpptk, cppdatatype) => {
                let cppstaticmethods = cppdatatype.staticmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, cpptk|));
                let cppvirtmethods = cppdatatype.virtmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, cpptk|));
                let cppabsmethods = cppdatatype.absmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, cpptk|));
                let cppovermethods = cppdatatype.overmethods.map<(|CPPAssembly::InvokeKey, CPPAssembly::TypeKey|)>(fn(m) => (|m, cpptk|));

                return CPPTransformNameManager::getNamespaceDeclMapping(cppdatatype.fullns, acc,
                    fn(decl) => {
                        let new_datatypes = decl.datatypes.pushBack(cpptk);
                        let new_alltypes = decl.alltypes.pushBack(cpptk);
                        return CPPAssembly::NamespaceDecl{ decl.nsname, decl.subns, decl.nsfuncs, decl.typefuncs, decl.constructables, decl.entities,
                            decl.datamembers, new_datatypes, decl.pconcepts, cppstaticmethods, cppvirtmethods, cppabsmethods, cppovermethods,
                            new_alltypes };
                    });                     
            });

        let transformer_pconcepts = bsqasm.pconcepts.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::PrimitiveConceptTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::PrimitiveConceptTypeDecl>{}, fn(acc, tk, pc) => {
                let cpppc = transformer.transformPrimitiveConceptDeclToCpp(pc);
                return acc.insert(cpppc.tkey, cpppc);
            });

        %% I could see name conflicts arising with emitting pconcepts at top of file, so we do in ns to be safe
        let transformer_nsdecls_pconcepts = transformer_pconcepts.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_datatypes, fn(acc, cpptk, cpppc) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cpppc.fullns, acc,
                    fn(decl) => {
                        let new_pconcepts = decl.pconcepts.pushBack(cpptk);
                        let new_alltypes = decl.alltypes.pushBack(cpptk);
                        return CPPAssembly::NamespaceDecl{ decl.nsname, decl.subns, decl.nsfuncs, decl.typefuncs, decl.constructables, decl.entities,
                            decl.datamembers, decl.datatypes, new_pconcepts, decl.staticmethods, decl.virtmethods, decl.absmethods, decl.overmethods,
                            new_alltypes };
                    });                     
            }); 

        let transformer_constructables = bsqasm.constructables.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::ConstructableTypeDecl>> (
            Map<CPPAssembly::TypeKey, CPPAssembly::ConstructableTypeDecl>{}, fn(acc, tk, ctd) => {
                let cppctd = transformer.transformConstructableTypeDecl(ctd);
                return acc.insert(cppctd.tkey, cppctd);
            });

        let transformer_nsdecls_constructables = transformer_constructables.reduce<Map<CString, CPPAssembly::NamespaceDecl>>(
            transformer_nsdecls_pconcepts, fn(acc, cpptk, cppctd) => {
                return CPPTransformNameManager::getNamespaceDeclMapping(cppctd.fullns, acc,
                    fn(decl) => {
                        let new_constructables = decl.constructables.pushBack(cpptk);
                        let new_alltypes = decl.alltypes.pushBack(cpptk);
                        return CPPAssembly::NamespaceDecl{ decl.nsname, decl.subns, decl.nsfuncs, decl.typefuncs, new_constructables, decl.entities,
                            decl.datamembers, decl.datatypes, decl.pconcepts, decl.staticmethods, decl.virtmethods, decl.absmethods, decl.overmethods,
                            new_alltypes };
                    });                     
            }); 

        let transformer_allfuncs = bsqasm.allfuncs.map<CPPAssembly::FunctionDecl>(fn(ikey) => {
            let cppikey = CPPTransformNameManager::convertInvokeKey(ikey);
            if(bsqasm.nsfuncs.has(ikey)) {
                let bsqfunc = bsqasm.nsfuncs.get(ikey);
                return CPPAssembly::FunctionDecl{ CPPTransformNameManager::convertNamespaceKey(bsqfunc.declaredInNS), 
                    bsqfunc.fullns, cppikey };
            }
            elif(bsqasm.typefuncs.has(ikey)) {
                let bsqfunc = bsqasm.typefuncs.get(ikey);
                return CPPAssembly::FunctionDecl{ CPPTransformNameManager::convertNamespaceKey(bsqfunc.declaredInNS), 
                    bsqfunc.fullns, cppikey };               
            }
            else {
                abort; 
            }
        });
    
        let transformer_primitives = bsqasm.primtives.reduce<Map<CPPAssembly::TypeKey, CPPAssembly::PrimitiveEntityTypeDecl>>(
            Map<CPPAssembly::TypeKey, CPPAssembly::PrimitiveEntityTypeDecl>{}, fn(acc, tkey, pe) => {
                let base = transformer.transformAbstractNominalTypeDeclBase(bsqasm.primtives.get(tkey)@<BSQAssembly::AbstractNominalTypeDecl>);
                return acc.insert(base.2, CPPAssembly::PrimitiveEntityTypeDecl{ base.0, base.1, base.2, base.3, base.4, base.5, base.6, base.7, base.8, base.9 });
        });

        let transformer_staticmethods = bsqasm.staticmethods.reduce<Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclStatic>>(
            Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclStatic>{}, fn(acc, ikey, decl) => {
                return acc.insert(CPPTransformNameManager::convertInvokeKey(ikey), transformer.transformStaticMethodDecl(decl));
        });

        let transformer_virtmethods = bsqasm.virtmethods.reduce<Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclVirtual>>(
            Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclVirtual>{}, fn(acc, ikey, decl) => {
                return acc.insert(CPPTransformNameManager::convertInvokeKey(ikey), transformer.transformVirtualMethodDecl(decl));
        });

        let transformer_absmethods = bsqasm.absmethods.reduce<Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclAbstract>>(
            Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclAbstract>{}, fn(acc, ikey, decl) => {
                return acc.insert(CPPTransformNameManager::convertInvokeKey(ikey), transformer.transformAbstractMethodDecl(decl));
        });

        let transformer_overmethods = bsqasm.overmethods.reduce<Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclOverride>>(
            Map<CPPAssembly::InvokeKey, CPPAssembly::MethodDeclOverride>{}, fn(acc, ikey, decl) => {
                return acc.insert(CPPTransformNameManager::convertInvokeKey(ikey), transformer.transformOverrideMethodDecl(decl));
        });

        let transformer_allmethods = bsqasm.allmethods.map<CPPAssembly::InvokeKey>(fn(ikey) => {
            return CPPTransformNameManager::convertInvokeKey(ikey);
        });

        let generated_typeinfos_concrete = bsqasm.allconcretetypes.reduce<(| Nat, Map<CPPAssembly::TypeKey, CPPAssembly::TypeInfo> |)>(
            (| 0n, Map<CPPAssembly::TypeKey, CPPAssembly::TypeInfo>{} |), fn(acc, tkey) => {
                let gen_tinfo = transformer.generateTypeInfo(tkey, acc.1, acc.0, bsqasm);
                return (| acc.0 + 1n, gen_tinfo.1 |);
            });
        
        let generated_typeinfos_abstract = bsqasm.allabstracttypes.reduce<(| Nat, Map<CPPAssembly::TypeKey, CPPAssembly::TypeInfo> |)>(
            generated_typeinfos_concrete, fn(acc, tkey) => {
                let gen_tinfo = transformer.generateTypeInfo(tkey, acc.1, acc.0, bsqasm);
                return (| acc.0 + 1n, gen_tinfo.1 |);
            });

        return CPPAssembly::Assembly {
            nsdecls = transformer_nsdecls_constructables,
            allfuncs = transformer_allfuncs,
            nsfuncs = transformer_nsfuncs,
            typefuncs = transformer_typefuncs,
            staticmethods = transformer_staticmethods,
            virtmethods = transformer_virtmethods,
            absmethods = transformer_absmethods, %% Not fully implemented
            overmethods = transformer_overmethods, %% Not fully implemented
            primitives = transformer_primitives,
            constructables = transformer_constructables,
            entities = transformer_entities,
            datamembers = transformer_datamembers,
            datatypes = transformer_datatypes,
            pconcepts = transformer_pconcepts,
            allmethods = transformer_allmethods, %% Might need to do someting like the funcs, being able to get the ns is nice
            typeinfos = generated_typeinfos_abstract.1
        };
    }
}