declare namespace CPPAssembly;

%% Most map well from Bosque/SMT emit

entity SourceInfo {
    field line: Nat;
    field column: Nat;
}

concept AbstractDecl {
    field declaredInNS: NamespaceKey;
    field fullns: List<CString>;
}

const namespaceComponentRE: CRegex = /[A-Z][_a-zA-Z0-9]+/c;
const namespaceKeyRE: CRegex = /(${CPPAssembly::namespaceComponentRE}'::')*${CPPAssembly::namespaceComponentRE}/c;
type NamespaceComponentKey = CString of CPPAssembly::namespaceComponentRE;
type NamespaceKey = CString of CPPAssembly::namespaceKeyRE; %%Core is implicit here

%% NOTE: The RE in basic nominal... allows for '::' to be detected. this is because we overload primitives and need access
%% to matching our __CoreCpp namespace
const basicNominalTypeKeyRE: CRegex = /(${CPPAssembly::namespaceKeyRE}'::')?[_a-zA-Z0-9'::']+('<'.+'>')?/c;
const nominalTypeKeyRE: CRegex = /(${CPPAssembly::basicNominalTypeKeyRE})/c; %% Will need to handle special scoped type key?

const typeKeyRE: CRegex = /${CPPAssembly::nominalTypeKeyRE}/c;
type TypeKey = CString of CPPAssembly::typeKeyRE;

const invokeKeyRE: CRegex = /(${CPPAssembly::namespaceKeyRE}|${CPPAssembly::nominalTypeKeyRE})'::'[_a-z][_a-zA-Z0-9$]+/c;
type InvokeKey = CString of CPPAssembly::invokeKeyRE;

const identifierRE: CRegex = /[_a-z][_a-zA-Z0-9$]*/c; %%we allow & inside these identifiers so we can make special names
const videntifierRE: CRegex = /'$'?[_a-z][_a-zA-Z0-9$]*/c; %%we allow & inside these identifiers so we can make special names
type Identifier = CString of CPPAssembly::identifierRE;
type VarIdentifier = CString of CPPAssembly::videntifierRE;

%* 
entity NamespaceConstDecl provides AbstractCoreDecl {
    field declaredType: TypeSignature;
    field value: Expression;
}
*%

%%
%% Not totaly sure if this is done in the parameter decl or in the args, but we will need to use the shuffle field
%% to correctly determine the position of our arguments (for the sake of named parameters)
%%

entity ParameterDecl {
    field pname: Identifier;
    field ptype: TypeSignature;
    field defaultval: Option<Expression>;

    %% TODO: Support ref/rest param
}

%%
%% Will need to move this fullns to a more general entity (or maybe just concept) because
%% other stuff like types and enums and stuff will also need namespace resolution
%%

%% May want to change this as it doesnt map super well to bsqir (but maps nice to how smtemit)
entity NamespaceFunctionDecl provides AbstractDecl {
    field name: CString;
    field ikey: InvokeKey;
    field params: List<ParameterDecl>;
    field resultType: TypeSignature;
    field body: BodyImplementation;
}

%% Use for function lookups (and maybe other stuff in the future)
entity FunctionDecl provides AbstractDecl {
    field ikey: InvokeKey;
}

entity NamespaceDecl {
    field nsname: CString;

    %% Will need other stuff like nsconsts, enums, typedecls, etc...

    field subns: Map<CString, NamespaceDecl>;
    field nsfuncs: Map<InvokeKey, NamespaceFunctionDecl>;
}

%% Will need expanding
entity Assembly {
    field nsdecls: Map<CString, NamespaceDecl>; %% Toplevel decls, traverse to find lower level decls
    field allfuncs: List<FunctionDecl>;
}