declare namespace CPPAssembly;

%% Most map well from Bosque/SMT emit

entity SourceInfo {
    field line: Nat;
    field column: Nat;
}

const namespaceComponentRE: CRegex = /[A-Z][_a-zA-Z0-9]+/c;
const namespaceKeyRE: CRegex = /(${CPPAssembly::namespaceComponentRE}'::')*${CPPAssembly::namespaceComponentRE}/c;
type NamespaceComponentKey = CString of CPPAssembly::namespaceComponentRE;
type NamespaceKey = CString of CPPAssembly::namespaceKeyRE; %%Core is implicit here

%% NOTE: The RE in basic nominal... allows for '::' to be detected. this is because we overload primitives and need access
%% to matching our __CoreCpp namespace
const basicNominalTypeKeyRE: CRegex = /(${CPPAssembly::namespaceKeyRE}'::')?[_a-zA-Z0-9'::']+('<'.+'>')?/c;
const nominalTypeKeyRE: CRegex = /(${CPPAssembly::basicNominalTypeKeyRE})/c; %% Will need to handle special scoped type key?

const typeKeyRE: CRegex = /${CPPAssembly::nominalTypeKeyRE}/c;
type TypeKey = CString of CPPAssembly::typeKeyRE;

const invokeKeyRE: CRegex = /(${CPPAssembly::namespaceKeyRE}|${CPPAssembly::nominalTypeKeyRE})'::'[_a-z][_a-zA-Z0-9$]+/c;
type InvokeKey = CString of CPPAssembly::invokeKeyRE;

const identifierRE: CRegex = /[_a-z][_a-zA-Z0-9$]*/c; %%we allow & inside these identifiers so we can make special names
const videntifierRE: CRegex = /'$'?[_a-z][_a-zA-Z0-9$]*/c; %%we allow & inside these identifiers so we can make special names
type Identifier = CString of CPPAssembly::identifierRE;
type VarIdentifier = CString of CPPAssembly::videntifierRE;

%* 
entity NamespaceConstDecl provides AbstractCoreDecl {
    field declaredType: TypeSignature;
    field value: Expression;
}
*%

%% May want to change this as it doesnt map super well to bsqir (but maps nice to how smtemit)
entity NamespaceFunctionDecl {
    field ns: NamespaceKey;
    field name: CString;
    field invokeKey: InvokeKey;

    field params: None; %% TODO: Parameters not implemented

    field resultType: TypeSignature;

    field body: BodyImplementation;
}

%%
%% What we can do is take the namespace name (not full key, just its name) and look it up from the assembly
%% entity in order to populate its sub namespaces. This allows us to keep namespaces grouped properly. The
%% main issue I am having is figuring out a way to actually grab the names themselves. From NamespaceFunctionDecl
%% in bsqasm, we are able to grab a string of the format 'Main::Foo::Bar' representing namespace. Problem
%% is there is no way to split lookup in our decks main, then go to its subns and lookup foo, then go to its sub ns
%% and look up bar. I think a possible answer could be to modify the ir emission itself to include this list directly.
%%
entity NamespaceDecl {
    %% field ns: NamespaceKey;
    field nsname: CString;

    %% Will need other stuff like nsconsts, enums, typedecls, etc...

    field subns: Map<NamespaceKey, NamespaceDecl>;
    field nsfuncs: Map<InvokeKey, NamespaceFunctionDecl>;
}

%% Will need expanding
entity Assembly {
    %% field nsdecls: Map<CString, NamespaceDecl>; %% Toplevel decls, traverse to find lower level decls
    field nsfuncs: Map<NamespaceKey, Map<InvokeKey, NamespaceFunctionDecl>>;
    field allfuncs: List<InvokeKey>;
}