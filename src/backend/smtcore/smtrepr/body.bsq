namespace BBody;

const c_varnameRE: CRegex = /'$'?[_a-z][a-zA-Z0-9_]*/;
type VarName = CString of c_varnameRE;

entity BinderInfo {
    field vname: VarName;
    field refineonfollow: Bool;
}

datatype ITest using {
    field isnot: Bool;
}
of
ITestType { field ttype: TypeSignature; }
| ITestNone { }
| ITestSome { }
| ITestOk { }
| ITestFail { }
;

concept Expression {
    field sinfo: IR::SourceInfo;
    field etype: TypeSignature;
}

concept Value provides Expression {
}

datatype ConstantValue provides Value
of
LiteralNoneExpression { }
| LiteralSimpleExpression {
    field value: CString;
}
| LiteralCStringExpression {
    field value: CString;
}
| LiteralStringExpression {
    field value: String;
}
| LiteralCRegexExpression {
    field value: CString;
}
| LiteralRegexExpression {
    field value: String;
}
;

entity VariableValue provides Value {
    field vname: CString;
    field layouttype: TypeSignature;
}

entity AccessNamespaceConstantExpression provides Value {
    field ns: FullyQualifiedNamespace;
    field name: CString;
}

entity AccessStaticFieldExpression provides Value {
    field stype: NominalTypeSignature;
    field name: CString;

    field resolvedDeclType: TypeSignature;
}

entity AccessEnumExpression provides Value {
    field stype: NominalTypeSignature;
    field name: CString;
}

entity AccessVariableExpression provides Value {
    field vname: CString;
}

entity AccessRetypeStep {
    field ttype: TypeSignature;
    field specialfname: CString
}

entity AccessVariableExpressionRetypeStep provides Value {
    field vname: CString;
    field steps: List<AccessRetypeStep>;
}

entity TermifyExpression provides Value {
    field value: Value;
    field fromtype: NominalTypeSignature;
}

entity UntermifyExpression provides Value {
    field value: Value;
    field fromtype: NominalTypeSignature;
}

entity LiteralTypeDeclSimpleExpression provides Value {
    field value: ConstantValue;
    field constype: NominalTypeSignature;
}

concept ConstructorExpression provides Value {
    field args: List<Value>;
}

%% Assume that checks are always inlined explicitly so that these are simple values
datatype ConstructorPrimaryExpression provides ConstructorExpression using {
    field ctype: NominalTypeSignature;
}
of 
ConstructorPrimaryCollectionSingletonsExpression { }
| ConstructorPrimarySpecialConstructableExpression { }
| ConstructorTypeDeclExpression { }
| ConstructorStdExpression { }
;

entity ConstructorEListExpression provides ConstructorExpression {
}

entity ConstructorLambdaExpression provides Expression {
    field invoke: LambdaDecl;
}

entity LetExpression provides Expression {
    field decls: List<(|CString, TypeSignature, Expression|)>;
    field body: Expression;
}

entity LambdaInvokeExpression provides Expression {
    field name: CString;

    field args: List<Value>;
    field lambda: LambdaTypeSignature;
}

entity CallNamespaceFunctionExpression provides Expression {
    field ns: FullyQualifiedNamespace;
    field name: CString;

    field args: List<Value>;
}

entity CallTypeFunctionExpression provides Expression {
    field resolvedType: NominalTypeSignature;
    field name: CString;
    
    field args: List<Value>;
}

entity CallRefThisExpression provides Expression {
    field name: CString;
    
    field args: List<Value>;
}

entity CallRefSelfExpression provides Expression {
    field name: CString;

    field args: List<Value>;
}

entity LogicActionAndExpression provides Value {
    field args: List<Value>;
}

entity LogicActionOrExpression provides Value {
    field args: List<Value>;
}

entity SafeConvertExpression provides Value {
    field exp: Value;
    field srctype: NominalTypeSignature;
    field trgttype: NominalTypeSignature;
}

entity CreateDirectExpression provides Value {
    field exp: Value;
    field srctype: NominalTypeSignature;
    field trgttype: NominalTypeSignature;
}

datatype SimplePostfixOperation using {
    field sinfo: IR::SourceInfo;
    field baseType: NominalTypeSignature;
}
of 
PostfixAccessFromName {
    field declaredInType: NominalTypeSignature;
    field name: CString;
}
| PostfixProjectFromNames {
    field declOnType: NominalTypeSignature;
    field names: List<(|CString, NominalTypeSignature|)>;
}
| PostfixAccessFromIndex {
    field idx: Nat;
}
| PostfixIsTest {
    field ttest: ITest;
}
;

entity SimplePostfixOp provides Value {
    field rootExp: Value;
    field ops: List<SimplePostfixOperation>;
}

datatype ErrorablePostfixOperation using {
    field sinfo: IR::SourceInfo;
}
of 
PostfixAsConvert {
    field ttest: ITest;
}
| PostfixAssignFields {
    field declOnType: NominalTypeSignature;
    field updates: List<(|CString, NominalTypeSignature, Value|)>;
}
| PostfixInvokeStatic extends PostfixOperation {
    field resolvedTrgt: NominalTypeSignature;
    field name: CString;
    field args: List<Value>;
}
| PostfixInvokeVirtual extends PostfixOperation {
    field resolvedBase: NominalTypeSignature;
    field name: CString;
    field args: List<Value>;
}
| PostfixLiteralKeyAccess {
    field kexp: Value;
}
;

entity ErrorablePostfixOp provides Expression {
    field rootExp: Value;
    field op: ErrorablePostfixOperation;
}
