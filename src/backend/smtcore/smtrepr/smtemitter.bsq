declare namespace SMTEmitter;

function cleanOptionalLeadingPlus(vstr: CString): CString {
    return if(vstr.startsWithString('+')) then vstr.removePrefixString('+') else vstr;
}

function emitTaggedNumericType(nstr: CString, tag: CString): CString {
    return cleanOptionalLeadingPlus(nstr.removeSuffixString(tag));
}

function emitLiteralNoneValue(): CString {
    return 'none';
}

function emitLiteralSimpleValue(v: LiteralSimpleValue): CString {
    switch(v.vtype) {
        'Bool'<TypeKey>     => { return v.value; }
        | 'Nat'<TypeKey>    => { return emitTaggedNumericType(v.value, 'n'); }
        | 'Int'<TypeKey>    => { return emitTaggedNumericType(v.value, 'i'); }
        | 'BigNat'<TypeKey> => { return emitTaggedNumericType(v.value, 'N'); }
        | 'BigInt'<TypeKey> => { return emitTaggedNumericType(v.value, 'I'); }
        | 'Float'<TypeKey>  => { return emitTaggedNumericType(v.value, 'f'); }
    }
}

function emitLiteralCStringValue(v: LiteralCStringValue): CString {
    return CString::concat('"', v.value, '"');
}

function emitLiteralStringValue(v: LiteralStringValue): CString {
    return CString::concat('"', v.value, '"');
}

function emitLiteralCRegexValue(v: LiteralCRegexValue): CString {
    %%TODO
    abort;
}

function emitLiteralRegexValue(v: LiteralRegexValue): CString {
    %%TODO
    abort;
}

function emitConstantValue(v: ConstantValue): CString {
    match(v)@ {
        LiteralNoneValue => { return emitLiteralNoneValue(); }
        | LiteralSimpleValue => { return emitLiteralSimpleValue($v); }
        | LiteralCStringValue => { return emitLiteralCStringValue($v); }
        | LiteralStringValue => { return emitLiteralStringValue($v); }
        | LiteralCRegexValue => { return emitLiteralCRegexValue($v); }
        | LiteralRegexValue => { return emitLiteralRegexValue($v); }
    }
}

function emitAccessNamespaceConstantValue(v: AccessNamespaceConstantValue): CString {
    return CString::concat(v.ns.value, '@', v.name);
}

function emitAccessStaticFieldValue(v: AccessStaticFieldValue): CString {
    return CString::concat(v.tresolved.value, '@', v.name);
}

function emitAccessEnumValue(v: AccessEnumValue): CString {
    return CString::concat(v.enumtype.value, '@', v.name);
}

function emitAccessVariableValue(v: AccessVariableValue): CString {
    return v.vname;
}

function emitAccessVariableRetypeStepValue(v: AccessVariableRetypeStepValue): CString {
    let access = SMTNameManager::generateStructFieldName(v.step.ttype,  v.step.specialfname);
    return CString::concat('(', access, ' ',  v.vname, ')');
}

function emitAccessVariableRetypeMultiStepValue(v: AccessVariableRetypeMultiStepValue): CString {
    %%TODO
    abort;
}

recursive function emitTermifyValue(v: TermifyValue): CString {
    let consname = SMTNameManager::generateStructTermConstructorName(v.fromtype);
    return CString::concat('(', consname, ' ', emitValue[recursive](v.value), ')');
}

function emitUntermifyValue(v: UntermifyValue): CString {
    let access = SMTNameManager::generateStructTermFieldName(v.fromtype, 'value');
    return CString::concat('(', access, ' ', emitValue[recursive](v.value), ')');
}

function emitLiteralTypeDeclValue(v: LiteralTypeDeclValue): CString {
    %%TODO
    abort;
}

recursive function emitValue(v: Value): CString {
    match(v)@ {
        ConstantValue => { return emitConstantValue($v); }
        | AccessNamespaceConstantValue => { return emitAccessNamespaceConstantValue($v); }
        | AccessStaticFieldValue => { return emitAccessStaticFieldValue($v); }
        | AccessEnumValue => { return emitAccessEnumValue($v); }
        | AccessVariableValue => { return emitAccessVariableValue($v); }
        | AccessVariableRetypeStepValue => { return emitAccessVariableRetypeStepValue($v); }
        | AccessVariableRetypeMultiStepValue => { return emitAccessVariableRetypeMultiStepValue($v); }
        | TermifyValue => { return emitTermifyValue[recursive]($v); }
        | UntermifyValue => { return emitUntermifyValue[recursive]($v); }
        | LiteralTypeDeclValue => { return emitLiteralTypeDeclValue($v); }
    }
}

function cleanOptionalLeadingPlus(vstr: CString): CString {
    return if(vstr.startsWithString('+')) then vstr.removePrefixString('+') else vstr;
}

function emitTaggedNumericType(nstr: CString, tag: CString): CString {
    return cleanOptionalLeadingPlus(nstr.removeSuffixString(tag));
}

function emitLiteralNoneValue(): CString {
    return 'none';
}

function emitLiteralSimpleValue(v: LiteralSimpleValue): CString {
    let tkey = v.vtype.tkeystr;

    switch(tkey) {
        'Bool'<IR::TypeKey>     => { return v.value; }
        | 'Nat'<IR::TypeKey>    => { return emitTaggedNumericType(v.value, 'n'); }
        | 'Int'<IR::TypeKey>    => { return emitTaggedNumericType(v.value, 'i'); }
        | 'BigNat'<IR::TypeKey> => { return emitTaggedNumericType(v.value, 'N'); }
        | 'BigInt'<IR::TypeKey> => { return emitTaggedNumericType(v.value, 'I'); }
        | 'Float'<IR::TypeKey>  => { return emitTaggedNumericType(v.value, 'f'); }
    }
}

function emitLiteralCStringValue(v: LiteralCStringValue): CString {
    return CString::concat('"', v.value, '"');
}

function emitLiteralStringValue(v: LiteralStringValue): CString {
    return CString::concat('"', v.value, '"');
}

function emitLiteralCRegexValue(v: LiteralCRegexValue): CString {
    %%TODO
    abort;
}

function emitLiteralRegexValue(v: LiteralRegexValue): CString {
    %%TODO
    abort;
}

function emitConstantValue(v: ConstantValue): CString {
    match(v)@ {
        LiteralNoneValue => { return emitLiteralNoneValue(); }
        | LiteralSimpleValue => { return emitLiteralSimpleValue($v); }
        | LiteralCStringValue => { return emitLiteralCStringValue($v); }
        | LiteralStringValue => { return emitLiteralStringValue($v); }
        | LiteralCRegexValue => { return emitLiteralCRegexValue($v); }
        | LiteralRegexValue => { return emitLiteralRegexValue($v); }
    }
}

public function main(): Int {
    var asm: Assembly;

    return 0i;
}
