namespace SMTEmitter;

namespace SMTNameManager {
    function generateStructConstructorName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat(tkey.value, '-mk');
    }

    function generateStructFieldName(tkey: SMTAssembly::TypeKey, vname: CString): CString {
        return CString::concat(tkey.value, '-', vname);
    }

    function generateStructTermConstructorName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat('@Term-', tkey.value, '-mk');
    }

    function generateStructTermFieldName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat('@Term-', tkey.value, '-value');
    }

    function generateNamespaceConstName(ns: SMTAssembly::NamespaceKey, cname: CString): CString {
        return CString::concat(ns.value, '@', cname);
    }

    function generateTypeConstName(tkey: SMTAssembly::TypeKey, cname: CString): CString {
        return CString::concat(tkey.value, '@', cname);
    }

    function generateTermSubtypeFunctionName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat('@SubtypeOf-', tkey.value);
    }

    function generateResultName(rtype: SMTAssembly::ResultType): CString {
        if(rtype)@<SMTAssembly::SafeResult> {
            return rtype.rtype.value;
        } else {
            return CString::concat('(@Result ', rtype.rtype.value, ')');
        }
    }
}

entity SMTEmitterEnv {
    field errtrgt: Nat;
    field restype: SMTAssembly::TypeKey;
}

function cleanOptionalLeadingPlus(vstr: CString): CString {
    return if(vstr.startsWithString('+')) then vstr.removePrefixString('+') else vstr;
}

function tidyNewlineJoin(s1: CString, s2: CString): CString {
    if(s1.empty() && s2.empty()) {
        return '';
    }
    elif(s1.empty()) {
        return s2;
    }
    elif(s2.empty()) {
        return s1;
    }
    else {
        return CString::join('%n;', s1, s2);
    }
}

function tryGetConstOperation(op: SMTAssembly::Operation): Option<SMTAssembly::ConstantExpression> {
    if(op)@<SMTAssembly::ReturnOperation> {
        if($vv = $op.exp)@<SMTAssembly::ConstantExpression> {
            return some($vv);
        }
    }

    return none;
}

function emitResultErrTrgtTest(testval: CString, tkey: SMTAssembly::TypeKey): CString {
    return CString::concat('(= ', testval, ' (as @Result-err-trgt (@Result ', tkey.value, ')))');
}

function emitResultErrOtherTest(testval: CString, tkey: SMTAssembly::TypeKey): CString {
    return CString::concat('(', testval, ' (as @Result-err-other (@Result ', tkey.value, ')))');
}

function emitResultErrTrgtAs(astype: SMTAssembly::TypeKey): CString {
    return CString::concat('(as @Result-err-trgt (@Result ', astype.value, '))');
}

function emitResultErrOtherAs(astype: SMTAssembly::TypeKey): CString {
    return CString::concat('(as @Result-err-other (@Result ', astype.value, '))');
}

function emitTaggedNumericType(nstr: CString, tag: CString): CString {
    return cleanOptionalLeadingPlus(nstr.removeSuffixString(tag));
}

const resultTrueValue: CString = '(@Result-ok true)';

function emitLiteralNoneExpression(): CString {
    return 'none';
}

function emitLiteralSimpleExpression(e: SMTAssembly::LiteralSimpleExpression): CString {
    switch(e.vtype) {
        'Bool'<SMTAssembly::TypeKey>     => { return e.value; }
        | 'Nat'<SMTAssembly::TypeKey>    => { return emitTaggedNumericType(e.value, 'n'); }
        | 'Int'<SMTAssembly::TypeKey>    => { return emitTaggedNumericType(e.value, 'i'); }
        | 'BigNat'<SMTAssembly::TypeKey> => { return emitTaggedNumericType(e.value, 'N'); }
        | 'BigInt'<SMTAssembly::TypeKey> => { return emitTaggedNumericType(e.value, 'I'); }
        | 'Float'<SMTAssembly::TypeKey>  => { return emitTaggedNumericType(e.value, 'f'); }
    }
}

function emitLiteralCCharExpression(e: SMTAssembly::LiteralCCharExpression): CString {
    return CString::concat('"', e.value, '"');
}

function emitLiteralUnicodeCharExpression(e: SMTAssembly::LiteralUnicodeCharExpression): CString {
    return CString::concat('"', e.value, '"');
}

function emitLiteralCStringExpression(e: SMTAssembly::LiteralCStringExpression): CString {
    return CString::concat('"', e.value, '"');
}

function emitLiteralStringExpression(e: SMTAssembly::LiteralStringExpression): CString {
    return CString::concat('"', e.value, '"');
}

function emitLiteralCRegexExpression(e: SMTAssembly::LiteralCRegexExpression): CString {
    %%TODO
    abort;
}

function emitLiteralRegexExpression(e: SMTAssembly::LiteralRegexExpression): CString {
    %%TODO
    abort;
}

function emitConstantExpression(e: SMTAssembly::ConstantExpression): CString {
    match(e)@ {
        SMTAssembly::LiteralNoneExpression => { return emitLiteralNoneExpression(); }
        | SMTAssembly::LiteralSimpleExpression => { return emitLiteralSimpleExpression($e); }
        | SMTAssembly::LiteralCCharExpression => { return emitLiteralCCharExpression($e); }
        | SMTAssembly::LiteralUnicodeCharExpression => { return emitLiteralUnicodeCharExpression($e); }
        | SMTAssembly::LiteralCStringExpression => { return emitLiteralCStringExpression($e); }
        | SMTAssembly::LiteralStringExpression => { return emitLiteralStringExpression($e); }
        | SMTAssembly::LiteralCRegexExpression => { return emitLiteralCRegexExpression($e); }
        | SMTAssembly::LiteralRegexExpression => { return emitLiteralRegexExpression($e); }
    }
}

function emitAccessNamespaceConstantExpression(e: SMTAssembly::AccessNamespaceConstantExpression): CString {
    return CString::concat(e.ns.value, '@', e.name);
}

function emitAccessStaticFieldExpression(e: SMTAssembly::AccessStaticFieldExpression): CString {
    return CString::concat(e.tresolved.value, '@', e.name);
}

function emitAccessEnumExpression(e: SMTAssembly::AccessEnumExpression): CString {
    return CString::concat(e.enumtype.value, '$$', e.name);
}

function emitAccessVariableExpression(e: SMTAssembly::AccessVariableExpression): CString {
    return e.vname.value;
}

recursive function emitTermifyExpression(e: SMTAssembly::TermifyExpression): CString {
    if(e.fromtype === 'None'<SMTAssembly::TypeKey>) {
        return '@Term-mk-None';
    }
    else {
        let consname = SMTNameManager::generateStructTermConstructorName(e.fromtype);
        let vv = emitSafeExpression[recursive](e.value);
    
        return CString::concat('(', consname, ' ', vv, ')');
    }
}

recursive function emitUntermifyExpression(e: SMTAssembly::UntermifyExpression): CString {
    let access = SMTNameManager::generateStructTermFieldName(e.intotype);
    let vv = emitSafeExpression[recursive](e.value);
    
    return CString::concat('(', access, ' ', vv, ')');
}
%*
function emitLiteralTypeDeclExpression(v: SMTAssembly::LiteralTypeDeclExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let vv = emitConstantExpression(v.value);

    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitConstructorListSingletonsExpression(v: SMTAssembly::ConstructorListSingletonsExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);

    if(v.args.empty()) {
        let scons = CString::concat('(as seq.empty (Seq ', v.oftype.value, '))');
        return CString::concat('(', consname, ' ', scons, ')');
    }
    else {
        if(v.args.isSingleElement()) {
            let scons = CString::concat('(seq.unit ', emitExpression[recursive](v.args.single()), ')');
            return CString::concat('(', consname, ' ', scons, ')');
        }
        else {
            let cvals = v.args.map[recursive]<CString>(fn(x) => CString::concat('(seq.unit ', emitExpression[recursive](x), ')'));
            let argsl = CString::joinAll(' ', cvals);

            let scons = CString::concat('(seq.++ ', argsl, ')');
            return CString::concat('(', consname, ' ', scons, ')');
        }
    }
}

recursive function emitConstructorMapSingletonsExpression(v: SMTAssembly::ConstructorMapSingletonsExpression): CString {
    %%TODO
    abort;
}
*%

recursive function emitConstructorPrimarySpecialConstructableExpression(v: SMTAssembly::ConstructorPrimarySpecialConstructableExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let vv = emitSafeExpression[recursive](v.arg);

    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitConstructorTypeDeclExpression(v: SMTAssembly::ConstructorTypeDeclExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let vv = emitSafeExpression[recursive](v.arg);

    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitConstructorStdExpression(v: SMTAssembly::ConstructorStdExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    if(v.args.empty()) {
        return consname;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitSafeExpression[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', consname, ' ', argsl, ')');
    }
}

recursive function emitConstructorPrimaryExpression(v: SMTAssembly::ConstructorPrimaryExpression): CString {
    match(v)@ {
        SMTAssembly::ConstructorListSingletonsExpression => {abort; }
        | SMTAssembly::ConstructorMapSingletonsExpression => { abort; }
        | SMTAssembly::ConstructorPrimarySpecialConstructableExpression => { return emitConstructorPrimarySpecialConstructableExpression($v); }
        | SMTAssembly::ConstructorTypeDeclExpression => { return emitConstructorTypeDeclExpression[recursive]($v); }
        | SMTAssembly::ConstructorStdExpression => { return emitConstructorStdExpression[recursive]($v); }
    }
}

recursive function emitConstructorEListExpression(v: SMTAssembly::ConstructorEListExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    if(v.args.empty()) {
        return consname;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitSafeExpression[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', consname, ' ', argsl, ')');
    }
}

recursive function emitCallFunctionExpression(v: SMTAssembly::CallFunctionExpression, eev: SMTEmitterEnv): CString {
    if(v.args.empty()) {
        return v.invokeKey.value;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(arg) => emitCallArgSafeExpression[recursive](arg, eev.errtrgt));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', v.invokeKey.value, ' ', argsl, ')');
    }
}

recursive function emitCallFunctionSafeExpression(v: SMTAssembly::CallFunctionSafeExpression): CString {
    if(v.args.empty()) {
        return v.invokeKey.value;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(arg) => emitCallArgSafeExpression[recursive](arg, SMTEmitter::s_ignoreErrTrgt));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', v.invokeKey.value, ' ', argsl, ')');
    }
}

recursive function emitLambdaConstructor(v: SMTAssembly::LambdaConstructor, errtrgt: Nat): CString {
    let plist = v.params.map<CString>(fn(p) => CString::concat('(', p.0.value, ' ', p.1.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let elambda = SMTEmitterEnv{errtrgt, v.resultType.rtype};
    let body = emitOperation[recursive](v.body, elambda, none);

    return CString::concat('(lambda ', pll, ' ', body, ')');
}

recursive function emitCallLambdaFunctionExpression(e: SMTAssembly::CallLambdaFunctionExpression, evv: SMTEmitterEnv): CString {
    if(e.args.isSingleElement()) {
        return CString::concat('(', e.lambda.value, ' ', emitCallArgSafeExpression[recursive](e.args.single(), evv.errtrgt), ')');
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitCallArgSafeExpression[recursive](x, evv.errtrgt));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(select ', e.lambda.value, ' ', argsl, ')');
    }
}

recursive function emitCallLambdaFunctionSafeExpression(e: SMTAssembly::CallLambdaFunctionSafeExpression): CString {
    if(e.args.isSingleElement()) {
        return CString::concat('(', e.lambda.value, ' ', emitCallArgSafeExpression[recursive](e.args.single(), SMTEmitter::s_ignoreErrTrgt), ')');
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitCallArgSafeExpression[recursive](x, SMTEmitter::s_ignoreErrTrgt));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(select ', e.lambda.value, ' ', argsl, ')');
    }
}


%*
recursive function emitLogicActionAndExpression(v: SMTAssembly::LogicActionAndExpression): CString {
    let cvals = v.args.map[recursive]<CString>(fn(x) => emitExpression[recursive](x));
    let argsl = CString::joinAll(' ', cvals);

    return CString::concat('(and ', argsl, ')');
}

recursive function emitLogicActionOrExpression(v: SMTAssembly::LogicActionOrExpression): CString {
    let cvals = v.args.map[recursive]<CString>(fn(x) => emitExpression[recursive](x));
    let argsl = CString::joinAll(' ', cvals);

    return CString::concat('(or ', argsl, ')');
}

recursive function emitUnwrapTypeDeclToPrimitiveExpression(v: SMTAssembly::UnwrapTypeDeclToPrimitiveExpression): CString {
    let access = SMTNameManager::generateStructFieldName(v.decltype, 'value');
    return CString::concat('(', access, ' ', emitExpression(v.arg), ')');
}
*%

recursive function emitAccessFromNameResolvedExpression(v: SMTAssembly::AccessFromNameResolvedExpression): CString {
    let access = SMTNameManager::generateStructFieldName(v.ontype, v.name);
    return CString::concat('(', access, ' ', emitSafeExpression(v.arg), ')');
}

%*
recursive function emitAccessFromIndexExpression(v: SMTAssembly::AccessFromIndexExpression): CString {
    let access = SMTNameManager::generateStructFieldName(v.elisttype, v.idx);
    return CString::concat('(', access, ' ', emitExpression(v.arg), ')');
}

recursive function emitIsTypeTestExpression(v: SMTAssembly::IsTypeTestExpression): CString {
    let ccons = SMTNameManager::generateStructTermConstructorName(v.istype);
    let ttchk = CString::concat('(_ is ', ccons, ')');
    let vv = emitExpression[recursive](v.arg);

    %%v is always in term repr to test against term constructor
    return CString::concat('(', ttchk, ' ', vv, ')');
}

recursive function emitIsSubtypeTestExpression(v: SMTAssembly::IsSubtypeTestExpression): CString {
    let subchk = SMTNameManager::generateTermSubtypeFunctionName(v.oftype);
    let vv = emitExpression[recursive](v.arg);

    %%v is always in term repr to test against term constructor
    return CString::concat('(', subchk, ' ', vv, ')');
}
*%

recursive function emitConvertOptionToSomeTExpression(v: SMTAssembly::ConvertOptionToSomeTExpression): CString {
    let ubx = SMTNameManager::generateStructTermFieldName(v.sometype);
    let extract = SMTNameManager::generateStructFieldName(v.sometype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', emitSafeExpression[recursive](v.arg), ')');
    return CString::concat('(', extract, ' ', ubxop, ')');
}

%*
recursive function emitConvertResultToOkTExpression(v: SMTAssembly::ConvertResultToOkTExpression): CString {
    let ubx = SMTNameManager::generateStructTermFieldName(v.resulttype);
    let extract = SMTNameManager::generateStructFieldName(v.oktype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', emitExpression[recursive](v.arg), ')');
    return CString::concat('(', extract, ' ', ubxop, ')');
}

recursive function emitConvertResultToFailEExpression(v: SMTAssembly::ConvertResultToFailEExpression): CString {
    let ubx = SMTNameManager::generateStructTermFieldName(v.resulttype);
    let extract = SMTNameManager::generateStructFieldName(v.failtype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', emitExpression[recursive](v.arg), ')');
    return CString::concat('(', extract, ' ', ubxop, ')');
}

recursive function emitMethodInvokeStaticExpression(v: SMTAssembly::MethodInvokeStaticExpression): CString {
    let fname = SMTNameManager::generateTypeFunctionName(v.resolvedTrgt, v.name);
    let rootv = emitExpression[recursive](v.rootExp);

    let rpfx = CString::concat(fname, ' ', rootv);
    if(v.args.empty()) {
        return CString::concat('(', rpfx, ')');
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitExpression[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', rpfx, ' ', argsl, ')');
    }
}
*%

recursive function emitPrefixNotOpExpression(v: SMTAssembly::PrefixNotOpExpression): CString {
    let vv = emitSafeExpression[recursive](v.exp);
    return CString::concat('(not ', vv, ')');
}

recursive function emitPrefixNegateOpExpression(v: SMTAssembly::PrefixNegateOpExpression): CString {
    let vv = emitSafeExpression[recursive](v.exp);
    return CString::concat('(- ', vv, ')');
}

recursive function emitPrefixPlusOpExpression(v: SMTAssembly::PrefixPlusOpExpression): CString {
    return emitSafeExpression[recursive](v.exp);
}

recursive function emitUnaryExpression(v: SMTAssembly::UnaryExpression): CString {
    match(v)@ {
        SMTAssembly::PrefixNotOpExpression => { return emitPrefixNotOpExpression[recursive]($v); }
        | SMTAssembly::PrefixNegateOpExpression => { return emitPrefixNegateOpExpression[recursive]($v); }
        | SMTAssembly::PrefixPlusOpExpression => { return emitPrefixPlusOpExpression[recursive]($v); }
    }
}

recursive function emitBinAddExpression(e: SMTAssembly::BinAddExpression): CString {
    let lhs = emitSafeExpression[recursive](e.lhs);
    let rhs = emitSafeExpression[recursive](e.rhs);
    return CString::concat('(+ ', lhs, ' ', rhs, ')');
}

recursive function emitBinSubExpression(e: SMTAssembly::BinSubExpression): CString {
    let lhs = emitSafeExpression[recursive](e.lhs);
    let rhs = emitSafeExpression[recursive](e.rhs);
    return CString::concat('(- ', lhs, ' ', rhs, ')');
}

recursive function emitBinMultExpression(e: SMTAssembly::BinMultExpression): CString {
    let lhs = emitSafeExpression[recursive](e.lhs);
    let rhs = emitSafeExpression[recursive](e.rhs);

    return CString::concat('(* ', lhs, ' ', rhs, ')');
}

recursive function emitBinDivExpression(e: SMTAssembly::BinDivExpression): CString {
    let lhs = emitSafeExpression[recursive](e.lhs);
    let rhs = emitSafeExpression[recursive](e.rhs);
    
    return CString::concat('(/ ', lhs, ' ', rhs, ')');
}

recursive function emitBinaryArithExpression(e: SMTAssembly::BinaryArithExpression): CString {
    match(e)@ {
        SMTAssembly::BinAddExpression => { return emitBinAddExpression[recursive]($e); }
        | SMTAssembly::BinSubExpression => { return emitBinSubExpression[recursive]($e); }
        | SMTAssembly::BinMultExpression => { return emitBinMultExpression[recursive]($e); }
        | SMTAssembly::BinDivExpression => { return emitBinDivExpression[recursive]($e); }
    }
}

recursive function emitBinKeyEqNoneExpression(e: SMTAssembly::BinKeyEqNoneExpression): CString {
    let vv = emitSafeExpression[recursive](e.exp);
    return CString::concat('(= ', vv, ' @Term-mk-None)');
}

recursive function emitBinKeyNotEqNoneExpression(e: SMTAssembly::BinKeyNotEqNoneExpression): CString {
    let vv = emitSafeExpression[recursive](e.exp);
    return CString::concat('(not (= ', vv, ' @Term-mk-None))');
}

recursive function emitBinKeySomeEqExpression(e: SMTAssembly::BinKeySomeEqExpression): CString {
    let eopt = emitSafeExpression[recursive](e.eoption);
    let val = emitSafeExpression[recursive](e.val);
    
    let ubx = SMTNameManager::generateStructTermFieldName(e.optiontype);
    let extract = SMTNameManager::generateStructFieldName(e.sometype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', eopt, ')');
    let extractop = CString::concat('(', extract, ' ', ubxop, ')');
    let eqop = CString::concat('(= ', extractop, ' ', val, ')');

    let notnoneop = CString::concat('(not (= ', eopt, ' @Term-mk-None))');

    return CString::concat('(and ', notnoneop, ' ', eqop, ')');
}

recursive function emitBinKeyNotSomeEqExpression(e: SMTAssembly::BinKeyNotSomeEqExpression): CString {
    let eopt = emitSafeExpression[recursive](e.eoption);
    let val = emitSafeExpression[recursive](e.val);
    
    let ubx = SMTNameManager::generateStructTermFieldName(e.optiontype);
    let extract = SMTNameManager::generateStructFieldName(e.sometype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', eopt, ')');
    let extractop = CString::concat('(', extract, ' ', ubxop, ')');
    let neqop = CString::concat('(not (= ', extractop, ' ', val, '))');

    let noneop = CString::concat('(= ', eopt, ' @Term-mk-None)');

    return CString::concat('(or ', noneop, ' ', neqop, ')');
}

recursive function emitBinKeyEqExpression(e: SMTAssembly::BinKeyEqExpression): CString {
    let lhs = emitSafeExpression[recursive](e.lhs);
    let rhs = emitSafeExpression[recursive](e.rhs);
    return CString::concat('(= ', lhs, ' ', rhs, ')');
}

recursive function emitBinKeyNotEqExpression(e: SMTAssembly::BinKeyNotEqExpression): CString {
    let lhs = emitSafeExpression[recursive](e.lhs);
    let rhs = emitSafeExpression[recursive](e.rhs);
    return CString::concat('(not (= ', lhs, ' ', rhs, '))');
}

recursive function emitBinaryKeyEqExpression(e: SMTAssembly::BinaryKeyEqExpression): CString {
    match(e)@ {
        SMTAssembly::BinKeyEqNoneExpression => { return emitBinKeyEqNoneExpression[recursive]($e); }
        | SMTAssembly::BinKeyNotEqNoneExpression => { return emitBinKeyNotEqNoneExpression[recursive]($e); }
        | SMTAssembly::BinKeySomeEqExpression => { return emitBinKeySomeEqExpression[recursive]($e); }
        | SMTAssembly::BinKeyNotSomeEqExpression => { return emitBinKeyNotSomeEqExpression[recursive]($e); }
        | SMTAssembly::BinKeyEqExpression => { return emitBinKeyEqExpression[recursive]($e); }
        | SMTAssembly::BinKeyNotEqExpression => { return emitBinKeyNotEqExpression[recursive]($e); }
    }
}

recursive function emitKeyLessExpression(e: SMTAssembly::KeyLessExpression): CString {
    let lhs = emitSafeExpression[recursive](e.lhs);
    let rhs = emitSafeExpression[recursive](e.rhs);

    switch(e.kind) {
        SMTAssembly::KeyLessKind#KeyBool => {return CString::concat('(and (not ', lhs, ') ', rhs, ')'); }
        | SMTAssembly::KeyLessKind#KeyNumber => { return CString::concat('(< ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::KeyLessKind#KeyString => { return CString::concat('(str.< ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::KeyLessKind#KeyUUID => { abort; }
        | SMTAssembly::KeyLessKind#KeyHash => { abort; }
        | SMTAssembly::KeyLessKind#KeyDataInfo => { abort; }
    }
}

recursive function emitBinaryNumericCompareExpression(e: SMTAssembly::BinaryNumericCompareExpression): CString {
    let lhs = emitSafeExpression[recursive](e.lhs);
    let rhs = emitSafeExpression[recursive](e.rhs);

    match(e)@ {
        SMTAssembly::NumericEqExpression => { return CString::concat('(= ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericNeqExpression => { return CString::concat('(not (= ', lhs, ' ', rhs, '))'); }
        | SMTAssembly::NumericLessExpression => { return CString::concat('(< ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericLessEqExpression => { return CString::concat('(<= ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericGreaterExpression => { return CString::concat('(> ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericGreaterEqExpression => { return CString::concat('(>= ', lhs, ' ', rhs, ')'); }
    }
}

recursive function emitMapEntryConstructorExpression(e: SMTAssembly::MapEntryConstructorExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(e.constype);
    let key = emitSafeExpression[recursive](e.kexp);
    let val = emitSafeExpression[recursive](e.vexp);

    let ops = CString::concat(' ', key, ' ', val);
    return CString::concat('(', consname, ops, ')');
}

recursive function emitLetSafeExpression(e: SMTAssembly::LetSafeExpression): CString {
    let vbind = CString::concat('((', e.vbind.value, ' ', emitSafeExpression[recursive](e.value), '))');
    let inexp = emitSafeExpression[recursive](e.inexp);
    return CString::concat('(let ', vbind, ' ', inexp, ')');
}

recursive function emitIfThenElseSafeExpression(e: SMTAssembly::IfThenElseSafeExpression): CString {
    let tst = emitSafeExpression[recursive](e.iftest);
    let tv = emitSafeExpression[recursive](e.trueexp);
    let fv = emitSafeExpression[recursive](e.falseexp);

    let flows = CString::concat(' ', tv, ' ', fv);
    return CString::concat('(ite ', tst, flows, ')');
}

function emitAbortExpression(e: SMTAssembly::AbortExpression, eev: SMTEmitterEnv): CString {
    if(e.label === eev.errtrgt) {
        return emitResultErrTrgtAs(e.etype);
    }
    else {
        return emitResultErrOtherAs(e.etype);
    }
}

function emitAssertExpression(e: SMTAssembly::AssertExpression, eev: SMTEmitterEnv): CString {
    let exp = emitExpression[recursive](e.inexp, eev);
    
    var tt: CString;
    if($cexp = e.aexp)@<SMTAssembly::SafeExpression> {
        tt = emitSafeExpression[recursive]($cexp);
    }
    else {
        let ecc = emitExpression[recursive]($cexp, eev);
        tt = CString::concat('(= ', ecc, ' ', SMTEmitter::resultTrueValue, ')');
    }

    var err: CString;
    if(e.label == eev.errtrgt) {
        err = emitResultErrTrgtAs(e.etype);
    }
    else {
        err = emitResultErrOtherAs(e.etype);
    }

    let bb = CString::concat('(not ', tt, ') ', err, ' ', exp);
    return CString::concat('(ite ', bb, ')');
}

function emitAssertSetExpression(e: SMTAssembly::AssertSetExpression, eev: SMTEmitterEnv): CString {
    let exp = emitExpression[recursive](e.inexp, eev);
    return e.aset.lreduce<CString>(exp, fn(expcc, chk) => {
        var tt: CString;
        if($cexp = chk.0)@<SMTAssembly::SafeExpression> {
            tt = emitSafeExpression[recursive]($cexp);
        }
        else {
            let ecc = emitExpression[recursive]($cexp, eev);
            tt = CString::concat('(= ', ecc, ' ', SMTEmitter::resultTrueValue, ')');
        }

        var err: CString;
        if(chk.1 == eev.errtrgt) {
            err = emitResultErrTrgtAs(e.etype);
        }
        else {
            err = emitResultErrOtherAs(e.etype);
        }

        let bb = CString::concat('(not ', tt, ') ', err, ' ', expcc);
        return CString::concat('(ite ', bb, ')');
    });
}

recursive function emitUnwrapFromResultExpression(e: SMTAssembly::UnwrapFromResultExpression): CString {
    return CString::concat('(@Result-value ', e.varg.value, ')');
}

recursive function emitWrapIntoResultExpression(e: SMTAssembly::WrapIntoResultExpression): CString {
    let vv = emitSafeExpression[recursive](e.arg);
    return CString::concat('(@Result-ok ', vv, ')');
}

recursive function emitConvertResultExpression(e: SMTAssembly::ConvertResultExpression, eev: SMTEmitterEnv): CString {
    abort;
}

recursive function emitIfThenElseExpression(e: SMTAssembly::IfThenElseExpression, eev: SMTEmitterEnv): CString {
    let tst = emitSafeExpression[recursive](e.iftest);
    let tv = emitExpression[recursive](e.trueexp, eev);
    let fv = emitExpression[recursive](e.falseexp, eev);

    let flows = CString::concat(' ', tv, ' ', fv);
    return CString::concat('(ite ', tst, flows, ')');
}

recursive function emitLetGeneralExpression(e: SMTAssembly::LetGeneralExpression, eev: SMTEmitterEnv): CString {
    let vbind = CString::concat('((', e.vbind.value, ' ', emitSafeExpression[recursive](e.value), '))');
    let inexp = emitExpression[recursive](e.inexp, eev);
    return CString::concat('(let ', vbind, ' ', inexp, ')');
}

recursive function emitLetWErrorsExpression(e: SMTAssembly::LetWErrorsExpression, eev: SMTEmitterEnv): CString {
    let iiexp = emitExpression[recursive](e.inexp, eev);
    let lbs = e.vvbind.lreduce<CString>(iiexp, fn(acc, vb) => {
        let vbind = CString::concat('((', vb.2.value, ' ', emitExpression[recursive](vb.0, eev), '))');
        let chk = CString::concat('(not (is-@Result-ok ', vb.2.value, ')) ');

        let errop = emitExpectedErrTypeConvertAsNeeded(vb.2.value, vb.1, e.errtype);

        let wcheck = CString::concat('(ite ', chk, errop, ' ', acc, ')');
        return CString::concat('(let ', vbind, ' ', wcheck, ')');
    });

    return lbs;
}

recursive function emitSafeExpression(e: SMTAssembly::SafeExpression): CString {
    match(e)@ {
        SMTAssembly::ConstantExpression => { return emitConstantExpression($e); }
        | SMTAssembly::AccessNamespaceConstantExpression => { return emitAccessNamespaceConstantExpression($e); }
        | SMTAssembly::AccessStaticFieldExpression => { return emitAccessStaticFieldExpression($e); }
        | SMTAssembly::AccessEnumExpression => { return emitAccessEnumExpression($e); }
        | SMTAssembly::AccessVariableExpression => { return emitAccessVariableExpression($e); }
        | SMTAssembly::TermifyExpression => { return emitTermifyExpression[recursive]($e); }
        | SMTAssembly::UntermifyExpression => { return emitUntermifyExpression[recursive]($e); }
        %*
        | SMTAssembly::LiteralTypeDeclExpression => { return emitLiteralTypeDeclExpression($v); }
        *%
        | SMTAssembly::ConstructorPrimaryExpression => { return emitConstructorPrimaryExpression[recursive]($e); }
        | SMTAssembly::ConstructorEListExpression => { return emitConstructorEListExpression[recursive]($e); }
        | SMTAssembly::CallFunctionSafeExpression => { return emitCallFunctionSafeExpression[recursive]($e); }
        | SMTAssembly::CallLambdaFunctionSafeExpression => { return emitCallLambdaFunctionSafeExpression[recursive]($e, ); }
        %*
        | SMTAssembly::LogicActionAndExpression => { return emitLogicActionAndExpression[recursive]($v); }
        | SMTAssembly::LogicActionOrExpression => { return emitLogicActionOrExpression[recursive]($v); }
        | SMTAssembly::UnwrapTypeDeclToPrimitiveExpression => { return emitUnwrapTypeDeclToPrimitiveExpression($v); }
        *%
        | SMTAssembly::AccessFromNameResolvedExpression => { return emitAccessFromNameResolvedExpression[recursive]($e); }
        %*
        | SMTAssembly::AccessFromIndexExpression => { return emitAccessFromIndexExpression[recursive]($v); }
        | SMTAssembly::IsTypeTestExpression => { return emitIsTypeTestExpression[recursive]($v); }
        | SMTAssembly::IsSubtypeTestExpression => { return emitIsSubtypeTestExpression[recursive]($v); }
        *%
        | SMTAssembly::ConvertOptionToSomeTExpression => { return emitConvertOptionToSomeTExpression[recursive]($e); }
        %*
        | SMTAssembly::ConvertResultToOkTExpression => { return emitConvertResultToOkTExpression[recursive]($v); }
        | SMTAssembly::ConvertResultToFailEExpression => { return emitConvertResultToFailEExpression[recursive]($v); }
        *%
        | SMTAssembly::UnaryExpression => { return emitUnaryExpression[recursive]($e); }
        | SMTAssembly::BinaryArithExpression => { return emitBinaryArithExpression[recursive]($e); }
        | SMTAssembly::BinaryKeyEqExpression => { return emitBinaryKeyEqExpression[recursive]($e); }
        | SMTAssembly::KeyLessExpression => { return emitKeyLessExpression[recursive]($e); }
        | SMTAssembly::BinaryNumericCompareExpression => { return emitBinaryNumericCompareExpression[recursive]($e); }
        | SMTAssembly::MapEntryConstructorExpression => { return emitMapEntryConstructorExpression[recursive]($e); }
        | SMTAssembly::LetSafeExpression => { return emitLetSafeExpression[recursive]($e); }
        | SMTAssembly::IfThenElseSafeExpression => { return emitIfThenElseSafeExpression[recursive]($e); }
        | SMTAssembly::UnwrapFromResultExpression => { return emitUnwrapFromResultExpression[recursive]($e); }
        | SMTAssembly::WrapIntoResultExpression => { return emitWrapIntoResultExpression[recursive]($e); }
    }
}

recursive function emitExpression(e: SMTAssembly::Expression, eev: SMTEmitterEnv): CString {
    match(e)@ {
        SMTAssembly::AbortExpression => { return emitAbortExpression($e, eev); }
        | SMTAssembly::AssertExpression => { return emitAssertExpression($e, eev); }
        | SMTAssembly::AssertSetExpression => { return emitAssertSetExpression($e, eev); }
        | SMTAssembly::ConvertResultExpression => { return emitConvertResultExpression[recursive]($e, eev); }
        | SMTAssembly::LetGeneralExpression => { return emitLetGeneralExpression[recursive]($e, eev); }
        | SMTAssembly::LetWErrorsExpression => { return emitLetWErrorsExpression[recursive]($e, eev); }
        | SMTAssembly::IfThenElseExpression => { return emitIfThenElseExpression[recursive]($e, eev); }
        | SMTAssembly::CallFunctionExpression => { return emitCallFunctionExpression[recursive]($e, eev); }
        | SMTAssembly::CallLambdaFunctionExpression => { return emitCallLambdaFunctionExpression[recursive]($e, eev); }
        %*
        | SMTAssembly::MethodInvokeStaticExpression => { return emitMethodInvokeStaticExpression[recursive]($v); }
        *%
        | SMTAssembly::SafeExpression => { return emitSafeExpression[recursive]($e); }
    }
}

recursive function emitCallArgSafeExpression(v: SMTAssembly::CallArgSafeExpression, errtrgt: Nat): CString {
    match(v)@ {
        SMTAssembly::LambdaConstructor => { return emitLambdaConstructor[recursive]($v, errtrgt); }
        | SMTAssembly::SafeExpression => { return emitSafeExpression[recursive]($v); }
    }
}

%*
recursive function emitMethodInvokeStaticExpression(e: SMTAssembly::MethodInvokeStaticExpression, evv: SMTEmitterEnv): CString {
    let fname = SMTNameManager::generateTypeFunctionName(e.resolvedTrgt, e.name);
    let rootv = emitExpression(e.rootExp);

    let rpfx = CString::concat(fname, ' ', rootv);
    if(e.args.empty()) {
        return CString::concat('(', rpfx, ')');
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitCallArgExpression[recursive](x, evv));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', rpfx, ' ', argsl, ')');
    }
}
*%

function emitResultErrTypeConvert(cval: CString, tkey: SMTAssembly::TypeKey, ekey: SMTAssembly::TypeKey): CString {
    let ttest = emitResultErrTrgtTest(cval, tkey);
    let astrgt = emitResultErrTrgtAs(ekey);
    let asother = emitResultErrOtherAs(ekey);

    let opack = CString::join(' ', ttest, astrgt, asother);
    return CString::concat('(ite ', opack, ')');
}

function emitResultErrTypeConvertAsNeeded(cval: CString, tkey: SMTAssembly::TypeKey, eev: SMTEmitterEnv): CString {
    if(tkey === eev.restype) {
        return cval;
    }
    else {
        return emitResultErrTypeConvert(cval, tkey, eev.restype);
    }
}

function emitExpectedErrTypeConvertAsNeeded(cval: CString, tkey: SMTAssembly::TypeKey, ekey: SMTAssembly::TypeKey): CString {
    if(tkey === ekey) {
        return cval;
    }
    else {
        return emitResultErrTypeConvert(cval, tkey, ekey);
    }
}

recursive function emitIfThenElseOperation(e: SMTAssembly::IfThenElseOperation, evv: SMTEmitterEnv, indent: Option<CString>): CString {
    let tst = emitSafeExpression[recursive](e.iftest);
    let ttst = CString::concat('(ite ', tst);

    if(indent)@none {
        return CString::concat(ttst, ' ', emitOperation[recursive](e.trueop, evv, none), ' ', emitOperation[recursive](e.falseop, evv, none), ')');
    }
    else {
        let iident = CString::concat('    ', $indent);
        let tident = CString::concat('%n;', $indent, ')');

        let tv = emitOperation[recursive](e.trueop, evv, some(iident));
        let fv = emitOperation[recursive](e.falseop, evv, some(iident));

        return CString::concat(ttst, '%n;', tv, '%n;', fv, tident);
    }
}

function emitReturnOperation(op: SMTAssembly::ReturnOperation, eev: SMTEmitterEnv): CString {
    return emitExpression(op.exp, eev);
}

function emitAbortOperation(op: SMTAssembly::AbortOperation, eev: SMTEmitterEnv): CString {
    if(op.label === eev.errtrgt) {
        return '@Result-err-trgt';
    }
    else {
        return '@Result-err-other';
    }
}

recursive function emitAssertOperation(e: SMTAssembly::AssertOperation, evv: SMTEmitterEnv, indent: Option<CString>): CString {
    var tt: CString;
    if($cexp = e.cond)@<SMTAssembly::SafeExpression> {
        tt = emitSafeExpression[recursive]($cexp);
    }
    else {
        let ecc = emitExpression[recursive]($cexp, evv);
        tt = CString::concat('(= ', ecc, ' ', SMTEmitter::resultTrueValue, ')');
    }

    let chk = CString::concat('(not ', tt, ') ');
    let rop = if(e.label === evv.errtrgt) then emitResultErrTrgtAs(evv.restype) else emitResultErrOtherAs(evv.restype);

    if(indent)@none {
        let inexp = emitOperation[recursive](e.inop, evv, none);
        let ops = CString::join(' ', chk, rop, ' ', inexp);
        return CString::concat('(ite ', ops, ')');
    }
    else {
        let iident = CString::concat('    ', $indent);
        let tident = CString::concat('%n;', $indent, ')');

        let inexp = emitOperation[recursive](e.inop, evv, some(iident));
        let ops = CString::concat(chk, rop, '%n;', inexp);
        return CString::concat('(ite ', ops, tident);
    }
}

recursive function emitAssumeOperation(e: SMTAssembly::AssumeOperation, evv: SMTEmitterEnv, indent: Option<CString>): CString {
    var tt: CString;
    if($cexp = e.cond)@<SMTAssembly::SafeExpression> {
        tt = emitSafeExpression[recursive]($cexp);
    }
    else {
        let ecc = emitExpression[recursive]($cexp, evv);
        tt = CString::concat('(= ', ecc, ' ', SMTEmitter::resultTrueValue, ')');
    }

    let chk = CString::concat('(not ', tt, ') ');
    let rop = emitResultErrOtherAs(evv.restype);

    if(indent)@none {
        let inexp = emitOperation[recursive](e.inop, evv, none);
        let ops = CString::join(' ', chk, rop, ' ', inexp);
        return CString::concat('(ite ', ops, ')');
    }
    else {
        let iident = CString::concat('    ', $indent);
        let tident = CString::concat('%n;', $indent, ')');

        let inexp = emitOperation[recursive](e.inop, evv, some(iident));
        let ops = CString::concat(chk, rop, '%n;', inexp);
        return CString::concat('(ite ', ops, tident);
    }
}

function doLetIndent(enext: SMTAssembly::Operation): Bool {
    return !\/(enext?<SMTAssembly::LetOperation>, enext?<SMTAssembly::LetOperationWError>, enext?<SMTAssembly::LetWErrorsOperation>);
}

recursive function emitLetOperation(e: SMTAssembly::LetOperation, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    let vbind = CString::concat('((', e.vbind.value, ' ', emitSafeExpression(e.value), '))');

    if(indent)@none {
        let inexp = emitOperation[recursive](e.inop, eev, none);
        return CString::concat('(let ', vbind, ' ', inexp, ')');
    }
    else {
        var iident = $indent;
        var tident = ')';

        if(doLetIndent(e.inop)) {
            iident = CString::concat('    ', $indent);
            tident = CString::concat('%n;', $indent, ')');
        }

        let inexp = emitOperation[recursive](e.inop, eev, some(iident));
        return CString::concat('(let ', vbind, '%n;', inexp, tident);
    }
}

recursive function emitLetOperationWError(e: SMTAssembly::LetOperationWError, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    let vval = emitExpression[recursive](e.value, eev);

    let bbind = CString::concat('((', e.vebind.value, ' ', vval, '))');
    let chk = CString::concat('(not (is-@Result-ok ', e.vebind.value, ')) ');
    let errop = emitResultErrTypeConvertAsNeeded(e.vebind.value, e.vtype, eev);

    let okbind = CString::concat('((', e.vbind.value, ' (@Result-value ', e.vebind.value, ')))');

    if(indent)@none {
        let inexp = emitOperation[recursive](e.inop, eev, none);
        let innerop = CString::concat(' (let ', okbind, ' ', inexp, ')');
        let wcheck = CString::concat('(ite ', chk, ' ', errop, innerop, ')');

        return CString::concat('(let ', bbind, ' ', wcheck, ')');
    }
    else {        
        var iident = $indent;
        var tident = ')';

        if(doLetIndent(e.inop)) {
            iident = CString::concat('    ', $indent);
            tident = CString::concat('%n;', $indent, ')');
        }

        let inexp = emitOperation[recursive](e.inop, eev, some(iident));
        let innerop = CString::concat(' (let ', okbind, '%n;', inexp, tident);
        let wcheck = CString::concat('(ite ', chk, ' ', errop, innerop, ')');

        return CString::concat('(let ', bbind, ' ', wcheck, ')');
    }
}

recursive function emitLetWErrorsOperation(e: SMTAssembly::LetWErrorsOperation, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    var inexp: CString;
    if(indent)@none {
        inexp = CString::concat(' ', emitOperation[recursive](e.inop, eev, none));
    }
    else {        
        var iident = $indent;
        var tident = '';

        if(doLetIndent(e.inop)) {
            iident = CString::concat('    ', $indent);
            tident = CString::concat('%n;', $indent);
        }

        inexp = CString::concat('%n;', emitOperation[recursive](e.inop, eev, some(iident)), tident);
    }
    
    let lbs = e.vvbind.lreduce<CString>(inexp, fn(acc, vb) => {
        let vbind = CString::concat('((', vb.2.value, ' ', emitExpression[recursive](vb.0, eev), '))');
        let chk = CString::concat('(not (is-@Result-ok ', vb.2.value, ')) ');

        let errop = emitResultErrTypeConvertAsNeeded(vb.2.value, vb.1, eev);

        let wcheck = CString::concat('(ite ', chk, errop, ' ', acc, ')');
        return CString::concat('(let ', vbind, ' ', wcheck, ')');
    });
    
    let iiexp = emitOperation[recursive](e.inop, eev, none);
    

    if(indent)@none {
        return lbs;
    }
    else {
        return CString::concat($indent, lbs);
    }
}

recursive function emitOperation(op: SMTAssembly::Operation, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    var opstr: CString;
    match(op)@ {
        SMTAssembly::ReturnOperation => { opstr = emitReturnOperation($op, eev); }
        | SMTAssembly::AbortOperation => { opstr = emitAbortOperation($op, eev); }
        | SMTAssembly::AssertOperation => { opstr = emitAssertOperation($op, eev, indent); }
        | SMTAssembly::AssumeOperation => { opstr = emitAssumeOperation($op, eev, indent); }
        | SMTAssembly::LetOperation => { opstr = emitLetOperation[recursive]($op, eev, indent); }
        | SMTAssembly::LetOperationWError => { opstr = emitLetOperationWError[recursive]($op, eev, indent); }
        | SMTAssembly::LetWErrorsOperation => { opstr = emitLetWErrorsOperation[recursive]($op, eev, indent); }
        | SMTAssembly::IfThenElseOperation => { opstr = emitIfThenElseOperation[recursive]($op, eev, indent); }
    }

    if(indent)@none {
        return opstr;
    }
    else {
        return CString::concat($indent, opstr);
    }
}

function emitBody(body: SMTAssembly::Body, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    return emitOperation(body.op, eev, indent);
}

function emitConstDeclarationHelper(cname: CString, vtype: SMTAssembly::ResultType, op: SMTAssembly::Operation): CString {
    let cdecl = CString::concat('(declare-const ', cname, ' ', vtype.rtype.value, ')');

    var optconstv = tryGetConstOperation(op);
    if(optconstv)@some {
        let cval = emitExpression($optconstv, SMTEmitterEnv{SMTEmitter::s_ignoreErrTrgt, vtype.rtype});
        let cinit = CString::concat('(assert (= ', cname, ' ', cval, '))');
        return CString::join(' ', cdecl, cinit);
    }
    else {
        if(vtype)<SMTAssembly::SafeResult> {
            return cdecl;
        }
        else {
            let tname = CString::concat(cname, '-cc-temp');
            let ttype = CString::concat('(@Result ', vtype.rtype.value, ')');
            let icompute = CString::concat('(declare-const ', tname, ' ', ttype, ')');

            return CString::join(' ', cdecl, icompute);
        }
    }
}

function emitConstInitializerHelper(cname: CString, vtype: SMTAssembly::ResultType, body: SMTAssembly::Body): CString {
    let cval = emitBody(body, SMTEmitterEnv{SMTEmitter::s_ignoreErrTrgt, vtype.rtype}, none);

    if(vtype)<SMTAssembly::SafeResult> {
        return CString::concat('(assert (= ', cname, ' ', cval, '))');
    }
    else {
        let tname = CString::concat(cname, '-cc-temp');
        let tval = CString::concat('(assert (= ', tname, ' ', cval, '))');
        let chk = CString::concat('(assert (is-@Result-ok ', tname, '))');
        let asgn = CString::concat('(assert (= ', cname, ' (@Result-value ', tname, ')))');

        return CString::join('%n;', tval, chk, asgn);
    }
}

%** Return the declarations and definitions as 2 seperate components **%
function emitConstInfo(nsconsts: List<SMTAssembly::NamespaceConstDecl>, typeconsts: List<SMTAssembly::ConstMemberDecl>): CString, CString {
    let nsconstdecls = nsconsts.map<CString>(fn(c) => {
        let cname = SMTNameManager::generateNamespaceConstName(c.ns, c.cname);
        return emitConstDeclarationHelper(cname, c.vtype, c.value.op);
    });
    let nsconstdecls_str = CString::joinAll('%n;', nsconstdecls);

    let tconstdecls = typeconsts.map<CString>(fn(c) => {
        let cname = SMTNameManager::generateTypeConstName(c.tkey, c.cname);
        return emitConstDeclarationHelper(cname, c.vtype, c.value.op);    
    });
    let tconstdecls_str = CString::joinAll('%n;', tconstdecls);

    let nsconstinits = nsconsts
        .filter(pred(c) => tryGetConstOperation(c.value.op)?none)
        .map<CString>(fn(c) => {
            let cname = SMTNameManager::generateNamespaceConstName(c.ns, c.cname);
            return emitConstInitializerHelper(cname, c.vtype, c.value);
        });
    let nsconstinits_str = CString::joinAll('%n;', nsconstinits);

    let tconstinits = typeconsts
        .filter(pred(c) => tryGetConstOperation(c.value.op)?none)
        .map<CString>(fn(c) => {
            let cname = SMTNameManager::generateTypeConstName(c.tkey, c.cname);
            return emitConstInitializerHelper(cname, c.vtype, c.value);
        });
    let tconstinits_str = CString::joinAll('%n;', tconstinits);

    return tidyNewlineJoin(nsconstdecls_str, tconstdecls_str), tidyNewlineJoin(nsconstinits_str, tconstinits_str);
}

function emitPredicateFunctionDecl(f: SMTAssembly::PredicateFunctionDecl): CString {
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname.value, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    return CString::concat('(declare-fun ', f.invokeKey.value, ' ', pll, ' Bool)');
}

function emitBuiltinFunctionDecl(f: SMTAssembly::BuiltinFunctionDecl, trgterr: Nat): CString {
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname.value, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let psig = CString::concat('define-fun ', f.invokeKey.value, ' ', pll, ' ');
    var body: CString;
    if(f.specialname === 'cstring_empty') {
        body = '(= s "")';
    }
    else {
        abort; %%Missing builtin function implementation
    }

    return CString::concat('(', psig, SMTNameManager::generateResultName(f.resultType), ' ', body, ')');
}

function emitFunctionDecl(f: SMTAssembly::FunctionDecl, trgterr: Nat): CString {
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname.value, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let psig = CString::concat('define-fun ', f.invokeKey.value, ' ', pll, ' ');
    let body = CString::concat('%n;', emitBody(f.body, SMTEmitterEnv{trgterr, f.resultType.rtype}, some('    ')));

    return CString::concat('(', psig, SMTNameManager::generateResultName(f.resultType), body, '%n;)');
}

function emitEnumTypeDecl(ttype: SMTAssembly::EnumTypeDecl): CString {
    let tvals = CString::joinAll(' ', ttype.members.map<CString>(fn(v) => CString::concat(ttype.tkey.value, '$$', v)));

    return CString::concat('(declare-datatype ', ttype.tkey.value, ' (', tvals, '))');
}

function emitEnumTypeDecls(ttypes: List<SMTAssembly::EnumTypeDecl>): CString {
    let tdecls = ttypes.map<CString>(fn(t) => emitEnumTypeDecl(t));
    return CString::joinAll('%n;', tdecls);
}

function emitTypedeclTypeDecl(ttype: SMTAssembly::TypedeclTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);
    let consfield = SMTNameManager::generateStructFieldName(ttype.tkey, 'value');

    let cval = CString::concat('(', consfield, ' ', ttype.valuetype.value, ')');
    let vval = CString::concat('(', consname, ' ', cval, ')');

    return CString::concat('(declare-datatype ', ttype.tkey.value, ' ( ', vval, ' ))');
}

function emitTypedeclTypeDeclTermCons(ttype: SMTAssembly::TypedeclTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitTypedeclTypes(ttypes: List<SMTAssembly::TypedeclTypeDecl>): CString, CString {
    let tds = ttypes.map<CString>(fn(t) => emitTypedeclTypeDecl(t));
    let ttcons = ttypes.filter(pred(t) => t.termable).map<CString>(fn(t) => emitTypedeclTypeDeclTermCons(t));

    return CString::joinAll('%n;', tds), CString::joinAll('%n;', ttcons);
}

function emitConstructableTypeDeclDeclaration(ttype: SMTAssembly::ConstructableTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitConstructableTypeDeclConstructor(ttype: SMTAssembly::ConstructableTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);

    var tlist: List<CString>;
    match(ttype)@ {
        SMTAssembly::OkTypeDecl => { 
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.ttype.value, ')'),
            };
        }
        | SMTAssembly::FailTypeDecl => {
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.etype.value, ')'),
            };
        }
        | SMTAssembly::SomeTypeDecl => {
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.vtype.value, ')'),
            };
        }
        | SMTAssembly::MapEntryTypeDecl => {
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'key'), ' ', $ttype.ktype.value, ')'),
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.vtype.value, ')'),
            };
        }
        | _ => {
            tlist = List<CString>{};
        }
    }

    if(tlist.empty()) {
        return CString::concat('        (', consname, ')');
    }
    else {
        let tvals = CString::joinAll(' ', tlist);
        return CString::concat('        ((', consname, ' ', tvals, '))');
    }
}

function emitConstructableTypeDeclTermConstructor(ttype: SMTAssembly::ConstructableTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitConstructableTypeDecls(ttypes: List<SMTAssembly::ConstructableTypeDecl>): CString, CString, CString {
   let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitConstructableTypeDeclDeclaration(t)));
   let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitConstructableTypeDeclConstructor(t)));
   let tcons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitConstructableTypeDeclTermConstructor(t)));

   return idecls, cons, tcons;
}

function emitCollectionTypeDeclDeclaration(ttype: SMTAssembly::CollectionTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitCollectionTypeDeclConstructor(ttype: SMTAssembly::CollectionTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);
    let consfield = SMTNameManager::generateStructFieldName(ttype.tkey, 'value');
    let cval = CString::concat('(', consfield, ' (Seq ', ttype.oftype.value, '))');
    return CString::concat('        (', consname, ' ', cval, ')');
}

function emitCollectionTypeDecls(ttypes: List<SMTAssembly::CollectionTypeDecl>): CString, CString {
    let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitCollectionTypeDeclDeclaration(t)));
    let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitCollectionTypeDeclConstructor(t)));
    
    return idecls, cons;
}

function emitEntityTypeDeclDeclaration(ttype: SMTAssembly::EntityTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitEntityTypeDeclConstructor(ttype: SMTAssembly::EntityTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);

    if(ttype.allfields.empty()) {
        return CString::concat('        (', consname, ')');
    }
    else {
        let consfields = ttype.allfields.map<CString>(fn(f) => CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, f.fname), ' ', f.ftype.value, ')'));
        return CString::concat('        ((', consname, ' ', CString::joinAll(' ', consfields), '))');
    }
}

function emitEntityTypeDeclTermConstructor(ttype: SMTAssembly::EntityTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitEntityTypeDecls(ttypes: List<SMTAssembly::EntityTypeDecl>): CString, CString, CString {
    let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitEntityTypeDeclDeclaration(t)));
    let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitEntityTypeDeclConstructor(t)));
    let tcons = CString::joinAll('%n;', ttypes.filter(pred(t) => t.termable).map<CString>(fn(t) => emitEntityTypeDeclTermConstructor(t)));

    return idecls, cons, tcons;
}

function emitDatatypeMemberTypeDeclDeclaration(ttype: SMTAssembly::DatatypeMemberEntityTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitDatatypeMemberEntityTypeDeclConstructor(ttype: SMTAssembly::DatatypeMemberEntityTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);

    if(ttype.allfields.empty()) {
        return CString::concat('        (', consname, ')');
    }
    else {
        let consfields = ttype.allfields.map<CString>(fn(f) => CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, f.fname), ' ', f.ftype.value, ')'));
        return CString::concat('        ((', consname, ' ', CString::joinAll(' ', consfields), '))');
    }
}

function emitDatatypeMemberEntityTypeDeclTermConstructor(ttype: SMTAssembly::DatatypeMemberEntityTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitDatatypeMemberEntityTypeDecls(ttypes: List<SMTAssembly::DatatypeMemberEntityTypeDecl>): CString, CString, CString {
    let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitDatatypeMemberTypeDeclDeclaration(t)));
    let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitDatatypeMemberEntityTypeDeclConstructor(t)));
    let tcons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitDatatypeMemberEntityTypeDeclTermConstructor(t)));

    return idecls, cons, tcons;
}

function emitSubtypePredicate(ctype: SMTAssembly::TypeKey, subtypes: List<SMTAssembly::TypeKey>): CString {
    let tname = SMTNameManager::generateTermSubtypeFunctionName(ctype);
    
    if(subtypes.empty()) {
        return CString::concat('(define-fun ', tname, '((tt @Term)) Bool false)');
    }
    elif(subtypes.isSingleElement()) {
        return CString::concat('(define-fun ', tname, '((tt @Term)) Bool (is-@Term-', subtypes.single().value, '-mk tt))');
    }
    else {
        let tlist = subtypes.map<CString>(fn(t) => CString::concat('(is-', t.value, ' tt)'));
        return CString::concat('(define-fun ', tname, '((tt @Term)) Bool (or ', CString::joinAll(' ', tlist), '))');
    }
}

function emitSpecialOptionSubtypePredicate(otype: SMTAssembly::OptionTypeDecl): CString {
    let tname = SMTNameManager::generateTermSubtypeFunctionName(otype.tkey);
    let tlist = List<CString>{
        CString::concat('(is-@Term-', otype.someType.value, '-mk tt)'),
        CString::concat('(= tt @Term-mk-None)'),
    };

    return CString::concat('(define-fun ', tname, '((tt @Term)) Bool (or ', CString::joinAll(' ', tlist), '))');
}

function emitPrimitiveConceptSubtypeChecks(ctype: List<SMTAssembly::PrimitiveConceptTypeDecl>): CString {
    let ccks = ctype.map<CString>(fn(c) => {
        match(c)@{
            SMTAssembly::OptionTypeDecl => {
                return emitSpecialOptionSubtypePredicate($c);
            }
            | SMTAssembly::ResultTypeDecl => {
                return emitSubtypePredicate(c.tkey, List<SMTAssembly::TypeKey>{$c.okType, $c.failType});
            }
            | SMTAssembly::APIResultTypeDecl => {
                return emitSubtypePredicate(c.tkey, List<SMTAssembly::TypeKey>{$c.errorType, $c.failedType, $c.rejectedType, $c.successType});
            }
        }
    });

    return CString::joinAll('%n;', ccks);
}

function emitConceptSubtypeChecks(ctype: List<SMTAssembly::ConceptTypeDecl>): CString {
    let ccks = ctype.map<CString>(fn(c) => emitSubtypePredicate(c.tkey, c.subtypes));
    return CString::joinAll('%n;', ccks);
}

function emitDatatypeSubtypeChecks(ctype: List<SMTAssembly::DatatypeTypeDecl>): CString {
    let ccks = ctype.map<CString>(fn(c) => emitSubtypePredicate(c.tkey, c.subtypes));
    return CString::joinAll('%n;', ccks);
}

function emitAllSubtypeChecks(pconcepts: List<SMTAssembly::PrimitiveConceptTypeDecl>, concepts: List<SMTAssembly::ConceptTypeDecl>, dconcepts: List<SMTAssembly::DatatypeTypeDecl>): CString {
    let pcks = emitPrimitiveConceptSubtypeChecks(pconcepts);
    let ccks = emitConceptSubtypeChecks(concepts);
    let dcks = emitDatatypeSubtypeChecks(dconcepts);

    return CString::joinAll('%n;', List<CString>{pcks, ccks, dcks}.filter(pred(s) => !s.empty()));
}

function emitAssembly(asm: SMTAssembly::Assembly, trgterr: Nat): CString {
    let constdecls, constimpls = emitConstInfo(asm.nsconsts, asm.typeconsts);
    let conststr = CString::join('%n;',
        '#BEGIN ;;--GLOBAL_DECLS--;;',
        constdecls,
        '#END ;;--GLOBAL_DECLS--;;',
        '#BEGIN ;;--GLOBAL_IMPLS--;;',
        constimpls,
        '#END ;;--GLOBAL_IMPLS--;;'
    );

    let nspreds = CString::joinAll('%n;', asm.nspreds.map<CString>(fn(f) => emitPredicateFunctionDecl(f)));
    let nsbuiltins = CString::joinAll('%n;', asm.nsbuiltins.map<CString>(fn(f) => emitBuiltinFunctionDecl(f, trgterr)));
    let prestr = CString::join('%n;',
        '#BEGIN ;;--PRE_FUNCS--;;',
        nspreds,
        nsbuiltins,
        '#END ;;--PRE_FUNCS--;;'
    );

    let efuncs_list = asm.allfuncs.map<CString>(fn(t) => emitFunctionDecl(asm.funcs.get(t), trgterr));
    let efuncs = CString::concat(
        '#BEGIN ;;--FUNCTION_DECLS--;;',
        CString::joinAll('%n;%n;', efuncs_list),
        '#END ;;--FUNCTION_DECLS--;;'
    );
    
    let enum_edcls = emitEnumTypeDecls(asm.enums);
    let typedecl_edcls, typedecl_etcons = emitTypedeclTypes(asm.typedecls);
    let predecls = CString::join('%n;',
        '#BEGIN ;;--ENUM_DECLS--;;',
        enum_edcls,
        '#END ;;--ENUM_DECLS--;;',
        '#BEGIN ;;--TYPEDECL_DECLS--;;',
        typedecl_edcls,
        '#END ;;--TYPEDECL_DECLS--;;'
    );

    let predecl_str = CString::join('%n;', conststr, prestr, predecls);

    let special_edcls, special_econs, special_etcons = emitConstructableTypeDecls(asm.constructables);
    let collection_edcls, collection_econs = emitCollectionTypeDecls(asm.collections);
    let entity_edcls, entity_econs, entity_etcons = emitEntityTypeDecls(asm.entities);
    let datamember_edcls, datamember_econs, datamember_etcons = emitDatatypeMemberEntityTypeDecls(asm.datamembers);

    let stddecls = CString::join('%n;',
        CString::join('%n;',
            '#BEGIN ;;--SPECIAL_DECLS--;;',
            special_edcls,
            '#END ;;--SPECIAL_DECLS--;;',
            '#BEGIN ;;--COLLECTION_DECLS--;;',
            collection_edcls,
            '#END ;;--COLLECTION_DECLS--;;'
        ),
        CString::join('%n;',
            '#BEGIN ;;--ENTITY_DECLS--;;',
            entity_edcls,
            '#END ;;--ENTITY_DECLS--;;',
            '#BEGIN ;;--DATATYPE_DECLS--;;',
            datamember_edcls,
            '#END ;;--DATATYPE_DECLS--;;'
        )
    );

    let stdcons = CString::join('%n;',
        CString::join('%n;',
            '#BEGIN ;;--SPECIAL_CONSTRUCTORS--;;',
            special_econs,
            '#END ;;--SPECIAL_CONSTRUCTORS--;;',
            '#BEGIN ;;--COLLECTION_CONSTRUCTORS--;;',
            collection_econs,
            '#END ;;--COLLECTION_CONSTRUCTORS--;;'
        ),
        CString::join('%n;',
            '#BEGIN ;;--ENTITY_CONSTRUCTORS--;;',
            entity_econs,
            '#END ;;--ENTITY_CONSTRUCTORS--;;',
            '#BEGIN ;;--DATATYPE_CONSTRUCTORS--;;',
            datamember_econs,
            '#END ;;--DATATYPE_CONSTRUCTORS--;;'
        )
    );

    let termcons = CString::join('%n;',
        CString::join('%n;',
            '#BEGIN ;;--TYPEDECL_TERM_CONSTRUCTORS--;;',
            typedecl_etcons,
            '#END ;;--TYPEDECL_TERM_CONSTRUCTORS--;;',
            '#BEGIN ;;--SPECIAL_TERM_CONSTRUCTORS--;;',
            special_etcons,
            '#END ;;--SPECIAL_TERM_CONSTRUCTORS--;;'
        ),
        CString::join('%n;',
            '#BEGIN ;;--ENTITY_TERM_CONSTRUCTORS--;;',
            entity_etcons,
            '#END ;;--ENTITY_TERM_CONSTRUCTORS--;;',
            '#BEGIN ;;--DATATYPE_TERM_CONSTRUCTORS--;;',
            datamember_etcons,
            '#END ;;--DATATYPE_TERM_CONSTRUCTORS--;;'
        )
    );

    let subchecks = emitAllSubtypeChecks(asm.pconcepts, asm.concepts, asm.datatypes);
    let subchecks_str = CString::join('%n;',
        '#BEGIN ;;--SUBTYPE_PREDICATES--;;',
        subchecks,
        '#END ;;--SUBTYPE_PREDICATES--;;'
    );

    return CString::join('%n;', predecl_str, CString::join('%n;', stddecls, stdcons, termcons), subchecks_str, efuncs);
}
