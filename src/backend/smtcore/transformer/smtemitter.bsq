namespace SMTEmitter;

namespace SMTNameManager {
    function generateStructConstructorName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat(tkey.value, '-mk');
    }

    function generateStructFieldName(tkey: SMTAssembly::TypeKey, vname: CString): CString {
        return CString::concat(tkey.value, '-', vname);
    }

    function generateStructTermConstructorName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat('@Term-', tkey.value, '-mk');
    }

    function generateStructTermFieldName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat('@Term-', tkey.value, '-value');
    }

    function generateNamespaceConstName(ns: SMTAssembly::NamespaceKey, cname: CString): CString {
        return CString::concat(ns.value, '@', cname);
    }

    function generateNamespaceFunctionName(ns: SMTAssembly::NamespaceKey, name: CString): CString {
        return CString::concat(ns.value, '@', name);
    }

    function generateTypeConstName(tkey: SMTAssembly::TypeKey, cname: CString): CString {
        return CString::concat(tkey.value, '@', cname);
    }

    function generateTypeFunctionName(tkey: SMTAssembly::TypeKey, name: CString): CString {
        return CString::concat(tkey.value, '@', name);
    }

    function generateTermSubtypeFunctionName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat('@SubtypeOf-', tkey.value);
    }

    function generateResultName(rtype: SMTAssembly::ResultType): CString {
        if(rtype)@<SMTAssembly::DirectResult> {
            return rtype.rtype.value;
        } else {
            return CString::concat('(@Result ', rtype.rtype.value, ')');
        }
    }
}

const s_ignoreErrTrgt: CString = '[ignore]';

entity SMTEmitterEnv {
    field expectedResultType: SMTAssembly::ResultType;
    field errtrgt: CString;
}

function cleanOptionalLeadingPlus(vstr: CString): CString {
    return if(vstr.startsWithString('+')) then vstr.removePrefixString('+') else vstr;
}

function tidyNewlineJoin(s1: CString, s2: CString): CString {
    if(s1.empty() && s2.empty()) {
        return '';
    }
    elif(s1.empty()) {
        return s2;
    }
    elif(s2.empty()) {
        return s1;
    }
    else {
        return CString::join('%n;', s1, s2);
    }
}

function tryGetConstOperation(value: SMTAssembly::OperationBlock): Option<SMTAssembly::ConstantValue> {
    if(!value.ops.empty()) {
        return none;
    }

    if($rop = value.resop)@<SMTAssembly::ReturnValueOperation> {
        if($vv = $rop.val)@<SMTAssembly::ConstantValue> {
            return some($vv);
        }
    }

    return none;
}

function emitTaggedNumericType(nstr: CString, tag: CString): CString {
    return cleanOptionalLeadingPlus(nstr.removeSuffixString(tag));
}

function emitLiteralNoneValue(): CString {
    return 'none';
}

function emitLiteralSimpleValue(v: SMTAssembly::LiteralSimpleValue): CString {
    switch(v.vtype) {
        'Bool'<SMTAssembly::TypeKey>     => { return v.value; }
        | 'Nat'<SMTAssembly::TypeKey>    => { return emitTaggedNumericType(v.value, 'n'); }
        | 'Int'<SMTAssembly::TypeKey>    => { return emitTaggedNumericType(v.value, 'i'); }
        | 'BigNat'<SMTAssembly::TypeKey> => { return emitTaggedNumericType(v.value, 'N'); }
        | 'BigInt'<SMTAssembly::TypeKey> => { return emitTaggedNumericType(v.value, 'I'); }
        | 'Float'<SMTAssembly::TypeKey>  => { return emitTaggedNumericType(v.value, 'f'); }
    }
}

function emitLiteralCStringValue(v: SMTAssembly::LiteralCStringValue): CString {
    return CString::concat('"', v.value, '"');
}

function emitLiteralStringValue(v: SMTAssembly::LiteralStringValue): CString {
    return CString::concat('"', v.value, '"');
}

function emitLiteralCRegexValue(v: SMTAssembly::LiteralCRegexValue): CString {
    %%TODO
    abort;
}

function emitLiteralRegexValue(v: SMTAssembly::LiteralRegexValue): CString {
    %%TODO
    abort;
}

function emitConstantValue(v: SMTAssembly::ConstantValue): CString {
    match(v)@ {
        SMTAssembly::LiteralNoneValue => { return emitLiteralNoneValue(); }
        | SMTAssembly::LiteralSimpleValue => { return emitLiteralSimpleValue($v); }
        | SMTAssembly::LiteralCStringValue => { return emitLiteralCStringValue($v); }
        | SMTAssembly::LiteralStringValue => { return emitLiteralStringValue($v); }
        | SMTAssembly::LiteralCRegexValue => { return emitLiteralCRegexValue($v); }
        | SMTAssembly::LiteralRegexValue => { return emitLiteralRegexValue($v); }
    }
}

function emitAccessNamespaceConstantValue(v: SMTAssembly::AccessNamespaceConstantValue): CString {
    return CString::concat(v.ns.value, '@', v.name);
}

function emitAccessStaticFieldValue(v: SMTAssembly::AccessStaticFieldValue): CString {
    return CString::concat(v.tresolved.value, '@', v.name);
}

function emitAccessEnumValue(v: SMTAssembly::AccessEnumValue): CString {
    return CString::concat(v.enumtype.value, '$$', v.name);
}

function emitAccessVariableValue(v: SMTAssembly::AccessVariableValue): CString {
    return v.vname;
}

function emitAccessVariableRetypeStepValue(v: SMTAssembly::AccessVariableRetypeStepValue): CString {
    let access = SMTNameManager::generateStructFieldName(v.step.ttype,  v.step.specialfname);
    
    return CString::concat('(', access, ' ',  v.vname, ')');
}

function emitAccessVariableRetypeMultiStepValue(v: SMTAssembly::AccessVariableRetypeMultiStepValue): CString {
    %%TODO
    abort;
}

recursive function emitTermifyValue(v: SMTAssembly::TermifyValue): CString {
    let consname = SMTNameManager::generateStructTermConstructorName(v.fromtype);
    let vv = emitValue[recursive](v.value);
    
    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitUntermifyValue(v: SMTAssembly::UntermifyValue): CString {
    let access = SMTNameManager::generateStructTermFieldName(v.fromtype);
    let vv = emitValue[recursive](v.value);
    
    return CString::concat('(', access, ' ', vv, ')');
}

function emitLiteralTypeDeclValue(v: SMTAssembly::LiteralTypeDeclValue): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let vv = emitConstantValue(v.value);

    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitConstructorListSingletonsValue(v: SMTAssembly::ConstructorListSingletonsValue): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);

    if(v.args.empty()) {
        let scons = CString::concat('(as seq.empty (Seq ', v.oftype.value, '))');
        return CString::concat('(', consname, ' ', scons, ')');
    }
    else {
        if(v.args.isSingleElement()) {
            let scons = CString::concat('(seq.unit ', emitValue[recursive](v.args.single()), ')');
            return CString::concat('(', consname, ' ', scons, ')');
        }
        else {
            let cvals = v.args.map[recursive]<CString>(fn(x) => CString::concat('(seq.unit ', emitValue[recursive](x), ')'));
            let argsl = CString::joinAll(' ', cvals);

            let scons = CString::concat('(seq.++ ', argsl, ')');
            return CString::concat('(', consname, ' ', scons, ')');
        }
    }
}

recursive function emitConstructorMapSingletonsValue(v: SMTAssembly::ConstructorMapSingletonsValue): CString {
    %%TODO
    abort;
}

recursive function emitConstructorPrimarySpecialConstructableValue(v: SMTAssembly::ConstructorPrimarySpecialConstructableValue): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let vv = emitValue[recursive](v.arg);

    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitConstructorTypeDeclValue(v: SMTAssembly::ConstructorTypeDeclValue): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let vv = emitValue[recursive](v.arg);

    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitConstructorStdValue(v: SMTAssembly::ConstructorStdValue): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    if(v.args.empty()) {
        return consname;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitValue[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', consname, ' ', argsl, ')');
    }
}

recursive function emitConstructorPrimaryValue(v: SMTAssembly::ConstructorPrimaryValue): CString {
    match(v)@ {
        SMTAssembly::ConstructorListSingletonsValue => { return emitConstructorListSingletonsValue[recursive]($v); }
        | SMTAssembly::ConstructorMapSingletonsValue => { return emitConstructorMapSingletonsValue[recursive]($v); }
        | SMTAssembly::ConstructorPrimarySpecialConstructableValue => { return emitConstructorPrimarySpecialConstructableValue[recursive]($v); }
        | SMTAssembly::ConstructorTypeDeclValue => { return emitConstructorTypeDeclValue[recursive]($v); }
        | SMTAssembly::ConstructorStdValue => { return emitConstructorStdValue[recursive]($v); }
    }
}

recursive function emitConstructorEListValue(v: SMTAssembly::ConstructorEListValue): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    if(v.args.empty()) {
        return consname;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitValue[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', consname, ' ', argsl, ')');
    }
}

recursive function emitCallNamespaceFunctionValue(v: SMTAssembly::CallNamespaceFunctionValue): CString {
    let fname = SMTNameManager::generateNamespaceFunctionName(v.ns, v.name);
    if(v.args.empty()) {
        return fname;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitValue[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', fname, ' ', argsl, ')');
    }
}

recursive function emitCallTypeFunctionValue(v: SMTAssembly::CallTypeFunctionValue): CString {
    let fname = SMTNameManager::generateTypeFunctionName(v.resolvedType, v.name);
    if(v.args.empty()) {
        return fname;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitValue[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', fname, ' ', argsl, ')');
    }
}

recursive function emitLogicActionAndValue(v: SMTAssembly::LogicActionAndValue): CString {
    let cvals = v.args.map[recursive]<CString>(fn(x) => emitValue[recursive](x));
    let argsl = CString::joinAll(' ', cvals);

    return CString::concat('(and ', argsl, ')');
}

recursive function emitLogicActionOrValue(v: SMTAssembly::LogicActionOrValue): CString {
    let cvals = v.args.map[recursive]<CString>(fn(x) => emitValue[recursive](x));
    let argsl = CString::joinAll(' ', cvals);

    return CString::concat('(or ', argsl, ')');
}

recursive function emitUnwrapTypeDeclToPrimitiveValue(v: SMTAssembly::UnwrapTypeDeclToPrimitiveValue): CString {
    let access = SMTNameManager::generateStructFieldName(v.decltype, 'value');
    return CString::concat('(', access, ' ', emitValue(v.arg), ')');
}

recursive function emitAccessFromNameResolvedValue(v: SMTAssembly::AccessFromNameResolvedValue): CString {
    let access = SMTNameManager::generateStructFieldName(v.ontype, v.name);
    return CString::concat('(', access, ' ', emitValue(v.arg), ')');
}

recursive function emitAccessFromIndexValue(v: SMTAssembly::AccessFromIndexValue): CString {
    let access = SMTNameManager::generateStructFieldName(v.elisttype, v.idx);
    return CString::concat('(', access, ' ', emitValue(v.arg), ')');
}

recursive function emitIsNoneTestValue(v: SMTAssembly::IsNoneTestValue): CString {
    let vv = emitValue[recursive](v.arg);
    return CString::concat('(= ', vv, ' @Term-mk-None)');
}

recursive function emitIsSomeTestValue(v: SMTAssembly::IsSomeTestValue): CString {
    let vv = emitValue[recursive](v.arg);
    return CString::concat('(not (= ', vv, ' @Term-mk-None))');
}

recursive function emitIsTypeTestValue(v: SMTAssembly::IsTypeTestValue): CString {
    let ccons = SMTNameManager::generateStructTermConstructorName(v.istype);
    let ttchk = CString::concat('(_ is ', ccons, ')');
    let vv = emitValue[recursive](v.arg);

    %%v is always in term repr to test against term constructor
    return CString::concat('(', ttchk, ' ', vv, ')');
}

recursive function emitIsSubtypeTestValue(v: SMTAssembly::IsSubtypeTestValue): CString {
    let subchk = SMTNameManager::generateTermSubtypeFunctionName(v.oftype);
    let vv = emitValue[recursive](v.arg);

    %%v is always in term repr to test against term constructor
    return CString::concat('(', subchk, ' ', vv, ')');
}

recursive function emitConvertOptionToSomeTValue(v: SMTAssembly::ConvertOptionToSomeTValue): CString {
    let ubx = SMTNameManager::generateStructTermFieldName(v.optiontype);
    let extract = SMTNameManager::generateStructFieldName(v.sometype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', emitValue[recursive](v.arg), ')');
    return CString::concat('(', extract, ' ', ubxop, ')');
}

recursive function emitConvertResultToOkTValue(v: SMTAssembly::ConvertResultToOkTValue): CString {
    let ubx = SMTNameManager::generateStructTermFieldName(v.resulttype);
    let extract = SMTNameManager::generateStructFieldName(v.oktype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', emitValue[recursive](v.arg), ')');
    return CString::concat('(', extract, ' ', ubxop, ')');
}

recursive function emitConvertResultToFailEValue(v: SMTAssembly::ConvertResultToFailEValue): CString {
    let ubx = SMTNameManager::generateStructTermFieldName(v.resulttype);
    let extract = SMTNameManager::generateStructFieldName(v.failtype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', emitValue[recursive](v.arg), ')');
    return CString::concat('(', extract, ' ', ubxop, ')');
}

recursive function emitMethodInvokeStaticValue(v: SMTAssembly::MethodInvokeStaticValue): CString {
    let fname = SMTNameManager::generateTypeFunctionName(v.resolvedTrgt, v.name);
    let rootv = emitValue[recursive](v.rootExp);

    let rpfx = CString::concat(fname, ' ', rootv);
    if(v.args.empty()) {
        return CString::concat('(', rpfx, ')');
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitValue[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', rpfx, ' ', argsl, ')');
    }
}

recursive function emitPrefixNotOpValue(v: SMTAssembly::PrefixNotOpValue): CString {
    let vv = emitValue[recursive](v.exp);
    return CString::concat('(not ', vv, ')');
}

recursive function emitPrefixNegateOpValue(v: SMTAssembly::PrefixNegateOpValue): CString {
    let vv = emitValue[recursive](v.exp);
    return CString::concat('(- ', vv, ')');
}

recursive function emitPrefixPlusOpValue(v: SMTAssembly::PrefixPlusOpValue): CString {
    return emitValue[recursive](v.exp);
}

recursive function emitUnaryValue(v: SMTAssembly::UnaryValue): CString {
    match(v)@ {
        SMTAssembly::PrefixNotOpValue => { return emitPrefixNotOpValue[recursive]($v); }
        | SMTAssembly::PrefixNegateOpValue => { return emitPrefixNegateOpValue[recursive]($v); }
        | SMTAssembly::PrefixPlusOpValue => { return emitPrefixPlusOpValue[recursive]($v); }
    }
}

recursive function emitBinAddValue(v: SMTAssembly::BinAddValue): CString {
    let lhs = emitValue[recursive](v.lhs);
    let rhs = emitValue[recursive](v.rhs);
    return CString::concat('(+ ', lhs, ' ', rhs, ')');
}

recursive function emitBinSubValue(v: SMTAssembly::BinSubValue): CString {
    let lhs = emitValue[recursive](v.lhs);
    let rhs = emitValue[recursive](v.rhs);
    return CString::concat('(- ', lhs, ' ', rhs, ')');
}

recursive function emitBinMultValue(v: SMTAssembly::BinMultValue): CString {
    let lhs = emitValue[recursive](v.lhs);
    let rhs = emitValue[recursive](v.rhs);

    if(v.useUninterpreted) {
        return CString::concat('(@NLA_I_mult ', lhs, ' ', rhs, ')');
    }
    else {
        return CString::concat('(* ', lhs, ' ', rhs, ')');
    }
}

recursive function emitBinDivValue(v: SMTAssembly::BinDivValue): CString {
    let lhs = emitValue[recursive](v.lhs);
    let rhs = emitValue[recursive](v.rhs);
    
    if(v.useUninterpreted) {
        return CString::concat('(@NLA_I_div ', lhs, ' ', rhs, ')');
    }
    else {
        return CString::concat('(/ ', lhs, ' ', rhs, ')');
    }
}

recursive function emitBinaryArithValue(v: SMTAssembly::BinaryArithValue): CString {
    match(v)@ {
        SMTAssembly::BinAddValue => { return emitBinAddValue[recursive]($v); }
        | SMTAssembly::BinSubValue => { return emitBinSubValue[recursive]($v); }
        | SMTAssembly::BinMultValue => { return emitBinMultValue[recursive]($v); }
        | SMTAssembly::BinDivValue => { return emitBinDivValue[recursive]($v); }
    }
}

recursive function emitBinKeyEqNoneValue(v: SMTAssembly::BinKeyEqNoneValue): CString {
    let vv = emitValue[recursive](v.exp);
    return CString::concat('(= ', vv, ' @Term-mk-None)');
}

recursive function emitBinKeyNotEqNoneValue(v: SMTAssembly::BinKeyNotEqNoneValue): CString {
    let vv = emitValue[recursive](v.exp);
    return CString::concat('(not (= ', vv, ' @Term-mk-None))');
}

recursive function emitBinKeySomeEqValue(v: SMTAssembly::BinKeySomeEqValue): CString {
    let eopt = emitValue[recursive](v.eoption);
    let val = emitValue[recursive](v.val);
    
    let ubx = SMTNameManager::generateStructTermFieldName(v.optiontype);
    let extract = SMTNameManager::generateStructFieldName(v.sometype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', eopt, ')');
    let extractop = CString::concat('(', extract, ' ', ubxop, ')');
    let eqop = CString::concat('(= ', extractop, ' ', val, ')');

    let notnoneop = CString::concat('(not (= ', eopt, ' @Term-mk-None))');

    return CString::concat('(and ', notnoneop, ' ', eqop, ')');
}

recursive function emitBinKeyNotSomeEqValue(v: SMTAssembly::BinKeyNotSomeEqValue): CString {
    let eopt = emitValue[recursive](v.eoption);
    let val = emitValue[recursive](v.val);
    
    let ubx = SMTNameManager::generateStructTermFieldName(v.optiontype);
    let extract = SMTNameManager::generateStructFieldName(v.sometype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', eopt, ')');
    let extractop = CString::concat('(', extract, ' ', ubxop, ')');
    let neqop = CString::concat('(not (= ', extractop, ' ', val, '))');

    let noneop = CString::concat('(= ', eopt, ' @Term-mk-None)');

    return CString::concat('(or ', noneop, ' ', neqop, ')');
}

recursive function emitBinKeyEqValue(v: SMTAssembly::BinKeyEqValue): CString {
    let lhs = emitValue[recursive](v.lhs);
    let rhs = emitValue[recursive](v.rhs);
    return CString::concat('(= ', lhs, ' ', rhs, ')');
}

recursive function emitBinKeyNotEqValue(v: SMTAssembly::BinKeyNotEqValue): CString {
    let lhs = emitValue[recursive](v.lhs);
    let rhs = emitValue[recursive](v.rhs);
    return CString::concat('(not (= ', lhs, ' ', rhs, '))');
}

recursive function emitBinaryKeyEqValue(v: SMTAssembly::BinaryKeyEqValue): CString {
    match(v)@ {
        SMTAssembly::BinKeyEqNoneValue => { return emitBinKeyEqNoneValue[recursive]($v); }
        | SMTAssembly::BinKeyNotEqNoneValue => { return emitBinKeyNotEqNoneValue[recursive]($v); }
        | SMTAssembly::BinKeySomeEqValue => { return emitBinKeySomeEqValue[recursive]($v); }
        | SMTAssembly::BinKeyNotSomeEqValue => { return emitBinKeyNotSomeEqValue[recursive]($v); }
        | SMTAssembly::BinKeyEqValue => { return emitBinKeyEqValue[recursive]($v); }
        | SMTAssembly::BinKeyNotEqValue => { return emitBinKeyNotEqValue[recursive]($v); }
    }
}

recursive function emitKeyLessValue(v: SMTAssembly::KeyLessValue): CString {
    let lhs = emitValue[recursive](v.lhs);
    let rhs = emitValue[recursive](v.rhs);

    switch(v.kind) {
        SMTAssembly::KeyLessKind#KeyBool => {return CString::concat('(and (not ', lhs, ') ', rhs, ')'); }
        | SMTAssembly::KeyLessKind#KeyNumber => { return CString::concat('(< ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::KeyLessKind#KeyString => { return CString::concat('(str.< ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::KeyLessKind#KeyUUID => { abort; }
        | SMTAssembly::KeyLessKind#KeyHash => { abort; }
        | SMTAssembly::KeyLessKind#KeyDataInfo => { abort; }
    }
}

recursive function emitBinaryNumericCompareValue(v: SMTAssembly::BinaryNumericCompareValue): CString {
    let lhs = emitValue[recursive](v.lhs);
    let rhs = emitValue[recursive](v.rhs);

    match(v)@ {
        SMTAssembly::NumericEqValue => { return CString::concat('(= ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericNeqValue => { return CString::concat('(not (= ', lhs, ' ', rhs, '))'); }
        | SMTAssembly::NumericLessValue => { return CString::concat('(< ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericLessEqValue => { return CString::concat('(<= ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericGreaterValue => { return CString::concat('(> ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericGreaterEqValue => { return CString::concat('(>= ', lhs, ' ', rhs, ')'); }
    }
}

recursive function emitBinLogicValue(v: SMTAssembly::BinLogicValue): CString {
    let lhs = emitValue[recursive](v.lhs);
    let rhs = emitValue[recursive](v.rhs);

    match(v)@ {
        SMTAssembly::BinLogicAndValue => { return CString::concat('(and ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::BinLogicOrValue => { return CString::concat('(or ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::BinLogicImpliesValue => { return CString::concat('(=> ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::BinLogicIFFValue => { return CString::concat('(= ', lhs, ' ', rhs, ')'); }
    }
}

recursive function emitMapEntryConstructorValue(v: SMTAssembly::MapEntryConstructorValue): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let key = emitValue[recursive](v.kexp);
    let val = emitValue[recursive](v.vexp);

    let ops = CString::concat(' ', key, ' ', val);
    return CString::concat('(', consname, ops, ')');
}

recursive function emitIfValue(v: SMTAssembly::IfValue): CString {
    let tst = emitValue[recursive](v.iftest);
    let tv = emitValue[recursive](v.trueValue);
    let fv = emitValue[recursive](v.falseValue);

    let flows = CString::concat(' ', tv, ' ', fv);
    return CString::concat('(ite ', tst, flows, ')');
}

recursive function emitValue(v: SMTAssembly::Value): CString {
    match(v)@ {
        SMTAssembly::ConstantValue => { return emitConstantValue($v); }
        | SMTAssembly::AccessNamespaceConstantValue => { return emitAccessNamespaceConstantValue($v); }
        | SMTAssembly::AccessStaticFieldValue => { return emitAccessStaticFieldValue($v); }
        | SMTAssembly::AccessEnumValue => { return emitAccessEnumValue($v); }
        | SMTAssembly::AccessVariableValue => { return emitAccessVariableValue($v); }
        | SMTAssembly::AccessVariableRetypeStepValue => { return emitAccessVariableRetypeStepValue($v); }
        | SMTAssembly::AccessVariableRetypeMultiStepValue => { return emitAccessVariableRetypeMultiStepValue($v); }
        | SMTAssembly::TermifyValue => { return emitTermifyValue[recursive]($v); }
        | SMTAssembly::UntermifyValue => { return emitUntermifyValue[recursive]($v); }
        | SMTAssembly::LiteralTypeDeclValue => { return emitLiteralTypeDeclValue($v); }
        | SMTAssembly::ConstructorPrimaryValue => { return emitConstructorPrimaryValue[recursive]($v); }
        | SMTAssembly::ConstructorEListValue => { return emitConstructorEListValue[recursive]($v); }
        | SMTAssembly::CallNamespaceFunctionValue => { return emitCallNamespaceFunctionValue[recursive]($v); }
        | SMTAssembly::CallTypeFunctionValue => { return emitCallTypeFunctionValue[recursive]($v); }
        | SMTAssembly::LogicActionAndValue => { return emitLogicActionAndValue[recursive]($v); }
        | SMTAssembly::LogicActionOrValue => { return emitLogicActionOrValue[recursive]($v); }
        | SMTAssembly::UnwrapTypeDeclToPrimitiveValue => { return emitUnwrapTypeDeclToPrimitiveValue($v); }
        | SMTAssembly::AccessFromNameResolvedValue => { return emitAccessFromNameResolvedValue[recursive]($v); }
        | SMTAssembly::AccessFromIndexValue => { return emitAccessFromIndexValue[recursive]($v); }
        | SMTAssembly::IsNoneTestValue => { return emitIsNoneTestValue[recursive]($v); }
        | SMTAssembly::IsSomeTestValue => { return emitIsSomeTestValue[recursive]($v); }
        | SMTAssembly::IsTypeTestValue => { return emitIsTypeTestValue[recursive]($v); }
        | SMTAssembly::IsSubtypeTestValue => { return emitIsSubtypeTestValue[recursive]($v); }
        | SMTAssembly::ConvertOptionToSomeTValue => { return emitConvertOptionToSomeTValue[recursive]($v); }
        | SMTAssembly::ConvertResultToOkTValue => { return emitConvertResultToOkTValue[recursive]($v); }
        | SMTAssembly::ConvertResultToFailEValue => { return emitConvertResultToFailEValue[recursive]($v); }
        | SMTAssembly::MethodInvokeStaticValue => { return emitMethodInvokeStaticValue[recursive]($v); }
        | SMTAssembly::UnaryValue => { return emitUnaryValue[recursive]($v); }
        | SMTAssembly::BinaryArithValue => { return emitBinaryArithValue[recursive]($v); }
        | SMTAssembly::BinaryKeyEqValue => { return emitBinaryKeyEqValue[recursive]($v); }
        | SMTAssembly::KeyLessValue => { return emitKeyLessValue($v); }
        | SMTAssembly::BinaryNumericCompareValue => { return emitBinaryNumericCompareValue[recursive]($v); }
        | SMTAssembly::BinLogicValue => { return emitBinLogicValue[recursive]($v); }
        | SMTAssembly::MapEntryConstructorValue => { return emitMapEntryConstructorValue[recursive]($v); }
        | SMTAssembly::IfValue => { return emitIfValue[recursive]($v); }
    }
}

recursive function emitLambdaConstructor(v: SMTAssembly::LambdaConstructor, evv: SMTEmitterEnv): CString {
    let plist = v.params.map<CString>(fn(p) => CString::concat('(', p.pname, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let elambda = SMTEmitterEnv{v.resultType, evv.errtrgt};
    let body = emitOperationBlock[recursive](v.body, elambda, none);

    return CString::concat('(lambda ', pll, ' ', body, ')');
}

recursive function emitCallArgExpression(v: SMTAssembly::CallArgExpression, evv: SMTEmitterEnv): CString {
    match(v)@ {
        SMTAssembly::LambdaConstructor => { return emitLambdaConstructor[recursive]($v, evv); }
        | SMTAssembly::Value => { return emitValue($v); }
    }
}

recursive function emitLambdaInvokeExpression(e: SMTAssembly::LambdaInvokeExpression, evv: SMTEmitterEnv): CString {
    if(e.args.isSingleElement()) {
        return CString::concat('(', e.name, ' ', emitCallArgExpression[recursive](e.args.single(), evv), ')');
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitCallArgExpression[recursive](x, evv));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(select ', e.name, ' ', argsl, ')');
    }
}

recursive function emitCallNamespaceFunctionExpression(e: SMTAssembly::CallNamespaceFunctionExpression, evv: SMTEmitterEnv): CString {
    let fname = SMTNameManager::generateNamespaceFunctionName(e.ns, e.name);
    if(e.args.empty()) {
        return fname;
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitCallArgExpression[recursive](x, evv));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', fname, ' ', argsl, ')');
    }
}

recursive function emitCallTypeFunctionExpression(e: SMTAssembly::CallTypeFunctionExpression, evv: SMTEmitterEnv): CString {
    let fname = SMTNameManager::generateTypeFunctionName(e.resolvedType, e.name);
    if(e.args.empty()) {
        return fname;
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitCallArgExpression[recursive](x, evv));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', fname, ' ', argsl, ')');
    }
}

recursive function emitMethodInvokeStaticExpression(e: SMTAssembly::MethodInvokeStaticExpression, evv: SMTEmitterEnv): CString {
    let fname = SMTNameManager::generateTypeFunctionName(e.resolvedTrgt, e.name);
    let rootv = emitValue(e.rootExp);

    let rpfx = CString::concat(fname, ' ', rootv);
    if(e.args.empty()) {
        return CString::concat('(', rpfx, ')');
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitCallArgExpression[recursive](x, evv));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', rpfx, ' ', argsl, ')');
    }
}

recursive function emitInvokeExpression(e: SMTAssembly::InvokeExpression, evv: SMTEmitterEnv): CString {
    match(e)@ {
        SMTAssembly::LambdaInvokeExpression => { return emitLambdaInvokeExpression[recursive]($e, evv); }
        | SMTAssembly::CallNamespaceFunctionExpression => { return emitCallNamespaceFunctionExpression[recursive]($e, evv); }
        | SMTAssembly::CallTypeFunctionExpression => { return emitCallTypeFunctionExpression[recursive]($e, evv); }
        | SMTAssembly::MethodInvokeStaticExpression => { return emitMethodInvokeStaticExpression[recursive]($e, evv); }
    }
}

function emitReturnValueOperation(e: SMTAssembly::ReturnValueOperation, evv: SMTEmitterEnv): CString {
    let vval = emitValue(e.val);

    if(evv.expectedResultType)<SMTAssembly::DirectResult> {
        return vval;
    }
    else {
        return CString::concat('(@Result-ok ', vval, ')');
    }
}

function emitResultErrTrgtTest(testval: CString, tkey: SMTAssembly::TypeKey): CString {
    return CString::concat('(=', testval, ' (as @Result-errtrgt (@Result ', tkey.value, ')))');
}

function emitResultErrOtherTest(testval: CString, tkey: SMTAssembly::TypeKey): CString {
    return CString::concat('(', testval, ' (as @Result-errother (@Result ', tkey.value, ')))');
}

function emitResultErrTrgtAs(evv: SMTEmitterEnv): CString {
    return CString::concat('(as @Result-errtrgt (@Result ', evv.expectedResultType.rtype.value, '))');
}

function emitResultErrOtherAs(evv: SMTEmitterEnv): CString {
    return CString::concat('(as @Result-errother (@Result ', evv.expectedResultType.rtype.value, '))');
}

function emitResultErrTypeConvert(cval: CString, tkey: SMTAssembly::TypeKey, evv: SMTEmitterEnv): CString {
    let ttest = emitResultErrTrgtTest(cval, tkey);
    let astrgt = emitResultErrTrgtAs(evv);
    let asother = emitResultErrOtherAs(evv);

    let opack = CString::join(' ', ttest, astrgt, asother);
    return CString::concat('(ite ', opack, ')');
}

function emitResultErrTypeConvertAsNeeded(cval: CString, tkey: SMTAssembly::TypeKey, evv: SMTEmitterEnv): CString {
    if(tkey === evv.expectedResultType.rtype) {
        return cval;
    }
    else {
        return emitResultErrTypeConvert(cval, tkey, evv);
    }
}

function emitAbortOperation(e: SMTAssembly::AbortOperation, evv: SMTEmitterEnv): CString {
    if(e.label === evv.errtrgt) {
        return emitResultErrTrgtAs(evv);
    }
    else {
        return emitResultErrOtherAs(evv);
    }
}

recursive function emitIfOperation(e: SMTAssembly::IfOperation, evv: SMTEmitterEnv, indent: Option<CString>): CString {
    let tst = emitValue[recursive](e.iftest);
    let ttst = CString::concat('(ite ', tst);

    if(indent)@none {
        return CString::concat(ttst, ' ', emitOperationBlock[recursive](e.trueOps, evv, none), ' ', emitOperationBlock[recursive](e.falseOps, evv, none), ')');
    }
    else {
        let iident = CString::concat('    ', $indent);
        let tident = CString::concat('%n;', $indent, ')');

        let tv = emitOperationBlock[recursive](e.trueOps, evv, some(iident));
        let fv = emitOperationBlock[recursive](e.falseOps, evv, some(iident));

        return CString::concat(ttst, '%n;', tv, '%n;', fv, tident);
    }
}

recursive function emitTerminalOperation(op: SMTAssembly::TerminalOperation, evv: SMTEmitterEnv, indent: Option<CString>): CString {
    var eexp: CString;
    match(op)@ {
        SMTAssembly::ReturnValueOperation => { eexp = emitReturnValueOperation($op, evv); }
        | SMTAssembly::AbortOperation => { eexp = emitAbortOperation($op, evv); }
        | SMTAssembly::IfOperation => { eexp = emitIfOperation[recursive]($op, evv, indent); }
    }

    if(indent)@none {
        return eexp;
    }
    else {
        return CString::concat($indent, eexp);
    }
}

function doLetIndent(enext: SMTAssembly::FlowOperation): Bool {
    return !\/(enext?<SMTAssembly::LetOperation>, enext?<SMTAssembly::LetWithErrorProcessOperation>);
}

recursive function emitLetOperation(e: SMTAssembly::LetOperation, evv: SMTEmitterEnv, inexp: CString, indent: Option<CString>, nnindent: Bool): CString {
    let vbind = CString::concat('((', e.vname, ' ', emitValue(e.value), '))');

    if(indent)@none {
        return CString::concat('(let ', vbind, ' ', inexp, ')');
    }
    else {
        let tident = if(nnindent) then CString::concat('%n;', $indent, ')') else ')';
        return CString::concat('(let ', vbind, '%n;', inexp, tident);
    }
}

recursive function emitLetWithErrorProcessOperation(e: SMTAssembly::LetWithErrorProcessOperation, evv: SMTEmitterEnv, inexp: CString, indent: Option<CString>): CString {
    let vval = emitInvokeExpression[recursive](e.val, evv);

    let bbind = CString::concat('((', e.tmpvar, ' ', vval, '))');
    let chk = CString::concat('(not ((_ is (@Result-ok ', e.valtype.value, ')) ', e.tmpvar, ')) ');
    let errop = emitResultErrTypeConvertAsNeeded(e.tmpvar, e.valtype, evv);

    let okbind = CString::concat('((', e.bindvar, ' (@Result-value ', e.tmpvar, ')))');

    if(indent)@none {
        let innerop = CString::concat(' (let ', okbind, ' ', inexp, ')');
        let wcheck = CString::concat('(ite ', chk, ' ', errop, innerop, ')');

        return CString::concat('(let ', bbind, ' ', wcheck, ')');
    }
    else {
        let tident = CString::concat('%n;', $indent, ')');

        let innerop = CString::concat(' (let ', okbind, '%n;', inexp, tident);
        let wcheck = CString::concat('(ite ', chk, ' ', errop, innerop, ')');

        return CString::concat('(let ', bbind, ' ', wcheck, ')');
    }
}

recursive function emitAssertOperation(e: SMTAssembly::AssertOperation, evv: SMTEmitterEnv, inexp: CString, indent: Option<CString>): CString {
    let chk = CString::concat('(not ', emitValue(e.cond), ') ');
    let rop = if(e.label === evv.errtrgt) then emitResultErrTrgtAs(evv) else emitResultErrOtherAs(evv);

    if(indent)@none {
        let ops = CString::join(' ', chk, rop, ' ', inexp);
        return CString::concat('(ite ', ops, ')');
    }
    else {
        let tident = CString::concat('%n;', $indent, ')');
        let ops = CString::concat(chk, rop, '%n;', inexp);
        return CString::concat('(ite ', ops, tident);
    }
}

recursive function emitAssumeOperation(e: SMTAssembly::AssumeOperation, evv: SMTEmitterEnv, inexp: CString, indent: Option<CString>): CString {
    let chk = CString::concat('(not ', emitValue(e.cond), ')');
    let rop = emitResultErrOtherAs(evv);

    if(indent)@none {
        let ops = CString::join(' ', chk, rop, ' ', inexp);
        return CString::concat('(ite ', ops, ')');
    }
    else {
        let tident = CString::concat('%n;', $indent, ')');
        let ops = CString::concat(chk, ' ', rop, '%n;', inexp);
        return CString::concat('(ite ', ops, tident);
    }
}

recursive function emitFlowOperation(op: SMTAssembly::FlowOperation, evv: SMTEmitterEnv, inexp: CString, indent: Option<CString>, nnindent: Bool): CString {
    var eexp: CString;
    match(op)@ {
        SMTAssembly::LetOperation => { eexp = emitLetOperation[recursive]($op, evv, inexp, indent, nnindent); }
        | SMTAssembly::LetWithErrorProcessOperation => { eexp = emitLetWithErrorProcessOperation[recursive]($op, evv, inexp, indent); }
        | SMTAssembly::AssertOperation => { eexp = emitAssertOperation[recursive]($op, evv, inexp, indent); }
        | SMTAssembly::AssumeOperation => { eexp = emitAssumeOperation[recursive]($op, evv, inexp, indent); }
    }

    if(indent)@none {
        return eexp;
    }
    else {
        return CString::concat($indent, eexp);
    }
}

recursive function emitOperationBlockStep(ops: List<SMTAssembly::FlowOperation>, iidx: Nat, evv: SMTEmitterEnv, vexp: SMTAssembly::TerminalOperation, indent: Option<CString>): CString {
    if(iidx === ops.size()) {
        return emitTerminalOperation(vexp, evv, indent);
    }
    
    if(indent)@none {
        let inexp = emitOperationBlockStep[recursive](ops, iidx + 1n, evv, vexp, indent);
        return emitFlowOperation[recursive](ops.get(iidx), evv, inexp, indent, false);
    }
    else {
        var iident = $indent;
        var nnindent = false;
        if(iidx >= ops.lastIndex() || doLetIndent(ops.get(iidx + 1n))) {
            iident = CString::concat('    ', $indent);
            nnindent = true;
        }
        
        let inexp = emitOperationBlockStep[recursive](ops, iidx + 1n, evv, vexp, some(iident));
        return emitFlowOperation[recursive](ops.get(iidx), evv, inexp, indent, nnindent);
    }
}

recursive function emitOperationBlock(block: SMTAssembly::OperationBlock, evv: SMTEmitterEnv, indent: Option<CString>): CString {
    return emitOperationBlockStep(block.ops, 0n, evv, block.resop, indent);
}

function emitConstDeclarationHelper(cname: CString, vtype: SMTAssembly::ResultType, value: SMTAssembly::OperationBlock): CString {
    var optconstv = tryGetConstOperation(value);
    var opteagerinit = '';
    if(optconstv)@some {
        opteagerinit = emitConstantValue($optconstv);
    }

    let cdecl = CString::concat('(declare-const ', cname, ' ', vtype.rtype.value, ')');

    if(!opteagerinit.empty()) {
        let cinit = CString::concat('(assert (= ', cname, ' ', opteagerinit, '))');
        return CString::join(' ', cdecl, cinit);
    }
    else {
        if(vtype)<SMTAssembly::DirectResult> {
            return cdecl;
        }
        else {
            let tname = CString::concat(cname, '-cc-temp');
            let ttype = CString::concat('(@Result ', vtype.rtype.value, ')');
            let icompute = CString::concat('(declare-const ', tname, ' ', vtype.rtype.value, ')');

            return CString::join(' ', cdecl, icompute);
        }
    }
}

function emitConstInitializerHelper(cname: CString, vtype: SMTAssembly::ResultType, value: SMTAssembly::OperationBlock): CString {
    let evv = SMTEmitterEnv{vtype, '[NO_CONST_ERRORS]'};
    let cval = emitOperationBlock(value, evv, none);

    if(vtype)<SMTAssembly::DirectResult> {
        return CString::concat('(assert (= ', cname, ' ', cval, '))');
    }
    else {
        let tname = CString::concat(cname, '-cc-temp');
        let tval = CString::concat('(assert (= ', tname, ' ', cval, '))');
        let chk = CString::concat('(assert ((_ is @Result-ok ', vtype.rtype.value, ') ', tname, '))');
        let asgn = CString::concat('(assert (= ', cname, ' (@Result-value', tname, ')))');

        return CString::join('%n;', tval, chk, asgn);
    }
}

%** Return the declarations and definitions as 2 seperate components **%
function emitConstInfo(nsconsts: List<SMTAssembly::NamespaceConstDecl>, typeconsts: List<SMTAssembly::ConstMemberDecl>): CString, CString {
    let nsconstdecls = nsconsts.map<CString>(fn(c) => {
        let cname = SMTNameManager::generateNamespaceConstName(c.ns, c.cname);
        return emitConstDeclarationHelper(cname, c.vtype, c.value);
    });
    let nsconstdecls_str = CString::joinAll('%n;', nsconstdecls);

    let tconstdecls = typeconsts.map<CString>(fn(c) => {
        let cname = SMTNameManager::generateTypeConstName(c.tkey, c.cname);
        return emitConstDeclarationHelper(cname, c.vtype, c.value);    
    });
    let tconstdecls_str = CString::joinAll('%n;', tconstdecls);

    let nsconstinits = nsconsts
        .filter(pred(c) => tryGetConstOperation(c.value)?none)
        .map<CString>(fn(c) => {
            let cname = SMTNameManager::generateNamespaceConstName(c.ns, c.cname);
            return emitConstInitializerHelper(cname, c.vtype, c.value);
        });
    let nsconstinits_str = CString::joinAll('%n;', nsconstinits);

    let tconstinits = typeconsts
        .filter(pred(c) => tryGetConstOperation(c.value)?none)
        .map<CString>(fn(c) => {
            let cname = SMTNameManager::generateTypeConstName(c.tkey, c.cname);
            return emitConstInitializerHelper(cname, c.vtype, c.value);
        });
    let tconstinits_str = CString::joinAll('%n;', tconstinits);

    return tidyNewlineJoin(nsconstdecls_str, tconstdecls_str), tidyNewlineJoin(nsconstinits_str, tconstinits_str);
}

function emitNamespacePredicateFunctionDecl(f: SMTAssembly::NamespacePredicateFunctionDecl): CString {
    let fname = SMTNameManager::generateNamespaceFunctionName(f.ns, f.name);
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    return CString::concat('(declare-fun ', fname, ' ', pll, ' Bool)');
}

function emitNamespaceBuiltinFunctionDecl(f: SMTAssembly::NamespaceBuiltinFunctionDecl, trgterr: CString): CString {
    let fname = SMTNameManager::generateNamespaceFunctionName(f.ns, f.name);
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let psig = CString::concat('define-fun ', fname, ' ', pll, ' ');
    var body: CString;
    if(f.specialname === 'cstring_empty') {
        body = '(= s "")';
    }
    else {
        abort; %%Missing builtin function implementation
    }

    return CString::concat('(', psig, SMTNameManager::generateResultName(f.resultType), ' ', body, ')');
}

function emitNamespaceFunctionDecl(f: SMTAssembly::NamespaceFunctionDecl, trgterr: CString): CString {
    let fname = SMTNameManager::generateNamespaceFunctionName(f.ns, f.name);
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let psig = CString::concat('define-fun ', fname, ' ', pll, ' ');

    let evv = SMTEmitterEnv{f.resultType, trgterr};
    let body = CString::concat('%n;', emitOperationBlock(f.body, evv, some('    ')));

    return CString::concat('(', psig, SMTNameManager::generateResultName(f.resultType), body, '%n;)');
}

function emitTypeFunctionDecl(f: SMTAssembly::TypeFunctionDecl, trgterr: CString): CString {
    let fname = SMTNameManager::generateTypeFunctionName(f.tkey, f.name);
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let psig = CString::concat('define-fun ', fname, ' ', pll, ' ');

    let evv = SMTEmitterEnv{f.resultType, trgterr};
    let body = CString::concat('%n;', emitOperationBlock(f.body, evv, some('    ')));

    return CString::concat('(', psig, SMTNameManager::generateResultName(f.resultType), body, '%n;)');
}

function emitEnumTypeDecl(ttype: SMTAssembly::EnumTypeDecl): CString {
    let tvals = CString::joinAll(' ', ttype.members.map<CString>(fn(v) => CString::concat(ttype.tkey.value, '$$', v)));

    return CString::concat('(declare-datatype ', ttype.tkey.value, ' (', tvals, '))');
}

function emitEnumTypeDecls(ttypes: List<SMTAssembly::EnumTypeDecl>): CString {
    let tdecls = ttypes.map<CString>(fn(t) => emitEnumTypeDecl(t));
    return CString::joinAll('%n;', tdecls);
}

function emitTypedeclTypeDecl(ttype: SMTAssembly::TypedeclTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);
    let consfield = SMTNameManager::generateStructFieldName(ttype.tkey, 'value');

    let cval = CString::concat('(', consfield, ' ', ttype.valuetype.value, ')');
    let vval = CString::concat('(', consname, ' ', cval, ')');

    return CString::concat('(declare-datatype ', ttype.tkey.value, ' ( ', vval, ' ))');
}

function emitTypedeclTypeDeclTermCons(ttype: SMTAssembly::TypedeclTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitTypedeclTypes(ttypes: List<SMTAssembly::TypedeclTypeDecl>): CString, CString {
    let tds = ttypes.map<CString>(fn(t) => emitTypedeclTypeDecl(t));
    let ttcons = ttypes.filter(pred(t) => t.termable).map<CString>(fn(t) => emitTypedeclTypeDeclTermCons(t));

    return CString::joinAll('%n;', tds), CString::joinAll('%n;', ttcons);
}

function emitConstructableTypeDeclDeclaration(ttype: SMTAssembly::ConstructableTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitConstructableTypeDeclConstructor(ttype: SMTAssembly::ConstructableTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);

    var tlist: List<CString>;
    match(ttype)@ {
        SMTAssembly::OkTypeDecl => { 
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.ttype.value, ')'),
            };
        }
        | SMTAssembly::FailTypeDecl => {
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.etype.value, ')'),
            };
        }
        | SMTAssembly::SomeTypeDecl => {
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.vtype.value, ')'),
            };
        }
        | SMTAssembly::MapEntryTypeDecl => {
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'key'), ' ', $ttype.ktype.value, ')'),
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.vtype.value, ')'),
            };
        }
        | _ => {
            tlist = List<CString>{};
        }
    }

    if(tlist.empty()) {
        return CString::concat('        (', consname, ')');
    }
    else {
        let tvals = CString::joinAll(' ', tlist);
        return CString::concat('        (', consname, ' ', tvals, ')');
    }
}

function emitConstructableTypeDeclTermConstructor(ttype: SMTAssembly::ConstructableTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitConstructableTypeDecls(ttypes: List<SMTAssembly::ConstructableTypeDecl>): CString, CString, CString {
   let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitConstructableTypeDeclDeclaration(t)));
   let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitConstructableTypeDeclConstructor(t)));
   let tcons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitConstructableTypeDeclTermConstructor(t)));

   return idecls, cons, tcons;
}

function emitCollectionTypeDeclDeclaration(ttype: SMTAssembly::CollectionTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitCollectionTypeDeclConstructor(ttype: SMTAssembly::CollectionTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);
    let consfield = SMTNameManager::generateStructFieldName(ttype.tkey, 'value');
    let cval = CString::concat('(', consfield, ' (Seq ', ttype.oftype.value, '))');
    return CString::concat('        (', consname, ' ', cval, ')');
}

function emitCollectionTypeDecls(ttypes: List<SMTAssembly::CollectionTypeDecl>): CString, CString {
    let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitCollectionTypeDeclDeclaration(t)));
    let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitCollectionTypeDeclConstructor(t)));
    
    return idecls, cons;
}

function emitEntityTypeDeclDeclaration(ttype: SMTAssembly::EntityTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitEntityTypeDeclConstructor(ttype: SMTAssembly::EntityTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);

    if(ttype.allfields.empty()) {
        return CString::concat('        (', consname, ')');
    }
    else {
        let consfields = ttype.allfields.map<CString>(fn(f) => CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, f.fname), ' ', f.ftype.value, ')'));
        return CString::concat('        (', consname, ' ', CString::joinAll(' ', consfields), ')');
    }
}

function emitEntityTypeDeclTermConstructor(ttype: SMTAssembly::EntityTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitEntityTypeDecls(ttypes: List<SMTAssembly::EntityTypeDecl>): CString, CString, CString {
    let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitEntityTypeDeclDeclaration(t)));
    let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitEntityTypeDeclConstructor(t)));
    let tcons = CString::joinAll('%n;', ttypes.filter(pred(t) => t.termable).map<CString>(fn(t) => emitEntityTypeDeclTermConstructor(t)));

    return idecls, cons, tcons;
}

function emitDatatypeMemberTypeDeclDeclaration(ttype: SMTAssembly::DatatypeMemberEntityTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitDatatypeMemberEntityTypeDeclConstructor(ttype: SMTAssembly::DatatypeMemberEntityTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);

    if(ttype.allfields.empty()) {
        return CString::concat('        (', consname, ')');
    }
    else {
        let consfields = ttype.allfields.map<CString>(fn(f) => CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, f.fname), ' ', f.ftype.value, ')'));
        return CString::concat('        (', consname, ' ', CString::joinAll(' ', consfields), ')');
    }
}

function emitDatatypeMemberEntityTypeDeclTermConstructor(ttype: SMTAssembly::DatatypeMemberEntityTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitDatatypeMemberEntityTypeDecls(ttypes: List<SMTAssembly::DatatypeMemberEntityTypeDecl>): CString, CString, CString {
    let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitDatatypeMemberTypeDeclDeclaration(t)));
    let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitDatatypeMemberEntityTypeDeclConstructor(t)));
    let tcons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitDatatypeMemberEntityTypeDeclTermConstructor(t)));

    return idecls, cons, tcons;
}

function emitSubtypePredicate(ctype: SMTAssembly::TypeKey, subtypes: List<SMTAssembly::TypeKey>): CString {
    let tname = SMTNameManager::generateTermSubtypeFunctionName(ctype);
    
    if(subtypes.empty()) {
        return CString::concat('(define-fun ', tname, '((tt @Term)) Bool false)');
    }
    elif(subtypes.isSingleElement()) {
        return CString::concat('(define-fun ', tname, '((tt @Term)) Bool ((_ is ', subtypes.single().value, ') tt))');
    }
    else {
        let tlist = subtypes.map<CString>(fn(t) => CString::concat('((_ is ', t.value, ') tt)'));
        return CString::concat('(define-fun ', tname, '((tt @Term)) Bool (or ', CString::joinAll(' ', tlist), '))');
    }
}

function emitSpecialOptionSubtypePredicate(otype: SMTAssembly::OptionTypeDecl): CString {
    let tname = SMTNameManager::generateTermSubtypeFunctionName(otype.tkey);
    let tlist = List<CString>{
        CString::concat('((_ is ', otype.someType.value, ') tt)'),
        CString::concat('(= tt @Term-mk-None)'),
    };

    return CString::concat('(define-fun ', tname, '((tt @Term)) Bool (or ', CString::joinAll(' ', tlist), '))');
}

function emitPrimitiveConceptSubtypeChecks(ctype: List<SMTAssembly::PrimitiveConceptTypeDecl>): CString {
    let ccks = ctype.map<CString>(fn(c) => {
        match(c)@{
            SMTAssembly::OptionTypeDecl => {
                return emitSpecialOptionSubtypePredicate($c);
            }
            | SMTAssembly::ResultTypeDecl => {
                return emitSubtypePredicate(c.tkey, List<SMTAssembly::TypeKey>{$c.okType, $c.failType});
            }
            | SMTAssembly::APIResultTypeDecl => {
                return emitSubtypePredicate(c.tkey, List<SMTAssembly::TypeKey>{$c.errorType, $c.failedType, $c.rejectedType, $c.successType});
            }
        }
    });

    return CString::joinAll('%n;', ccks);
}

function emitConceptSubtypeChecks(ctype: List<SMTAssembly::ConceptTypeDecl>): CString {
    let ccks = ctype.map<CString>(fn(c) => emitSubtypePredicate(c.tkey, c.subtypes));
    return CString::joinAll('%n;', ccks);
}

function emitDatatypeSubtypeChecks(ctype: List<SMTAssembly::DatatypeTypeDecl>): CString {
    let ccks = ctype.map<CString>(fn(c) => emitSubtypePredicate(c.tkey, c.subtypes));
    return CString::joinAll('%n;', ccks);
}

function emitAllSubtypeChecks(pconcepts: List<SMTAssembly::PrimitiveConceptTypeDecl>, concepts: List<SMTAssembly::ConceptTypeDecl>, dconcepts: List<SMTAssembly::DatatypeTypeDecl>): CString {
    let pcks = emitPrimitiveConceptSubtypeChecks(pconcepts);
    let ccks = emitConceptSubtypeChecks(concepts);
    let dcks = emitDatatypeSubtypeChecks(dconcepts);

    return CString::joinAll('%n;', List<CString>{pcks, ccks, dcks}.filter(pred(s) => !s.empty()));
}

function emitAssembly(asm: SMTAssembly::Assembly, trgterr: CString): CString {
    let constdecls, constimpls = emitConstInfo(asm.nsconsts, asm.typeconsts);
    let conststr = CString::join('%n;',
        '#BEGIN ;;--GLOBAL_DECLS--;;',
        constdecls,
        '#END ;;--GLOBAL_DECLS--;;',
        '#BEGIN ;;--GLOBAL_IMPLS--;;',
        constimpls,
        '#END ;;--GLOBAL_IMPLS--;;'
    );

    let nspreds = CString::joinAll('%n;', asm.nspreds.map<CString>(fn(f) => emitNamespacePredicateFunctionDecl(f)));
    let nsbuiltins = CString::joinAll('%n;', asm.nsbuiltins.map<CString>(fn(f) => emitNamespaceBuiltinFunctionDecl(f, trgterr)));
    let prestr = CString::join('%n;',
        '#BEGIN ;;--PRE_FUNCS--;;',
        nspreds,
        nsbuiltins,
        '#END ;;--PRE_FUNCS--;;'
    );

    let efuncs_list = asm.allfuncs.map<CString>(fn(t) => {
        if(asm.nsfuncs.has(t)) {
            return emitNamespaceFunctionDecl(asm.nsfuncs.get(t), trgterr);
        }
        else {
            return emitTypeFunctionDecl(asm.typefuncs.get(t), trgterr);
        }
    });
    let efuncs = CString::concat(
        '#BEGIN ;;--FUNCTION_DECLS--;;',
        CString::joinAll('%n;%n;', efuncs_list),
        '#END ;;--FUNCTION_DECLS--;;'
    );
    
    let enum_edcls = emitEnumTypeDecls(asm.enums);
    let typedecl_edcls, typedecl_etcons = emitTypedeclTypes(asm.typedecls);
    let predecls = CString::join('%n;',
        '#BEGIN ;;--ENUM_DECLS--;;',
        enum_edcls,
        '#END ;;--ENUM_DECLS--;;',
        '#BEGIN ;;--TYPEDECL_DECLS--;;',
        typedecl_edcls,
        '#END ;;--TYPEDECL_DECLS--;;'
    );

    let predecl_str = CString::join('%n;', conststr, prestr, predecls);

    let special_edcls, special_econs, special_etcons = emitConstructableTypeDecls(asm.constructables);
    let collection_edcls, collection_econs = emitCollectionTypeDecls(asm.collections);
    let entity_edcls, entity_econs, entity_etcons = emitEntityTypeDecls(asm.entities);
    let datamember_edcls, datamember_econs, datamember_etcons = emitDatatypeMemberEntityTypeDecls(asm.datamembers);

    let stddecls = CString::join('%n;',
        CString::join('%n;',
            '#BEGIN ;;--CONSTRUCTABLE_DECLS--;;',
            special_edcls,
            '#END ;;--CONSTRUCTABLE_DECLS--;;',
            '#BEGIN ;;--COLLECTION_DECLS--;;',
            collection_edcls,
            '#END ;;--COLLECTION_DECLS--;;'
        ),
        CString::join('%n;',
            '#BEGIN ;;--ENTITY_DECLS--;;',
            entity_edcls,
            '#END ;;--ENTITY_DECLS--;;',
            '#BEGIN ;;--DATAMEMBER_DECLS--;;',
            datamember_edcls,
            '#END ;;--DATAMEMBER_DECLS--;;'
        )
    );

    let stdcons = CString::join('%n;',
        CString::join('%n;',
            '#BEGIN ;;--SPECIAL_CONSTRUCTORS--;;',
            special_econs,
            '#END ;;--SPECIAL_CONSTRUCTORS--;;',
            '#BEGIN ;;--COLLECTION_CONSTRUCTORS--;;',
            collection_econs,
            '#END ;;--COLLECTION_CONSTRUCTORS--;;'
        ),
        CString::join('%n;',
            '#BEGIN ;;--ENTITY_CONSTRUCTORS--;;',
            entity_econs,
            '#END ;;--ENTITY_CONSTRUCTORS--;;',
            '#BEGIN ;;--ENTITY_CONSTRUCTORS--;;',
            datamember_econs,
            '#END ;;--ENTITY_CONSTRUCTORS--;;'
        )
    );

    let termcons = CString::join('%n;',
        CString::join('%n;',
            '#BEGIN ;;--TYPEDECL_TERM_CONSTRUCTORS--;;',
            typedecl_etcons,
            '#END ;;--TYPEDECL_TERM_CONSTRUCTORS--;;',
            '#BEGIN ;;--SPECIAL_TERM_CONSTRUCTORS--;;',
            special_etcons,
            '#END ;;--SPECIAL_TERM_CONSTRUCTORS--;;'
        ),
        CString::join('%n;',
            '#BEGIN ;;--ENTITY_TERM_CONSTRUCTORS--;;',
            entity_etcons,
            '#END ;;--ENTITY_TERM_CONSTRUCTORS--;;',
            '#BEGIN ;;--ENTITY_TERM_CONSTRUCTORS--;;',
            datamember_etcons,
            '#END ;;--ENTITY_TERM_CONSTRUCTORS--;;'
        )
    );

    let subchecks = emitAllSubtypeChecks(asm.pconcepts, asm.concepts, asm.datatypes);
    let subchecks_str = CString::join('%n;',
        '#BEGIN ;;--SUBTYPE_PREDICATES--;;',
        subchecks,
        '#END ;;--SUBTYPE_PREDICATES--;;'
    );

    return CString::join('%n;', predecl_str, CString::join('%n;', stddecls, stdcons, termcons), subchecks_str, efuncs);
}
