namespace SMTEmitter;

namespace SMTNameManager {
    function generateStructConstructorName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat(tkey.value, '-mk');
    }

    function generateStructFieldName(tkey: SMTAssembly::TypeKey, vname: CString): CString {
        return CString::concat(tkey.value, '-', vname);
    }

    function generateStructTermConstructorName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat('@Term-', tkey.value, '-mk');
    }

    function generateStructTermFieldName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat('@Term-', tkey.value, '-value');
    }

    function generateNamespaceConstName(ns: SMTAssembly::NamespaceKey, cname: CString): CString {
        return CString::concat(ns.value, '@', cname);
    }

    function generateNamespaceFunctionName(ns: SMTAssembly::NamespaceKey, name: CString): CString {
        return CString::concat(ns.value, '@', name);
    }

    function generateTypeConstName(tkey: SMTAssembly::TypeKey, cname: CString): CString {
        return CString::concat(tkey.value, '@', cname);
    }

    function generateTypeFunctionName(tkey: SMTAssembly::TypeKey, name: CString): CString {
        return CString::concat(tkey.value, '@', name);
    }

    function generateTermSubtypeFunctionName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat('@SubtypeOf-', tkey.value);
    }

    function generateResultName(rtype: SMTAssembly::ResultType): CString {
        if(rtype)@<SMTAssembly::DirectResult> {
            return rtype.rtype.value;
        } else {
            return CString::concat('(@Result ', rtype.rtype.value, ')');
        }
    }
}

const s_ignoreErrTrgt: Nat = 0n;

function cleanOptionalLeadingPlus(vstr: CString): CString {
    return if(vstr.startsWithString('+')) then vstr.removePrefixString('+') else vstr;
}

function tidyNewlineJoin(s1: CString, s2: CString): CString {
    if(s1.empty() && s2.empty()) {
        return '';
    }
    elif(s1.empty()) {
        return s2;
    }
    elif(s2.empty()) {
        return s1;
    }
    else {
        return CString::join('%n;', s1, s2);
    }
}

function tryGetConstOperation(op: SMTAssembly::Operation): Option<SMTAssembly::ConstantExpression> {
    if(op)@<SMTAssembly::ReturnOperation> {
        if($vv = $op.exp)@<SMTAssembly::ConstantExpression> {
            return some($vv);
        }
    }

    return none;
}

function emitTaggedNumericType(nstr: CString, tag: CString): CString {
    return cleanOptionalLeadingPlus(nstr.removeSuffixString(tag));
}

function emitLiteralNoneExpression(): CString {
    return 'none';
}

function emitLiteralSimpleExpression(e: SMTAssembly::LiteralSimpleExpression): CString {
    switch(e.vtype) {
        'Bool'<SMTAssembly::TypeKey>     => { return e.value; }
        | 'Nat'<SMTAssembly::TypeKey>    => { return emitTaggedNumericType(e.value, 'n'); }
        | 'Int'<SMTAssembly::TypeKey>    => { return emitTaggedNumericType(e.value, 'i'); }
        | 'BigNat'<SMTAssembly::TypeKey> => { return emitTaggedNumericType(e.value, 'N'); }
        | 'BigInt'<SMTAssembly::TypeKey> => { return emitTaggedNumericType(e.value, 'I'); }
        | 'Float'<SMTAssembly::TypeKey>  => { return emitTaggedNumericType(e.value, 'f'); }
    }
}

function emitLiteralCStringExpression(e: SMTAssembly::LiteralCStringExpression): CString {
    return CString::concat('"', e.value, '"');
}

function emitLiteralStringExpression(e: SMTAssembly::LiteralStringExpression): CString {
    return CString::concat('"', e.value, '"');
}

function emitLiteralCRegexExpression(e: SMTAssembly::LiteralCRegexExpression): CString {
    %%TODO
    abort;
}

function emitLiteralRegexExpression(e: SMTAssembly::LiteralRegexExpression): CString {
    %%TODO
    abort;
}

function emitConstantExpression(e: SMTAssembly::ConstantExpression): CString {
    match(e)@ {
        SMTAssembly::LiteralNoneExpression => { return emitLiteralNoneExpression(); }
        | SMTAssembly::LiteralSimpleExpression => { return emitLiteralSimpleExpression($e); }
        | SMTAssembly::LiteralCStringExpression => { return emitLiteralCStringExpression($e); }
        | SMTAssembly::LiteralStringExpression => { return emitLiteralStringExpression($e); }
        | SMTAssembly::LiteralCRegexExpression => { return emitLiteralCRegexExpression($e); }
        | SMTAssembly::LiteralRegexExpression => { return emitLiteralRegexExpression($e); }
    }
}

function emitAccessNamespaceConstantExpression(e: SMTAssembly::AccessNamespaceConstantExpression): CString {
    return CString::concat(e.ns.value, '@', e.name);
}

function emitAccessStaticFieldExpression(e: SMTAssembly::AccessStaticFieldExpression): CString {
    return CString::concat(e.tresolved.value, '@', e.name);
}

function emitAccessEnumExpression(e: SMTAssembly::AccessEnumExpression): CString {
    return CString::concat(e.enumtype.value, '$$', e.name);
}

function emitAccessVariableExpression(e: SMTAssembly::AccessVariableExpression): CString {
    return e.vname.value;
}

recursive function emitTermifyExpression(e: SMTAssembly::TermifyExpression): CString {
    let consname = SMTNameManager::generateStructTermConstructorName(e.fromtype);
    let vv = emitExpression[recursive](e.value, SMTEmitter::s_ignoreErrTrgt);
    
    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitUntermifyExpression(e: SMTAssembly::UntermifyExpression): CString {
    let access = SMTNameManager::generateStructTermFieldName(e.intotype);
    let vv = emitExpression[recursive](e.value, SMTEmitter::s_ignoreErrTrgt);
    
    return CString::concat('(', access, ' ', vv, ')');
}
%*
function emitLiteralTypeDeclExpression(v: SMTAssembly::LiteralTypeDeclExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let vv = emitConstantExpression(v.value);

    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitConstructorListSingletonsExpression(v: SMTAssembly::ConstructorListSingletonsExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);

    if(v.args.empty()) {
        let scons = CString::concat('(as seq.empty (Seq ', v.oftype.value, '))');
        return CString::concat('(', consname, ' ', scons, ')');
    }
    else {
        if(v.args.isSingleElement()) {
            let scons = CString::concat('(seq.unit ', emitExpression[recursive](v.args.single()), ')');
            return CString::concat('(', consname, ' ', scons, ')');
        }
        else {
            let cvals = v.args.map[recursive]<CString>(fn(x) => CString::concat('(seq.unit ', emitExpression[recursive](x), ')'));
            let argsl = CString::joinAll(' ', cvals);

            let scons = CString::concat('(seq.++ ', argsl, ')');
            return CString::concat('(', consname, ' ', scons, ')');
        }
    }
}

recursive function emitConstructorMapSingletonsExpression(v: SMTAssembly::ConstructorMapSingletonsExpression): CString {
    %%TODO
    abort;
}

recursive function emitConstructorPrimarySpecialConstructableExpression(v: SMTAssembly::ConstructorPrimarySpecialConstructableExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let vv = emitExpression[recursive](v.arg);

    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitConstructorTypeDeclExpression(v: SMTAssembly::ConstructorTypeDeclExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let vv = emitExpression[recursive](v.arg);

    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitConstructorStdExpression(v: SMTAssembly::ConstructorStdExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    if(v.args.empty()) {
        return consname;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitExpression[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', consname, ' ', argsl, ')');
    }
}

recursive function emitConstructorPrimaryExpression(v: SMTAssembly::ConstructorPrimaryExpression): CString {
    match(v)@ {
        SMTAssembly::ConstructorListSingletonsExpression => { return emitConstructorListSingletonsExpression[recursive]($v); }
        | SMTAssembly::ConstructorMapSingletonsExpression => { return emitConstructorMapSingletonsExpression[recursive]($v); }
        | SMTAssembly::ConstructorPrimarySpecialConstructableExpression => { return emitConstructorPrimarySpecialConstructableExpression[recursive]($v); }
        | SMTAssembly::ConstructorTypeDeclExpression => { return emitConstructorTypeDeclExpression[recursive]($v); }
        | SMTAssembly::ConstructorStdExpression => { return emitConstructorStdExpression[recursive]($v); }
    }
}

recursive function emitConstructorEListExpression(v: SMTAssembly::ConstructorEListExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    if(v.args.empty()) {
        return consname;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitExpression[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', consname, ' ', argsl, ')');
    }
}

recursive function emitCallNamespaceFunctionExpression(v: SMTAssembly::CallNamespaceFunctionExpression): CString {
    let fname = SMTNameManager::generateNamespaceFunctionName(v.ns, v.name);
    if(v.args.empty()) {
        return fname;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitExpression[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', fname, ' ', argsl, ')');
    }
}

recursive function emitCallTypeFunctionExpression(v: SMTAssembly::CallTypeFunctionExpression): CString {
    let fname = SMTNameManager::generateTypeFunctionName(v.resolvedType, v.name);
    if(v.args.empty()) {
        return fname;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitExpression[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', fname, ' ', argsl, ')');
    }
}

recursive function emitLogicActionAndExpression(v: SMTAssembly::LogicActionAndExpression): CString {
    let cvals = v.args.map[recursive]<CString>(fn(x) => emitExpression[recursive](x));
    let argsl = CString::joinAll(' ', cvals);

    return CString::concat('(and ', argsl, ')');
}

recursive function emitLogicActionOrExpression(v: SMTAssembly::LogicActionOrExpression): CString {
    let cvals = v.args.map[recursive]<CString>(fn(x) => emitExpression[recursive](x));
    let argsl = CString::joinAll(' ', cvals);

    return CString::concat('(or ', argsl, ')');
}

recursive function emitUnwrapTypeDeclToPrimitiveExpression(v: SMTAssembly::UnwrapTypeDeclToPrimitiveExpression): CString {
    let access = SMTNameManager::generateStructFieldName(v.decltype, 'value');
    return CString::concat('(', access, ' ', emitExpression(v.arg), ')');
}

recursive function emitAccessFromNameResolvedExpression(v: SMTAssembly::AccessFromNameResolvedExpression): CString {
    let access = SMTNameManager::generateStructFieldName(v.ontype, v.name);
    return CString::concat('(', access, ' ', emitExpression(v.arg), ')');
}

recursive function emitAccessFromIndexExpression(v: SMTAssembly::AccessFromIndexExpression): CString {
    let access = SMTNameManager::generateStructFieldName(v.elisttype, v.idx);
    return CString::concat('(', access, ' ', emitExpression(v.arg), ')');
}

recursive function emitIsNoneTestExpression(v: SMTAssembly::IsNoneTestExpression): CString {
    let vv = emitExpression[recursive](v.arg);
    return CString::concat('(= ', vv, ' @Term-mk-None)');
}

recursive function emitIsSomeTestExpression(v: SMTAssembly::IsSomeTestExpression): CString {
    let vv = emitExpression[recursive](v.arg);
    return CString::concat('(not (= ', vv, ' @Term-mk-None))');
}

recursive function emitIsTypeTestExpression(v: SMTAssembly::IsTypeTestExpression): CString {
    let ccons = SMTNameManager::generateStructTermConstructorName(v.istype);
    let ttchk = CString::concat('(_ is ', ccons, ')');
    let vv = emitExpression[recursive](v.arg);

    %%v is always in term repr to test against term constructor
    return CString::concat('(', ttchk, ' ', vv, ')');
}

recursive function emitIsSubtypeTestExpression(v: SMTAssembly::IsSubtypeTestExpression): CString {
    let subchk = SMTNameManager::generateTermSubtypeFunctionName(v.oftype);
    let vv = emitExpression[recursive](v.arg);

    %%v is always in term repr to test against term constructor
    return CString::concat('(', subchk, ' ', vv, ')');
}

recursive function emitConvertOptionToSomeTExpression(v: SMTAssembly::ConvertOptionToSomeTExpression): CString {
    let ubx = SMTNameManager::generateStructTermFieldName(v.optiontype);
    let extract = SMTNameManager::generateStructFieldName(v.sometype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', emitExpression[recursive](v.arg), ')');
    return CString::concat('(', extract, ' ', ubxop, ')');
}

recursive function emitConvertResultToOkTExpression(v: SMTAssembly::ConvertResultToOkTExpression): CString {
    let ubx = SMTNameManager::generateStructTermFieldName(v.resulttype);
    let extract = SMTNameManager::generateStructFieldName(v.oktype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', emitExpression[recursive](v.arg), ')');
    return CString::concat('(', extract, ' ', ubxop, ')');
}

recursive function emitConvertResultToFailEExpression(v: SMTAssembly::ConvertResultToFailEExpression): CString {
    let ubx = SMTNameManager::generateStructTermFieldName(v.resulttype);
    let extract = SMTNameManager::generateStructFieldName(v.failtype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', emitExpression[recursive](v.arg), ')');
    return CString::concat('(', extract, ' ', ubxop, ')');
}

recursive function emitMethodInvokeStaticExpression(v: SMTAssembly::MethodInvokeStaticExpression): CString {
    let fname = SMTNameManager::generateTypeFunctionName(v.resolvedTrgt, v.name);
    let rootv = emitExpression[recursive](v.rootExp);

    let rpfx = CString::concat(fname, ' ', rootv);
    if(v.args.empty()) {
        return CString::concat('(', rpfx, ')');
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitExpression[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', rpfx, ' ', argsl, ')');
    }
}

recursive function emitPrefixNotOpExpression(v: SMTAssembly::PrefixNotOpExpression): CString {
    let vv = emitExpression[recursive](v.exp);
    return CString::concat('(not ', vv, ')');
}

recursive function emitPrefixNegateOpExpression(v: SMTAssembly::PrefixNegateOpExpression): CString {
    let vv = emitExpression[recursive](v.exp);
    return CString::concat('(- ', vv, ')');
}

recursive function emitPrefixPlusOpExpression(v: SMTAssembly::PrefixPlusOpExpression): CString {
    return emitExpression[recursive](v.exp);
}

recursive function emitUnaryExpression(v: SMTAssembly::UnaryExpression): CString {
    match(v)@ {
        SMTAssembly::PrefixNotOpExpression => { return emitPrefixNotOpExpression[recursive]($v); }
        | SMTAssembly::PrefixNegateOpExpression => { return emitPrefixNegateOpExpression[recursive]($v); }
        | SMTAssembly::PrefixPlusOpExpression => { return emitPrefixPlusOpExpression[recursive]($v); }
    }
}
*%
recursive function emitBinAddExpression(e: SMTAssembly::BinAddExpression): CString {
    let lhs = emitExpression[recursive](e.lhs, SMTEmitter::s_ignoreErrTrgt);
    let rhs = emitExpression[recursive](e.rhs, SMTEmitter::s_ignoreErrTrgt);
    return CString::concat('(+ ', lhs, ' ', rhs, ')');
}

recursive function emitBinSubExpression(e: SMTAssembly::BinSubExpression): CString {
    let lhs = emitExpression[recursive](e.lhs, SMTEmitter::s_ignoreErrTrgt);
    let rhs = emitExpression[recursive](e.rhs, SMTEmitter::s_ignoreErrTrgt);
    return CString::concat('(- ', lhs, ' ', rhs, ')');
}

recursive function emitBinMultExpression(e: SMTAssembly::BinMultExpression): CString {
    let lhs = emitExpression[recursive](e.lhs, SMTEmitter::s_ignoreErrTrgt);
    let rhs = emitExpression[recursive](e.rhs, SMTEmitter::s_ignoreErrTrgt);

    if(e.useUninterpreted) {
        return CString::concat('(@NLA_I_mult ', lhs, ' ', rhs, ')');
    }
    else {
        return CString::concat('(* ', lhs, ' ', rhs, ')');
    }
}

recursive function emitBinDivExpression(e: SMTAssembly::BinDivExpression): CString {
    let lhs = emitExpression[recursive](e.lhs, SMTEmitter::s_ignoreErrTrgt);
    let rhs = emitExpression[recursive](e.rhs, SMTEmitter::s_ignoreErrTrgt);
    
    if(e.useUninterpreted) {
        return CString::concat('(@NLA_I_div ', lhs, ' ', rhs, ')');
    }
    else {
        return CString::concat('(/ ', lhs, ' ', rhs, ')');
    }
}

recursive function emitBinaryArithExpression(e: SMTAssembly::BinaryArithExpression): CString {
    match(e)@ {
        SMTAssembly::BinAddExpression => { return emitBinAddExpression[recursive]($e); }
        | SMTAssembly::BinSubExpression => { return emitBinSubExpression[recursive]($e); }
        | SMTAssembly::BinMultExpression => { return emitBinMultExpression[recursive]($e); }
        | SMTAssembly::BinDivExpression => { return emitBinDivExpression[recursive]($e); }
    }
}
%*
recursive function emitBinKeyEqNoneExpression(v: SMTAssembly::BinKeyEqNoneExpression): CString {
    let vv = emitExpression[recursive](v.exp);
    return CString::concat('(= ', vv, ' @Term-mk-None)');
}

recursive function emitBinKeyNotEqNoneExpression(v: SMTAssembly::BinKeyNotEqNoneExpression): CString {
    let vv = emitExpression[recursive](v.exp);
    return CString::concat('(not (= ', vv, ' @Term-mk-None))');
}

recursive function emitBinKeySomeEqExpression(v: SMTAssembly::BinKeySomeEqExpression): CString {
    let eopt = emitExpression[recursive](v.eoption);
    let val = emitExpression[recursive](v.val);
    
    let ubx = SMTNameManager::generateStructTermFieldName(v.optiontype);
    let extract = SMTNameManager::generateStructFieldName(v.sometype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', eopt, ')');
    let extractop = CString::concat('(', extract, ' ', ubxop, ')');
    let eqop = CString::concat('(= ', extractop, ' ', val, ')');

    let notnoneop = CString::concat('(not (= ', eopt, ' @Term-mk-None))');

    return CString::concat('(and ', notnoneop, ' ', eqop, ')');
}

recursive function emitBinKeyNotSomeEqExpression(v: SMTAssembly::BinKeyNotSomeEqExpression): CString {
    let eopt = emitExpression[recursive](v.eoption);
    let val = emitExpression[recursive](v.val);
    
    let ubx = SMTNameManager::generateStructTermFieldName(v.optiontype);
    let extract = SMTNameManager::generateStructFieldName(v.sometype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', eopt, ')');
    let extractop = CString::concat('(', extract, ' ', ubxop, ')');
    let neqop = CString::concat('(not (= ', extractop, ' ', val, '))');

    let noneop = CString::concat('(= ', eopt, ' @Term-mk-None)');

    return CString::concat('(or ', noneop, ' ', neqop, ')');
}

recursive function emitBinKeyEqExpression(v: SMTAssembly::BinKeyEqExpression): CString {
    let lhs = emitExpression[recursive](v.lhs);
    let rhs = emitExpression[recursive](v.rhs);
    return CString::concat('(= ', lhs, ' ', rhs, ')');
}

recursive function emitBinKeyNotEqExpression(v: SMTAssembly::BinKeyNotEqExpression): CString {
    let lhs = emitExpression[recursive](v.lhs);
    let rhs = emitExpression[recursive](v.rhs);
    return CString::concat('(not (= ', lhs, ' ', rhs, '))');
}

recursive function emitBinaryKeyEqExpression(v: SMTAssembly::BinaryKeyEqExpression): CString {
    match(v)@ {
        SMTAssembly::BinKeyEqNoneExpression => { return emitBinKeyEqNoneExpression[recursive]($v); }
        | SMTAssembly::BinKeyNotEqNoneExpression => { return emitBinKeyNotEqNoneExpression[recursive]($v); }
        | SMTAssembly::BinKeySomeEqExpression => { return emitBinKeySomeEqExpression[recursive]($v); }
        | SMTAssembly::BinKeyNotSomeEqExpression => { return emitBinKeyNotSomeEqExpression[recursive]($v); }
        | SMTAssembly::BinKeyEqExpression => { return emitBinKeyEqExpression[recursive]($v); }
        | SMTAssembly::BinKeyNotEqExpression => { return emitBinKeyNotEqExpression[recursive]($v); }
    }
}

recursive function emitKeyLessExpression(v: SMTAssembly::KeyLessExpression): CString {
    let lhs = emitExpression[recursive](v.lhs);
    let rhs = emitExpression[recursive](v.rhs);

    switch(v.kind) {
        SMTAssembly::KeyLessKind#KeyBool => {return CString::concat('(and (not ', lhs, ') ', rhs, ')'); }
        | SMTAssembly::KeyLessKind#KeyNumber => { return CString::concat('(< ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::KeyLessKind#KeyString => { return CString::concat('(str.< ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::KeyLessKind#KeyUUID => { abort; }
        | SMTAssembly::KeyLessKind#KeyHash => { abort; }
        | SMTAssembly::KeyLessKind#KeyDataInfo => { abort; }
    }
}

recursive function emitBinaryNumericCompareExpression(v: SMTAssembly::BinaryNumericCompareExpression): CString {
    let lhs = emitExpression[recursive](v.lhs);
    let rhs = emitExpression[recursive](v.rhs);

    match(v)@ {
        SMTAssembly::NumericEqExpression => { return CString::concat('(= ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericNeqExpression => { return CString::concat('(not (= ', lhs, ' ', rhs, '))'); }
        | SMTAssembly::NumericLessExpression => { return CString::concat('(< ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericLessEqExpression => { return CString::concat('(<= ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericGreaterExpression => { return CString::concat('(> ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericGreaterEqExpression => { return CString::concat('(>= ', lhs, ' ', rhs, ')'); }
    }
}

recursive function emitBinLogicExpression(v: SMTAssembly::BinLogicExpression): CString {
    let lhs = emitExpression[recursive](v.lhs);
    let rhs = emitExpression[recursive](v.rhs);

    match(v)@ {
        SMTAssembly::BinLogicAndExpression => { return CString::concat('(and ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::BinLogicOrExpression => { return CString::concat('(or ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::BinLogicImpliesExpression => { return CString::concat('(=> ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::BinLogicIFFExpression => { return CString::concat('(= ', lhs, ' ', rhs, ')'); }
    }
}

recursive function emitMapEntryConstructorExpression(v: SMTAssembly::MapEntryConstructorExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let key = emitExpression[recursive](v.kexp);
    let val = emitExpression[recursive](v.vexp);

    let ops = CString::concat(' ', key, ' ', val);
    return CString::concat('(', consname, ops, ')');
}

recursive function emitIfExpression(v: SMTAssembly::IfExpression): CString {
    let tst = emitExpression[recursive](v.iftest);
    let tv = emitExpression[recursive](v.trueExpression);
    let fv = emitExpression[recursive](v.falseExpression);

    let flows = CString::concat(' ', tv, ' ', fv);
    return CString::concat('(ite ', tst, flows, ')');
}
*%
recursive function emitIfThenElseExpression(e: SMTAssembly::IfThenElseExpression, trgterr: Nat): CString {
    let tst = emitExpression[recursive](e.iftest, SMTEmitter::s_ignoreErrTrgt);
    let tv = emitExpression[recursive](e.trueexp, trgterr);
    let fv = emitExpression[recursive](e.falseexp, trgterr);

    let flows = CString::concat(' ', tv, ' ', fv);
    return CString::concat('(ite ', tst, flows, ')');
}

recursive function emitExpression(e: SMTAssembly::Expression, trgterr: Nat): CString {
    match(e)@ {
        SMTAssembly::ConstantExpression => { return emitConstantExpression($e); }
        | SMTAssembly::AccessNamespaceConstantExpression => { return emitAccessNamespaceConstantExpression($e); }
        | SMTAssembly::AccessStaticFieldExpression => { return emitAccessStaticFieldExpression($e); }
        | SMTAssembly::AccessEnumExpression => { return emitAccessEnumExpression($e); }
        | SMTAssembly::AccessVariableExpression => { return emitAccessVariableExpression($e); }
        | SMTAssembly::TermifyExpression => { return emitTermifyExpression[recursive]($e); }
        | SMTAssembly::UntermifyExpression => { return emitUntermifyExpression[recursive]($e); }
        %*
        | SMTAssembly::LiteralTypeDeclExpression => { return emitLiteralTypeDeclExpression($v); }
        | SMTAssembly::ConstructorPrimaryExpression => { return emitConstructorPrimaryExpression[recursive]($v); }
        | SMTAssembly::ConstructorEListExpression => { return emitConstructorEListExpression[recursive]($v); }
        | SMTAssembly::CallNamespaceFunctionExpression => { return emitCallNamespaceFunctionExpression[recursive]($v); }
        | SMTAssembly::CallTypeFunctionExpression => { return emitCallTypeFunctionExpression[recursive]($v); }
        | SMTAssembly::LogicActionAndExpression => { return emitLogicActionAndExpression[recursive]($v); }
        | SMTAssembly::LogicActionOrExpression => { return emitLogicActionOrExpression[recursive]($v); }
        | SMTAssembly::UnwrapTypeDeclToPrimitiveExpression => { return emitUnwrapTypeDeclToPrimitiveExpression($v); }
        | SMTAssembly::AccessFromNameResolvedExpression => { return emitAccessFromNameResolvedExpression[recursive]($v); }
        | SMTAssembly::AccessFromIndexExpression => { return emitAccessFromIndexExpression[recursive]($v); }
        | SMTAssembly::IsNoneTestExpression => { return emitIsNoneTestExpression[recursive]($v); }
        | SMTAssembly::IsSomeTestExpression => { return emitIsSomeTestExpression[recursive]($v); }
        | SMTAssembly::IsTypeTestExpression => { return emitIsTypeTestExpression[recursive]($v); }
        | SMTAssembly::IsSubtypeTestExpression => { return emitIsSubtypeTestExpression[recursive]($v); }
        | SMTAssembly::ConvertOptionToSomeTExpression => { return emitConvertOptionToSomeTExpression[recursive]($v); }
        | SMTAssembly::ConvertResultToOkTExpression => { return emitConvertResultToOkTExpression[recursive]($v); }
        | SMTAssembly::ConvertResultToFailEExpression => { return emitConvertResultToFailEExpression[recursive]($v); }
        | SMTAssembly::MethodInvokeStaticExpression => { return emitMethodInvokeStaticExpression[recursive]($v); }
        | SMTAssembly::UnaryExpression => { return emitUnaryExpression[recursive]($v); }
        *%
        | SMTAssembly::BinaryArithExpression => { return emitBinaryArithExpression[recursive]($e); }
        %*
        | SMTAssembly::BinaryKeyEqExpression => { return emitBinaryKeyEqExpression[recursive]($v); }
        | SMTAssembly::KeyLessExpression => { return emitKeyLessExpression($v); }
        | SMTAssembly::BinaryNumericCompareExpression => { return emitBinaryNumericCompareExpression[recursive]($v); }
        | SMTAssembly::BinLogicExpression => { return emitBinLogicExpression[recursive]($v); }
        | SMTAssembly::MapEntryConstructorExpression => { return emitMapEntryConstructorExpression[recursive]($v); }
        *%
        | SMTAssembly::IfThenElseExpression => { return emitIfThenElseExpression[recursive]($e, trgterr); }
    }
}
%*
recursive function emitLambdaConstructor(v: SMTAssembly::LambdaConstructor, evv: SMTEmitterEnv): CString {
    let plist = v.params.map<CString>(fn(p) => CString::concat('(', p.pname, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let elambda = SMTEmitterEnv{v.resultType, evv.errtrgt};
    let body = emitOperationBlock[recursive](v.body, elambda, none);

    return CString::concat('(lambda ', pll, ' ', body, ')');
}

recursive function emitCallArgExpression(v: SMTAssembly::CallArgExpression, evv: SMTEmitterEnv): CString {
    match(v)@ {
        SMTAssembly::LambdaConstructor => { return emitLambdaConstructor[recursive]($v, evv); }
        | SMTAssembly::Expression => { return emitExpression($v); }
    }
}

recursive function emitLambdaInvokeExpression(e: SMTAssembly::LambdaInvokeExpression, evv: SMTEmitterEnv): CString {
    if(e.args.isSingleElement()) {
        return CString::concat('(', e.name, ' ', emitCallArgExpression[recursive](e.args.single(), evv), ')');
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitCallArgExpression[recursive](x, evv));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(select ', e.name, ' ', argsl, ')');
    }
}

recursive function emitCallNamespaceFunctionExpression(e: SMTAssembly::CallNamespaceFunctionExpression, evv: SMTEmitterEnv): CString {
    let fname = SMTNameManager::generateNamespaceFunctionName(e.ns, e.name);
    if(e.args.empty()) {
        return fname;
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitCallArgExpression[recursive](x, evv));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', fname, ' ', argsl, ')');
    }
}

recursive function emitCallTypeFunctionExpression(e: SMTAssembly::CallTypeFunctionExpression, evv: SMTEmitterEnv): CString {
    let fname = SMTNameManager::generateTypeFunctionName(e.resolvedType, e.name);
    if(e.args.empty()) {
        return fname;
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitCallArgExpression[recursive](x, evv));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', fname, ' ', argsl, ')');
    }
}

recursive function emitMethodInvokeStaticExpression(e: SMTAssembly::MethodInvokeStaticExpression, evv: SMTEmitterEnv): CString {
    let fname = SMTNameManager::generateTypeFunctionName(e.resolvedTrgt, e.name);
    let rootv = emitExpression(e.rootExp);

    let rpfx = CString::concat(fname, ' ', rootv);
    if(e.args.empty()) {
        return CString::concat('(', rpfx, ')');
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitCallArgExpression[recursive](x, evv));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', rpfx, ' ', argsl, ')');
    }
}

recursive function emitInvokeExpression(e: SMTAssembly::InvokeExpression, evv: SMTEmitterEnv): CString {
    match(e)@ {
        SMTAssembly::LambdaInvokeExpression => { return emitLambdaInvokeExpression[recursive]($e, evv); }
        | SMTAssembly::CallNamespaceFunctionExpression => { return emitCallNamespaceFunctionExpression[recursive]($e, evv); }
        | SMTAssembly::CallTypeFunctionExpression => { return emitCallTypeFunctionExpression[recursive]($e, evv); }
        | SMTAssembly::MethodInvokeStaticExpression => { return emitMethodInvokeStaticExpression[recursive]($e, evv); }
    }
}

function emitReturnExpressionOperation(e: SMTAssembly::ReturnExpressionOperation, evv: SMTEmitterEnv): CString {
    let vval = emitExpression(e.val);

    if(evv.expectedResultType)<SMTAssembly::DirectResult> {
        return vval;
    }
    else {
        return CString::concat('(@Result-ok ', vval, ')');
    }
}

function emitResultErrTrgtTest(testval: CString, tkey: SMTAssembly::TypeKey): CString {
    return CString::concat('(=', testval, ' (as @Result-errtrgt (@Result ', tkey.value, ')))');
}

function emitResultErrOtherTest(testval: CString, tkey: SMTAssembly::TypeKey): CString {
    return CString::concat('(', testval, ' (as @Result-errother (@Result ', tkey.value, ')))');
}

function emitResultErrTrgtAs(evv: SMTEmitterEnv): CString {
    return CString::concat('(as @Result-errtrgt (@Result ', evv.expectedResultType.rtype.value, '))');
}

function emitResultErrOtherAs(evv: SMTEmitterEnv): CString {
    return CString::concat('(as @Result-errother (@Result ', evv.expectedResultType.rtype.value, '))');
}

function emitResultErrTypeConvert(cval: CString, tkey: SMTAssembly::TypeKey, evv: SMTEmitterEnv): CString {
    let ttest = emitResultErrTrgtTest(cval, tkey);
    let astrgt = emitResultErrTrgtAs(evv);
    let asother = emitResultErrOtherAs(evv);

    let opack = CString::join(' ', ttest, astrgt, asother);
    return CString::concat('(ite ', opack, ')');
}

function emitResultErrTypeConvertAsNeeded(cval: CString, tkey: SMTAssembly::TypeKey, evv: SMTEmitterEnv): CString {
    if(tkey === evv.expectedResultType.rtype) {
        return cval;
    }
    else {
        return emitResultErrTypeConvert(cval, tkey, evv);
    }
}

function emitAbortOperation(e: SMTAssembly::AbortOperation, evv: SMTEmitterEnv): CString {
    if(e.label === evv.errtrgt) {
        return emitResultErrTrgtAs(evv);
    }
    else {
        return emitResultErrOtherAs(evv);
    }
}

recursive function emitIfOperation(e: SMTAssembly::IfOperation, evv: SMTEmitterEnv, indent: Option<CString>): CString {
    let tst = emitExpression[recursive](e.iftest);
    let ttst = CString::concat('(ite ', tst);

    if(indent)@none {
        return CString::concat(ttst, ' ', emitOperationBlock[recursive](e.trueOps, evv, none), ' ', emitOperationBlock[recursive](e.falseOps, evv, none), ')');
    }
    else {
        let iident = CString::concat('    ', $indent);
        let tident = CString::concat('%n;', $indent, ')');

        let tv = emitOperationBlock[recursive](e.trueOps, evv, some(iident));
        let fv = emitOperationBlock[recursive](e.falseOps, evv, some(iident));

        return CString::concat(ttst, '%n;', tv, '%n;', fv, tident);
    }
}

recursive function emitTerminalOperation(op: SMTAssembly::TerminalOperation, evv: SMTEmitterEnv, indent: Option<CString>): CString {
    var eexp: CString;
    match(op)@ {
        SMTAssembly::ReturnExpressionOperation => { eexp = emitReturnExpressionOperation($op, evv); }
        | SMTAssembly::AbortOperation => { eexp = emitAbortOperation($op, evv); }
        | SMTAssembly::IfOperation => { eexp = emitIfOperation[recursive]($op, evv, indent); }
    }

    if(indent)@none {
        return eexp;
    }
    else {
        return CString::concat($indent, eexp);
    }
}

function doLetIndent(enext: SMTAssembly::FlowOperation): Bool {
    return !\/(enext?<SMTAssembly::LetOperation>, enext?<SMTAssembly::LetWithErrorProcessOperation>);
}

recursive function emitLetOperation(e: SMTAssembly::LetOperation, evv: SMTEmitterEnv, inexp: CString, indent: Option<CString>, nnindent: Bool): CString {
    let vbind = CString::concat('((', e.vname, ' ', emitExpression(e.value), '))');

    if(indent)@none {
        return CString::concat('(let ', vbind, ' ', inexp, ')');
    }
    else {
        let tident = if(nnindent) then CString::concat('%n;', $indent, ')') else ')';
        return CString::concat('(let ', vbind, '%n;', inexp, tident);
    }
}

recursive function emitLetWithErrorProcessOperation(e: SMTAssembly::LetWithErrorProcessOperation, evv: SMTEmitterEnv, inexp: CString, indent: Option<CString>): CString {
    let vval = emitInvokeExpression[recursive](e.val, evv);

    let bbind = CString::concat('((', e.tmpvar, ' ', vval, '))');
    let chk = CString::concat('(not ((_ is (@Result-ok ', e.valtype.value, ')) ', e.tmpvar, ')) ');
    let errop = emitResultErrTypeConvertAsNeeded(e.tmpvar, e.valtype, evv);

    let okbind = CString::concat('((', e.bindvar, ' (@Result-value ', e.tmpvar, ')))');

    if(indent)@none {
        let innerop = CString::concat(' (let ', okbind, ' ', inexp, ')');
        let wcheck = CString::concat('(ite ', chk, ' ', errop, innerop, ')');

        return CString::concat('(let ', bbind, ' ', wcheck, ')');
    }
    else {
        let tident = CString::concat('%n;', $indent, ')');

        let innerop = CString::concat(' (let ', okbind, '%n;', inexp, tident);
        let wcheck = CString::concat('(ite ', chk, ' ', errop, innerop, ')');

        return CString::concat('(let ', bbind, ' ', wcheck, ')');
    }
}

recursive function emitAssertOperation(e: SMTAssembly::AssertOperation, evv: SMTEmitterEnv, inexp: CString, indent: Option<CString>): CString {
    let chk = CString::concat('(not ', emitExpression(e.cond), ') ');
    let rop = if(e.label === evv.errtrgt) then emitResultErrTrgtAs(evv) else emitResultErrOtherAs(evv);

    if(indent)@none {
        let ops = CString::join(' ', chk, rop, ' ', inexp);
        return CString::concat('(ite ', ops, ')');
    }
    else {
        let tident = CString::concat('%n;', $indent, ')');
        let ops = CString::concat(chk, rop, '%n;', inexp);
        return CString::concat('(ite ', ops, tident);
    }
}

recursive function emitAssumeOperation(e: SMTAssembly::AssumeOperation, evv: SMTEmitterEnv, inexp: CString, indent: Option<CString>): CString {
    let chk = CString::concat('(not ', emitExpression(e.cond), ')');
    let rop = emitResultErrOtherAs(evv);

    if(indent)@none {
        let ops = CString::join(' ', chk, rop, ' ', inexp);
        return CString::concat('(ite ', ops, ')');
    }
    else {
        let tident = CString::concat('%n;', $indent, ')');
        let ops = CString::concat(chk, ' ', rop, '%n;', inexp);
        return CString::concat('(ite ', ops, tident);
    }
}

recursive function emitFlowOperation(op: SMTAssembly::FlowOperation, evv: SMTEmitterEnv, inexp: CString, indent: Option<CString>, nnindent: Bool): CString {
    var eexp: CString;
    match(op)@ {
        SMTAssembly::LetOperation => { eexp = emitLetOperation[recursive]($op, evv, inexp, indent, nnindent); }
        | SMTAssembly::LetWithErrorProcessOperation => { eexp = emitLetWithErrorProcessOperation[recursive]($op, evv, inexp, indent); }
        | SMTAssembly::AssertOperation => { eexp = emitAssertOperation[recursive]($op, evv, inexp, indent); }
        | SMTAssembly::AssumeOperation => { eexp = emitAssumeOperation[recursive]($op, evv, inexp, indent); }
    }

    if(indent)@none {
        return eexp;
    }
    else {
        return CString::concat($indent, eexp);
    }
}

recursive function emitOperationBlockStep(ops: List<SMTAssembly::FlowOperation>, iidx: Nat, evv: SMTEmitterEnv, vexp: SMTAssembly::TerminalOperation, indent: Option<CString>): CString {
    if(iidx === ops.size()) {
        return emitTerminalOperation(vexp, evv, indent);
    }
    
    if(indent)@none {
        let inexp = emitOperationBlockStep[recursive](ops, iidx + 1n, evv, vexp, indent);
        return emitFlowOperation[recursive](ops.get(iidx), evv, inexp, indent, false);
    }
    else {
        var iident = $indent;
        var nnindent = false;
        if(iidx >= ops.lastIndex() || doLetIndent(ops.get(iidx + 1n))) {
            iident = CString::concat('    ', $indent);
            nnindent = true;
        }
        
        let inexp = emitOperationBlockStep[recursive](ops, iidx + 1n, evv, vexp, some(iident));
        return emitFlowOperation[recursive](ops.get(iidx), evv, inexp, indent, nnindent);
    }
}

recursive function emitOperationBlock(block: SMTAssembly::OperationBlock, evv: SMTEmitterEnv, indent: Option<CString>): CString {
    return emitOperationBlockStep(block.ops, 0n, evv, block.resop, indent);
}
*%

function emitReturnOperation(op: SMTAssembly::ReturnOperation, errtrgt: Nat): CString {
    return emitExpression(op.exp, errtrgt);
}

function emitAbortOperation(op: SMTAssembly::AbortOperation, errtrgt: Nat): CString {
    if(op.label === errtrgt) {
        return '@Result-err-trgt';
    }
    else {
        return '@Result-err-other';
    }
}

function emitOperation(op: SMTAssembly::Operation, errtrgt: Nat, indent: Option<CString>): CString {
    var opstr: CString;
    match(op)@ {
        SMTAssembly::ReturnOperation => { opstr = emitReturnOperation($op, errtrgt); }
        | SMTAssembly::AbortOperation => { opstr = emitAbortOperation($op, errtrgt); }
    }

    if(indent)@none {
        return opstr;
    }
    else {
        return CString::concat($indent, opstr);
    }
}

function emitBody(body: SMTAssembly::Body, errtrgt: Nat, indent: Option<CString>): CString {
    return emitOperation(body.op, errtrgt, indent);
}

function emitConstDeclarationHelper(cname: CString, vtype: SMTAssembly::ResultType, op: SMTAssembly::Operation): CString {
    let cdecl = CString::concat('(declare-const ', cname, ' ', vtype.rtype.value, ')');

    var optconstv = tryGetConstOperation(op);
    if(optconstv)@some {
        let cval = emitExpression($optconstv, SMTEmitter::s_ignoreErrTrgt);
        let cinit = CString::concat('(assert (= ', cname, ' ', cval, '))');
        return CString::join(' ', cdecl, cinit);
    }
    else {
        if(vtype)<SMTAssembly::DirectResult> {
            return cdecl;
        }
        else {
            let tname = CString::concat(cname, '-cc-temp');
            let ttype = CString::concat('(@Result ', vtype.rtype.value, ')');
            let icompute = CString::concat('(declare-const ', tname, ' ', vtype.rtype.value, ')');

            return CString::join(' ', cdecl, icompute);
        }
    }
}

function emitConstInitializerHelper(cname: CString, vtype: SMTAssembly::ResultType, body: SMTAssembly::Body): CString {
    let cval = emitBody(body, SMTEmitter::s_ignoreErrTrgt, none);

    if(vtype)<SMTAssembly::DirectResult> {
        return CString::concat('(assert (= ', cname, ' ', cval, '))');
    }
    else {
        let tname = CString::concat(cname, '-cc-temp');
        let tval = CString::concat('(assert (= ', tname, ' ', cval, '))');
        let chk = CString::concat('(assert ((_ is @Result-ok ', vtype.rtype.value, ') ', tname, '))');
        let asgn = CString::concat('(assert (= ', cname, ' (@Result-value', tname, ')))');

        return CString::join('%n;', tval, chk, asgn);
    }
}

%** Return the declarations and definitions as 2 seperate components **%
function emitConstInfo(nsconsts: List<SMTAssembly::NamespaceConstDecl>, typeconsts: List<SMTAssembly::ConstMemberDecl>): CString, CString {
    let nsconstdecls = nsconsts.map<CString>(fn(c) => {
        let cname = SMTNameManager::generateNamespaceConstName(c.ns, c.cname);
        return emitConstDeclarationHelper(cname, c.vtype, c.value.op);
    });
    let nsconstdecls_str = CString::joinAll('%n;', nsconstdecls);

    let tconstdecls = typeconsts.map<CString>(fn(c) => {
        let cname = SMTNameManager::generateTypeConstName(c.tkey, c.cname);
        return emitConstDeclarationHelper(cname, c.vtype, c.value.op);    
    });
    let tconstdecls_str = CString::joinAll('%n;', tconstdecls);

    let nsconstinits = nsconsts
        .filter(pred(c) => tryGetConstOperation(c.value.op)?none)
        .map<CString>(fn(c) => {
            let cname = SMTNameManager::generateNamespaceConstName(c.ns, c.cname);
            return emitConstInitializerHelper(cname, c.vtype, c.value);
        });
    let nsconstinits_str = CString::joinAll('%n;', nsconstinits);

    let tconstinits = typeconsts
        .filter(pred(c) => tryGetConstOperation(c.value.op)?none)
        .map<CString>(fn(c) => {
            let cname = SMTNameManager::generateTypeConstName(c.tkey, c.cname);
            return emitConstInitializerHelper(cname, c.vtype, c.value);
        });
    let tconstinits_str = CString::joinAll('%n;', tconstinits);

    return tidyNewlineJoin(nsconstdecls_str, tconstdecls_str), tidyNewlineJoin(nsconstinits_str, tconstinits_str);
}

function emitNamespacePredicateFunctionDecl(f: SMTAssembly::NamespacePredicateFunctionDecl): CString {
    let fname = SMTNameManager::generateNamespaceFunctionName(f.ns, f.name);
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    return CString::concat('(declare-fun ', fname, ' ', pll, ' Bool)');
}

function emitNamespaceBuiltinFunctionDecl(f: SMTAssembly::NamespaceBuiltinFunctionDecl, trgterr: Nat): CString {
    let fname = SMTNameManager::generateNamespaceFunctionName(f.ns, f.name);
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let psig = CString::concat('define-fun ', fname, ' ', pll, ' ');
    var body: CString;
    if(f.specialname === 'cstring_empty') {
        body = '(= s "")';
    }
    else {
        abort; %%Missing builtin function implementation
    }

    return CString::concat('(', psig, SMTNameManager::generateResultName(f.resultType), ' ', body, ')');
}

function emitNamespaceFunctionDecl(f: SMTAssembly::NamespaceFunctionDecl, trgterr: Nat): CString {
    let fname = SMTNameManager::generateNamespaceFunctionName(f.ns, f.name);
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let psig = CString::concat('define-fun ', fname, ' ', pll, ' ');
    let body = CString::concat('%n;', emitBody(f.body, trgterr, some('    ')));

    return CString::concat('(', psig, SMTNameManager::generateResultName(f.resultType), body, '%n;)');
}

function emitTypeFunctionDecl(f: SMTAssembly::TypeFunctionDecl, trgterr: Nat): CString {
    let fname = SMTNameManager::generateTypeFunctionName(f.tkey, f.name);
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let psig = CString::concat('define-fun ', fname, ' ', pll, ' ');
    let body = CString::concat('%n;', emitBody(f.body, trgterr, some('    ')));

    return CString::concat('(', psig, SMTNameManager::generateResultName(f.resultType), body, '%n;)');
}

function emitEnumTypeDecl(ttype: SMTAssembly::EnumTypeDecl): CString {
    let tvals = CString::joinAll(' ', ttype.members.map<CString>(fn(v) => CString::concat(ttype.tkey.value, '$$', v)));

    return CString::concat('(declare-datatype ', ttype.tkey.value, ' (', tvals, '))');
}

function emitEnumTypeDecls(ttypes: List<SMTAssembly::EnumTypeDecl>): CString {
    let tdecls = ttypes.map<CString>(fn(t) => emitEnumTypeDecl(t));
    return CString::joinAll('%n;', tdecls);
}

function emitTypedeclTypeDecl(ttype: SMTAssembly::TypedeclTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);
    let consfield = SMTNameManager::generateStructFieldName(ttype.tkey, 'value');

    let cval = CString::concat('(', consfield, ' ', ttype.valuetype.value, ')');
    let vval = CString::concat('(', consname, ' ', cval, ')');

    return CString::concat('(declare-datatype ', ttype.tkey.value, ' ( ', vval, ' ))');
}

function emitTypedeclTypeDeclTermCons(ttype: SMTAssembly::TypedeclTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitTypedeclTypes(ttypes: List<SMTAssembly::TypedeclTypeDecl>): CString, CString {
    let tds = ttypes.map<CString>(fn(t) => emitTypedeclTypeDecl(t));
    let ttcons = ttypes.filter(pred(t) => t.termable).map<CString>(fn(t) => emitTypedeclTypeDeclTermCons(t));

    return CString::joinAll('%n;', tds), CString::joinAll('%n;', ttcons);
}

function emitConstructableTypeDeclDeclaration(ttype: SMTAssembly::ConstructableTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitConstructableTypeDeclConstructor(ttype: SMTAssembly::ConstructableTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);

    var tlist: List<CString>;
    match(ttype)@ {
        SMTAssembly::OkTypeDecl => { 
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.ttype.value, ')'),
            };
        }
        | SMTAssembly::FailTypeDecl => {
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.etype.value, ')'),
            };
        }
        | SMTAssembly::SomeTypeDecl => {
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.vtype.value, ')'),
            };
        }
        | SMTAssembly::MapEntryTypeDecl => {
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'key'), ' ', $ttype.ktype.value, ')'),
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.vtype.value, ')'),
            };
        }
        | _ => {
            tlist = List<CString>{};
        }
    }

    if(tlist.empty()) {
        return CString::concat('        (', consname, ')');
    }
    else {
        let tvals = CString::joinAll(' ', tlist);
        return CString::concat('        (', consname, ' ', tvals, ')');
    }
}

function emitConstructableTypeDeclTermConstructor(ttype: SMTAssembly::ConstructableTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitConstructableTypeDecls(ttypes: List<SMTAssembly::ConstructableTypeDecl>): CString, CString, CString {
   let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitConstructableTypeDeclDeclaration(t)));
   let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitConstructableTypeDeclConstructor(t)));
   let tcons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitConstructableTypeDeclTermConstructor(t)));

   return idecls, cons, tcons;
}

function emitCollectionTypeDeclDeclaration(ttype: SMTAssembly::CollectionTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitCollectionTypeDeclConstructor(ttype: SMTAssembly::CollectionTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);
    let consfield = SMTNameManager::generateStructFieldName(ttype.tkey, 'value');
    let cval = CString::concat('(', consfield, ' (Seq ', ttype.oftype.value, '))');
    return CString::concat('        (', consname, ' ', cval, ')');
}

function emitCollectionTypeDecls(ttypes: List<SMTAssembly::CollectionTypeDecl>): CString, CString {
    let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitCollectionTypeDeclDeclaration(t)));
    let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitCollectionTypeDeclConstructor(t)));
    
    return idecls, cons;
}

function emitEntityTypeDeclDeclaration(ttype: SMTAssembly::EntityTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitEntityTypeDeclConstructor(ttype: SMTAssembly::EntityTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);

    if(ttype.allfields.empty()) {
        return CString::concat('        (', consname, ')');
    }
    else {
        let consfields = ttype.allfields.map<CString>(fn(f) => CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, f.fname), ' ', f.ftype.value, ')'));
        return CString::concat('        (', consname, ' ', CString::joinAll(' ', consfields), ')');
    }
}

function emitEntityTypeDeclTermConstructor(ttype: SMTAssembly::EntityTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitEntityTypeDecls(ttypes: List<SMTAssembly::EntityTypeDecl>): CString, CString, CString {
    let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitEntityTypeDeclDeclaration(t)));
    let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitEntityTypeDeclConstructor(t)));
    let tcons = CString::joinAll('%n;', ttypes.filter(pred(t) => t.termable).map<CString>(fn(t) => emitEntityTypeDeclTermConstructor(t)));

    return idecls, cons, tcons;
}

function emitDatatypeMemberTypeDeclDeclaration(ttype: SMTAssembly::DatatypeMemberEntityTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitDatatypeMemberEntityTypeDeclConstructor(ttype: SMTAssembly::DatatypeMemberEntityTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);

    if(ttype.allfields.empty()) {
        return CString::concat('        (', consname, ')');
    }
    else {
        let consfields = ttype.allfields.map<CString>(fn(f) => CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, f.fname), ' ', f.ftype.value, ')'));
        return CString::concat('        (', consname, ' ', CString::joinAll(' ', consfields), ')');
    }
}

function emitDatatypeMemberEntityTypeDeclTermConstructor(ttype: SMTAssembly::DatatypeMemberEntityTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitDatatypeMemberEntityTypeDecls(ttypes: List<SMTAssembly::DatatypeMemberEntityTypeDecl>): CString, CString, CString {
    let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitDatatypeMemberTypeDeclDeclaration(t)));
    let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitDatatypeMemberEntityTypeDeclConstructor(t)));
    let tcons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitDatatypeMemberEntityTypeDeclTermConstructor(t)));

    return idecls, cons, tcons;
}

function emitSubtypePredicate(ctype: SMTAssembly::TypeKey, subtypes: List<SMTAssembly::TypeKey>): CString {
    let tname = SMTNameManager::generateTermSubtypeFunctionName(ctype);
    
    if(subtypes.empty()) {
        return CString::concat('(define-fun ', tname, '((tt @Term)) Bool false)');
    }
    elif(subtypes.isSingleElement()) {
        return CString::concat('(define-fun ', tname, '((tt @Term)) Bool ((_ is ', subtypes.single().value, ') tt))');
    }
    else {
        let tlist = subtypes.map<CString>(fn(t) => CString::concat('((_ is ', t.value, ') tt)'));
        return CString::concat('(define-fun ', tname, '((tt @Term)) Bool (or ', CString::joinAll(' ', tlist), '))');
    }
}

function emitSpecialOptionSubtypePredicate(otype: SMTAssembly::OptionTypeDecl): CString {
    let tname = SMTNameManager::generateTermSubtypeFunctionName(otype.tkey);
    let tlist = List<CString>{
        CString::concat('((_ is ', otype.someType.value, ') tt)'),
        CString::concat('(= tt @Term-mk-None)'),
    };

    return CString::concat('(define-fun ', tname, '((tt @Term)) Bool (or ', CString::joinAll(' ', tlist), '))');
}

function emitPrimitiveConceptSubtypeChecks(ctype: List<SMTAssembly::PrimitiveConceptTypeDecl>): CString {
    let ccks = ctype.map<CString>(fn(c) => {
        match(c)@{
            SMTAssembly::OptionTypeDecl => {
                return emitSpecialOptionSubtypePredicate($c);
            }
            | SMTAssembly::ResultTypeDecl => {
                return emitSubtypePredicate(c.tkey, List<SMTAssembly::TypeKey>{$c.okType, $c.failType});
            }
            | SMTAssembly::APIResultTypeDecl => {
                return emitSubtypePredicate(c.tkey, List<SMTAssembly::TypeKey>{$c.errorType, $c.failedType, $c.rejectedType, $c.successType});
            }
        }
    });

    return CString::joinAll('%n;', ccks);
}

function emitConceptSubtypeChecks(ctype: List<SMTAssembly::ConceptTypeDecl>): CString {
    let ccks = ctype.map<CString>(fn(c) => emitSubtypePredicate(c.tkey, c.subtypes));
    return CString::joinAll('%n;', ccks);
}

function emitDatatypeSubtypeChecks(ctype: List<SMTAssembly::DatatypeTypeDecl>): CString {
    let ccks = ctype.map<CString>(fn(c) => emitSubtypePredicate(c.tkey, c.subtypes));
    return CString::joinAll('%n;', ccks);
}

function emitAllSubtypeChecks(pconcepts: List<SMTAssembly::PrimitiveConceptTypeDecl>, concepts: List<SMTAssembly::ConceptTypeDecl>, dconcepts: List<SMTAssembly::DatatypeTypeDecl>): CString {
    let pcks = emitPrimitiveConceptSubtypeChecks(pconcepts);
    let ccks = emitConceptSubtypeChecks(concepts);
    let dcks = emitDatatypeSubtypeChecks(dconcepts);

    return CString::joinAll('%n;', List<CString>{pcks, ccks, dcks}.filter(pred(s) => !s.empty()));
}

function emitAssembly(asm: SMTAssembly::Assembly, trgterr: Nat): CString {
    let constdecls, constimpls = emitConstInfo(asm.nsconsts, asm.typeconsts);
    let conststr = CString::join('%n;',
        '#BEGIN ;;--GLOBAL_DECLS--;;',
        constdecls,
        '#END ;;--GLOBAL_DECLS--;;',
        '#BEGIN ;;--GLOBAL_IMPLS--;;',
        constimpls,
        '#END ;;--GLOBAL_IMPLS--;;'
    );

    let nspreds = CString::joinAll('%n;', asm.nspreds.map<CString>(fn(f) => emitNamespacePredicateFunctionDecl(f)));
    let nsbuiltins = CString::joinAll('%n;', asm.nsbuiltins.map<CString>(fn(f) => emitNamespaceBuiltinFunctionDecl(f, trgterr)));
    let prestr = CString::join('%n;',
        '#BEGIN ;;--PRE_FUNCS--;;',
        nspreds,
        nsbuiltins,
        '#END ;;--PRE_FUNCS--;;'
    );

    let efuncs_list = asm.allfuncs.map<CString>(fn(t) => {
        if(asm.nsfuncs.has(t)) {
            return emitNamespaceFunctionDecl(asm.nsfuncs.get(t), trgterr);
        }
        else {
            return emitTypeFunctionDecl(asm.typefuncs.get(t), trgterr);
        }
    });
    let efuncs = CString::concat(
        '#BEGIN ;;--FUNCTION_DECLS--;;',
        CString::joinAll('%n;%n;', efuncs_list),
        '#END ;;--FUNCTION_DECLS--;;'
    );
    
    let enum_edcls = emitEnumTypeDecls(asm.enums);
    let typedecl_edcls, typedecl_etcons = emitTypedeclTypes(asm.typedecls);
    let predecls = CString::join('%n;',
        '#BEGIN ;;--ENUM_DECLS--;;',
        enum_edcls,
        '#END ;;--ENUM_DECLS--;;',
        '#BEGIN ;;--TYPEDECL_DECLS--;;',
        typedecl_edcls,
        '#END ;;--TYPEDECL_DECLS--;;'
    );

    let predecl_str = CString::join('%n;', conststr, prestr, predecls);

    let special_edcls, special_econs, special_etcons = emitConstructableTypeDecls(asm.constructables);
    let collection_edcls, collection_econs = emitCollectionTypeDecls(asm.collections);
    let entity_edcls, entity_econs, entity_etcons = emitEntityTypeDecls(asm.entities);
    let datamember_edcls, datamember_econs, datamember_etcons = emitDatatypeMemberEntityTypeDecls(asm.datamembers);

    let stddecls = CString::join('%n;',
        CString::join('%n;',
            '#BEGIN ;;--SPECIAL_DECLS--;;',
            special_edcls,
            '#END ;;--SPECIAL_DECLS--;;',
            '#BEGIN ;;--COLLECTION_DECLS--;;',
            collection_edcls,
            '#END ;;--COLLECTION_DECLS--;;'
        ),
        CString::join('%n;',
            '#BEGIN ;;--ENTITY_DECLS--;;',
            entity_edcls,
            '#END ;;--ENTITY_DECLS--;;',
            '#BEGIN ;;--DATATYPE_DECLS--;;',
            datamember_edcls,
            '#END ;;--DATATYPE_DECLS--;;'
        )
    );

    let stdcons = CString::join('%n;',
        CString::join('%n;',
            '#BEGIN ;;--SPECIAL_CONSTRUCTORS--;;',
            special_econs,
            '#END ;;--SPECIAL_CONSTRUCTORS--;;',
            '#BEGIN ;;--COLLECTION_CONSTRUCTORS--;;',
            collection_econs,
            '#END ;;--COLLECTION_CONSTRUCTORS--;;'
        ),
        CString::join('%n;',
            '#BEGIN ;;--ENTITY_CONSTRUCTORS--;;',
            entity_econs,
            '#END ;;--ENTITY_CONSTRUCTORS--;;',
            '#BEGIN ;;--DATATYPE_CONSTRUCTORS--;;',
            datamember_econs,
            '#END ;;--DATATYPE_CONSTRUCTORS--;;'
        )
    );

    let termcons = CString::join('%n;',
        CString::join('%n;',
            '#BEGIN ;;--TYPEDECL_TERM_CONSTRUCTORS--;;',
            typedecl_etcons,
            '#END ;;--TYPEDECL_TERM_CONSTRUCTORS--;;',
            '#BEGIN ;;--SPECIAL_TERM_CONSTRUCTORS--;;',
            special_etcons,
            '#END ;;--SPECIAL_TERM_CONSTRUCTORS--;;'
        ),
        CString::join('%n;',
            '#BEGIN ;;--ENTITY_TERM_CONSTRUCTORS--;;',
            entity_etcons,
            '#END ;;--ENTITY_TERM_CONSTRUCTORS--;;',
            '#BEGIN ;;--DATATYPE_TERM_CONSTRUCTORS--;;',
            datamember_etcons,
            '#END ;;--DATATYPE_TERM_CONSTRUCTORS--;;'
        )
    );

    let subchecks = emitAllSubtypeChecks(asm.pconcepts, asm.concepts, asm.datatypes);
    let subchecks_str = CString::join('%n;',
        '#BEGIN ;;--SUBTYPE_PREDICATES--;;',
        subchecks,
        '#END ;;--SUBTYPE_PREDICATES--;;'
    );

    return CString::join('%n;', predecl_str, CString::join('%n;', stddecls, stdcons, termcons), subchecks_str, efuncs);
}
