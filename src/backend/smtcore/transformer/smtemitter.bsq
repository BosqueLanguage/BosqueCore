namespace SMTEmitter;

namespace SMTNameManager {
    function generateStructConstructorName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat(tkey.value, '-mk');
    }

    function generateStructFieldName(tkey: SMTAssembly::TypeKey, vname: CString): CString {
        return CString::concat(tkey.value, '-', vname);
    }

    function generateStructTermConstructorName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat('@Term-', tkey.value, '-mk');
    }

    function generateStructTermFieldName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat('@Term-', tkey.value, '-value');
    }

    function generateNamespaceConstName(ns: SMTAssembly::NamespaceKey, cname: CString): CString {
        return CString::concat(ns.value, '@', cname);
    }

    function generateTypeConstName(tkey: SMTAssembly::TypeKey, cname: CString): CString {
        return CString::concat(tkey.value, '@', cname);
    }

    function generateTermSubtypeFunctionName(tkey: SMTAssembly::TypeKey): CString {
        return CString::concat('@SubtypeOf-', tkey.value);
    }

    function generateVirtualFieldAccessorFunctionName(tkey: SMTAssembly::TypeKey, fname: CString): CString {
        return CString::concat('@VField-', tkey.value , '-', fname);
    }

    function generateResultName(rtype: SMTAssembly::ResultType): CString {
        if(rtype)@<SMTAssembly::SafeResult> {
            return rtype.rtype.value;
        } else {
            return CString::concat('(@Result ', rtype.rtype.value, ')');
        }
    }
}

entity SMTEmitterEnv {
    field errtrgt: Nat;
    field restype: SMTAssembly::TypeKey;
}

function cleanOptionalLeadingPlus(vstr: CString): CString {
    return if(vstr.startsWithString('+')) then vstr.removePrefixString('+') else vstr;
}

function tidyNewlineJoin(s1: CString, s2: CString): CString {
    if(s1.empty() && s2.empty()) {
        return '';
    }
    elif(s1.empty()) {
        return s2;
    }
    elif(s2.empty()) {
        return s1;
    }
    else {
        return CString::join('%n;', s1, s2);
    }
}

function tryGetConstOperation(op: SMTAssembly::Operation): Option<SMTAssembly::ConstantExpression> {
    if(op)@<SMTAssembly::ReturnOperation> {
        if($vv = $op.exp)@<SMTAssembly::ConstantExpression> {
            return some($vv);
        }
    }

    return none;
}

function emitResultErrTrgtAs(astype: SMTAssembly::TypeKey): CString {
    return CString::concat('((as @Result-err (@Result ', astype.value, ')) @err-trgt)');
}

function emitResultErrOtherAs(astype: SMTAssembly::TypeKey): CString {
    return CString::concat('((as @Result-err (@Result ', astype.value, ')) @err-other)');
}

function emitTaggedNumericType(nstr: CString, tag: CString): CString {
    return cleanOptionalLeadingPlus(nstr.removeSuffixString(tag));
}

function emitLiteralNoneExpression(): CString {
    return 'none';
}

function emitLiteralSimpleExpression(e: SMTAssembly::LiteralSimpleExpression): CString {
    switch(e.vtype) {
        'Bool'<SMTAssembly::TypeKey>     => { return e.value; }
        | 'Nat'<SMTAssembly::TypeKey>    => { return emitTaggedNumericType(e.value, 'n'); }
        | 'Int'<SMTAssembly::TypeKey>    => { return emitTaggedNumericType(e.value, 'i'); }
        | 'BigNat'<SMTAssembly::TypeKey> => { return emitTaggedNumericType(e.value, 'N'); }
        | 'BigInt'<SMTAssembly::TypeKey> => { return emitTaggedNumericType(e.value, 'I'); }
        | 'Float'<SMTAssembly::TypeKey>  => { return emitTaggedNumericType(e.value, 'f'); }
    }
}

function emitLiteralCCharExpression(e: SMTAssembly::LiteralCCharExpression): CString {
    return CString::concat('"', e.value, '"');
}

function emitLiteralUnicodeCharExpression(e: SMTAssembly::LiteralUnicodeCharExpression): CString {
    return CString::concat('"', e.value, '"');
}

function emitLiteralCStringExpression(e: SMTAssembly::LiteralCStringExpression): CString {
    return CString::concat('"', e.value, '"');
}

function emitLiteralStringExpression(e: SMTAssembly::LiteralStringExpression): CString {
    return CString::concat('"', e.value, '"');
}

function emitLiteralCRegexExpression(e: SMTAssembly::LiteralCRegexExpression): CString {
    return e.smtlib;
}

function emitLiteralRegexExpression(e: SMTAssembly::LiteralRegexExpression): CString {
    return e.smtlib;
}

function emitConstantExpression(e: SMTAssembly::ConstantExpression): CString {
    match(e)@ {
        SMTAssembly::LiteralNoneExpression => { return emitLiteralNoneExpression(); }
        | SMTAssembly::LiteralSimpleExpression => { return emitLiteralSimpleExpression($e); }
        | SMTAssembly::LiteralCCharExpression => { return emitLiteralCCharExpression($e); }
        | SMTAssembly::LiteralUnicodeCharExpression => { return emitLiteralUnicodeCharExpression($e); }
        | SMTAssembly::LiteralCStringExpression => { return emitLiteralCStringExpression($e); }
        | SMTAssembly::LiteralStringExpression => { return emitLiteralStringExpression($e); }
        | SMTAssembly::LiteralCRegexExpression => { return emitLiteralCRegexExpression($e); }
        | SMTAssembly::LiteralRegexExpression => { return emitLiteralRegexExpression($e); }
    }
}

function emitAccessNamespaceConstantExpression(e: SMTAssembly::AccessNamespaceConstantExpression): CString {
    return CString::concat(e.ns.value, '@', e.name);
}

function emitAccessStaticFieldExpression(e: SMTAssembly::AccessStaticFieldExpression): CString {
    return CString::concat(e.tresolved.value, '@', e.name);
}

function emitAccessEnumExpression(e: SMTAssembly::AccessEnumExpression): CString {
    return CString::concat(e.enumtype.value, '$$', e.name);
}

function emitAccessVariableExpression(e: SMTAssembly::AccessVariableExpression): CString {
    return e.vname.value;
}

recursive function emitTermifyExpression(e: SMTAssembly::TermifyExpression, eev: SMTEmitterEnv): CString {
    if(e.fromtype === 'None'<SMTAssembly::TypeKey>) {
        return '@Term-mk-None';
    }
    else {
        let consname = SMTNameManager::generateStructTermConstructorName(e.fromtype);
        let vv = emitSafeExpression[recursive](e.value, eev);
    
        return CString::concat('(', consname, ' ', vv, ')');
    }
}

recursive function emitUntermifyExpression(e: SMTAssembly::UntermifyExpression, eev: SMTEmitterEnv): CString {
    let access = SMTNameManager::generateStructTermFieldName(e.intotype);
    let vv = emitSafeExpression[recursive](e.value, eev);
    
    return CString::concat('(', access, ' ', vv, ')');
}

function emitLiteralTypeDeclExpression(v: SMTAssembly::LiteralTypeDeclExpression): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let vv = emitConstantExpression(v.value);

    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitConstructorListSingletonExpression(v: SMTAssembly::ConstructorListSingletonExpression, eev: SMTEmitterEnv): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);

    if(v.args.empty()) {
        let scons = CString::concat('(as seq.empty (Seq ', v.oftype.value, '))');
        return CString::concat('(', consname, ' ', scons, ')');
    }
    else {
        if(v.args.isSingle()) {
            let scons = CString::concat('(seq.unit ', emitSafeExpression[recursive](v.args.single(), eev), ')');
            return CString::concat('(', consname, ' ', scons, ')');
        }
        else {
            let cvals = v.args.map[recursive]<CString>(fn(x) => CString::concat('(seq.unit ', emitSafeExpression[recursive](x, eev), ')'));
            let argsl = CString::joinAll(' ', cvals);

            let scons = CString::concat('(seq.++ ', argsl, ')');
            return CString::concat('(', consname, ' ', scons, ')');
        }
    }
}

recursive function emitConstructorMapSingletonExpression(v: SMTAssembly::ConstructorMapSingletonExpression, eev: SMTEmitterEnv): CString {
    %%TODO
    abort;
}

recursive function emitConstructorPrimarySpecialConstructableExpression(v: SMTAssembly::ConstructorPrimarySpecialConstructableExpression, eev: SMTEmitterEnv): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let vv = emitSafeExpression[recursive](v.arg, eev);

    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitConstructorTypeDeclExpression(v: SMTAssembly::ConstructorTypeDeclExpression, eev: SMTEmitterEnv): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    let vv = emitSafeExpression[recursive](v.arg, eev);

    return CString::concat('(', consname, ' ', vv, ')');
}

recursive function emitConstructorStdExpression(v: SMTAssembly::ConstructorStdExpression, eev: SMTEmitterEnv): CString {
    let consname = SMTNameManager::generateStructConstructorName(v.constype);
    if(v.args.empty()) {
        return consname;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitSafeExpression[recursive](x, eev));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', consname, ' ', argsl, ')');
    }
}

recursive function emitConstructorPrimaryExpression(v: SMTAssembly::ConstructorPrimaryExpression, eev: SMTEmitterEnv): CString {
    match(v)@ {
        SMTAssembly::ConstructorListSingletonExpression => { return emitConstructorListSingletonExpression[recursive]($v, eev); }
        | SMTAssembly::ConstructorMapSingletonExpression => { return emitConstructorMapSingletonExpression[recursive]($v, eev); }
        | SMTAssembly::ConstructorPrimarySpecialConstructableExpression => { return emitConstructorPrimarySpecialConstructableExpression[recursive]($v, eev); }
        | SMTAssembly::ConstructorTypeDeclExpression => { return emitConstructorTypeDeclExpression[recursive]($v, eev); }
        | SMTAssembly::ConstructorStdExpression => { return emitConstructorStdExpression[recursive]($v, eev); }
    }
}

recursive function emitConstructorEListExpression(v: SMTAssembly::ConstructorEListExpression, eev: SMTEmitterEnv): CString {
    let consname = CString::concat('@EList-', v.args.size().toCString(), '-mk');
    if(v.args.empty()) {
        return consname;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitSafeExpression[recursive](x, eev));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', consname, ' ', argsl, ')');
    }
}

recursive function emitCallForceInlineExpression(v: SMTAssembly::CallForceInlineExpression, eev: SMTEmitterEnv): CString {
    if(v.iname === 'cregex_accepts') {
        let re = emitSafeExpression[recursive](v.args.get(0n), eev);
        let str = emitSafeExpression[recursive](v.args.get(1n), eev);

        return CString::concat('(str.in.re ', str, ' ', re, ')');
    }
    elif(v.iname === 'regex_accepts') {
        let re = emitSafeExpression[recursive](v.args.get(0n), eev);
        let str = emitSafeExpression[recursive](v.args.get(1n), eev);

        return CString::concat('(str.in.re ', str, ' ', re, ')');
    }
    else {
        abort; %% Missing case
    }
}

recursive function emitCallFunctionExpression(v: SMTAssembly::CallFunctionExpression, eev: SMTEmitterEnv): CString {
    if(v.args.empty()) {
        return v.invokeKey.value;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(arg) => emitSafeExpression[recursive](arg, eev));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', v.invokeKey.value, ' ', argsl, ')');
    }
}

recursive function emitCallFunctionSafeExpression(v: SMTAssembly::CallFunctionSafeExpression, eev: SMTEmitterEnv): CString {
    if(v.args.empty()) {
        return v.invokeKey.value;
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(arg) => emitSafeExpression[recursive](arg, eev));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', v.invokeKey.value, ' ', argsl, ')');
    }
}

recursive function emitLambdaConstructor(v: SMTAssembly::LambdaConstructor, eev: SMTEmitterEnv): CString {
    let plist = v.params.map<CString>(fn(p) => CString::concat('(', p.0.value, ' ', p.1.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let elambda = SMTEmitterEnv{eev.errtrgt, v.resultType.rtype};
    let body = emitOperation[recursive](v.body, elambda, none);

    return CString::concat('(lambda ', pll, ' ', body, ')');
}

recursive function emitCallLambdaFunctionExpression(e: SMTAssembly::CallLambdaFunctionExpression, evv: SMTEmitterEnv): CString {
    if(e.args.isSingle()) {
        return CString::concat('(', e.lambda.value, ' ', emitSafeExpression[recursive](e.args.single(), evv), ')');
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitSafeExpression[recursive](x, evv));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(select ', e.lambda.value, ' ', argsl, ')');
    }
}

recursive function emitCallLambdaFunctionSafeExpression(e: SMTAssembly::CallLambdaFunctionSafeExpression, eev: SMTEmitterEnv): CString {
    if(e.args.isSingle()) {
        return CString::concat('(', e.lambda.value, ' ', emitSafeExpression[recursive](e.args.single(), eev), ')');
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitSafeExpression[recursive](x, eev));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(select ', e.lambda.value, ' ', argsl, ')');
    }
}

recursive function emitLogicActionAndExpression(v: SMTAssembly::LogicActionAndExpression, eev: SMTEmitterEnv): CString {
    let cvals = v.args.map[recursive]<CString>(fn(x) => emitSafeExpression[recursive](x, eev));
    let argsl = CString::joinAll(' ', cvals);

    return CString::concat('(and ', argsl, ')');
}

recursive function emitLogicActionOrExpression(v: SMTAssembly::LogicActionOrExpression, eev: SMTEmitterEnv): CString {
    let cvals = v.args.map[recursive]<CString>(fn(x) => emitSafeExpression[recursive](x, eev));
    let argsl = CString::joinAll(' ', cvals);

    return CString::concat('(or ', argsl, ')');
}

recursive function emitUnwrapTypeDeclToPrimitiveExpression(v: SMTAssembly::UnwrapTypeDeclToPrimitiveExpression, eev: SMTEmitterEnv): CString {
    let access = SMTNameManager::generateStructFieldName(v.decltype, 'value');
    return CString::concat('(', access, ' ', emitExpression(v.arg, eev), ')');
}

recursive function emitAccessFromNameResolvedExpression(v: SMTAssembly::AccessFromNameResolvedExpression, eev: SMTEmitterEnv): CString {
    let access = SMTNameManager::generateStructFieldName(v.resolvedType, v.name);
    return CString::concat('(', access, ' ', emitSafeExpression(v.arg, eev), ')');
}

recursive function emitAccessFromNameVirtualExpression(v: SMTAssembly::AccessFromNameVirtualExpression, eev: SMTEmitterEnv): CString {
    let vfaccess = SMTNameManager::generateVirtualFieldAccessorFunctionName(v.declType, v.name);
    return CString::concat('(', vfaccess, ' ', emitSafeExpression(v.arg, eev), ')');
}

recursive function emitAccessFromIndexExpression(v: SMTAssembly::AccessFromIndexExpression, eev: SMTEmitterEnv): CString {
    return CString::concat('(', v.elistkey, ' ', emitExpression(v.arg, eev), ')');
}

recursive function emitValidateResultIsTrueExpression(v: SMTAssembly::ValidateResultIsTrueExpression, eev: SMTEmitterEnv): CString {
    return CString::concat('(= ', emitExpression(v.arg, eev), ' (@Result-ok true))');
}

recursive function emitFormatCheckExpression(v: SMTAssembly::FormatCheckExpression, eev: SMTEmitterEnv): CString {
    let re = v.smtregex;
    let arg = emitSafeExpression[recursive](v.arg, eev);

    return CString::concat('(str.in.re ', arg, ' ', re, ')');
}

recursive function emitValidateAccessContainerSizeExpression(v: SMTAssembly::ValidateAccessContainerSizeExpression, eev: SMTEmitterEnv): CString {
    let gseq = SMTNameManager::generateStructFieldName(v.ontype, 'value');
    let arg = emitSafeExpression[recursive](v.arg, eev);
    let vv = CString::concat('(', gseq, ' ', arg, ')');

    return CString::concat('(<= (seq.len ', vv, ') SMV_LIST_SIZE_MAX)');
}

recursive function emitValidateAccessContainerElementSafeExpression(v: SMTAssembly::ValidateAccessContainerElementSafeExpression, eev: SMTEmitterEnv): CString {
    let gseq = SMTNameManager::generateStructFieldName(v.ontype, 'value');
    let arg = emitSafeExpression[recursive](v.arg, eev);
    let vv = CString::concat('(', gseq, ' ', arg, ')');
    
    let bcheck = CString::concat('(< ', v.index, ' (seq.len ', vv, '))');

    let access = CString::concat('(seq.nth ', vv, ' ', v.index, ')');
    let call = CString::concat('(', v.validateinvoke.value, ' ', access, ')');

    return CString::concat('(and ', bcheck, ' ', call, ')');
}

recursive function emitIsTypeTestExpression(v: SMTAssembly::IsTypeTestExpression, eev: SMTEmitterEnv): CString {
    let tcons = SMTNameManager::generateStructTermConstructorName(v.istype);
    let vv = emitExpression[recursive](v.arg, eev);

    %%v is always in term repr to test against term constructor
    return CString::concat('(is-', tcons, ' ', vv, ')');
}

recursive function emitIsSubtypeTestExpression(v: SMTAssembly::IsSubtypeTestExpression, eev: SMTEmitterEnv): CString {
    let subchk = SMTNameManager::generateTermSubtypeFunctionName(v.oftype);
    let vv = emitExpression[recursive](v.arg, eev);

    return CString::concat('(', subchk, ' ', vv, ')');
}

recursive function emitConvertOptionToSomeTExpression(v: SMTAssembly::ConvertOptionToSomeTExpression, eev: SMTEmitterEnv): CString {
    let ubx = SMTNameManager::generateStructTermFieldName(v.sometype);
    let extract = SMTNameManager::generateStructFieldName(v.sometype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', emitSafeExpression[recursive](v.arg, eev), ')');
    return CString::concat('(', extract, ' ', ubxop, ')');
}

%*
recursive function emitConvertResultToOkTExpression(v: SMTAssembly::ConvertResultToOkTExpression): CString {
    let ubx = SMTNameManager::generateStructTermFieldName(v.resulttype);
    let extract = SMTNameManager::generateStructFieldName(v.oktype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', emitExpression[recursive](v.arg), ')');
    return CString::concat('(', extract, ' ', ubxop, ')');
}

recursive function emitConvertResultToFailEExpression(v: SMTAssembly::ConvertResultToFailEExpression): CString {
    let ubx = SMTNameManager::generateStructTermFieldName(v.resulttype);
    let extract = SMTNameManager::generateStructFieldName(v.failtype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', emitExpression[recursive](v.arg), ')');
    return CString::concat('(', extract, ' ', ubxop, ')');
}

recursive function emitMethodInvokeStaticExpression(v: SMTAssembly::MethodInvokeStaticExpression): CString {
    let fname = SMTNameManager::generateTypeFunctionName(v.resolvedTrgt, v.name);
    let rootv = emitExpression[recursive](v.rootExp);

    let rpfx = CString::concat(fname, ' ', rootv);
    if(v.args.empty()) {
        return CString::concat('(', rpfx, ')');
    }
    else {
        let cvals = v.args.map[recursive]<CString>(fn(x) => emitExpression[recursive](x));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', rpfx, ' ', argsl, ')');
    }
}
*%

recursive function emitPrefixNotOpExpression(v: SMTAssembly::PrefixNotOpExpression, eev: SMTEmitterEnv): CString {
    let vv = emitSafeExpression[recursive](v.exp, eev);
    return CString::concat('(not ', vv, ')');
}

recursive function emitPrefixNegateOpExpression(v: SMTAssembly::PrefixNegateOpExpression, eev: SMTEmitterEnv): CString {
    let vv = emitSafeExpression[recursive](v.exp, eev);
    return CString::concat('(- ', vv, ')');
}

recursive function emitPrefixPlusOpExpression(v: SMTAssembly::PrefixPlusOpExpression, eev: SMTEmitterEnv): CString {
    return emitSafeExpression[recursive](v.exp, eev);
}

recursive function emitUnaryExpression(v: SMTAssembly::UnaryExpression, eev: SMTEmitterEnv): CString {
    match(v)@ {
        SMTAssembly::PrefixNotOpExpression => { return emitPrefixNotOpExpression[recursive]($v, eev); }
        | SMTAssembly::PrefixNegateOpExpression => { return emitPrefixNegateOpExpression[recursive]($v, eev); }
        | SMTAssembly::PrefixPlusOpExpression => { return emitPrefixPlusOpExpression[recursive]($v, eev); }
    }
}

recursive function emitBinAddExpression(e: SMTAssembly::BinAddExpression, eev: SMTEmitterEnv): CString {
    let lhs = emitSafeExpression[recursive](e.lhs, eev);
    let rhs = emitSafeExpression[recursive](e.rhs, eev);
    return CString::concat('(+ ', lhs, ' ', rhs, ')');
}

recursive function emitBinSubExpression(e: SMTAssembly::BinSubExpression, eev: SMTEmitterEnv): CString {
    let lhs = emitSafeExpression[recursive](e.lhs, eev);
    let rhs = emitSafeExpression[recursive](e.rhs, eev);
    return CString::concat('(- ', lhs, ' ', rhs, ')');
}

recursive function emitBinMultExpression(e: SMTAssembly::BinMultExpression, eev: SMTEmitterEnv): CString {
    let lhs = emitSafeExpression[recursive](e.lhs, eev);
    let rhs = emitSafeExpression[recursive](e.rhs, eev);

    return CString::concat('(* ', lhs, ' ', rhs, ')');
}

recursive function emitBinDivExpression(e: SMTAssembly::BinDivExpression, eev: SMTEmitterEnv): CString {
    let lhs = emitSafeExpression[recursive](e.lhs, eev);
    let rhs = emitSafeExpression[recursive](e.rhs, eev);
    
    return CString::concat('(/ ', lhs, ' ', rhs, ')');
}

recursive function emitBinaryArithExpression(e: SMTAssembly::BinaryArithExpression, eev: SMTEmitterEnv): CString {
    match(e)@ {
        SMTAssembly::BinAddExpression => { return emitBinAddExpression[recursive]($e, eev); }
        | SMTAssembly::BinSubExpression => { return emitBinSubExpression[recursive]($e, eev); }
        | SMTAssembly::BinMultExpression => { return emitBinMultExpression[recursive]($e, eev); }
        | SMTAssembly::BinDivExpression => { return emitBinDivExpression[recursive]($e, eev); }
    }
}

recursive function emitBinKeyEqNoneExpression(e: SMTAssembly::BinKeyEqNoneExpression, eev: SMTEmitterEnv): CString {
    let vv = emitSafeExpression[recursive](e.exp, eev);
    return CString::concat('(= ', vv, ' @Term-mk-None)');
}

recursive function emitBinKeyNotEqNoneExpression(e: SMTAssembly::BinKeyNotEqNoneExpression, eev: SMTEmitterEnv): CString {
    let vv = emitSafeExpression[recursive](e.exp, eev);
    return CString::concat('(not (= ', vv, ' @Term-mk-None))');
}

recursive function emitBinKeySomeEqExpression(e: SMTAssembly::BinKeySomeEqExpression, eev: SMTEmitterEnv): CString {
    let eopt = emitSafeExpression[recursive](e.eoption, eev);
    let val = emitSafeExpression[recursive](e.val, eev);
    
    let ubx = SMTNameManager::generateStructTermFieldName(e.sometype);
    let extract = SMTNameManager::generateStructFieldName(e.sometype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', eopt, ')');
    let extractop = CString::concat('(', extract, ' ', ubxop, ')');
    let eqop = CString::concat('(= ', extractop, ' ', val, ')');

    let notnoneop = CString::concat('(not (= ', eopt, ' @Term-mk-None))');

    return CString::concat('(and ', notnoneop, ' ', eqop, ')');
}

recursive function emitBinKeyNotSomeEqExpression(e: SMTAssembly::BinKeyNotSomeEqExpression, eev: SMTEmitterEnv): CString {
    let eopt = emitSafeExpression[recursive](e.eoption, eev);
    let val = emitSafeExpression[recursive](e.val, eev);
    
    let ubx = SMTNameManager::generateStructTermFieldName(e.sometype);
    let extract = SMTNameManager::generateStructFieldName(e.sometype, 'value');

    let ubxop = CString::concat('(', ubx, ' ', eopt, ')');
    let extractop = CString::concat('(', extract, ' ', ubxop, ')');
    let neqop = CString::concat('(not (= ', extractop, ' ', val, '))');

    let noneop = CString::concat('(= ', eopt, ' @Term-mk-None)');

    return CString::concat('(or ', noneop, ' ', neqop, ')');
}

recursive function emitBinKeyEqExpression(e: SMTAssembly::BinKeyEqExpression, eev: SMTEmitterEnv): CString {
    let lhs = emitSafeExpression[recursive](e.lhs, eev);
    let rhs = emitSafeExpression[recursive](e.rhs, eev);
    return CString::concat('(= ', lhs, ' ', rhs, ')');
}

recursive function emitBinKeyNotEqExpression(e: SMTAssembly::BinKeyNotEqExpression, eev: SMTEmitterEnv): CString {
    let lhs = emitSafeExpression[recursive](e.lhs, eev);
    let rhs = emitSafeExpression[recursive](e.rhs, eev);
    return CString::concat('(not (= ', lhs, ' ', rhs, '))');
}

recursive function emitBinaryKeyEqExpression(e: SMTAssembly::BinaryKeyEqExpression, eev: SMTEmitterEnv): CString {
    match(e)@ {
        SMTAssembly::BinKeyEqNoneExpression => { return emitBinKeyEqNoneExpression[recursive]($e, eev); }
        | SMTAssembly::BinKeyNotEqNoneExpression => { return emitBinKeyNotEqNoneExpression[recursive]($e, eev); }
        | SMTAssembly::BinKeySomeEqExpression => { return emitBinKeySomeEqExpression[recursive]($e, eev); }
        | SMTAssembly::BinKeyNotSomeEqExpression => { return emitBinKeyNotSomeEqExpression[recursive]($e, eev); }
        | SMTAssembly::BinKeyEqExpression => { return emitBinKeyEqExpression[recursive]($e, eev); }
        | SMTAssembly::BinKeyNotEqExpression => { return emitBinKeyNotEqExpression[recursive]($e, eev); }
    }
}

recursive function emitKeyLessExpression(e: SMTAssembly::KeyLessExpression, eev: SMTEmitterEnv): CString {
    let lhs = emitSafeExpression[recursive](e.lhs, eev);
    let rhs = emitSafeExpression[recursive](e.rhs, eev);

    switch(e.kind) {
        SMTAssembly::KeyLessKind#KeyBool => {return CString::concat('(and (not ', lhs, ') ', rhs, ')'); }
        | SMTAssembly::KeyLessKind#KeyNumber => { return CString::concat('(< ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::KeyLessKind#KeyString => { return CString::concat('(str.< ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::KeyLessKind#KeyUUID => { abort; }
        | SMTAssembly::KeyLessKind#KeyHash => { abort; }
        | SMTAssembly::KeyLessKind#KeyDataInfo => { abort; }
    }
}

recursive function emitBinaryNumericCompareExpression(e: SMTAssembly::BinaryNumericCompareExpression, eev: SMTEmitterEnv): CString {
    let lhs = emitSafeExpression[recursive](e.lhs, eev);
    let rhs = emitSafeExpression[recursive](e.rhs, eev);

    match(e)@ {
        SMTAssembly::NumericEqExpression => { return CString::concat('(= ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericNeqExpression => { return CString::concat('(not (= ', lhs, ' ', rhs, '))'); }
        | SMTAssembly::NumericLessExpression => { return CString::concat('(< ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericLessEqExpression => { return CString::concat('(<= ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericGreaterExpression => { return CString::concat('(> ', lhs, ' ', rhs, ')'); }
        | SMTAssembly::NumericGreaterEqExpression => { return CString::concat('(>= ', lhs, ' ', rhs, ')'); }
    }
}

recursive function emitMapEntryConstructorExpression(e: SMTAssembly::MapEntryConstructorExpression, eev: SMTEmitterEnv): CString {
    let consname = SMTNameManager::generateStructConstructorName(e.constype);
    let key = emitSafeExpression[recursive](e.kexp, eev);
    let val = emitSafeExpression[recursive](e.vexp, eev);

    let ops = CString::concat(' ', key, ' ', val);
    return CString::concat('(', consname, ops, ')');
}

recursive function emitLetSafeExpression(e: SMTAssembly::LetSafeExpression, eev: SMTEmitterEnv): CString {
    let vbind = CString::concat('((', e.vbind.value, ' ', emitSafeExpression[recursive](e.value, eev), '))');
    let inexp = emitSafeExpression[recursive](e.inexp, eev);
    return CString::concat('(let ', vbind, ' ', inexp, ')');
}

recursive function emitIfThenElseSafeExpression(e: SMTAssembly::IfThenElseSafeExpression, eev: SMTEmitterEnv): CString {
    let tst = emitSafeExpression[recursive](e.iftest, eev);
    let tv = emitSafeExpression[recursive](e.trueexp, eev);
    let fv = emitSafeExpression[recursive](e.falseexp, eev);

    let flows = CString::concat(' ', tv, ' ', fv);
    return CString::concat('(ite ', tst, flows, ')');
}

function emitAbortExpression(e: SMTAssembly::AbortExpression, eev: SMTEmitterEnv): CString {
    if(e.label === eev.errtrgt) {
        return emitResultErrTrgtAs(e.etype);
    }
    else {
        return emitResultErrOtherAs(e.etype);
    }
}

function emitAssertExpression(e: SMTAssembly::AssertExpression, eev: SMTEmitterEnv): CString {
    let exp = emitExpression[recursive](e.inexp, eev);
    
    var err: CString;
    if(e.label == eev.errtrgt) {
        err = emitResultErrTrgtAs(e.etype);
    }
    else {
        err = emitResultErrOtherAs(e.etype);
    }

    var tt: CString;
    var errop: CString;
    if($cexp = e.aexp)@<SMTAssembly::SafeExpression> {
        tt = emitSafeExpression[recursive]($cexp, eev);
        errop = err;
    }
    else {
        let ecc = emitExpression[recursive]($cexp, eev);
        tt = CString::concat('(= ', ecc, ' (@Result-ok true))');

        let fbind = CString::concat('(@failure ', ecc, ')');
        let eprop = SMTEmitter::emitExpectedErrTypeConvertAsNeeded('@failure', 'Bool'<SMTAssembly::TypeKey>, e.etype);
        let eaction = CString::concat('(ite (= @failure (@Result-ok false)) ', err, ' ', eprop, ')');
        errop = CString::concat('(let (', fbind, ') ', eaction, ')');
    }

    let bb = CString::concat('(not ', tt, ') ', errop, ' ', exp);
    return CString::concat('(ite ', bb, ')');
}

function emitAssertSetExpression(e: SMTAssembly::AssertSetExpression, eev: SMTEmitterEnv): CString {
    let exp = emitExpression[recursive](e.inexp, eev);
    return e.aset.lreduce<CString>(exp, fn(expcc, chk) => {
        var err: CString;
        if(chk.1 == eev.errtrgt) {
            err = emitResultErrTrgtAs(e.etype);
        }
        else {
            err = emitResultErrOtherAs(e.etype);
        }
        
        var tt: CString;
        var errop: CString;
        if($cexp = chk.0)@<SMTAssembly::SafeExpression> {
            tt = emitSafeExpression[recursive]($cexp, eev);
            errop = err;
        }
        else {
            let ecc = emitExpression[recursive]($cexp, eev);
            tt = CString::concat('(= ', ecc, ' (@Result-ok true))');

            let fbind = CString::concat('(@failure ', ecc, ')');
            let eprop = SMTEmitter::emitExpectedErrTypeConvertAsNeeded('@failure', 'Bool'<SMTAssembly::TypeKey>, e.etype);
            let eaction = CString::concat('(ite (= @failure (@Result-ok false)) ', err, ' ', eprop, ')');
            errop = CString::concat('(let (', fbind, ') ', eaction, ')');
        }

        let bb = CString::concat('(not ', tt, ') ', errop, ' ', expcc);
        return CString::concat('(ite ', bb, ')');
    });
}

recursive function emitUnwrapFromResultExpression(e: SMTAssembly::UnwrapFromResultExpression, eev: SMTEmitterEnv): CString {
    return CString::concat('(@Result-value ', e.varg.value, ')');
}

recursive function emitWrapIntoResultExpression(e: SMTAssembly::WrapIntoResultExpression, eev: SMTEmitterEnv): CString {
    let vv = emitSafeExpression[recursive](e.arg, eev);
    return CString::concat('(@Result-ok ', vv, ')');
}

recursive function emitConvertResultExpression(e: SMTAssembly::ConvertResultExpression, eev: SMTEmitterEnv): CString {
    abort;
}

recursive function emitIfThenElseExpression(e: SMTAssembly::IfThenElseExpression, eev: SMTEmitterEnv): CString {
    let tst = emitSafeExpression[recursive](e.iftest, eev);
    let tv = emitExpression[recursive](e.trueexp, eev);
    let fv = emitExpression[recursive](e.falseexp, eev);

    let flows = CString::concat(' ', tv, ' ', fv);
    return CString::concat('(ite ', tst, flows, ')');
}

recursive function emitLetGeneralExpression(e: SMTAssembly::LetGeneralExpression, eev: SMTEmitterEnv): CString {
    let vbind = CString::concat('((', e.vbind.value, ' ', emitSafeExpression[recursive](e.value, eev), '))');
    let inexp = emitExpression[recursive](e.inexp, eev);
    return CString::concat('(let ', vbind, ' ', inexp, ')');
}

recursive function emitLetWErrorsExpression(e: SMTAssembly::LetWErrorsExpression, eev: SMTEmitterEnv): CString {
    let iiexp = emitExpression[recursive](e.inexp, eev);
    let lbs = e.vvbind.lreduce<CString>(iiexp, fn(acc, vb) => {
        let vbind = CString::concat('((', vb.2.value, ' ', emitExpression[recursive](vb.0, eev), '))');
        let chk = CString::concat('(not (is-@Result-ok ', vb.2.value, ')) ');

        let errop = emitExpectedErrTypeConvertAsNeeded(vb.2.value, vb.1, e.errtype);

        let wcheck = CString::concat('(ite ', chk, errop, ' ', acc, ')');
        return CString::concat('(let ', vbind, ' ', wcheck, ')');
    });

    return lbs;
}

recursive function emitSafeExpression(e: SMTAssembly::SafeExpression, eev: SMTEmitterEnv): CString {
    match(e)@ {
        SMTAssembly::ConstantExpression => { return emitConstantExpression($e); }
        | SMTAssembly::AccessNamespaceConstantExpression => { return emitAccessNamespaceConstantExpression($e); }
        | SMTAssembly::AccessStaticFieldExpression => { return emitAccessStaticFieldExpression($e); }
        | SMTAssembly::AccessEnumExpression => { return emitAccessEnumExpression($e); }
        | SMTAssembly::AccessVariableExpression => { return emitAccessVariableExpression($e); }
        | SMTAssembly::TermifyExpression => { return emitTermifyExpression[recursive]($e, eev); }
        | SMTAssembly::UntermifyExpression => { return emitUntermifyExpression[recursive]($e, eev); }
        | SMTAssembly::LiteralTypeDeclExpression => { return emitLiteralTypeDeclExpression($e); }
        | SMTAssembly::ConstructorPrimaryExpression => { return emitConstructorPrimaryExpression[recursive]($e, eev); }
        | SMTAssembly::ConstructorEListExpression => { return emitConstructorEListExpression[recursive]($e, eev); }
        | SMTAssembly::LambdaConstructor => { return emitLambdaConstructor[recursive]($e, eev); }
        | SMTAssembly::CallForceInlineExpression => { return emitCallForceInlineExpression[recursive]($e, eev); }
        | SMTAssembly::CallFunctionSafeExpression => { return emitCallFunctionSafeExpression[recursive]($e, eev); }
        | SMTAssembly::CallLambdaFunctionSafeExpression => { return emitCallLambdaFunctionSafeExpression[recursive]($e, eev); }
        | SMTAssembly::LogicActionAndExpression => { return emitLogicActionAndExpression[recursive]($e, eev); }
        | SMTAssembly::LogicActionOrExpression => { return emitLogicActionOrExpression[recursive]($e, eev); }
        | SMTAssembly::UnwrapTypeDeclToPrimitiveExpression => { return emitUnwrapTypeDeclToPrimitiveExpression($e, eev); }
        | SMTAssembly::AccessFromNameResolvedExpression => { return emitAccessFromNameResolvedExpression[recursive]($e, eev); }
        | SMTAssembly::AccessFromNameVirtualExpression => { return emitAccessFromNameVirtualExpression[recursive]($e, eev); }
        | SMTAssembly::AccessFromIndexExpression => { return emitAccessFromIndexExpression[recursive]($e, eev); }
        | SMTAssembly::ValidateResultIsTrueExpression => { return emitValidateResultIsTrueExpression[recursive]($e, eev); }
        | SMTAssembly::FormatCheckExpression => { return emitFormatCheckExpression[recursive]($e, eev); }
        | SMTAssembly::ValidateAccessContainerSizeExpression => { return emitValidateAccessContainerSizeExpression[recursive]($e, eev); }
        | SMTAssembly::ValidateAccessContainerElementSafeExpression => { return emitValidateAccessContainerElementSafeExpression[recursive]($e, eev); }
        | SMTAssembly::IsTypeTestExpression => { return emitIsTypeTestExpression[recursive]($e, eev); }
        | SMTAssembly::IsSubtypeTestExpression => { return emitIsSubtypeTestExpression[recursive]($e, eev); }
        | SMTAssembly::ConvertOptionToSomeTExpression => { return emitConvertOptionToSomeTExpression[recursive]($e, eev); }
        %*
        | SMTAssembly::ConvertResultToOkTExpression => { return emitConvertResultToOkTExpression[recursive]($v); }
        | SMTAssembly::ConvertResultToFailEExpression => { return emitConvertResultToFailEExpression[recursive]($v); }
        *%
        | SMTAssembly::UnaryExpression => { return emitUnaryExpression[recursive]($e, eev); }
        | SMTAssembly::BinaryArithExpression => { return emitBinaryArithExpression[recursive]($e, eev); }
        | SMTAssembly::BinaryKeyEqExpression => { return emitBinaryKeyEqExpression[recursive]($e, eev); }
        | SMTAssembly::KeyLessExpression => { return emitKeyLessExpression[recursive]($e, eev); }
        | SMTAssembly::BinaryNumericCompareExpression => { return emitBinaryNumericCompareExpression[recursive]($e, eev); }
        | SMTAssembly::MapEntryConstructorExpression => { return emitMapEntryConstructorExpression[recursive]($e, eev); }
        | SMTAssembly::LetSafeExpression => { return emitLetSafeExpression[recursive]($e, eev); }
        | SMTAssembly::IfThenElseSafeExpression => { return emitIfThenElseSafeExpression[recursive]($e, eev); }
        | SMTAssembly::UnwrapFromResultExpression => { return emitUnwrapFromResultExpression[recursive]($e, eev); }
        | SMTAssembly::WrapIntoResultExpression => { return emitWrapIntoResultExpression[recursive]($e, eev); }
    }
}

recursive function emitExpression(e: SMTAssembly::Expression, eev: SMTEmitterEnv): CString {
    match(e)@ {
        SMTAssembly::AbortExpression => { return emitAbortExpression($e, eev); }
        | SMTAssembly::AssertExpression => { return emitAssertExpression($e, eev); }
        | SMTAssembly::AssertSetExpression => { return emitAssertSetExpression($e, eev); }
        | SMTAssembly::ConvertResultExpression => { return emitConvertResultExpression[recursive]($e, eev); }
        | SMTAssembly::LetGeneralExpression => { return emitLetGeneralExpression[recursive]($e, eev); }
        | SMTAssembly::LetWErrorsExpression => { return emitLetWErrorsExpression[recursive]($e, eev); }
        | SMTAssembly::IfThenElseExpression => { return emitIfThenElseExpression[recursive]($e, eev); }
        | SMTAssembly::CallFunctionExpression => { return emitCallFunctionExpression[recursive]($e, eev); }
        | SMTAssembly::CallLambdaFunctionExpression => { return emitCallLambdaFunctionExpression[recursive]($e, eev); }
        %*
        | SMTAssembly::MethodInvokeStaticExpression => { return emitMethodInvokeStaticExpression[recursive]($v); }
        *%
        | SMTAssembly::SafeExpression => { return emitSafeExpression[recursive]($e, eev); }
    }
}

%*
recursive function emitMethodInvokeStaticExpression(e: SMTAssembly::MethodInvokeStaticExpression, evv: SMTEmitterEnv): CString {
    let fname = SMTNameManager::generateTypeFunctionName(e.resolvedTrgt, e.name);
    let rootv = emitExpression(e.rootExp);

    let rpfx = CString::concat(fname, ' ', rootv);
    if(e.args.empty()) {
        return CString::concat('(', rpfx, ')');
    }
    else {
        let cvals = e.args.map[recursive]<CString>(fn(x) => emitCallArgExpression[recursive](x, evv));
        let argsl = CString::joinAll(' ', cvals);

        return CString::concat('(', rpfx, ' ', argsl, ')');
    }
}
*%

function emitResultErrTypeConvert(cval: CString, tkey: SMTAssembly::TypeKey, ekey: SMTAssembly::TypeKey): CString {
    let access = CString::concat('(@Result-etag ', cval, ')');
    return CString::concat('((as @Result-err (@Result ', ekey.value, ')) ', access, ')');
}

function emitResultErrTypeConvertAsNeeded(cval: CString, tkey: SMTAssembly::TypeKey, eev: SMTEmitterEnv): CString {
    %%TODO: here is where we eventually want to do the trgt, other, any conversions too

    if(tkey === eev.restype) {
        return cval;
    }
    else {
        return emitResultErrTypeConvert(cval, tkey, eev.restype);
    }
}

function emitExpectedErrTypeConvertAsNeeded(cval: CString, tkey: SMTAssembly::TypeKey, ekey: SMTAssembly::TypeKey): CString {
    %%TODO: here is where we eventually want to do the trgt, other, any conversions too

    if(tkey === ekey) {
        return cval;
    }
    else {
        return emitResultErrTypeConvert(cval, tkey, ekey);
    }
}

recursive function emitIfThenElseOperation(e: SMTAssembly::IfThenElseOperation, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    let tst = emitSafeExpression[recursive](e.iftest, eev);
    let ttst = CString::concat('(ite ', tst);

    if(indent)@none {
        return CString::concat(ttst, ' ', emitOperation[recursive](e.trueop, eev, none), ' ', emitOperation[recursive](e.falseop, eev, none), ')');
    }
    else {
        let iident = CString::concat('    ', $indent);
        let tident = CString::concat('%n;', $indent, ')');

        let tv = emitOperation[recursive](e.trueop, eev, some(iident));
        let fv = emitOperation[recursive](e.falseop, eev, some(iident));

        return CString::concat(ttst, '%n;', tv, '%n;', fv, tident);
    }
}

recursive function emitMatchOperation(e: SMTAssembly::MatchOperation, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    let tst = emitSafeExpression[recursive](e.matchexp, eev);
    let ttst = CString::concat('(match ', tst);

    if(indent)@none {
        var cases = e.cases.map[recursive]<CString>(fn(c) => {
            let ttest = SMTNameManager::generateStructTermConstructorName(c.0);
            let cbody = emitOperation[recursive](c.1, eev, none);
            return CString::concat('(', ttest, ' ', cbody, ')');
        });

        if($dop = e.defaultop)@some {
            let defop = emitOperation[recursive]($dop, eev, none);
            cases = cases.pushBack(CString::concat('(_ ', defop, ')'));
        }

        let casesl = CString::joinAll(' ', cases);
        return CString::concat(ttst, ' ', casesl, ')');
    }
    else {
        let iident = CString::concat('    ', $indent);
        let tident = CString::concat('%n;', $indent, '))');

        var cases = e.cases.map[recursive]<CString>(fn(c) => {
            let ttest = SMTNameManager::generateStructTermConstructorName(c.0);
            let cbody = emitOperation[recursive](c.1, eev, none);
            return CString::concat(iident, '(', ttest, ' ', cbody, ')');
        });

        if($dop = e.defaultop)@some {
            let defop = emitOperation[recursive]($dop, eev, none);
            cases = cases.pushBack(CString::concat(iident, '(_ ', defop, ')'));
        }

        let casesl = CString::joinAll('%n;', cases);
        return CString::concat(ttst, ' (%n;', casesl, tident);
    }
}

function emitReturnOperation(op: SMTAssembly::ReturnOperation, eev: SMTEmitterEnv): CString {
    return emitExpression(op.exp, eev);
}

function emitAbortOperation(op: SMTAssembly::AbortOperation, eev: SMTEmitterEnv): CString {
    if(op.label === eev.errtrgt) {
        return emitResultErrTrgtAs(eev.restype);
    }
    else {
        return emitResultErrOtherAs(eev.restype);
    }
}

recursive function emitAssertOperation(e: SMTAssembly::AssertOperation, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    var err: CString;
    if(e.label == eev.errtrgt) {
        err = emitResultErrTrgtAs(eev.restype);
    }
    else {
        err = emitResultErrOtherAs(eev.restype);
    }
    
    var tt: CString;
    var errop: CString;
    if($cexp = e.cond)@<SMTAssembly::SafeExpression> {
        tt = emitSafeExpression[recursive]($cexp, eev);
        errop = err;
    }
    else {
        let ecc = emitExpression[recursive]($cexp, eev);
        tt = CString::concat('(= ', ecc, ' (@Result-ok true))');

        let fbind = CString::concat('(@failure ', ecc, ')');
        let eprop = SMTEmitter::emitResultErrTypeConvertAsNeeded('@failure', 'Bool'<SMTAssembly::TypeKey>, eev);
        let eaction = CString::concat('(ite (= @failure (@Result-ok false)) ', err, ' ', eprop, ')');
        errop = CString::concat('(let (', fbind, ') ', eaction, ')');
    }

    let chk = CString::concat('(not ', tt, ') ');

    if(indent)@none {
        let inexp = emitOperation[recursive](e.inop, eev, none);
        let ops = CString::join(' ', chk, errop, ' ', inexp);
        return CString::concat('(ite ', ops, ')');
    }
    else {
        let iident = CString::concat('    ', $indent);
        let tident = CString::concat('%n;', $indent, ')');

        let inexp = emitOperation[recursive](e.inop, eev, some(iident));
        let ops = CString::concat(chk, errop, '%n;', inexp);
        return CString::concat('(ite ', ops, tident);
    }
}

recursive function emitAssumeOperation(e: SMTAssembly::AssumeOperation, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    let err: CString = emitResultErrOtherAs(eev.restype);
    
    var tt: CString;
    var errop: CString;
    if($cexp = e.cond)@<SMTAssembly::SafeExpression> {
        tt = emitSafeExpression[recursive]($cexp, eev);
        errop = err;
    }
    else {
        let ecc = emitExpression[recursive]($cexp, eev);
        tt = CString::concat('(= ', ecc, ' (@Result-ok true))');

        let fbind = CString::concat('(@failure ', ecc, ')');
        let eprop = SMTEmitter::emitResultErrTypeConvertAsNeeded('@failure', 'Bool'<SMTAssembly::TypeKey>, eev);
        let eaction = CString::concat('(ite (= @failure (@Result-ok false)) ', err, ' ', eprop, ')');
        errop = CString::concat('(let (', fbind, ') ', eaction, ')');
    }
    
    let chk = CString::concat('(not ', tt, ') ');

    if(indent)@none {
        let inexp = emitOperation[recursive](e.inop, eev, none);
        let ops = CString::join(' ', chk, errop, ' ', inexp);
        return CString::concat('(ite ', ops, ')');
    }
    else {
        let iident = CString::concat('    ', $indent);
        let tident = CString::concat('%n;', $indent, ')');

        let inexp = emitOperation[recursive](e.inop, eev, some(iident));
        let ops = CString::concat(chk, errop, '%n;', inexp);
        return CString::concat('(ite ', ops, tident);
    }
}

function doLetIndent(enext: SMTAssembly::Operation): Bool {
    return !\/(enext?<SMTAssembly::LetOperation>, enext?<SMTAssembly::LetsOperation>, enext?<SMTAssembly::LetOperationWError>, enext?<SMTAssembly::LetWErrorsOperation>);
}

recursive function emitLetOperation(e: SMTAssembly::LetOperation, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    let vbind = CString::concat('((', e.vbind.value, ' ', emitSafeExpression(e.value, eev), '))');

    if(indent)@none {
        let inexp = emitOperation[recursive](e.inop, eev, none);
        return CString::concat('(let ', vbind, ' ', inexp, ')');
    }
    else {
        var iident = $indent;
        var tident = ')';

        if(doLetIndent(e.inop)) {
            iident = CString::concat('    ', $indent);
            tident = CString::concat('%n;', $indent, ')');
        }

        let inexp = emitOperation[recursive](e.inop, eev, some(iident));
        return CString::concat('(let ', vbind, '%n;', inexp, tident);
    }
}

recursive function emitLetsOperation(e: SMTAssembly::LetsOperation, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    var inexp: CString;
    if(indent)@none {
        inexp = CString::concat(' ', emitOperation[recursive](e.inop, eev, none));
    }
    else {        
        var iident = $indent;
        var tident = '';

        if(doLetIndent(e.inop)) {
            iident = CString::concat('    ', $indent);
            tident = CString::concat('%n;', $indent);
        }

        inexp = CString::concat('%n;', emitOperation[recursive](e.inop, eev, some(iident)), tident);
    }
    
    let lbs = e.vvbind.lreduce<CString>(inexp, fn(acc, vb) => {
        let vbind = CString::concat('((', vb.2.value, ' ', emitSafeExpression[recursive](vb.0, eev), '))');
        return CString::concat('(let ', vbind, ' ', acc, ')');
    });
    
    if(indent)@none {
        return lbs;
    }
    else {
        return CString::concat($indent, lbs);
    }
}

recursive function emitLetOperationWError(e: SMTAssembly::LetOperationWError, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    let vval = emitExpression[recursive](e.value, eev);

    let bbind = CString::concat('((', e.vebind.value, ' ', vval, '))');
    let chk = CString::concat('(not (is-@Result-ok ', e.vebind.value, ')) ');
    let errop = emitResultErrTypeConvertAsNeeded(e.vebind.value, e.vtype, eev);

    let okbind = CString::concat('((', e.vbind.value, ' (@Result-value ', e.vebind.value, ')))');

    if(indent)@none {
        let inexp = emitOperation[recursive](e.inop, eev, none);
        let innerop = CString::concat(' (let ', okbind, ' ', inexp, ')');
        let wcheck = CString::concat('(ite ', chk, ' ', errop, innerop, ')');

        return CString::concat('(let ', bbind, ' ', wcheck, ')');
    }
    else {        
        var iident = $indent;
        var tident = ')';

        if(doLetIndent(e.inop)) {
            iident = CString::concat('    ', $indent);
            tident = CString::concat('%n;', $indent, ')');
        }

        let inexp = emitOperation[recursive](e.inop, eev, some(iident));
        let innerop = CString::concat(' (let ', okbind, '%n;', inexp, tident);
        let wcheck = CString::concat('(ite ', chk, ' ', errop, innerop, ')');

        return CString::concat('(let ', bbind, ' ', wcheck, ')');
    }
}

recursive function emitLetWErrorsOperation(e: SMTAssembly::LetWErrorsOperation, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    var inexp: CString;
    if(indent)@none {
        inexp = CString::concat(' ', emitOperation[recursive](e.inop, eev, none));
    }
    else {        
        var iident = $indent;
        var tident = '';

        if(doLetIndent(e.inop)) {
            iident = CString::concat('    ', $indent);
            tident = CString::concat('%n;', $indent);
        }

        inexp = CString::concat('%n;', emitOperation[recursive](e.inop, eev, some(iident)), tident);
    }
    
    let lbs = e.vvbind.lreduce<CString>(inexp, fn(acc, vb) => {
        let vbind = CString::concat('((', vb.2.value, ' ', emitExpression[recursive](vb.0, eev), '))');
        let chk = CString::concat('(not (is-@Result-ok ', vb.2.value, ')) ');

        let errop = emitResultErrTypeConvertAsNeeded(vb.2.value, vb.1, eev);

        let wcheck = CString::concat('(ite ', chk, errop, ' ', acc, ')');
        return CString::concat('(let ', vbind, ' ', wcheck, ')');
    });
    
    if(indent)@none {
        return lbs;
    }
    else {
        return CString::concat($indent, lbs);
    }
}

recursive function emitOperation(op: SMTAssembly::Operation, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    var opstr: CString;
    match(op)@ {
        SMTAssembly::ReturnOperation => { opstr = emitReturnOperation($op, eev); }
        | SMTAssembly::AbortOperation => { opstr = emitAbortOperation($op, eev); }
        | SMTAssembly::AssertOperation => { opstr = emitAssertOperation($op, eev, indent); }
        | SMTAssembly::AssumeOperation => { opstr = emitAssumeOperation($op, eev, indent); }
        | SMTAssembly::LetOperation => { opstr = emitLetOperation[recursive]($op, eev, indent); }
        | SMTAssembly::LetsOperation => { opstr = emitLetsOperation[recursive]($op, eev, indent); }
        | SMTAssembly::LetOperationWError => { opstr = emitLetOperationWError[recursive]($op, eev, indent); }
        | SMTAssembly::LetWErrorsOperation => { opstr = emitLetWErrorsOperation[recursive]($op, eev, indent); }
        | SMTAssembly::MatchOperation => { opstr = emitMatchOperation[recursive]($op, eev, indent); }
        | SMTAssembly::IfThenElseOperation => { opstr = emitIfThenElseOperation[recursive]($op, eev, indent); }
    }

    if(indent)@none {
        return opstr;
    }
    else {
        return CString::concat($indent, opstr);
    }
}

function emitBody(body: SMTAssembly::Body, eev: SMTEmitterEnv, indent: Option<CString>): CString {
    return emitOperation(body.op, eev, indent);
}

function emitConstDeclarationHelper(cname: CString, vtype: SMTAssembly::ResultType, op: SMTAssembly::Operation): CString {
    let cdecl = CString::concat('(declare-const ', cname, ' ', vtype.rtype.value, ')');

    var optconstv = tryGetConstOperation(op);
    if(optconstv)@some {
        let cval = emitExpression($optconstv, SMTEmitterEnv{SMTEmitter::s_ignoreErrTrgt, vtype.rtype});
        let cinit = CString::concat('(assert (= ', cname, ' ', cval, '))');
        return CString::join(' ', cdecl, cinit);
    }
    else {
        if(vtype)<SMTAssembly::SafeResult> {
            return cdecl;
        }
        else {
            let tname = CString::concat(cname, '-cc-temp');
            let ttype = CString::concat('(@Result ', vtype.rtype.value, ')');
            let icompute = CString::concat('(declare-const ', tname, ' ', ttype, ')');

            return CString::join(' ', cdecl, icompute);
        }
    }
}

function emitConstInitializerHelper(cname: CString, vtype: SMTAssembly::ResultType, body: SMTAssembly::Body): CString {
    let cval = emitBody(body, SMTEmitterEnv{SMTEmitter::s_ignoreErrTrgt, vtype.rtype}, none);

    if(vtype)<SMTAssembly::SafeResult> {
        return CString::concat('(assert (= ', cname, ' ', cval, '))');
    }
    else {
        let tname = CString::concat(cname, '-cc-temp');
        let tval = CString::concat('(assert (= ', tname, ' ', cval, '))');
        let chk = CString::concat('(assert (is-@Result-ok ', tname, '))');
        let asgn = CString::concat('(assert (= ', cname, ' (@Result-value ', tname, ')))');

        return CString::join('%n;', tval, chk, asgn);
    }
}

%** Return the declarations and definitions as 2 seperate components **%
function emitConstInfo(nsconsts: List<SMTAssembly::NamespaceConstDecl>, typeconsts: List<SMTAssembly::ConstMemberDecl>): CString, CString {
    let nsconstdecls = nsconsts.map<CString>(fn(c) => {
        let cname = SMTNameManager::generateNamespaceConstName(c.ns, c.cname);
        return emitConstDeclarationHelper(cname, c.vtype, c.value.op);
    });
    let nsconstdecls_str = CString::joinAll('%n;', nsconstdecls);

    let tconstdecls = typeconsts.map<CString>(fn(c) => {
        let cname = SMTNameManager::generateTypeConstName(c.tkey, c.cname);
        return emitConstDeclarationHelper(cname, c.vtype, c.value.op);    
    });
    let tconstdecls_str = CString::joinAll('%n;', tconstdecls);

    let nsconstinits = nsconsts
        .filter(pred(c) => tryGetConstOperation(c.value.op)?none)
        .map<CString>(fn(c) => {
            let cname = SMTNameManager::generateNamespaceConstName(c.ns, c.cname);
            return emitConstInitializerHelper(cname, c.vtype, c.value);
        });
    let nsconstinits_str = CString::joinAll('%n;', nsconstinits);

    let tconstinits = typeconsts
        .filter(pred(c) => tryGetConstOperation(c.value.op)?none)
        .map<CString>(fn(c) => {
            let cname = SMTNameManager::generateTypeConstName(c.tkey, c.cname);
            return emitConstInitializerHelper(cname, c.vtype, c.value);
        });
    let tconstinits_str = CString::joinAll('%n;', tconstinits);

    return tidyNewlineJoin(nsconstdecls_str, tconstdecls_str), tidyNewlineJoin(nsconstinits_str, tconstinits_str);
}

function emitPredicateFunctionDecl(f: SMTAssembly::PredicateFunctionDecl): CString {
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname.value, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    return CString::concat('(declare-fun ', f.invokeKey.value, ' ', pll, ' Bool)');
}

function emitBuiltinFunctionDecl(f: SMTAssembly::BuiltinFunctionDecl, trgterr: Nat): CString {
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname.value, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let psig = CString::concat('define-fun ', f.invokeKey.value, ' ', pll, ' ');
    var body: CString;
    if(f.specialname === 'cstring_empty') {
        body = '(= s "")';
    }
    elif(f.specialname === 's_list_empty') {
        let oftype = f.binds.find(pred(bb) => bb.0 === 'T').1.value;
        let consname = SMTNameManager::generateStructConstructorName(f.params.single().ptype);
        body = CString::concat('(= l (', consname, ' (as seq.empty (Seq ', oftype, '))))');
    }
    elif(f.specialname === 's_list_size') {
        let fname = SMTNameManager::generateStructFieldName(f.params.single().ptype, 'value');
        body = CString::concat('(seq.len (', fname, ' l))');
    }
    elif(f.specialname === 's_list_front') {
        let fname = SMTNameManager::generateStructFieldName(f.params.single().ptype, 'value');
        body = CString::concat('(seq.nth (', fname, ' l) 0)');
    }
    elif(f.specialname === 's_list_back') {
        let fname = SMTNameManager::generateStructFieldName(f.params.single().ptype, 'value');
        body = CString::concat('(let ((lseq (', fname, ' l))) (seq.nth lseq (- (seq.len lseq) 1)))');
    }
    elif(f.specialname === 's_list_get') {
        let fname = SMTNameManager::generateStructFieldName(f.params.front().ptype, 'value');
        body = CString::concat('(seq.nth (', fname, ' l) ', 'idx)');
    }
    elif(f.specialname === 's_list_create_empty') {
        let oftype = f.binds.find(pred(bb) => bb.0 === 'T').1.value;
        let consname = SMTNameManager::generateStructConstructorName(f.resultType.rtype);
        let scons = CString::concat('(as seq.empty (Seq ', oftype, '))');
        body = CString::concat('(', consname, ' ', scons, ')');
    }
    elif(f.specialname === 's_list_push_back') {
        let fname = SMTNameManager::generateStructFieldName(f.resultType.rtype, 'value');
        let consname = SMTNameManager::generateStructConstructorName(f.resultType.rtype);
        body = CString::concat('(', consname, ' (seq.++ (', fname, ' l) (seq.unit v)))');
    }
    elif(f.specialname === 's_list_push_front') {
        let fname = SMTNameManager::generateStructFieldName(f.resultType.rtype, 'value');
        let consname = SMTNameManager::generateStructConstructorName(f.resultType.rtype);
        body = CString::concat('(', consname, ' (seq.++ (seq.unit v) (', fname, ' l)))');
    }
    elif(f.specialname === 's_list_allof') {
        let oftype = f.binds.find(pred(bb) => bb.0 === 'T').1.value;
        let lseq = CString::concat('(', SMTNameManager::generateStructFieldName(f.params.front().ptype, 'value'), ' l)');

        if(f.resultType)<SMTAssembly::SafeResult> {
            let rpred = CString::concat('(lambda ((acc Bool) (vv ', oftype, ')) (and acc (p vv)))');
            body = CString::concat('(seq.fold_left ', rpred, ' true ', lseq, ')');
        }
        else {
            body = 'NOT IMPLEMENTED';
        }
    }
    elif(f.specialname === 's_list_noneof') {
        let oftype = f.binds.find(pred(bb) => bb.0 === 'T').1.value;
        let lseq = CString::concat('(', SMTNameManager::generateStructFieldName(f.params.front().ptype, 'value'), ' l)');

        if(f.resultType)<SMTAssembly::SafeResult> {
            let rpred = CString::concat('(lambda ((acc Bool) (vv ', oftype, ')) (and acc (not (p vv))))');
            body = CString::concat('(seq.fold_left ', rpred, ' true ', lseq, ')');
        }
        else {
            body = 'NOT IMPLEMENTED';
        }
    }
    elif(f.specialname === 's_list_someof') {
        let oftype = f.binds.find(pred(bb) => bb.0 === 'T').1.value;
        let lseq = CString::concat('(', SMTNameManager::generateStructFieldName(f.params.front().ptype, 'value'), ' l)');

        if(f.resultType)<SMTAssembly::SafeResult> {
            let rpred = CString::concat('(lambda ((acc Bool) (vv ', oftype, ')) (or acc (p vv)))');
            body = CString::concat('(seq.fold_left ', rpred, ' false ', lseq, ')');
        }
        else {
            body = 'NOT IMPLEMENTED';
        }
    }
    else {
        _debug f.specialname;
        abort; %%Missing builtin function implementation
    }

    return CString::concat('(', psig, SMTNameManager::generateResultName(f.resultType), ' ', body, ')');
}

function emitFunctionDecl(f: SMTAssembly::FunctionDecl, trgterr: Nat): CString {
    let plist = f.params.map<CString>(fn(p) => CString::concat('(', p.pname.value, ' ', p.ptype.value, ')'));
    let pll = CString::concat('(', CString::joinAll(' ', plist), ')');

    let psig = CString::concat('define-fun ', f.invokeKey.value, ' ', pll, ' ');
    let body = CString::concat('%n;', emitBody(f.body, SMTEmitterEnv{trgterr, f.resultType.rtype}, some('    ')));

    return CString::concat('(', psig, SMTNameManager::generateResultName(f.resultType), body, '%n;)');
}

function emitEnumTypeDecl(ttype: SMTAssembly::EnumTypeDecl): CString {
    let tvals = CString::joinAll(' ', ttype.members.map<CString>(fn(v) => CString::concat(ttype.tkey.value, '$$', v)));

    return CString::concat('(declare-datatype ', ttype.tkey.value, ' (', tvals, '))');
}

function emitEnumTypeDecls(ttypes: List<SMTAssembly::EnumTypeDecl>): CString {
    let tdecls = ttypes.map<CString>(fn(t) => emitEnumTypeDecl(t));
    return CString::joinAll('%n;', tdecls);
}

function emitTypedeclTypeDecl(ttype: SMTAssembly::TypedeclTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);
    let consfield = SMTNameManager::generateStructFieldName(ttype.tkey, 'value');

    let cval = CString::concat('(', consfield, ' ', ttype.valuetype.value, ')');
    let vval = CString::concat('(', consname, ' ', cval, ')');

    return CString::concat('(declare-datatype ', ttype.tkey.value, ' ( ', vval, ' ))');
}

function emitTypedeclTypeDeclTermCons(ttype: SMTAssembly::TypedeclTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitTypedeclTypes(ttypes: List<SMTAssembly::TypedeclTypeDecl>): CString, CString {
    let tds = ttypes.map<CString>(fn(t) => emitTypedeclTypeDecl(t));
    let ttcons = ttypes.filter(pred(t) => t.termable).map<CString>(fn(t) => emitTypedeclTypeDeclTermCons(t));

    return CString::joinAll('%n;', tds), CString::joinAll('%n;', ttcons);
}

function emitConstructableTypeDeclDeclaration(ttype: SMTAssembly::ConstructableTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitConstructableTypeDeclConstructor(ttype: SMTAssembly::ConstructableTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);

    var tlist: List<CString>;
    match(ttype)@ {
        SMTAssembly::OkTypeDecl => { 
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.ttype.value, ')'),
            };
        }
        | SMTAssembly::FailTypeDecl => {
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.etype.value, ')'),
            };
        }
        | SMTAssembly::SomeTypeDecl => {
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.vtype.value, ')'),
            };
        }
        | SMTAssembly::MapEntryTypeDecl => {
            tlist = List<CString>{
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'key'), ' ', $ttype.ktype.value, ')'),
                CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, 'value'), ' ', $ttype.vtype.value, ')'),
            };
        }
        | _ => {
            tlist = List<CString>{};
        }
    }

    if(tlist.empty()) {
        return CString::concat('        (', consname, ')');
    }
    else {
        let tvals = CString::joinAll(' ', tlist);
        return CString::concat('        ((', consname, ' ', tvals, '))');
    }
}

function emitConstructableTypeDeclTermConstructor(ttype: SMTAssembly::ConstructableTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitConstructableTypeDecls(ttypes: List<SMTAssembly::ConstructableTypeDecl>): CString, CString, CString {
   let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitConstructableTypeDeclDeclaration(t)));
   let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitConstructableTypeDeclConstructor(t)));
   let tcons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitConstructableTypeDeclTermConstructor(t)));

   return idecls, cons, tcons;
}

function emitCollectionTypeDeclDeclaration(ttype: SMTAssembly::CollectionTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitCollectionTypeDeclConstructor(ttype: SMTAssembly::CollectionTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);
    let consfield = SMTNameManager::generateStructFieldName(ttype.tkey, 'value');
    let cval = CString::concat('(', consfield, ' (Seq ', ttype.oftype.value, '))');
    return CString::concat('        ((', consname, ' ', cval, '))');
}

function emitCollectionTypeDecls(ttypes: List<SMTAssembly::CollectionTypeDecl>): CString, CString {
    let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitCollectionTypeDeclDeclaration(t)));
    let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitCollectionTypeDeclConstructor(t)));
    
    return idecls, cons;
}

function emitEntityTypeDeclDeclaration(ttype: SMTAssembly::EntityTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitEntityTypeDeclConstructor(ttype: SMTAssembly::EntityTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);

    if(ttype.allfields.empty()) {
        return CString::concat('        (', consname, ')');
    }
    else {
        let consfields = ttype.allfields.map<CString>(fn(f) => CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, f.fname), ' ', f.ftype.value, ')'));
        return CString::concat('        ((', consname, ' ', CString::joinAll(' ', consfields), '))');
    }
}

function emitEntityTypeDeclTermConstructor(ttype: SMTAssembly::EntityTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitEntityTypeDecls(ttypes: List<SMTAssembly::EntityTypeDecl>): CString, CString, CString {
    let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitEntityTypeDeclDeclaration(t)));
    let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitEntityTypeDeclConstructor(t)));
    let tcons = CString::joinAll('%n;', ttypes.filter(pred(t) => t.termable).map<CString>(fn(t) => emitEntityTypeDeclTermConstructor(t)));

    return idecls, cons, tcons;
}

function emitDatatypeMemberTypeDeclDeclaration(ttype: SMTAssembly::DatatypeMemberEntityTypeDecl): CString {
    return CString::concat('    (', ttype.tkey.value, ' 0)');
}

function emitDatatypeMemberEntityTypeDeclConstructor(ttype: SMTAssembly::DatatypeMemberEntityTypeDecl): CString {
    let consname = SMTNameManager::generateStructConstructorName(ttype.tkey);

    if(ttype.allfields.empty()) {
        return CString::concat('        (', consname, ')');
    }
    else {
        let consfields = ttype.allfields.map<CString>(fn(f) => CString::concat('(', SMTNameManager::generateStructFieldName(ttype.tkey, f.fname), ' ', f.ftype.value, ')'));
        return CString::concat('        ((', consname, ' ', CString::joinAll(' ', consfields), '))');
    }
}

function emitDatatypeMemberEntityTypeDeclTermConstructor(ttype: SMTAssembly::DatatypeMemberEntityTypeDecl): CString {
    let termcons = SMTNameManager::generateStructTermConstructorName(ttype.tkey);
    let termfield = SMTNameManager::generateStructTermFieldName(ttype.tkey);
    let cval = CString::concat('(', termfield, ' ', ttype.tkey.value, ')');
    return CString::concat('            (', termcons, ' ', cval, ')');
}

function emitDatatypeMemberEntityTypeDecls(ttypes: List<SMTAssembly::DatatypeMemberEntityTypeDecl>): CString, CString, CString {
    let idecls = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitDatatypeMemberTypeDeclDeclaration(t)));
    let cons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitDatatypeMemberEntityTypeDeclConstructor(t)));
    let tcons = CString::joinAll('%n;', ttypes.map<CString>(fn(t) => emitDatatypeMemberEntityTypeDeclTermConstructor(t)));

    return idecls, cons, tcons;
}

function emitSubtypePredicate(ctype: SMTAssembly::TypeKey, subtypes: List<SMTAssembly::TypeKey>): CString {
    let tname = SMTNameManager::generateTermSubtypeFunctionName(ctype);
    
    if(subtypes.empty()) {
        return CString::concat('(define-fun ', tname, '((tt @Term)) Bool false)');
    }
    elif(subtypes.isSingle()) {
        let tcons = SMTNameManager::generateStructTermConstructorName(subtypes.single());

        return CString::concat('(define-fun ', tname, '((tt @Term)) Bool (is-', tcons, ' tt))');
    }
    else {
        let tlist = subtypes.map<CString>(fn(t) => {
            let tcons = SMTNameManager::generateStructTermConstructorName(t);
            return CString::concat('(is-', tcons, ' tt)');
        });
    
        return CString::concat('(define-fun ', tname, '((tt @Term)) Bool (or ', CString::joinAll(' ', tlist), '))');
    }
}

function emitSpecialOptionSubtypePredicate(otype: SMTAssembly::OptionTypeDecl): CString {
    let tname = SMTNameManager::generateTermSubtypeFunctionName(otype.tkey);
    let tlist = List<CString>{
        CString::concat('(is-@Term-', otype.someType.value, '-mk tt)'),
        CString::concat('(= tt @Term-mk-None)'),
    };

    return CString::concat('(define-fun ', tname, '((tt @Term)) Bool (or ', CString::joinAll(' ', tlist), '))');
}

function emitPrimitiveConceptSubtypeChecks(ctype: List<SMTAssembly::PrimitiveConceptTypeDecl>): CString {
    let ccks = ctype.map<CString>(fn(c) => {
        match(c)@{
            SMTAssembly::OptionTypeDecl => {
                return emitSpecialOptionSubtypePredicate($c);
            }
            | SMTAssembly::ResultTypeDecl => {
                return emitSubtypePredicate(c.tkey, List<SMTAssembly::TypeKey>{$c.okType, $c.failType});
            }
            | SMTAssembly::APIResultTypeDecl => {
                return emitSubtypePredicate(c.tkey, List<SMTAssembly::TypeKey>{$c.errorType, $c.failedType, $c.rejectedType, $c.successType});
            }
        }
    });

    return CString::joinAll('%n;', ccks);
}

function emitConceptSubtypeChecks(ctype: List<SMTAssembly::ConceptTypeDecl>): CString {
    let ccks = ctype.map<CString>(fn(c) => emitSubtypePredicate(c.tkey, c.subtypes));
    return CString::joinAll('%n;', ccks);
}

function emitDatatypeSubtypeChecks(ctype: List<SMTAssembly::DatatypeTypeDecl>): CString {
    let ccks = ctype.map<CString>(fn(c) => emitSubtypePredicate(c.tkey, c.subtypes));
    return CString::joinAll('%n;', ccks);
}

function emitAllSubtypeChecks(pconcepts: List<SMTAssembly::PrimitiveConceptTypeDecl>, concepts: List<SMTAssembly::ConceptTypeDecl>, dconcepts: List<SMTAssembly::DatatypeTypeDecl>): CString {
    let pcks = emitPrimitiveConceptSubtypeChecks(pconcepts);
    let ccks = emitConceptSubtypeChecks(concepts);
    let dcks = emitDatatypeSubtypeChecks(dconcepts);

    return CString::joinAll('%n;', List<CString>{pcks, ccks, dcks}.filter(pred(s) => !s.empty()));
}

function emitVFieldFunctionDeclFor(ccptkey: SMTAssembly::TypeKey, fi: SMTAssembly::FieldInfo, subtypes: List<SMTAssembly::TypeKey>): CString {
    let vfname = SMTNameManager::generateVirtualFieldAccessorFunctionName(ccptkey, fi.fname);
    if(subtypes.empty()) {
        return CString::concat('(declare-fun ', vfname, ' (@Term) ', fi.ftype.value, ')');
    }
        
    var body: CString;
    if(subtypes.isSingle()) {
        let extract = SMTNameManager::generateStructTermFieldName(subtypes.single());
        let ssubf = SMTNameManager::generateStructFieldName(subtypes.single(), fi.fname);

        body = CString::concat('(', ssubf, ' (', extract, ' v))');
    }
    else {
        let opts = subtypes.map<CString>(fn(t) => {
            let tcons = SMTNameManager::generateStructConstructorName(t);
            let extract = SMTNameManager::generateStructTermFieldName(t);
            let ssubf = SMTNameManager::generateStructFieldName(t, fi.fname);
            let access = CString::concat('(', ssubf, ' (', extract, ' v))');

            return CString::concat('    (', tcons, ' ', access, ')');
        });

        body = CString::concat('(match v (%n;', CString::joinAll('%n;', opts), '%n;))');
    }

    let sig = CString::concat('define-fun ', vfname, ' ((v @Term)) ', fi.ftype.value);
    return CString::concat('(', sig, ' ', body, ')');
}

function emitConceptVFieldFunctionsFor(ccpt: SMTAssembly::ConceptTypeDecl): List<CString> {
    return ccpt.absfields.map<CString>(fn(f) => emitVFieldFunctionDeclFor(ccpt.tkey, f, ccpt.subtypes));
}

function emitDatatypeVFieldFunctionsFor(ddt: SMTAssembly::DatatypeTypeDecl): List<CString> {
    return ddt.absfields.map<CString>(fn(f) => emitVFieldFunctionDeclFor(ddt.tkey, f, ddt.subtypes));
}

function emitAllFieldAccessFunctions(concepts: List<SMTAssembly::ConceptTypeDecl>, dconcepts: List<SMTAssembly::DatatypeTypeDecl>): CString {
    let cfields = List<CString>::concatAll(concepts.map<List<CString>>(fn(c) => emitConceptVFieldFunctionsFor(c)));
    let dfields = List<CString>::concatAll(dconcepts.map<List<CString>>(fn(c) => emitDatatypeVFieldFunctionsFor(c)));

    return CString::joinAll('%n;', List<CString>::concat(cfields, dfields).filter(pred(s) => !s.empty()));
}

function emitAssembly(asm: SMTAssembly::Assembly, trgterr: Nat): CString {
    let constdecls, constimpls = emitConstInfo(asm.nsconsts, asm.typeconsts);
    let conststr = CString::join('%n;',
        '#BEGIN ;;--GLOBAL_DECLS--;;',
        constdecls,
        '#END ;;--GLOBAL_DECLS--;;',
        '#BEGIN ;;--GLOBAL_IMPLS--;;',
        constimpls,
        '#END ;;--GLOBAL_IMPLS--;;'
    );

    let nspreds = CString::joinAll('%n;', asm.nspreds.map<CString>(fn(f) => emitPredicateFunctionDecl(f)));
    let prestr = CString::join('%n;',
        '#BEGIN ;;--PRE_FUNCS--;;',
        nspreds,
        '#END ;;--PRE_FUNCS--;;'
    );

    let efuncs_list = asm.orderedfuncs.map<CString>(fn(t) => {
        if(asm.funcs.has(t)) {
            return emitFunctionDecl(asm.funcs.get(t), trgterr);
        }

        if(asm.nsbuiltins.has(t)) {
            return emitBuiltinFunctionDecl(asm.nsbuiltins.get(t), trgterr);
        }
        
        abort;
    });
    let efuncs = CString::concat(
        '#BEGIN ;;--FUNCTION_DECLS--;;',
        CString::joinAll('%n;%n;', efuncs_list),
        '#END ;;--FUNCTION_DECLS--;;'
    );
    
    let enum_edcls = emitEnumTypeDecls(asm.enums);
    let typedecl_edcls, typedecl_etcons = emitTypedeclTypes(asm.typedecls);
    let predecls = CString::join('%n;',
        '#BEGIN ;;--ENUM_DECLS--;;',
        enum_edcls,
        '#END ;;--ENUM_DECLS--;;',
        '#BEGIN ;;--TYPEDECL_DECLS--;;',
        typedecl_edcls,
        '#END ;;--TYPEDECL_DECLS--;;'
    );

    let predecl_str = CString::join('%n;', conststr, prestr, predecls);

    let special_edcls, special_econs, special_etcons = emitConstructableTypeDecls(asm.constructables);
    let collection_edcls, collection_econs = emitCollectionTypeDecls(asm.collections);
    let entity_edcls, entity_econs, entity_etcons = emitEntityTypeDecls(asm.entities);
    let datamember_edcls, datamember_econs, datamember_etcons = emitDatatypeMemberEntityTypeDecls(asm.datamembers);

    let stddecls = CString::join('%n;',
        CString::join('%n;',
            '#BEGIN ;;--SPECIAL_DECLS--;;',
            special_edcls,
            '#END ;;--SPECIAL_DECLS--;;',
            '#BEGIN ;;--COLLECTION_DECLS--;;',
            collection_edcls,
            '#END ;;--COLLECTION_DECLS--;;'
        ),
        CString::join('%n;',
            '#BEGIN ;;--ENTITY_DECLS--;;',
            entity_edcls,
            '#END ;;--ENTITY_DECLS--;;',
            '#BEGIN ;;--DATATYPE_DECLS--;;',
            datamember_edcls,
            '#END ;;--DATATYPE_DECLS--;;'
        )
    );

    let stdcons = CString::join('%n;',
        CString::join('%n;',
            '#BEGIN ;;--SPECIAL_CONSTRUCTORS--;;',
            special_econs,
            '#END ;;--SPECIAL_CONSTRUCTORS--;;',
            '#BEGIN ;;--COLLECTION_CONSTRUCTORS--;;',
            collection_econs,
            '#END ;;--COLLECTION_CONSTRUCTORS--;;'
        ),
        CString::join('%n;',
            '#BEGIN ;;--ENTITY_CONSTRUCTORS--;;',
            entity_econs,
            '#END ;;--ENTITY_CONSTRUCTORS--;;',
            '#BEGIN ;;--DATATYPE_CONSTRUCTORS--;;',
            datamember_econs,
            '#END ;;--DATATYPE_CONSTRUCTORS--;;'
        )
    );

    let termcons = CString::join('%n;',
        CString::join('%n;',
            '#BEGIN ;;--TYPEDECL_TERM_CONSTRUCTORS--;;',
            typedecl_etcons,
            '#END ;;--TYPEDECL_TERM_CONSTRUCTORS--;;',
            '#BEGIN ;;--SPECIAL_TERM_CONSTRUCTORS--;;',
            special_etcons,
            '#END ;;--SPECIAL_TERM_CONSTRUCTORS--;;'
        ),
        CString::join('%n;',
            '#BEGIN ;;--ENTITY_TERM_CONSTRUCTORS--;;',
            entity_etcons,
            '#END ;;--ENTITY_TERM_CONSTRUCTORS--;;',
            '#BEGIN ;;--DATATYPE_TERM_CONSTRUCTORS--;;',
            datamember_etcons,
            '#END ;;--DATATYPE_TERM_CONSTRUCTORS--;;'
        )
    );

    let subchecks = emitAllSubtypeChecks(asm.pconcepts, asm.concepts, asm.datatypes);
    let vfields = emitAllFieldAccessFunctions(asm.concepts, asm.datatypes);
    let subchecks_str = CString::join('%n;',
        '#BEGIN ;;--SUBTYPE_PREDICATES--;;',
        subchecks,
        '#END ;;--SUBTYPE_PREDICATES--;;',
        '#BEGIN ;;--VFIELD_ACCESS--;;',
        vfields,
        '#END ;;--VFIELD_ACCESS--;;'
    );

    let validates = CString::join('%n;',
        '#BEGIN ;;--VALIDATE_PREDICATES--;;',
        CString::joinAll('%n;', asm.validators.map<CString>(fn(vf) => emitFunctionDecl(vf, SMTEmitter::s_ignoreErrTrgt))),
        '#END ;;--VALIDATE_PREDICATES--;;'
    );

    return CString::join('%n;', predecl_str, CString::join('%n;', stddecls, stdcons, termcons), subchecks_str, CString::join('%n;', efuncs, validates));
}
