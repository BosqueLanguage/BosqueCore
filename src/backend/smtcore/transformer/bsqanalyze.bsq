namespace SMTEmitter;

entity BSQInvokeInfo {
    %** Map from an invoke to all of the callees **%
    field calleemap: Map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>;

    %** Map from an invoke to all of the callers **%
    field callermap: Map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>;

    %** List of every reachable invoke **%
    field reachable: List<BSQAssembly::InvokeKey>;
}

entity BSQToSMTCallGraph {
    field invokeinfo: BSQInvokeInfo;

    %** Topological order of invokes (up to SCC) **%
    field topoorder: List<BSQAssembly::InvokeKey>;

    %** Info on the strongly connected components **%
    field sccs: List<List<BSQAssembly::InvokeKey>>;

    method isInSCC(inv: BSQAssembly::InvokeKey): Bool {
        return this.sccs.someOf(pred(scc) => scc.contains(inv));
    }
}

entity BSQCCInfo {
    %** Map from an invoke to all of the callees **%
    field calleemap: Map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>;

    %** Map from an invoke to all of the callers **%
    field callermap: Map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>;

    function createEmpty(): BSQCCInfo {
        return BSQCCInfo{Map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>{}, Map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>{}};
    }

    function createWCallInfo(current: BSQAssembly::InvokeKey, ...callees: List<BSQAssembly::InvokeKey>): BSQCCInfo {
        return createWAllCallInfo(current, callees);
    }

    function createWAllCallInfo(current: BSQAssembly::InvokeKey, callees: List<BSQAssembly::InvokeKey>): BSQCCInfo {
        let calleemap = Map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>::createEmpty();
        calleemap.set(current, callees);
        
        let callermap = Map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>::createEmpty();
        callees.forEach(fn(callee) => {
            if(!callermap.has(callee)) {
                callermap.set(callee, List<BSQAssembly::InvokeKey>{});
            }
            callermap.get(callee).add(current);
        });

        return BSQCCInfo{calleemap, callermap};
    }

    function mergeInfos(reachable: List<BSQAssembly::InvokeKey>, ...infos: List<BSQInvokeInfo>): BSQInvokeInfo {
        return mergeAllInfos(reachable, infos);
    }

    function mergeAllInfos(reachable: List<BSQAssembly::InvokeKey>, infos: List<BSQInvokeInfo>): BSQInvokeInfo {
        if(infos.empty()) {
            return BSQInvokeInfo{Map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>{}, Map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>{}, reachable};
        }
        else {
            let calleemaps = infos.map<BSQAssembly::InvokeKey, Map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>>(fn(info) => info.calleemap);
            let callees = BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>::mergeAllConfluent(calleemaps, fn(k, v1, v2) => List<BSQAssembly::InvokeKey>::concat(v1, v2));

            let callermaps = infos.map<BSQAssembly::InvokeKey, Map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>>(fn(info) => info.callermap);
            let callers = BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>::mergeAllIdempotent(infos.map<BSQAssembly::InvokeKey, List<BSQAssembly::InvokeKey>>(fn(info) => info.callermap));

            return BSQInvokeInfo{callees, callers, reachable};
        }
    }
}

entity BSQToSMTCallGraphBuilder {
    field assembly: BSQAssembly::Assembly;

    function gatherInvariantFunctions(assembly: BSQAssembly::Assembly): List<BSQAssembly::InvokeKey> {
        let cinvs = assembly.allconcretetypes
            .map<BSQAssembly::AbstractNominalTypeDecl>(fn(tkey) => assembly.lookupNominalTypeDeclaration(tkey))
            .filter(pred(tdecl) => !tdecl.invariants.empty())
            .map<List<BSQAssembly::InvokeKey>>(fn(tdecl) => tdecl.invariants.map<BSQAssembly::InvokeKey>(fn(idecl) => idecl.ikey));
            
        let cvalidates = assembly.allconcretetypes
            .map<BSQAssembly::AbstractNominalTypeDecl>(fn(tkey) => assembly.lookupNominalTypeDeclaration(tkey))
            .filter(pred(tdecl) => !tdecl.validates.empty())
            .map<List<BSQAssembly::InvokeKey>>(fn(tdecl) => tdecl.validates.map<BSQAssembly::InvokeKey>(fn(idecl) => idecl.ikey));

        let ainvs = assembly.allabstracttypes
            .map<BSQAssembly::AbstractNominalTypeDecl>(fn(tkey) => assembly.lookupNominalTypeDeclaration(tkey))
            .filter(pred(tdecl) => !tdecl.invariants.empty())
            .map<List<BSQAssembly::InvokeKey>>(fn(tdecl) => tdecl.invariants.map<BSQAssembly::InvokeKey>(fn(idecl) => idecl.ikey));

        let avalidates = assembly.allabstracttypes
            .map<BSQAssembly::AbstractNominalTypeDecl>(fn(tkey) => assembly.lookupNominalTypeDeclaration(tkey))
            .filter(pred(tdecl) => !tdecl.validates.empty())
            .map<List<BSQAssembly::InvokeKey>>(fn(tdecl) => tdecl.validates.map<BSQAssembly::InvokeKey>(fn(idecl) => idecl.ikey));

        return List<BSQAssembly::InvokeKey>::concat(List<BSQAssembly::InvokeKey>::concatAll(cinvs), List<BSQAssembly::InvokeKey>::concatAll(cvalidates), List<BSQAssembly::InvokeKey>::concatAll(ainvs), List<BSQAssembly::InvokeKey>::concatAll(avalidates));
    }

    recursive method processArgs(current: BSQAssembly::InvokeKey, args: List<BSQAssembly::Expression>, info: BSQInvokeInfo): BSQInvokeInfo {
        return args.someOf[recursive](recursive pred(arg) => MayErrorAnalysis::processExpression[recursive](arg));
    }

    recursive method processUnaryArg(current: BSQAssembly::InvokeKey, exp: BSQAssembly::Expression, info: BSQInvokeInfo): BSQInvokeInfo {
        return this.processExpression(current, exp, info);
    }

    recursive method processBinaryArgs(current: BSQAssembly::InvokeKey, lhs: BSQAssembly::Expression, rhs: BSQAssembly::Expression, info: BSQInvokeInfo): BSQInvokeInfo {
        return BSQInvokeInfo::mergeInfos(info.reachable, this.processExpression[recursive](current, lhs, info), this.processExpression[recursive](current, rhs, info));
    }

    recursive method processArgumentList(current: BSQAssembly::InvokeKey, argl: BSQAssembly::ArgumentList, info: BSQInvokeInfo): BSQInvokeInfo {
        let infos = argl.args.map[recursive]<BSQInvokeInfo>(recursive fn(arg) => this.processExpression[recursive](current, arg.exp));
    }

    recursive method processLiteralTypeDeclValueExpression(current: BSQAssembly::InvokeKey, e: BSQAssembly::ConstructorExpression, info: BSQInvokeInfo): BSQInvokeInfo {
        var chks: Bool;
        match(e)@ {
            BSQAssembly::ConstructorPrimaryMapExpression => { chks = true; } %% map constructor may always fail
            | BSQAssembly::ConstructorTypeDeclExpression => { chks = $e.invchecks; }
            | BSQAssembly::ConstructorTypeDeclStringExpression => { chks = \/($e.invchecks, $e.ofcheck?some); }
            | BSQAssembly::ConstructorStdExpression => { chks = $e.invchecks; }
            | _ => { chks = false; }
        }
        
        return chks || MayErrorAnalysis::processArgumentList[recursive](e.args);
    }

    recursive method processConstructorExpression(current: BSQAssembly::InvokeKey, e: BSQAssembly::ConstructorExpression, info: BSQInvokeInfo): BSQInvokeInfo {
        var chks: Bool;
        match(e)@ {
            BSQAssembly::ConstructorPrimaryMapExpression => { chks = true; } %% map constructor may always fail
            | BSQAssembly::ConstructorTypeDeclExpression => { chks = $e.invchecks; }
            | BSQAssembly::ConstructorTypeDeclStringExpression => { chks = \/($e.invchecks, $e.ofcheck?some); }
            | BSQAssembly::ConstructorStdExpression => { chks = $e.invchecks; }
            | _ => { chks = false; }
        }
        
        return chks || MayErrorAnalysis::processArgumentList[recursive](e.args);
    }

    recursive method processConstructorLambdaExpression(current: BSQAssembly::InvokeKey, e: BSQAssembly::ConstructorLambdaExpression, info: BSQInvokeInfo): BSQInvokeInfo {
        xxxx;
    }

    recursive method processCallNamespaceFunctionExpression(current: BSQAssembly::InvokeKey, e: BSQAssembly::CallNamespaceFunctionExpression, info: BSQInvokeInfo): BSQInvokeInfo {
        xxxx;
    }

    recursive method processPostfixOp(current: BSQAssembly::InvokeKey, e: BSQAssembly::PostfixOp, info: BSQInvokeInfo): BSQInvokeInfo {
        let rootinfo = this.processUnaryArg[recursive](current, e.rootExpinfo );
        
        return e.ops.reduce[recursive](rootinfo, recursive fn(iinfo, op) => {
            match(op)@ {
                BSQAssembly::PostfixAccessFromName => { return iinfo; }
                | BSQAssembly::PostfixProjectFromNames => { return iinfo; }
                | BSQAssembly::PostfixAccessFromIndex => { return iinfo; }
                | BSQAssembly::PostfixIsTest => { return iinfo; }
                | BSQAssembly::PostfixAsConvert => { return iinfo; }
                | BSQAssembly::PostfixAssignFields => { return iinfo; }
                | BSQAssembly::PostfixInvokeStatic => { abort; }
                | BSQAssembly::PostfixInvokeVirtual => { abort; }
                | BSQAssembly::PostfixLiteralKeyAccess => { return iinfo; }
                | BSQAssembly::PostfixBoolConstant => { return iinfo; }
                | BSQAssembly::PostfixNop => { return iinfo; }
                | BSQAssembly::PostfixAbort => { return iinfo; }
                | BSQAssembly::PostfixWidenConvert => { return iinfo; }
                | BSQAssembly::PostfixAccessSomeValue => { return iinfo; }
                | BSQAssembly::PostfixLiteralNoneValue => { return iinfo; } 
            }
        });
    }

    recursive method processBinaryKeyEqExpression(current: BSQAssembly::InvokeKey, e: BSQAssembly::BinaryKeyEqExpression, info: BSQInvokeInfo): BSQInvokeInfo {
        match(e)@ {
            BSQAssembly::BinKeyEqNoneExpression => { return this.processUnaryArg[recursive](current, $e.exp, info); }
            | BSQAssembly::BinKeyNotEqNoneExpression => { return this.processUnaryArg[recursive](current, $e.exp, info); }
            | BSQAssembly::BinKeySomeEqExpression => { return this.processBinaryArgs[recursive](current, $e.eqoption, $e.eqval, info); }
            | BSQAssembly::BinKeyNotSomeEqExpression => { return this.processBinaryArgs[recursive](current, $e.neoption, $e.neval, info); }
            | BSQAssembly::BinKeyEqExpression => { return this.processBinaryArgs[recursive](current, $e.lhs, $e.rhs, info); }
            | BSQAssembly::BinKeyNotEqExpression => { return this.processBinaryArgs[recursive](current, $e.lhs, $e.rhs, info); }
        }
    }

    recursive method processIfExpression(current: BSQAssembly::InvokeKey, e: BSQAssembly::IfExpression, info: BSQInvokeInfo): BSQInvokeInfo {
        let infotest = this.processExpression[recursive](current, e.texp, info);
        let infothen = this.processExpression[recursive](current, e.thenexp, info);
        let infoelse = this.processExpression[recursive](current, e.elseexp, info);

        return BSQInvokeInfo::mergeInfos(info.reachable, infotest, infothen, infoelse);
    }

    recursive method processExpression(current: BSQAssembly::InvokeKey, e: BSQAssembly::Expression, info: BSQInvokeInfo): BSQInvokeInfo {
        match(e)@ {
            BSQAssembly::LiteralNoneExpression => { return info; }
            | BSQAssembly::LiteralSimpleExpression => { return info; }
            | BSQAssembly::LiteralCStringExpression => { return info; }
            | BSQAssembly::LiteralStringExpression => { return info; }
            | BSQAssembly::LiteralCRegexExpression => { return info; }
            | BSQAssembly::LiteralRegexExpression => { return info; }
            | BSQAssembly::LiteralTypeDeclValueExpression => { return this.processLiteralTypeDeclValueExpression[recursive](current, $e, info); }
            | BSQAssembly::AccessNamespaceConstantExpression => { return info; }
            | BSQAssembly::AccessStaticFieldExpression => { return info; }
            | BSQAssembly::AccessEnumExpression => { return info; }
            | BSQAssembly::AccessVariableExpression => { return info; }
            | BSQAssembly::AccessCapturedVariableExpression => { return info; }
            | BSQAssembly::ConstructorExpression => { return this.processConstructorExpression[recursive](current, $e, info); }
            | BSQAssembly::ConstructorLambdaExpression => { return this.processConstructorLambdaExpression[recursive](current, $e, info); }
            | BSQAssembly::LetExpression => { abort; }
            | BSQAssembly::LambdaInvokeExpression => { return info; }
            | BSQAssembly::CallNamespaceFunctionExpression => { return this.processCallNamespaceFunctionExpression[recursive](current, $e, info); }
            | BSQAssembly::CallTypeFunctionExpression => { abort; }
            | BSQAssembly::CallTypeFunctionSpecialExpression => { abort; }
            | BSQAssembly::CallRefInvokeStaticResolveExpression => { abort; }
            | BSQAssembly::CallRefInvokeVirtualExpression => { abort; }
            | BSQAssembly::LogicActionAndExpression => { abort; }
            | BSQAssembly::LogicActionOrExpression => { abort; }
            | BSQAssembly::TypeDeclPrimitiveFieldAccessExpression => { abort; }
            | BSQAssembly::CoerceNarrowTypeExpression => { return this.processArg[recursive](current, $e.exp, info); }
            | BSQAssembly::CoerceWidenTypeExpression => { return this.processArg[recursive](current, $e.exp, info); }
            | BSQAssembly::SafeConvertExpression => { return this.processArg[recursive](current, $e.exp, info); }
            | BSQAssembly::CreateDirectExpression => { return this.processArg[recursive](current, $e.exp, info); }
            | BSQAssembly::PostfixOp => { return this.processPostfixOp[recursive](current, $e, info); }
            | BSQAssembly::UnaryExpression => { return this.processArg[recursive](current, $e.exp, info); }
            | BSQAssembly::BinaryArithExpression => { return this.processBinaryArgs[recursive](current, $e.lhs, $e.rhs, info); }
            | BSQAssembly::BinaryKeyEqExpression => { return this.processBinaryKeyEqExpression[recursive]($e); }
            | BSQAssembly::KeyCmpEqualExpression => { return this.processBinaryArgs[recursive](current, $e.lhs, $e.rhs, info); }
            | BSQAssembly::KeyCmpLessExpression => { return this.processBinaryArgs[recursive](current, $e.lhs, $e.rhs, info); }
            | BSQAssembly::BinaryNumericExpression => { return this.processBinaryArgs[recursive](current, $e.lhs, $e.rhs, info); }
            | BSQAssembly::BinLogicExpression => { return this.processBinaryArgs[recursive](current, $e.lhs, $e.rhs, info); }
            | BSQAssembly::MapEntryConstructorExpression => { abort; }
            | BSQAssembly::IfExpression => { return this.processIfExpression[recursive](current, $e, info); }
        }
    }

    recursive method processIfStatement(current: BSQAssembly::InvokeKey, s: BSQAssembly::IfStatement, info: BSQInvokeInfo): BSQInvokeInfo {
        let infotest = this.processExpression[recursive](current, s.texp, info);
        let infotrue = this.processBlockStatement[recursive](current, s.trueBlock, info);

        return BSQInvokeInfo::mergeInfos(info.reachable, infotest, infotrue);
    }

    recursive method processIfElseStatement(current: BSQAssembly::InvokeKey, s: BSQAssembly::IfElseStatement, info: BSQInvokeInfo): BSQInvokeInfo {
        let infotest = this.processExpression[recursive](current, s.texp, info);
        let infotrue = this.processBlockStatement[recursive](current, s.trueBlock, info);
        let infofalse = this.processBlockStatement[recursive](current, s.falseBlock, info);

        return BSQInvokeInfo::mergeInfos(info.reachable, infotest, infotrue, infofalse);
    }

    recursive method processStatement(current: BSQAssembly::InvokeKey, s: BSQAssembly::Statement, info: BSQInvokeInfo): BSQInvokeInfo {
        match(s)@ {
            BSQAssembly::EmptyStatement => { return info; }
            | BSQAssembly::VariableDeclarationStatement => { return info; }
            | BSQAssembly::VariableMultiDeclarationStatement => { return info; }
            | BSQAssembly::VariableInitializationStatement => { return this.processExpression[recursive](current, $s.exp, info); }
            | BSQAssembly::VariableMultiInitializationExplicitStatement => { abort; } %% NOT IMPLEMENTED
            | BSQAssembly::VariableMultiInitializationImplicitStatement => { abort; } %% NOT IMPLEMENTED
            | BSQAssembly::VariableAssignmentStatement => { return this.processExpression[recursive](current $s.exp, info); }
            | BSQAssembly::VariableMultiAssignmentExplicitStatement => { abort; } %% NOT IMPLEMENTED
            | BSQAssembly::VariableMultiAssignmentImplicitStatement => { abort; } %% NOT IMPLEMENTED
            | BSQAssembly::ReturnVoidStatement => { return info; }
            | BSQAssembly::ReturnSingleStatement => { return this.processExpression(current, $s.value, info); }
            | BSQAssembly::ReturnMultiStatement => { abort; } %% NOT IMPLEMENTED
            | BSQAssembly::IfStatement => { return this.processIfStatement[recursive](current, $s, info);}
            | BSQAssembly::IfElseStatement => { return this.processIfElseStatement[recursive](current, $s, info); }
            | BSQAssembly::AbortStatement => { return info; }
            | BSQAssembly::AssertStatement => { return this.processExpression[recursive](current $s.cond, info); }
            | BSQAssembly::BlockStatement => { return this.processBlockStatement[recursive](current, $s, info); }
        }
    }

    recursive method processBlockStatement(current: BSQAssembly::InvokeKey, s: BSQAssembly::BlockStatement, info: BSQInvokeInfo): BSQInvokeInfo {
        let infos = s.statements.reduce[recursive](info, recursive fn(iinfo, stmt) => this.processStatement[recursive](iinfo, current, stmt));
        return BSQInvokeInfo::mergeAllInfos(infos.reachable, infos);
    }

    recursive method processBodyStatementList(current: BSQAssembly::InvokeKey, stmts: List<BSQAssembly::Statement>, info: BSQInvokeInfo): BSQInvokeInfo {
        let infos = stmts.reduce[recursive](info, recursive fn(iinfo, stmt) => this.processStatement[recursive](iinfo, current, stmt));
        return BSQInvokeInfo::mergeAllInfos(infos.reachable, infos);
    }

    recursive method processBodyImpl(current: BSQAssembly::InvokeKey, body: BSQAssembly::BodyImplementation, info: BSQInvokeInfo): BSQInvokeInfo {
        match(body)@ {
            BSQAssembly::ExpressionBodyImplementation => { return this.processExpression[recursive](current, $body.exp, info); }
            | BSQAssembly::StandardBodyImplementation => { return this.processBodyStatementList[recursive](current, $body.statements, info); }
            | _ => { return info; }
        }
    }

    method processNamespaceFunctionDecl(nsfunc: BSQAssembly::NamespaceFunctionDecl, info: BSQInvokeInfo): BSQInvokeInfo {
        return this.processBodyImpl(nsfunc.ikey, nsfunc.body, info);
    }

    method processTypeFunctionDecl(typefunc: BSQAssembly::TypeFunctionDecl, info: BSQInvokeInfo): BSQInvokeInfo {
        abort;
    }

    method processMethodDeclVirtual(virtmethod: BSQAssembly::MethodDeclVirtual, info: BSQInvokeInfo): BSQInvokeInfo {
        abort;
    }

    method processMethodDeclOverrideInfo(overmethod: BSQAssembly::MethodDeclOverride, info: BSQInvokeInfo): BSQInvokeInfo {
        abort;
    }

    method processMethodDeclStaticInfo(staticmethod: BSQAssembly::MethodDeclStatic, info: BSQInvokeInfo): BSQInvokeInfo {
        abort;
    }

    function constructBSQInvokeInfo(assembly: BSQAssembly::Assembly, entrypoints: List<BSQAssembly::InvokeKey>): BSQInvokeInfo {
        xxxx;
    }
}

%*
 * Compute the may error status of every invoke in the assembly
 *%
entity MayErrorAnalysis {
    recursive function processArgs(args: List<BSQAssembly::Expression>): Bool {
        return args.someOf[recursive](recursive pred(arg) => MayErrorAnalysis::processExpression[recursive](arg));
    }

    recursive function processUnaryArg(exp: BSQAssembly::Expression): Bool {
        return MayErrorAnalysis::processExpression(exp);
    }

    recursive function processBinaryArgs(lhs: BSQAssembly::Expression, rhs: BSQAssembly::Expression): Bool {
        return \/(MayErrorAnalysis::processExpression(lhs), MayErrorAnalysis::processExpression(rhs));
    }

    recursive function processArgumentList(argl: BSQAssembly::ArgumentList): Bool {
        return argl.args.someOf[recursive](recursive pred(arg) => MayErrorAnalysis::processExpression[recursive](arg.exp));
    }

    recursive function processConstructorExpression(e: BSQAssembly::ConstructorExpression): Bool {
        var chks: Bool;
        match(e)@ {
            BSQAssembly::ConstructorPrimaryMapExpression => { chks = true; } %% map constructor may always fail
            | BSQAssembly::ConstructorTypeDeclExpression => { chks = $e.invchecks; }
            | BSQAssembly::ConstructorTypeDeclStringExpression => { chks = \/($e.invchecks, $e.ofcheck?some); }
            | BSQAssembly::ConstructorStdExpression => { chks = $e.invchecks; }
            | _ => { chks = false; }
        }
        
        return chks || MayErrorAnalysis::processArgumentList[recursive](e.args);
    }

    recursive function processCoerceNarrowTypeExpression(e: BSQAssembly::CoerceNarrowTypeExpression): Bool {
        return MayErrorAnalysis::processUnaryArg[recursive](e.exp);
    }

    recursive function processCoerceWidenTypeExpression(e: BSQAssembly::CoerceWidenTypeExpression): Bool {
        return MayErrorAnalysis::processUnaryArg[recursive](e.exp);
    }

    recursive function processSafeConvertExpression(e: BSQAssembly::SafeConvertExpression): Bool {
        return MayErrorAnalysis::processUnaryArg[recursive](e.exp);
    }

    recursive function processPostfixOp(e: BSQAssembly::PostfixOp): Bool {
        let baseerr = MayErrorAnalysis::processUnaryArg[recursive](e.rootExp);
        if(baseerr) {
            return true;
        }
        else {
            return e.ops.someOf[recursive](recursive pred(op) => {
                match(op)@ {
                    BSQAssembly::PostfixAccessFromName => { return false; }
                    | BSQAssembly::PostfixProjectFromNames => { return false; }
                    | BSQAssembly::PostfixAccessFromIndex => { return false; }
                    | BSQAssembly::PostfixIsTest => { return false; }
                    | BSQAssembly::PostfixAsConvert => { return true; }
                    | BSQAssembly::PostfixAssignFields => { abort; }
                    | BSQAssembly::PostfixInvokeStatic => { abort; }
                    | BSQAssembly::PostfixInvokeVirtual => { abort; }
                    | BSQAssembly::PostfixLiteralKeyAccess => { return false; }
                    | BSQAssembly::PostfixBoolConstant => { return false; }
                    | BSQAssembly::PostfixNop => { return false; }
                    | BSQAssembly::PostfixAbort => { return true; }
                    | BSQAssembly::PostfixWidenConvert => { return false; }
                    | BSQAssembly::PostfixAccessSomeValue => { return false; }
                    | BSQAssembly::PostfixLiteralNoneValue => { return false; } 
                }
            });
        }
    }

    recursive function processUnaryExpression(e: BSQAssembly::UnaryExpression): Bool {
        return MayErrorAnalysis::processUnaryArg[recursive](e.exp);
    }

    function maySubtractionUnderflow(e: BSQAssembly::BinaryArithExpression): Bool {
        if(e)!<BSQAssembly::BinSubExpression> {
            return false;
        }
        else {
            return \/(e.etype.tkeystr === 'Nat'<BSQAssembly::TypeKey>, e.etype.tkeystr === 'BigNat'<BSQAssembly::TypeKey>);
        }
    }

    recursive function processBinaryArithExpression(e: BSQAssembly::BinaryArithExpression): Bool {
        if(e?<BSQAssembly::BinDivExpression>) { 
            return true; %%div zero may always happen
        }
        elif(MayErrorAnalysis::maySubtractionUnderflow(e)) {
            return true;
        }
        else {
            return MayErrorAnalysis::processBinaryArgs[recursive](e.lhs, e.rhs);
        }
    }

    recursive function processBinaryKeyEqExpression(e: BSQAssembly::BinaryKeyEqExpression): Bool {
        match(e)@ {
            BSQAssembly::BinKeyEqNoneExpression => { return MayErrorAnalysis::processUnaryArg[recursive]($e.exp); }
            | BSQAssembly::BinKeyNotEqNoneExpression => { return MayErrorAnalysis::processUnaryArg[recursive]($e.exp); }
            | BSQAssembly::BinKeySomeEqExpression => { return MayErrorAnalysis::processBinaryArgs[recursive]($e.eqoption, $e.eqval); }
            | BSQAssembly::BinKeyNotSomeEqExpression => { return MayErrorAnalysis::processBinaryArgs[recursive]($e.neoption, $e.neval); }
            | BSQAssembly::BinKeyEqExpression => { return MayErrorAnalysis::processBinaryArgs[recursive]($e.lhs, $e.rhs); }
            | BSQAssembly::BinKeyNotEqExpression => { return MayErrorAnalysis::processBinaryArgs[recursive]($e.lhs, $e.rhs); }
        }
    }

    recursive function processBinaryNumericExpression(e: BSQAssembly::BinaryNumericExpression): Bool {
        return MayErrorAnalysis::processBinaryArgs[recursive](e.lhs, e.rhs);
    }

    recursive function processIfExpression(e: BSQAssembly::IfExpression): Bool {
        return \/(MayErrorAnalysis::processExpression[recursive](e.texp), MayErrorAnalysis::processExpression[recursive](e.thenexp), MayErrorAnalysis::processExpression[recursive](e.elseexp));
    }

    recursive function processExpression(e: BSQAssembly::Expression): Bool {
        match(e)@ {
            BSQAssembly::LiteralNoneExpression => { return false; }
            | BSQAssembly::LiteralSimpleExpression => { return false; }
            | BSQAssembly::LiteralCStringExpression => { return false; }
            | BSQAssembly::LiteralStringExpression => { return false; }
            | BSQAssembly::LiteralCRegexExpression => { return false; }
            | BSQAssembly::LiteralRegexExpression => { return false; }
            | BSQAssembly::LiteralTypeDeclValueExpression => { return $e.invchecks; }
            | BSQAssembly::AccessNamespaceConstantExpression => { return false; }
            | BSQAssembly::AccessStaticFieldExpression => { return false; }
            | BSQAssembly::AccessEnumExpression => { return false; }
            | BSQAssembly::AccessVariableExpression => { return false; }
            | BSQAssembly::AccessCapturedVariableExpression => { return false; }
            | BSQAssembly::ConstructorExpression => { return MayErrorAnalysis::processConstructorExpression[recursive]($e); }
            | BSQAssembly::ConstructorLambdaExpression => { return false; }
            | BSQAssembly::LetExpression => { abort; }
            | BSQAssembly::LambdaInvokeExpression => { return false; }
            | BSQAssembly::CallNamespaceFunctionExpression => { return false; }
            | BSQAssembly::CallTypeFunctionExpression => { abort; }
            | BSQAssembly::CallTypeFunctionSpecialExpression => { abort; }
            | BSQAssembly::CallRefInvokeStaticResolveExpression => { abort; }
            | BSQAssembly::CallRefInvokeVirtualExpression => { abort; }
            | BSQAssembly::LogicActionAndExpression => { abort; }
            | BSQAssembly::LogicActionOrExpression => { abort; }
            | BSQAssembly::TypeDeclPrimitiveFieldAccessExpression => { abort; }
            | BSQAssembly::CoerceNarrowTypeExpression => { return MayErrorAnalysis::processCoerceNarrowTypeExpression($e); }
            | BSQAssembly::CoerceWidenTypeExpression => { return MayErrorAnalysis::processCoerceWidenTypeExpression($e); }
            | BSQAssembly::SafeConvertExpression => { return MayErrorAnalysis::processSafeConvertExpression($e); }
            | BSQAssembly::CreateDirectExpression => { abort; }
            | BSQAssembly::PostfixOp => { return MayErrorAnalysis::processPostfixOp[recursive]($e); }
            | BSQAssembly::UnaryExpression => { return MayErrorAnalysis::processUnaryExpression[recursive]($e); }
            | BSQAssembly::BinaryArithExpression => { return MayErrorAnalysis::processBinaryArithExpression[recursive]($e); }
            | BSQAssembly::BinaryKeyEqExpression => { return MayErrorAnalysis::processBinaryKeyEqExpression[recursive]($e); }
            | BSQAssembly::KeyCmpEqualExpression => { abort; }
            | BSQAssembly::KeyCmpLessExpression => { abort; }
            | BSQAssembly::BinaryNumericExpression => { return MayErrorAnalysis::processBinaryNumericExpression[recursive]($e); }
            | BSQAssembly::BinLogicExpression => { abort; }
            | BSQAssembly::MapEntryConstructorExpression => { abort; }
            | BSQAssembly::IfExpression => { return MayErrorAnalysis::processIfExpression[recursive]($e); }
        }
    }

    recursive function processIfStatement(s: BSQAssembly::IfStatement): Bool {
        return \/(MayErrorAnalysis::processExpression[recursive](s.texp), MayErrorAnalysis::processBlockStatement[recursive](s.trueBlock));
    }

    recursive function processIfElseStatement(s: BSQAssembly::IfElseStatement): Bool {
        return \/(MayErrorAnalysis::processExpression[recursive](s.texp), MayErrorAnalysis::processBlockStatement[recursive](s.trueBlock), MayErrorAnalysis::processBlockStatement[recursive](s.falseBlock));
    }

    recursive function processStatement(s: BSQAssembly::Statement): Bool {
        match(s)@ {
            BSQAssembly::EmptyStatement => { 
                return false; 
            }
            | BSQAssembly::VariableDeclarationStatement => {
                return false;
            }
            | BSQAssembly::VariableMultiDeclarationStatement => {
                return false;
            }
            | BSQAssembly::VariableInitializationStatement => {
                return MayErrorAnalysis::processExpression($s.exp);
            }
            | BSQAssembly::VariableMultiInitializationExplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::VariableMultiInitializationImplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::VariableAssignmentStatement => {
                return MayErrorAnalysis::processExpression($s.exp);
            }
            | BSQAssembly::VariableMultiAssignmentExplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::VariableMultiAssignmentImplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::ReturnVoidStatement => {
                return false;
            }
            | BSQAssembly::ReturnSingleStatement => {
                return MayErrorAnalysis::processExpression($s.value);
            }
            | BSQAssembly::ReturnMultiStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::IfStatement => {
                return MayErrorAnalysis::processIfStatement[recursive]($s);
            }
            | BSQAssembly::IfElseStatement => {
                return MayErrorAnalysis::processIfElseStatement[recursive]($s);
            }
            | BSQAssembly::AbortStatement => {
                return true;
            }
            | BSQAssembly::AssertStatement => {
                return true;
            }
            | BSQAssembly::BlockStatement => {
                return MayErrorAnalysis::processBlockStatement[recursive]($s);
            }
        }
    }

    recursive function processBlockStatement(s: BSQAssembly::BlockStatement): Bool {
        return s.statements.someOf[recursive](recursive pred(stmt) => MayErrorAnalysis::processStatement[recursive](stmt));
    }

    recursive function processBodyStatementList(stmts: List<BSQAssembly::Statement>): Bool {
        return stmts.someOf[recursive](recursive pred(stmt) => MayErrorAnalysis::processStatement[recursive](stmt));
    }

    function processBodyImpl(body: BSQAssembly::BodyImplementation): Bool {
        match(body)@ {
            BSQAssembly::ExpressionBodyImplementation => { return MayErrorAnalysis::processExpression($body.exp); }
            | BSQAssembly::StandardBodyImplementation => { return MayErrorAnalysis::processBodyStatementList($body.statements); }
            | _ => { return false; }
        }
    }

    function processNamespaceFunctionDecl(nsfunc: BSQAssembly::NamespaceFunctionDecl): Bool {
        return MayErrorAnalysis::processBodyImpl(nsfunc.body);
    }

    function processTypeFunctionDecl(typefunc: BSQAssembly::TypeFunctionDecl): Bool {
        abort;
    }

    function processMethodDeclVirtual(virtmethod: BSQAssembly::MethodDeclVirtual): Bool {
        abort;
    }

    function processMethodDeclOverride(overmethod: BSQAssembly::MethodDeclOverride): Bool {
        abort;
    }

    function processMethodDeclStatic(staticmethod: BSQAssembly::MethodDeclStatic): Bool {
        abort;
    }

    function setDirectMayErrorInfoInvariantFunctions(assembly: BSQAssembly::Assembly): Map<BSQAssembly::InvokeKey, Bool> {
        let cinvs = assembly.allconcretetypes
            .map<BSQAssembly::AbstractNominalTypeDecl>(fn(tkey) => assembly.lookupNominalTypeDeclaration(tkey))
            .filter(pred(tdecl) => !tdecl.invariants.empty())
            .map<Map<BSQAssembly::InvokeKey, Bool>>(fn(tdecl) => Map<BSQAssembly::InvokeKey, Bool>::unionAll(tdecl.invariants.map<Map<BSQAssembly::InvokeKey, Bool>>(fn(idecl) => Map<BSQAssembly::InvokeKey, Bool>{idecl.ikey => MayErrorAnalysis::processExpression(idecl.exp)})));
            
        let cvalidates = assembly.allconcretetypes
            .map<BSQAssembly::AbstractNominalTypeDecl>(fn(tkey) => assembly.lookupNominalTypeDeclaration(tkey))
            .filter(pred(tdecl) => !tdecl.validates.empty())
            .map<Map<BSQAssembly::InvokeKey, Bool>>(fn(tdecl) => Map<BSQAssembly::InvokeKey, Bool>::unionAll(tdecl.validates.map<Map<BSQAssembly::InvokeKey, Bool>>(fn(idecl) => Map<BSQAssembly::InvokeKey, Bool>{idecl.ikey => MayErrorAnalysis::processExpression(idecl.exp)})));
            
        let ainvs = assembly.allabstracttypes
            .map<BSQAssembly::AbstractNominalTypeDecl>(fn(tkey) => assembly.lookupNominalTypeDeclaration(tkey))
            .filter(pred(tdecl) => !tdecl.invariants.empty())
            .map<Map<BSQAssembly::InvokeKey, Bool>>(fn(tdecl) => Map<BSQAssembly::InvokeKey, Bool>::unionAll(tdecl.invariants.map<Map<BSQAssembly::InvokeKey, Bool>>(fn(idecl) => Map<BSQAssembly::InvokeKey, Bool>{idecl.ikey => MayErrorAnalysis::processExpression(idecl.exp)})));
            
        let avalidates = assembly.allabstracttypes
            .map<BSQAssembly::AbstractNominalTypeDecl>(fn(tkey) => assembly.lookupNominalTypeDeclaration(tkey))
            .filter(pred(tdecl) => !tdecl.validates.empty())
            .map<Map<BSQAssembly::InvokeKey, Bool>>(fn(tdecl) => Map<BSQAssembly::InvokeKey, Bool>::unionAll(tdecl.validates.map<Map<BSQAssembly::InvokeKey, Bool>>(fn(idecl) => Map<BSQAssembly::InvokeKey, Bool>{idecl.ikey => MayErrorAnalysis::processExpression(idecl.exp)})));
            
        return Map<BSQAssembly::InvokeKey, Bool>::union(
            Map<BSQAssembly::InvokeKey, Bool>::unionAll(cinvs), 
            Map<BSQAssembly::InvokeKey, Bool>::unionAll(cvalidates), 
            Map<BSQAssembly::InvokeKey, Bool>::unionAll(ainvs), 
            Map<BSQAssembly::InvokeKey, Bool>::unionAll(avalidates)
            );
    }

    function setDirectMayErrorInfo(assembly: BSQAssembly::Assembly): Map<BSQAssembly::InvokeKey, Bool> {
        let nsferrinvokes = assembly.nsfuncs.map<Bool>(fn(ikey, nsfunc) => MayErrorAnalysis::processNamespaceFunctionDecl(nsfunc));
        let tferrinvokes = assembly.typefuncs.map<Bool>(fn(ikey, typefunc) => MayErrorAnalysis::processTypeFunctionDecl(typefunc));
        let smethoderrinvokes = assembly.staticmethods.map<Bool>(fn(ikey, staticmethod) => MayErrorAnalysis::processMethodDeclStatic(staticmethod));

        let implicitinvokes = MayErrorAnalysis::setDirectMayErrorInfoInvariantFunctions(assembly);

        %%TODO: this is not implemented yet -- need to implement the virtual and override method processing
        assert assembly.absmethods.empty();
        assert assembly.virtmethods.empty();
        assert assembly.overmethods.empty();

        return Map<BSQAssembly::InvokeKey, Bool>::union(nsferrinvokes, tferrinvokes, smethoderrinvokes, implicitinvokes);
    }

    function generate(assembly: BSQAssembly::Assembly, callg: BSQAssembly::CallGraph): Map<BSQAssembly::InvokeKey, Bool> {
        let baseerrinvokes = MayErrorAnalysis::setDirectMayErrorInfo(assembly);

        let properrinvokes = callg.topoorder.reduce<Map<BSQAssembly::InvokeKey, Bool>>(baseerrinvokes, fn(emap, ikey) => {
            let err = baseerrinvokes.get(ikey);
            if(err) {
                return emap;
            }
            else {
                if(callg.isInSCC(ikey)) {
                    return emap.set(ikey, true);
                }
                else {
                    let callees = callg.callgraph.get(ikey);
                    let transerr = callees.someOf(pred(ckey) => emap.get(ckey));

                    return emap.set(ikey, transerr);
                }
            }
        });

        return properrinvokes;
    }
}
