namespace SMTEmitter;

entity ErrorAnalysisCtx {
    field cinvoke: BSQAssembly::InvokeKey;
    field vstack: List<BSQAssembly::InvokeKey>;
    field merrors: Map<BSQAssembly::InvokeKey, Bool>;

    method isRecursiveCall(ikey: BSQAssembly::InvokeKey): Bool {
        return this.vstack.(ctx);
    }

    method pushInvoke(ikey: BSQAssembly::InvokeKey): ErrorAnalysisCtx 
        requires !this.isRecursiveCall(ikey);
    {
        return ErrorAnalysisCtx{ikey, this.vstack.append(ikey), this.merrors};
    }
}

%*
 * Compute the may error status of every invoke in the assembly
 *%
entity MayErrorAnalysis {
    field assembly: BSQAssembly::Assembly;

    recursive method processArgs(args: List<BSQAssembly::Expression>, ctx: ErrorAnalysisCtx): ErrorAnalysisCtx, Bool {
        let nctx, ell = args.transduce<ErrorAnalysisCtx, Bool>(ctx, recursive fn(ctx, arg) => this.processExpression[recursive](arg, ctx));

        return nctx, ell.someOf(pred(err) => err);
    }

    method processExpression(e: Expression, ectx: ErrorAnalysisCtx): ErrorAnalysisCtx, Bool {
        match(e)@ {
            LiteralNoneExpression => { return ectx, false; }
            | LiteralSimpleExpression => { return ectx, false; }
            | LiteralCStringExpression => { return ectx, false; }
            | LiteralStringExpression => { return ectx, false; }
            | LiteralCRegexExpression => { return ectx, false; }
            | LiteralRegexExpression => { return ectx, false; }
            | LiteralTypeDeclValueExpression => { return ectx, $e.invchecks; }
            | AccessNamespaceConstantExpression => { return ectx, false; }
            | AccessStaticFieldExpression => { return ectx, false; }
            | AccessEnumExpression => { return ectx, false; }
            | AccessVariableExpression => { return ectx, false; }
            | AccessCapturedVariableExpressionSpecial => { return ectx, false; }
            | ConstructorExpression => { abort; }
            | ConstructorLambdaExpression => { return ectx, false; }
            | LetExpression => { abort; }
            | LambdaInvokeExpression => { abort; }
            | CallNamespaceFunctionExpression => { abort; }
            | CallTypeFunctionExpression => { abort; }
            | CallTypeFunctionSpecialExpression => { abort; }
            | CallRefInvokeStaticResolveExpression => { abort; }
            | CallRefInvokeVirtualExpression => { abort; }
            | LogicActionAndExpression => { abort; }
            | LogicActionOrExpression => { abort; }
            | TypeDeclPrimitiveFieldAccessExpression => { abort; }
            | CoerceNarrowTypeExpression => { abort; }
            | CoerceWidenTypeExpression => { abort; }
            | SafeConvertExpression => { abort; }
            | CreateDirectExpression => { abort; }
            | PostfixOp => { abort; }
            | UnaryExpression => { abort; }
            | BinaryArithExpression => { return this.processArgs(List<BSQAssembly::Expression>{$e.lhs, $e.rhs}, ectx); }
            | BinaryKeyEqExpression => { abort; }
            | KeyCmpEqualExpression => { abort; }
            | KeyCmpLessExpression => { abort; }
            | BinaryNumericExpression => { abort; }
            | BinLogicExpression => { abort; }
            | MapEntryConstructorExpression => { abort; }
            | IfExpression => { abort; }
        }
    }

    method processStatement(s: Statement, ectx: ErrorAnalysisCtx): ErrorAnalysisCtx, Bool {
        match(s)@ {
            ReturnVoidStatement => {
                return ectx, false;
            }
            | ReturnSingleStatement => {
                return this.processExpression($s.value, ectx);
            }
            | ReturnMultiStatement => {
                abort; %% NOT IMPLEMENTED
            }
        }
    }

   method processInvokeParameter(param: InvokeParameterDecl): InvokeParameterDecl {
      if(param.defaultval)@none {
         return param;
      }
      else {
         abort;
      }
   }

   method processPrecondition(precond: PreConditionDecl): PreConditionDecl {
      abort;
   }

   method processPostcondition(postcond: PostConditionDecl): PostConditionDecl {
      abort;
   }

   method processBodyStatementList(stmts: List<Statement>, vmap: VarMapping): List<Statement>, VarMapping {
        let rr = stmts.transduce<VarMapping, Statement>(vmap, fn(vmap, stmt) => {
            let rs = this.processStatement(stmt, vmap);
            return rs.1, rs.0;
         });

         return rr.1, rr.0; %%TODO: in our language we might also want to have a project elist to allow for quick reshuffles in cases like this
    }

   method processBodyImpl(body: BodyImplementation): BodyImplementation {
      match(body)@ {
         ExpressionBodyImplementation => { return ExpressionBodyImplementation{ this.processExpression($body.exp, VarMapping::createEmpty()).0 }; }
         | StandardBodyImplementation => { return StandardBodyImplementation{ this.processBodyStatementList($body.statements, VarMapping::createEmpty()).0 }; }
         | _ => { return body; }
      }
   }

   method processNamespaceConstDecl(nsconst: NamespaceConstDecl): NamespaceConstDecl {
      let evalue = this.processExpression(nsconst.value, VarMapping::createEmpty()).0;
      return nsconst[value=evalue];
   }

   method processConstMemberDecl(typeconst: ConstMemberDecl): ConstMemberDecl {
      let evalue = this.processExpression(typeconst.value, VarMapping::createEmpty()).0;
      return typeconst[value=evalue];
   }

   method processNamespaceFunctionDecl(nsfunc: NamespaceFunctionDecl): NamespaceFunctionDecl {
      return NamespaceFunctionDecl{
         file = nsfunc.file,
         sinfo = nsfunc.sinfo,
         declaredInNS = nsfunc.declaredInNS,

         attributes = nsfunc.attributes,
         name = nsfunc.name,

         ikey = nsfunc.ikey,
         irecursive = nsfunc.irecursive,
         params = nsfunc.params.map<InvokeParameterDecl>(fn(param) => this.processInvokeParameter(param)),
         resultType = nsfunc.resultType,

         body = this.processBodyImpl(nsfunc.body),

         preconditions = nsfunc.preconditions.map<PreConditionDecl>(fn(precond) => this.processPrecondition(precond)),
         postconditions = nsfunc.postconditions.map<PostConditionDecl>(fn(postcond) => this.processPostcondition(postcond)),
         fkind = nsfunc.fkind
      };
   }

   method processTypeFunctionDecl(typefunc: TypeFunctionDecl): TypeFunctionDecl {
      abort;
   }

   method processMethodDeclAbstract(absmethod: MethodDeclAbstract): MethodDeclAbstract {
      abort;
   }

   method processMethodDeclVirtual(virtmethod: MethodDeclVirtual): MethodDeclVirtual {
      abort;
   }

   method processMethodDeclOverride(overmethod: MethodDeclOverride): MethodDeclOverride {
      abort;
   }

   method processMethodDeclStatic(staticmethod: MethodDeclStatic): MethodDeclStatic {
      abort;
   }

   method processEnumTypeDecl(enumdecl: EnumTypeDecl): EnumTypeDecl {
      abort;
   }

   method processTypedeclTypeDecl(typedecl: TypedeclTypeDecl): TypedeclTypeDecl {
      abort;
   }

   method processPrimitiveEntityTypeDecl(primtype: PrimitiveEntityTypeDecl): PrimitiveEntityTypeDecl {
      return primtype;
   }

   method processConstructableTypeDecl(ctype: ConstructableTypeDecl): ConstructableTypeDecl {
      abort;
   }

   method processCollectionTypeDecl(ctype: CollectionTypeDecl): CollectionTypeDecl {
      abort;
   }

   method processEntityTypeDecl(etype: EntityTypeDecl): EntityTypeDecl {
      abort;
   }

   method processDatatypeMemberEntityTypeDecl(dmtype: DatatypeMemberEntityTypeDecl): DatatypeMemberEntityTypeDecl {
      abort;
   }

   method processPrimitiveConceptTypeDecl(pconcept: PrimitiveConceptTypeDecl): PrimitiveConceptTypeDecl {
      abort;
   }

   method processConceptTypeDecl(cconcept: ConceptTypeDecl): ConceptTypeDecl {
      abort;
   }

   method processDatatypeTypeDecl(ddatatype: DatatypeTypeDecl): DatatypeTypeDecl {
      abort;
   }

   function process(assembly: Assembly): Assembly {
      let explicitifier = ExplicitifyTransform{ assembly };

      return Assembly{
         nsconsts = assembly.nsconsts.map<NamespaceConstDecl>(fn(nsconst) => explicitifier.processNamespaceConstDecl(nsconst)),
         typeconsts = assembly.typeconsts.map<ConstMemberDecl>(fn(typeconst) => explicitifier.processConstMemberDecl(typeconst)),

         nsfuncs = assembly.nsfuncs.map<NamespaceFunctionDecl>(fn(ikey, nsfunc) => explicitifier.processNamespaceFunctionDecl(nsfunc)),
         typefuncs = assembly.typefuncs.map<TypeFunctionDecl>(fn(ikey, typefunc) => explicitifier.processTypeFunctionDecl(typefunc)),

         absmethods = assembly.absmethods.map<MethodDeclAbstract>(fn(ikey, absmethod) => explicitifier.processMethodDeclAbstract(absmethod)),
         virtmethods = assembly.virtmethods.map<MethodDeclVirtual>(fn(ikey, virtmethod) => explicitifier.processMethodDeclVirtual(virtmethod)),
         overmethods = assembly.overmethods.map<MethodDeclOverride>(fn(ikey, overmethod) => explicitifier.processMethodDeclOverride(overmethod)),
         staticmethods = assembly.staticmethods.map<MethodDeclStatic>(fn(ikey, staticmethod) => explicitifier.processMethodDeclStatic(staticmethod)),

         enums = assembly.enums.map<EnumTypeDecl>(fn(ikey, enumdecl) => explicitifier.processEnumTypeDecl(enumdecl)),
         typedecls = assembly.typedecls.map<TypedeclTypeDecl>(fn(ikey, typedecl) => explicitifier.processTypedeclTypeDecl(typedecl)),

         primtives = assembly.primtives.map<PrimitiveEntityTypeDecl>(fn(ikey, primtype) => explicitifier.processPrimitiveEntityTypeDecl(primtype)),
         constructables = assembly.constructables.map<ConstructableTypeDecl>(fn(ikey, ctype) => explicitifier.processConstructableTypeDecl(ctype)),
         collections = assembly.collections.map<CollectionTypeDecl>(fn(ikey, ctype) => explicitifier.processCollectionTypeDecl(ctype)),

         entities = assembly.entities.map<EntityTypeDecl>(fn(ikey, etype) => explicitifier.processEntityTypeDecl(etype)),
         datamembers = assembly.datamembers.map<DatatypeMemberEntityTypeDecl>(fn(ikey, dmtype) => explicitifier.processDatatypeMemberEntityTypeDecl(dmtype)),

         pconcepts = assembly.pconcepts.map<PrimitiveConceptTypeDecl>(fn(ikey, pconcept) => explicitifier.processPrimitiveConceptTypeDecl(pconcept)),
         concepts = assembly.concepts.map<ConceptTypeDecl>(fn(ikey, cconcept) => explicitifier.processConceptTypeDecl(cconcept)),

         datatypes = assembly.datatypes.map<DatatypeTypeDecl>(fn(ikey, ddatatype) => explicitifier.processDatatypeTypeDecl(ddatatype)),

         allfuncs = assembly.allfuncs,
         allmethods = assembly.allmethods,
         allvmethods = assembly.allvmethods,

         allconcretetypes = assembly.allconcretetypes,
         allabstracttypes = assembly.allabstracttypes
      };
   }
}
