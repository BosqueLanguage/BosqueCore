
namespace SMTEmitter;

namespace TransformNameManager {
    const c_dangerous: Map<CString, CString> = Map<CString, CString>{
        'ite' => '@ite'
    };

    function resymbolCStringForSMT(cstr: CString): CString {
        return cstr.replaceAllStringOccurrences('::', '@')
            .replaceAllStringOccurrences(', ', '-')
            .replaceAllStringOccurrences('(|', '@EList<')
            .replaceAllStringOccurrences('|)', '>');
    }

    function safeifyName(name: CString): CString {
        if(!TransformNameManager::c_dangerous.has(name)) {
            return name;
        }
        else {
            return TransformNameManager::c_dangerous.get(name);
        }    
    }

    function convertNamespaceKey(nskey: BSQAssembly::NamespaceKey): SMTAssembly::NamespaceKey {
        return SMTAssembly::NamespaceKey::from(resymbolCStringForSMT(nskey.value));
    }

    function convertTypeKey(nskey: BSQAssembly::TypeKey): SMTAssembly::TypeKey {
        return SMTAssembly::TypeKey::from(resymbolCStringForSMT(nskey.value));
    }

    function convertInvokeKey(ikey: BSQAssembly::InvokeKey, ttags: List<Bool>): SMTAssembly::InvokeKey {
        if(ttags.empty()) {
            return SMTAssembly::InvokeKey::from(resymbolCStringForSMT(ikey.value));
        }
        else {
            if(ttags.allOf(pred(tt) => !tt)) {
                return SMTAssembly::InvokeKey::from(resymbolCStringForSMT(ikey.value));
            }
            else {
                let ttagstr = CString::concatAll(ttags.map<CString>(fn(tt) => if(tt) then 'T' else 'F'));
                return SMTAssembly::InvokeKey::from(CString::concat(resymbolCStringForSMT(ikey.value), '$$', ttagstr));
            }
        }
    }

    function generateNameForFieldDefaultFunction(tkey: BSQAssembly::TypeKey, fname: CString): CString {
        return CString::join('-', '@FieldDefault', TransformNameManager::resymbolCStringForSMT(tkey.value), fname);
    }

    function generateNameForInvariantFunction(tkey: BSQAssembly::TypeKey, iid: CString): CString {
        return CString::join('-', '@Invariant', TransformNameManager::resymbolCStringForSMT(tkey.value), iid);
    }
}

datatype SMTExpTransformResult using {
    field oftype: SMTAssembly::TypeKey;
}
of 
SafeResult { field exp: SMTAssembly::SafeExpression; }
| ErrorResult { field exp: SMTAssembly::Expression; }
;

entity LambdaGeneratorInfo {
    field invoke: BSQAssembly::InvokeKey;
    field largerrors: List<(|BSQAssembly::Identifier, Bool|)>;

    function isame(lg1: LambdaGeneratorInfo, lg2: LambdaGeneratorInfo): Bool {
        if(\/(lg1.invoke !== lg2.invoke, lg1.largerrors.size() !== lg2.largerrors.size())) {
            return false;
        } 
        
        return lg1.largerrors.allOf(pred(e1) => {
            let e2 = lg2.largerrors.tryFind(pred(e2) => e1.0 === e2.0);
            return if(e2)@some then e1.1 === $e2.1 else false;
        });
    }
}

entity LambdaGeneratorState {
    field smap: Map<BSQAssembly::InvokeKey, List<LambdaGeneratorInfo>>;

    method getLambdaGeneratorInfo(ikey: BSQAssembly::InvokeKey): Option<List<LambdaGeneratorInfo>> {
        return this.smap.tryGet(ikey);
    }

    method mergeLambdaGeneratorInfo(lgeninfo: List<LambdaGeneratorInfo>): LambdaGeneratorState {
        let nsmap = lgeninfo.reduce<Map<BSQAssembly::InvokeKey, List<LambdaGeneratorInfo>>>(this.smap, fn(mm, lgi) => {
            if(!mm.has(lgi.invoke)) {
                return mm.insert(lgi.invoke, List<LambdaGeneratorInfo>{lgi});
            }
            else {
                let llist = mm.get(lgi.invoke);
                if(llist.someOf(pred(lgi2) => LambdaGeneratorInfo::isame(lgi, lgi2))) {
                    return mm;
                }
                else {
                    return mm.set(lgi.invoke, llist.pushBack(lgi));
                }
            }
        });

        return LambdaGeneratorState{nsmap};
    }
}

entity SMTTransformerCtx {
    field mayErrorReturn: Bool;
    field lambdaerr: Map<BSQAssembly::Identifier, Bool>;

    field currentFile: String;
    field currentInvoke: Option<BSQAssembly::InvokeKey>;

    field tempCtr: Nat;
    field errCtr: Nat;

    field errors: List<SMTAssembly::ErrorInfo>;
    field lambdagen: List<LambdaGeneratorInfo>;

    method addError(bsqsinfo: BSQAssembly::SourceInfo): SMTTransformerCtx {
        let smtsinfo = SMTAssembly::SourceInfo{bsqsinfo.line, bsqsinfo.column};
        let iiv = if ($ci = this.currentInvoke)@some then some($ci.value) else none; 
        let errinfo = SMTAssembly::ErrorInfo{this.errCtr, this.currentFile, smtsinfo, iiv};

        return this[errors = $errors.pushBack(errinfo), errCtr = $errCtr + 1n];
    }
}

entity SMTTransformer {
    field assembly: BSQAssembly::Assembly;
    field callg: BSQToSMTCallGraph;
    field errinvokes: Map<BSQAssembly::InvokeKey, Bool>;

    field erranalysis: MayErrorAnalysis;

    const nonetype: BSQAssembly::TypeSignature = BSQAssembly::NominalTypeSignature{ BSQAssembly::SourceInfo{0n, 0n, 0n, 0n}, 'None'<BSQAssembly::TypeKey> };
    const booltype: BSQAssembly::TypeSignature = BSQAssembly::NominalTypeSignature{ BSQAssembly::SourceInfo{0n, 0n, 0n, 0n}, 'Bool'<BSQAssembly::TypeKey> };

    function isTermSMTTypeKey(tkey: SMTAssembly::TypeKey): Bool {
        return tkey === '@Term'<SMTAssembly::TypeKey>;
    }

    method transformParamTypeToSMT(tsig: BSQAssembly::TypeSignature, islambdaerr: Bool): SMTAssembly::TypeKey {
        if(tsig)@!<BSQAssembly::LambdaTypeSignature> {
            return this.transformStdTypeToSMT(tsig);
        }
        else {
            let ptypes = $tsig.params.map<CString>(fn(pt) => this.transformStdTypeToSMT(pt.ptype).value);
            let rtype = if (islambdaerr) then CString::concat('(@Result ', this.transformStdTypeToSMT($tsig.resultType).value, ')')  else this.transformStdTypeToSMT($tsig.resultType).value;
            return SMTAssembly::TypeKey::from(CString::concat('(Array ', CString::joinAll(' ', ptypes), ' ', rtype, ')'));
        }
    }

    method transformStdTypeToSMT(tsig: BSQAssembly::TypeSignature): SMTAssembly::TypeKey {
        if(tsig)@<BSQAssembly::LambdaTypeSignature> {
            let ptypes = $tsig.params.map<CString>(fn(pt) => this.transformStdTypeToSMT(pt.ptype).value);
            let rtype = this.transformStdTypeToSMT($tsig.resultType).value;
            return SMTAssembly::TypeKey::from(CString::concat('(Array ', CString::joinAll(' ', ptypes), ' ', rtype, ')'));
        }
        else {
            if(tsig)@!<BSQAssembly::NominalTypeSignature> {
                return TransformNameManager::convertTypeKey(tsig.tkeystr);
            }
            else {
                if(this.assembly.isNominalTypeConcrete($tsig.tkeystr)) {
                    return TransformNameManager::convertTypeKey($tsig.tkeystr);
                }
                else {
                    return SMTAssembly::TypeKey::from('@Term');
                }
            }
        }
    }

    method unpackSingleResultErrors(subexp: SMTExpTransformResult, ctx: SMTTransformerCtx): SMTAssembly::SafeExpression, SMTTransformerCtx, Option<List<(|SMTAssembly::Expression, SMTAssembly::TypeKey, SMTAssembly::Identifier|)>> {
        if(subexp)@<SafeResult> {
            return $subexp.exp, ctx, none;
        }
        else {
            let mtag = ctx.tempCtr.toCString();
            let vname = SMTAssembly::Identifier::from(CString::concat('@tmp-', mtag));
            let vtype = $subexp.oftype;
            let rexp = SMTAssembly::UnwrapFromResultExpression{$subexp.oftype, vname};

            return rexp, ctx[tempCtr = $tempCtr + 1n], some(List<(|SMTAssembly::Expression, SMTAssembly::TypeKey, SMTAssembly::Identifier|)>{(|$subexp.exp, vtype, vname|)});
        }
    }

    method unpackExpressionErrors(subexps: List<SMTExpTransformResult>, ctx: SMTTransformerCtx): List<SMTAssembly::SafeExpression>, SMTTransformerCtx, Option<List<(|SMTAssembly::Expression, SMTAssembly::TypeKey, SMTAssembly::Identifier|)>> {
        if(subexps.allOf(pred(etr) => etr?<SafeResult>)) {
            return subexps.map<SMTAssembly::SafeExpression>(fn(etr) => etr@<SafeResult>.exp), ctx, none;
        }
        else {
            let mtag = ctx.tempCtr.toCString();
            let eexps = subexps.mapIdx<(|SMTExpTransformResult, Option<SMTAssembly::Identifier>|)>(fn(etr, idx) => {
                if(etr)<SafeResult> {
                    return (|etr, none|);
                }
                else {
                    let vname = SMTAssembly::Identifier::from(CString::concat('@tmp-', mtag, '-', idx.toCString()));
                    return (|etr, some(vname)|);
                }
            });

            let exps = eexps.map<SMTAssembly::SafeExpression>(fn(etrp) => {
                if($vv = etrp.0)@<SafeResult> {
                    return $vv.exp;
                }
                else {
                    return SMTAssembly::UnwrapFromResultExpression{$vv.oftype, etrp.1@some};
                }
            });

            let binds = eexps.filter(pred(etrp) => etrp.0?<ErrorResult>).map<(|SMTAssembly::Expression, SMTAssembly::TypeKey, SMTAssembly::Identifier|)>(fn(etrp) => (|etrp.0@<ErrorResult>.exp, etrp.0@<ErrorResult>.oftype, etrp.1@some|));

            return exps, ctx[tempCtr = $tempCtr + 1n], some(binds);
        }
    }

    recursive method processArgsInOrder(args: List<BSQAssembly::Expression>, ctx: SMTTransformerCtx): List<SMTAssembly::SafeExpression>, SMTTransformerCtx, Option<List<(|SMTAssembly::Expression, SMTAssembly::TypeKey, SMTAssembly::Identifier|)>> {
        let nctx, subexps = args.transduce<SMTTransformerCtx, SMTExpTransformResult>(ctx, recursive fn(ctx, arg) => this.transformExpressionToSMT[recursive](arg, ctx));

        return this.unpackExpressionErrors(subexps, nctx);
    }

    recursive method processUnaryArg(arg: BSQAssembly::Expression, ctx: SMTTransformerCtx): SMTAssembly::SafeExpression, SMTTransformerCtx, Option<List<(|SMTAssembly::Expression, SMTAssembly::TypeKey, SMTAssembly::Identifier|)>> {
        let rexps, nctx, obinds = this.processArgsInOrder[recursive](List<BSQAssembly::Expression>{arg}, ctx);
        return rexps.get(0n), nctx, obinds;
    }

    recursive method processBinaryArgs(lhs: BSQAssembly::Expression, rhs: BSQAssembly::Expression, ctx: SMTTransformerCtx): SMTAssembly::SafeExpression, SMTAssembly::SafeExpression, SMTTransformerCtx, Option<List<(|SMTAssembly::Expression, SMTAssembly::TypeKey, SMTAssembly::Identifier|)>> {
        let rexps, nctx, obinds = this.processArgsInOrder[recursive](List<BSQAssembly::Expression>{lhs, rhs}, ctx);
        return rexps.get(0n), rexps.get(1n), nctx, obinds;
    }

    method wrapOperationResult(etype: BSQAssembly::TypeSignature, exp: SMTAssembly::SafeExpression, binds: Option<List<(|SMTAssembly::Expression, SMTAssembly::TypeKey, SMTAssembly::Identifier|)>>): SMTExpTransformResult {
        let smtetype = this.transformStdTypeToSMT(etype);

        if(binds)@none {
            return SafeResult{smtetype, exp};
        }
        else {
            let rexp = SMTAssembly::WrapIntoResultExpression{smtetype, exp};
            let lerr = SMTAssembly::LetWErrorsExpression{smtetype, $binds, rexp};

            return ErrorResult{smtetype, lerr};
        }
    }

    method wrapOperationResultWErr(etype: BSQAssembly::TypeSignature, exp: SMTAssembly::Expression, binds: Option<List<(|SMTAssembly::Expression, SMTAssembly::TypeKey, SMTAssembly::Identifier|)>>): SMTExpTransformResult {
        let smtetype = this.transformStdTypeToSMT(etype);

        if(binds)@none {
            return ErrorResult{smtetype, exp};
        }
        else {
            return ErrorResult{smtetype, SMTAssembly::LetWErrorsExpression{smtetype, $binds, exp}};
        }
    }

    method transformLiteralNoneExpression(exp: BSQAssembly::LiteralNoneExpression): SMTAssembly::SafeExpression {
        return SMTAssembly::LiteralNoneExpression{};
    }

    method transformLiteralSimpleExpression(exp: BSQAssembly::LiteralSimpleExpression): SMTAssembly::SafeExpression {
        return SMTAssembly::LiteralSimpleExpression{this.transformStdTypeToSMT(exp.etype), exp.value};
    }

    method transformLiteralCStringExpression(exp: BSQAssembly::LiteralCStringExpression): SMTAssembly::SafeExpression {
        return SMTAssembly::LiteralCStringExpression{exp.value};
    }

    method transformLiteralStringExpression(exp: BSQAssembly::LiteralStringExpression): SMTAssembly::SafeExpression {
        return SMTAssembly::LiteralStringExpression{exp.value};
    }

    method transformAccessVariableExpression(exp: BSQAssembly::AccessVariableExpression): SMTAssembly::SafeExpression {
        return SMTAssembly::AccessVariableExpression{SMTAssembly::Identifier::from(TransformNameManager::safeifyName(exp.vname.value))};
    }

    method transformAccessCapturedVariableExpression(exp: BSQAssembly::AccessCapturedVariableExpression): SMTAssembly::SafeExpression {
        return SMTAssembly::AccessVariableExpression{SMTAssembly::Identifier::from(TransformNameManager::safeifyName(exp.vname.value))};
    }

    recursive method transformConstructorPrimarySpecialSomeExpression(e: BSQAssembly::ConstructorPrimarySpecialSomeExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let uarg, nctx, obinds = this.processUnaryArg[recursive](e.args.args.get(0n).exp, ctx);
        let smttype = this.transformStdTypeToSMT(e.ctype);

        let createop = SMTAssembly::ConstructorPrimarySpecialConstructableExpression{smttype, uarg};

        return nctx, this.wrapOperationResult(e.ctype, createop, obinds);
    }

    recursive method transformConstructorStdExpression(e: BSQAssembly::ConstructorStdExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let aargs, nctx, obinds = this.processArgsInOrder[recursive](e.args.args.map<BSQAssembly::Expression>(fn(arg) => arg.exp), ctx);
        let smttype = this.transformStdTypeToSMT(e.ctype);

        let tdecl = this.assembly.lookupNominalTypeDeclaration(e.ctype.tkeystr);
        let invchecks = !tdecl.allInvariants.empty();

        let needsdefault = !e.shuffleinfo.allOf(pred(arg) => arg.0?some);
        if(!invchecks && !needsdefault) {
            let orderargs = e.shuffleinfo.map<SMTAssembly::SafeExpression>(fn(si) => aargs.get(si.0@some));
            let createop = SMTAssembly::ConstructorStdExpression{smttype, orderargs};

            return nctx, this.wrapOperationResult(e.ctype, createop, obinds);
        }
        else {
            var orderargs: List<SMTAssembly::SafeExpression>;
            if(!needsdefault) {
                orderargs = e.shuffleinfo.map<SMTAssembly::SafeExpression>(fn(si) => aargs.get(si.0@some));
            }
            else {
                abort;
            }

            let createop = SMTAssembly::WrapIntoResultExpression{this.transformStdTypeToSMT(e.ctype), SMTAssembly::ConstructorStdExpression{smttype, orderargs}};

            let rctx, iichecks = tdecl.allInvariants.ltransduce<SMTTransformerCtx, (|SMTAssembly::Expression, Nat|)>(nctx, fn(cctx, iiv) => {
                let iitypekey = this.transformStdTypeToSMT(iiv.declaredInType);
                let iitypedecl = this.assembly.lookupNominalTypeDeclaration(iiv.declaredInType.tkeystr);
                let smtikey = TransformNameManager::convertInvokeKey(iiv.ikey, List<Bool>{});
                
                let eeid = cctx.errCtr;
                let aargs = orderargs.firstK(iitypedecl.saturatedBFieldInfo.size());
                if(!this.errinvokes.get(iiv.ikey)) {
                    return cctx.addError(e.sinfo), (|SMTAssembly::CallFunctionSafeExpression{smtikey, aargs}, eeid|);
                }
                else {
                    return cctx.addError(e.sinfo), (|SMTAssembly::CallFunctionExpression{smtikey, aargs}, eeid|);
                }
            });

            let createexp = SMTAssembly::AssertSetExpression{this.transformStdTypeToSMT(e.ctype), iichecks, createop};
            return rctx, this.wrapOperationResultWErr(e.ctype, createexp, obinds);
        }
    }

    recursive method transformConstructorPrimaryListExpression(e: BSQAssembly::ConstructorPrimaryListExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let aargs, nctx, obinds = this.processArgsInOrder[recursive](e.args.args.map<BSQAssembly::Expression>(fn(arg) => arg.exp), ctx);
        let smttype = this.transformStdTypeToSMT(e.ctype);
        let oftype = this.transformStdTypeToSMT(e.ctype);

        if(e.args.args.allOf(pred(arg) => arg?<BSQAssembly::PositionalArgumentValue>)) {
            return nctx, this.wrapOperationResult(e.ctype, SMTAssembly::ConstructorListSingletonExpression{smttype, oftype, aargs}, obinds);
        }
        else {
            abort; %% Not implemented
        }
    }

    recursive method transformConstructorEListExpression(e: BSQAssembly::ConstructorEListExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        abort;
    }

    recursive method transformConstructorExpression(e: BSQAssembly::ConstructorExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        match(e)@ {
            BSQAssembly::ConstructorPrimaryListExpression => { return this.transformConstructorPrimaryListExpression($e, ctx); }
            | BSQAssembly::ConstructorPrimaryMapExpression => { abort; }
            | BSQAssembly::ConstructorPrimarySpecialSomeExpression => { return this.transformConstructorPrimarySpecialSomeExpression($e, ctx); }
            | BSQAssembly::ConstructorPrimarySpecialOkExpression => { abort; }
            | BSQAssembly::ConstructorPrimarySpecialFailExpression => { abort; }
            | BSQAssembly::ConstructorTypeDeclExpression => { abort; }
            | BSQAssembly::ConstructorTypeDeclStringExpression => { abort; }
            | BSQAssembly::ConstructorStdExpression => { return this.transformConstructorStdExpression($e, ctx); }
            | BSQAssembly::ConstructorEListExpression => { return this.transformConstructorEListExpression($e, ctx); }
        }
    }

    recursive method transformConstructorLambdaExpression(e: BSQAssembly::ConstructorLambdaExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let lambda = e.etype@<BSQAssembly::LambdaTypeSignature>;
        let params = lambda.params.map<(|SMTAssembly::Identifier, SMTAssembly::TypeKey|)>(fn(p) => (|SMTAssembly::Identifier::from(p.pname), this.transformStdTypeToSMT(p.ptype)|));

        let lambdamayerror = this.erranalysis.processConstructorLambdaExpression(e, this.errinvokes, ctx.lambdaerr);
        let resultType = if(lambdamayerror) then SMTAssembly::ErrorResult{ this.transformStdTypeToSMT(lambda.resultType) } else SMTAssembly::SafeResult{ this.transformStdTypeToSMT(lambda.resultType) };
        let lctx = ctx[mayErrorReturn=lambdamayerror];
        let rctx, bop = this.transformBodyToSMTOperation[recursive](e.body, lctx, lambda.resultType);

        return rctx[mayErrorReturn=ctx.mayErrorReturn], this.wrapOperationResult(e.etype, SMTAssembly::LambdaConstructor{ params, resultType, bop }, none);
    }

    recursive method transformLambdaInvokeExpression(e: BSQAssembly::LambdaInvokeExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let aargs, nctx, obinds = this.processArgsInOrder[recursive](e.argsinfo.args.args.map<BSQAssembly::Expression>(fn(arg) => arg.exp), ctx);
    
        if(!ctx.lambdaerr.get(e.fname)) {
            let callop = SMTAssembly::CallLambdaFunctionSafeExpression{SMTAssembly::Identifier::from(e.fname), aargs};
            return nctx, this.wrapOperationResult(e.lambda.resultType, callop, obinds);
        }
        else {
            let callop = SMTAssembly::CallLambdaFunctionExpression{SMTAssembly::Identifier::from(e.fname), aargs};
            return nctx, this.wrapOperationResultWErr(e.lambda.resultType, callop, obinds);
        }
    }

    recursive method transformCallNamespaceFunctionExpression(e: BSQAssembly::CallNamespaceFunctionExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        var sccerr = false;
        if($cinv = ctx.currentInvoke)@some {
            sccerr = this.callg.sccs.someOf(pred(scc) => /\(scc.contains($cinv), scc.contains(e.ikey)));
        }

        if(sccerr) {
            let abtop = SMTAssembly::AbortExpression{this.transformStdTypeToSMT(e.etype), SMTEmitter::s_invalidErrTrgt};
            return ctx, ErrorResult{this.transformStdTypeToSMT(e.etype), abtop};
        }
        else {
            let aargs, nctx, obinds = this.processArgsInOrder[recursive](e.argsinfo.args.args.map<BSQAssembly::Expression>(fn(arg) => arg.exp), ctx);

            let fdecl = this.assembly.tryLookupInvokeImplDeclaration(e.ikey)@some;
            let largs = fdecl.params.mapIdx<Option<(|BSQAssembly::Identifier, Bool|)>>(fn(p, ii) => {
                if(p.ptype)@!<BSQAssembly::LambdaTypeSignature> {
                    return none;
                }
                else {
                    let iserr = this.erranalysis.processExpression(e.argsinfo.args.args.get(ii).exp, this.errinvokes, ctx.lambdaerr);
                    return some((|p.pname, iserr|));
                }
            })
            %%TODO: make this filterSome<(|BSQAssembly::Identifier, Bool|)>(); when that works
            .filter(pred(aa) => aa?some)
            .map<(|BSQAssembly::Identifier, Bool|)>(fn(aa) => aa@some);

            let fctx = if(!largs.empty()) then nctx[lambdagen=$lambdagen.pushBack(LambdaGeneratorInfo{e.ikey, largs})] else nctx;
            if(/\(largs.allOf(pred(aa) => !aa.1), !this.errinvokes.get(e.ikey))) {
                let smtikey = TransformNameManager::convertInvokeKey(e.ikey, List<Bool>{});

                let callop = SMTAssembly::CallFunctionSafeExpression{smtikey, aargs};
                return fctx, this.wrapOperationResult(e.etype, callop, obinds);
            }
            else {
                let smtikey = TransformNameManager::convertInvokeKey(e.ikey, largs.map<Bool>(fn(aa) => aa.1));

                let callop = SMTAssembly::CallFunctionExpression{smtikey, aargs};
                return fctx, this.wrapOperationResultWErr(e.etype, callop, obinds);
            }
        }
    }

    recursive method transformCoerceNarrowTypeExpression(e: BSQAssembly::CoerceNarrowTypeExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, nctx, obinds = this.processUnaryArg[recursive](e.exp, ctx);
        let narrowop = SMTAssembly::UntermifyExpression{onarg, this.transformStdTypeToSMT(e.srctype), this.transformStdTypeToSMT(e.trgttype)};

        return nctx, this.wrapOperationResult(e.trgttype, narrowop, obinds);
    } 
             
    recursive method transformCoerceWidenTypeExpression(e: BSQAssembly::CoerceWidenTypeExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, nctx, obinds = this.processUnaryArg[recursive](e.exp, ctx);
        let widenop = SMTAssembly::TermifyExpression{onarg, this.transformStdTypeToSMT(e.srctype), this.transformStdTypeToSMT(e.trgttype)};

        return nctx, this.wrapOperationResult(e.trgttype, widenop, obinds);
    } 

    recursive method transformSafeConvertExpression(e: BSQAssembly::SafeConvertExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, nctx, obinds = this.processUnaryArg[recursive](e.exp, ctx);

        return nctx, this.wrapOperationResult(e.trgttype, onarg, obinds);
    }

    method transformITestTypeAsTest(srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestType, onarg: SMTAssembly::SafeExpression): SMTAssembly::SafeExpression {
        abort; %% Not implemented
    }

    method transformITestNoneAsTest(srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestNone, onarg: SMTAssembly::SafeExpression): SMTAssembly::SafeExpression {
        return if(itest.isnot) then SMTAssembly::BinKeyNotEqNoneExpression{onarg} else SMTAssembly::BinKeyEqNoneExpression{onarg};
    }

    method transformITestSomeAsTest(srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestSome, onarg: SMTAssembly::SafeExpression): SMTAssembly::SafeExpression {
        return if(itest.isnot) then SMTAssembly::BinKeyEqNoneExpression{onarg} else SMTAssembly::BinKeyNotEqNoneExpression{onarg};
    }

    method transformITestOkAsTest(srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestOk, onarg: SMTAssembly::SafeExpression): SMTAssembly::SafeExpression {
        abort; %% Not implemented
    }

    method transformITestFailAsTest(srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestFail, onarg: SMTAssembly::SafeExpression): SMTAssembly::SafeExpression {
        abort; %% Not implemented
    }

    method transformITestAsTest(srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITest, onarg: SMTAssembly::SafeExpression): SMTAssembly::SafeExpression {
        match(itest)@ {
            BSQAssembly::ITestType => { return this.transformITestTypeAsTest(srctype, $itest, onarg); }
            | BSQAssembly::ITestNone => { return this.transformITestNoneAsTest(srctype, $itest, onarg); }
            | BSQAssembly::ITestSome => { return this.transformITestSomeAsTest(srctype, $itest, onarg); }
            | BSQAssembly::ITestOk => { return this.transformITestOkAsTest(srctype, $itest, onarg); }
            | BSQAssembly::ITestFail => { return this.transformITestFailAsTest(srctype, $itest, onarg); }
        }
    }

    method transformITestPostfixOp(op: BSQAssembly::PostfixIsTest, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, nctx, obinds = this.unpackSingleResultErrors(bexp, ctx);
        let testop = this.transformITestAsTest(op.baseType, op.ttest, onarg);

        return nctx, this.wrapOperationResult(SMTTransformer::booltype, testop, obinds);
    }

    method transformITestTypeAsSafeConvertOptions(srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestType, onarg: SMTAssembly::SafeExpression): SMTAssembly::SafeExpression, SMTAssembly::SafeExpression {
        abort; %% Not implemented
    }

    method transformITestNoneAsSafeConvertOptions(srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestNone, onarg: SMTAssembly::SafeExpression): SMTAssembly::SafeExpression, SMTAssembly::SafeExpression {
        let optdecl = this.assembly.lookupNominalTypeDeclaration(srctype.tkeystr)@<BSQAssembly::OptionTypeDecl>;
        let someopt = SMTAssembly::ConvertOptionToSomeTExpression{TransformNameManager::convertTypeKey(srctype.tkeystr), TransformNameManager::convertTypeKey(optdecl.someType.tkeystr), onarg};
        let noneopt = SMTAssembly::LiteralNoneExpression{};

        if(itest.isnot) {    
            return someopt, noneopt;
        }
        else {
            return noneopt, someopt;
        }
    }

    method transformITestSomeAsSafeConvertOptions(srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestSome, onarg: SMTAssembly::SafeExpression): SMTAssembly::SafeExpression, SMTAssembly::SafeExpression {
        let optdecl = this.assembly.lookupNominalTypeDeclaration(srctype.tkeystr)@<BSQAssembly::OptionTypeDecl>;
        let someopt = SMTAssembly::ConvertOptionToSomeTExpression{TransformNameManager::convertTypeKey(srctype.tkeystr), TransformNameManager::convertTypeKey(optdecl.someType.tkeystr), onarg};
        let noneopt = SMTAssembly::LiteralNoneExpression{};
        
        if(itest.isnot) {
            return noneopt, someopt;
        }
        else {
            return someopt, noneopt;
        }
    }

    method transformITestOkAsSafeConvertOptions(srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestOk, onarg: SMTAssembly::SafeExpression): SMTAssembly::SafeExpression, SMTAssembly::SafeExpression {
        abort; %% Not implemented
    }

    method transformITestFailAsSafeConvertOptions(srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestFail, onarg: SMTAssembly::SafeExpression): SMTAssembly::SafeExpression, SMTAssembly::SafeExpression {
        abort; %% Not implemented
    }

    method transformITestAsSafeConvertOptions(srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITest, onarg: SMTAssembly::SafeExpression): SMTAssembly::SafeExpression, SMTAssembly::SafeExpression {
        match(itest)@ {
            BSQAssembly::ITestType => { return this.transformITestTypeAsSafeConvertOptions(srctype, $itest, onarg); }
            | BSQAssembly::ITestNone => { return this.transformITestNoneAsSafeConvertOptions(srctype, $itest, onarg); }
            | BSQAssembly::ITestSome => { return this.transformITestSomeAsSafeConvertOptions(srctype, $itest, onarg); }
            | BSQAssembly::ITestOk => { return this.transformITestOkAsSafeConvertOptions(srctype, $itest, onarg); }
            | BSQAssembly::ITestFail => { return this.transformITestFailAsSafeConvertOptions(srctype, $itest, onarg); }
        }
    }

    method transformITestTypeAsConvert(sinfo: BSQAssembly::SourceInfo, srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestType, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        abort; %% Not implemented
    }

    method transformITestNoneAsConvert(sinfo: BSQAssembly::SourceInfo, srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestNone, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, nctx, obinds = this.unpackSingleResultErrors(bexp, ctx);

        if(itest.isnot) {
            let chkexp = SMTAssembly::BinKeyNotEqNoneExpression{onarg};
            let optdecl = this.assembly.lookupNominalTypeDeclaration(srctype.tkeystr)@<BSQAssembly::OptionTypeDecl>;
            let accessop = SMTAssembly::ConvertOptionToSomeTExpression{TransformNameManager::convertTypeKey(srctype.tkeystr), TransformNameManager::convertTypeKey(optdecl.someType.tkeystr), onarg};

            let chkedop = SMTAssembly::AssertExpression{this.transformStdTypeToSMT(optdecl.oftype), chkexp, nctx.errCtr, SMTAssembly::WrapIntoResultExpression{this.transformStdTypeToSMT(optdecl.oftype), accessop}};
            return nctx.addError(sinfo), this.wrapOperationResultWErr(optdecl.oftype, chkedop, obinds);

        }
        else {
            let chkexp = SMTAssembly::BinKeyEqNoneExpression{onarg};
            let accessop = SMTAssembly::LiteralNoneExpression{};

            let chkedop = SMTAssembly::AssertExpression{'None'<SMTAssembly::TypeKey>, chkexp, nctx.errCtr, SMTAssembly::WrapIntoResultExpression{'None'<SMTAssembly::TypeKey>, accessop}};
            return nctx.addError(sinfo), this.wrapOperationResultWErr(SMTTransformer::nonetype, chkedop, obinds);
        }
    }

    method transformITestSomeAsConvert(sinfo: BSQAssembly::SourceInfo, srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestSome, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, nctx, obinds = this.unpackSingleResultErrors(bexp, ctx);
        
        if(itest.isnot) {
            let chkexp = SMTAssembly::BinKeyEqNoneExpression{onarg};
            let accessop = SMTAssembly::LiteralNoneExpression{};

            let chkedop = SMTAssembly::AssertExpression{'None'<SMTAssembly::TypeKey>, chkexp, nctx.errCtr, SMTAssembly::WrapIntoResultExpression{'None'<SMTAssembly::TypeKey>, accessop}};
            return nctx.addError(sinfo), this.wrapOperationResultWErr(SMTTransformer::nonetype, chkedop, obinds);
        }
        else {
            let chkexp = SMTAssembly::BinKeyNotEqNoneExpression{onarg};
            let optdecl = this.assembly.lookupNominalTypeDeclaration(srctype.tkeystr)@<BSQAssembly::OptionTypeDecl>;
            let accessop = SMTAssembly::ConvertOptionToSomeTExpression{TransformNameManager::convertTypeKey(srctype.tkeystr), TransformNameManager::convertTypeKey(optdecl.someType.tkeystr), onarg};

            let chkedop = SMTAssembly::AssertExpression{this.transformStdTypeToSMT(optdecl.oftype), chkexp, nctx.errCtr, SMTAssembly::WrapIntoResultExpression{this.transformStdTypeToSMT(optdecl.oftype), accessop}};
            return nctx.addError(sinfo), this.wrapOperationResultWErr(optdecl.oftype, chkedop, obinds);
        }
    }

    method transformITestOkAsConvert(sinfo: BSQAssembly::SourceInfo, srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestOk, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        abort; %% Not implemented
    }

    method transformITestFailAsConvert(sinfo: BSQAssembly::SourceInfo, srctype: BSQAssembly::TypeSignature, itest: BSQAssembly::ITestFail, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        abort; %% Not implemented
    }

    method processITestAsConvert(op: BSQAssembly::PostfixAsConvert, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        let sinfo = op.sinfo;

        match($itest = op.ttest)@ {
            BSQAssembly::ITestType => { return this.transformITestTypeAsConvert(sinfo, op.baseType, $itest, ctx, bexp); }
            | BSQAssembly::ITestNone => { return this.transformITestNoneAsConvert(sinfo, op.baseType, $itest, ctx, bexp); }
            | BSQAssembly::ITestSome => { return this.transformITestSomeAsConvert(sinfo, op.baseType, $itest, ctx, bexp); }
            | BSQAssembly::ITestOk => { return this.transformITestOkAsConvert(sinfo, op.baseType, $itest, ctx, bexp); }
            | BSQAssembly::ITestFail => { return this.transformITestFailAsConvert(sinfo, op.baseType, $itest, ctx, bexp); }
        }
    }

    recursive method processPostfixInvokeStatic(op: BSQAssembly::PostfixInvokeStatic, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, nctx, obinds = this.unpackSingleResultErrors(bexp, ctx);
        let scargs, scnctx, scobinds = this.processArgsInOrder[recursive](op.argsinfo.args.args.map<BSQAssembly::Expression>(fn(arg) => arg.exp), nctx);
        
        let aargs = scargs.pushFront(onarg);
        var allobinds: Option<List<(|SMTAssembly::Expression, SMTAssembly::TypeKey, SMTAssembly::Identifier|)>>;
        if(obinds)@some {
            if(scobinds)@some {
                allobinds = some($obinds.append($scobinds));
            }
            else {
                allobinds = obinds;
            }
        }
        else {
            if(scobinds)@some {
                allobinds = scobinds;
            }
            else {
                allobinds = none;
            }
        }

        let smdecl = this.assembly.tryLookupInvokeImplDeclaration(op.resolvedTrgt)@some;
        let largs = smdecl.params.mapIdx<Option<(|BSQAssembly::Identifier, Bool|)>>(fn(p, ii) => {
            if(p.ptype)@!<BSQAssembly::LambdaTypeSignature> {
                return none;
            }
            else {
                let iserr = this.erranalysis.processExpression(op.argsinfo.args.args.get(ii).exp, this.errinvokes, ctx.lambdaerr);
                return some((|p.pname, iserr|));
            }
        })
        %%TODO: make this filterSome<(|BSQAssembly::Identifier, Bool|)>(); when that works
        .filter(pred(aa) => aa?some)
        .map<(|BSQAssembly::Identifier, Bool|)>(fn(aa) => aa@some);
        
        let smctx = if(!largs.empty()) then scnctx[lambdagen=$lambdagen.pushBack(LambdaGeneratorInfo{op.resolvedTrgt, largs})] else scnctx;
        if(/\(largs.allOf(pred(aa) => !aa.1), !this.errinvokes.get(op.resolvedTrgt))) {
            let smtikey = TransformNameManager::convertInvokeKey(op.resolvedTrgt, List<Bool>{});

            let callop = SMTAssembly::CallFunctionSafeExpression{smtikey, aargs};
            return smctx, this.wrapOperationResult(smdecl.resultType, callop, allobinds);
        }
        else {
            let smtikey = TransformNameManager::convertInvokeKey(op.resolvedTrgt, largs.map<Bool>(fn(aa) => aa.1));

            let callop = SMTAssembly::CallFunctionExpression{smtikey, aargs};
            return smctx, this.wrapOperationResultWErr(smdecl.resultType, callop, allobinds);
        }
    }

    method transformPostfixAccessFromName(op: BSQAssembly::PostfixAccessFromName, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        if(this.assembly.isNominalTypeConcrete(op.baseType.tkeystr)) {
            let onarg, nctx, obinds = this.unpackSingleResultErrors(bexp, ctx);
            let accessop = SMTAssembly::AccessFromNameResolvedExpression{TransformNameManager::convertTypeKey(op.declaredInType.tkeystr), op.name.value, onarg};

            return nctx, this.wrapOperationResult(op.ftype, accessop, obinds);
        }
        else {
            abort; %% NOT IMPLEMENTED
        }
    }

    method transformPostfixBoolConstant(op: BSQAssembly::PostfixBoolConstant, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, nctx, obinds = this.unpackSingleResultErrors(bexp, ctx);
        let constop = SMTAssembly::LiteralSimpleExpression{'Bool'<SMTAssembly::TypeKey>, if(op.value) then 'true' else 'false'};

        return nctx, this.wrapOperationResult(SMTTransformer::booltype, constop, obinds);
    }

    method transformPostfixNop(op: BSQAssembly::PostfixNop, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, nctx, obinds = this.unpackSingleResultErrors(bexp, ctx);
        
        return nctx, this.wrapOperationResult(op.baseType, onarg, obinds);
    }

    method transformPostfixAbort(op: BSQAssembly::PostfixAbort, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, nctx, obinds = this.unpackSingleResultErrors(bexp, ctx);
        let abtop = SMTAssembly::AbortExpression{this.transformStdTypeToSMT(op.finaltype@some), nctx.errCtr};
        
        return nctx.addError(op.sinfo), this.wrapOperationResultWErr(op.finaltype@some, abtop, obinds);
    }

    method transformPostfixWidenConvert(op: BSQAssembly::PostfixWidenConvert, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, nctx, obinds = this.unpackSingleResultErrors(bexp, ctx);
        let widenop = SMTAssembly::TermifyExpression{onarg, this.transformStdTypeToSMT(op.baseType), this.transformStdTypeToSMT(op.trgttype)};

        return nctx, this.wrapOperationResult(op.baseType, widenop, obinds);
    }

    method transformPostfixAccessSomeValue(op: BSQAssembly::PostfixAccessSomeValue, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, nctx, obinds = this.unpackSingleResultErrors(bexp, ctx);
        let accessop = SMTAssembly::AccessFromNameResolvedExpression{this.transformStdTypeToSMT(op.baseType), 'value', onarg};

        return nctx, this.wrapOperationResult(op.baseType, accessop, obinds);
    }

    method transformPostfixLiteralNoneValue(op: BSQAssembly::PostfixLiteralNoneValue, ctx: SMTTransformerCtx, bexp: SMTExpTransformResult): SMTTransformerCtx, SMTExpTransformResult {
        let _, nctx, obinds = this.unpackSingleResultErrors(bexp, ctx);
        let accessop = SMTAssembly::LiteralNoneExpression{};

        return nctx, this.wrapOperationResult(SMTTransformer::nonetype, accessop, obinds);
    }

    recursive method transformPostfixOp(exp: BSQAssembly::PostfixOp, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let ebase, nctx, obinds = this.processUnaryArg[recursive](exp.rootExp, ctx);
        let eexp = this.wrapOperationResult(exp.rootExp.etype, ebase, obinds);

        let rres = exp.ops.reduce[recursive]<(|SMTTransformerCtx, SMTExpTransformResult|)>((|nctx, eexp|), recursive fn(pstate, op) => {
            match(op)@ {
                BSQAssembly::PostfixAccessFromName => { return this.transformPostfixAccessFromName($op, pstate.0, pstate.1); }
                | BSQAssembly::PostfixProjectFromNames => { abort; }
                | BSQAssembly::PostfixAccessFromIndex => { abort; }
                | BSQAssembly::PostfixIsTest => { return this.transformITestPostfixOp($op, pstate.0, pstate.1); }
                | BSQAssembly::PostfixAsConvert => { return this.processITestAsConvert($op, pstate.0, pstate.1); }
                | BSQAssembly::PostfixAssignFields => { abort; }
                | BSQAssembly::PostfixInvokeStatic => { return this.processPostfixInvokeStatic[recursive]($op, pstate.0, pstate.1); }
                | BSQAssembly::PostfixInvokeVirtual => { abort; }
                | BSQAssembly::PostfixLiteralKeyAccess => { abort; }
                | BSQAssembly::PostfixBoolConstant => { return this.transformPostfixBoolConstant($op, pstate.0, pstate.1); }
                | BSQAssembly::PostfixNop => { return this.transformPostfixNop($op, pstate.0, pstate.1); }
                | BSQAssembly::PostfixAbort => { return this.transformPostfixAbort($op, pstate.0, pstate.1); }
                | BSQAssembly::PostfixWidenConvert => { return this.transformPostfixWidenConvert($op, pstate.0, pstate.1); }
                | BSQAssembly::PostfixAccessSomeValue => { return this.transformPostfixAccessSomeValue($op, pstate.0, pstate.1); }
                | BSQAssembly::PostfixLiteralNoneValue => { return this.transformPostfixLiteralNoneValue($op, pstate.0, pstate.1); }
            }
        });

        return rres;
    }

    recursive method transformUnaryExpression(exp: BSQAssembly::UnaryExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let nexp, nctx, obinds = this.processUnaryArg[recursive](exp.exp, ctx);

        var unaryop: SMTAssembly::UnaryExpression;
        match(exp)@ {
            BSQAssembly::PrefixNotOpExpression => { unaryop = SMTAssembly::PrefixNotOpExpression{nexp}; }
            | BSQAssembly::PrefixNegateOpExpression => { unaryop = SMTAssembly::PrefixNegateOpExpression{nexp}; }
            | BSQAssembly::PrefixPlusOpExpression => { unaryop = SMTAssembly::PrefixPlusOpExpression{nexp}; }
        }

        return nctx, this.wrapOperationResult(exp.etype, unaryop, obinds);
    }

    recursive method transformBinAddExpression(exp: BSQAssembly::BinAddExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let lexp, rexp, nctx, obinds = this.processBinaryArgs[recursive](exp.lhs, exp.rhs, ctx);
        let addop = SMTAssembly::BinAddExpression{lexp, rexp};

        return nctx, this.wrapOperationResult(exp.etype, addop, obinds);
    }

    recursive method transformBinSubExpression(exp: BSQAssembly::BinSubExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let smtetype = this.transformStdTypeToSMT(exp.etype);

        let lexp, rexp, nctx, obinds = this.processBinaryArgs[recursive](exp.lhs, exp.rhs, ctx);
        let subop = SMTAssembly::BinSubExpression{lexp, rexp};

        if(exp.etype.tkeystr !== 'Nat'<BSQAssembly::TypeKey> && exp.etype.tkeystr !== 'BigNat'<BSQAssembly::TypeKey>) {
            return nctx, this.wrapOperationResult(exp.etype, subop, obinds);
        }
        else {
            let lesstest = SMTAssembly::NumericLessExpression{lexp, rexp};
            let chekd = SMTAssembly::IfThenElseExpression{lesstest, SMTAssembly::AbortExpression{smtetype, nctx.errCtr}, SMTAssembly::WrapIntoResultExpression{smtetype, subop}};
            
            return nctx.addError(exp.sinfo), this.wrapOperationResultWErr(exp.etype, chekd, obinds);
        }
    }

    recursive method transformBinMultExpression(exp: BSQAssembly::BinMultExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let lexp, rexp, nctx, obinds = this.processBinaryArgs[recursive](exp.lhs, exp.rhs, ctx);
        let multop = SMTAssembly::BinMultExpression{lexp, rexp};

        return nctx, this.wrapOperationResult(exp.etype, multop, obinds);
    }

    recursive method transformBinDivExpression(exp: BSQAssembly::BinDivExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let smtetype = this.transformStdTypeToSMT(exp.etype);

        let lexp, rexp, nctx, obinds = this.processBinaryArgs[recursive](exp.lhs, exp.rhs, ctx);
        let divop = SMTAssembly::BinDivExpression{lexp, rexp};

        let ztest = SMTAssembly::NumericEqExpression{rexp, SMTAssembly::AccessStaticFieldExpression{smtetype, 'zero'}};
        let chekd = SMTAssembly::IfThenElseExpression{ztest, SMTAssembly::AbortExpression{smtetype, nctx.errCtr}, SMTAssembly::WrapIntoResultExpression{smtetype, divop}};
        
        return nctx.addError(exp.sinfo), this.wrapOperationResultWErr(exp.etype, chekd, obinds);
    }

    recursive method transformBinaryArithExpression(exp: BSQAssembly::BinaryArithExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        match(exp)@ {
            BSQAssembly::BinAddExpression => { 
                return this.transformBinAddExpression[recursive]($exp, ctx); 
            }
            | BSQAssembly::BinSubExpression => { 
                return this.transformBinSubExpression[recursive]($exp, ctx); 
            }
            | BSQAssembly::BinMultExpression => { 
                return this.transformBinMultExpression[recursive]($exp, ctx); 
            }
            | BSQAssembly::BinDivExpression => { 
                return this.transformBinDivExpression[recursive]($exp, ctx); 
            }
        }
    }

    recursive method transformBinKeyEqNoneExpression(exp: BSQAssembly::BinKeyEqNoneExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let nexp, nctx, obinds = this.processUnaryArg[recursive](exp.exp, ctx);
        let noneop = SMTAssembly::BinKeyEqNoneExpression{nexp};

        return nctx, this.wrapOperationResult(exp.etype, noneop, obinds);
    }

    recursive method transformBinKeyNotEqNoneExpression(exp: BSQAssembly::BinKeyNotEqNoneExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let nexp, nctx, obinds = this.processUnaryArg[recursive](exp.exp, ctx);
        let noneop = SMTAssembly::BinKeyNotEqNoneExpression{nexp};

        return nctx, this.wrapOperationResult(exp.etype, noneop, obinds);
    }

    recursive method transformBinKeySomeEqExpression(exp: BSQAssembly::BinKeySomeEqExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let neqoption, neqval, nctx, obinds = this.processBinaryArgs[recursive](exp.eqoption, exp.eqval, ctx);
        let optiondecl = this.assembly.lookupNominalTypeDeclaration(exp.eqoption.etype.tkeystr)@<BSQAssembly::OptionTypeDecl>;

        let someop = SMTAssembly::BinKeySomeEqExpression{ 
            TransformNameManager::convertTypeKey(optiondecl.tkey),
            this.transformStdTypeToSMT(optiondecl.someType),
            neqoption,
            neqval
        };

        return nctx, this.wrapOperationResult(exp.etype, someop, obinds);
    }

    recursive method transformBinKeyNotSomeEqExpression(exp: BSQAssembly::BinKeyNotSomeEqExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let neqoption, neqval, nctx, obinds = this.processBinaryArgs[recursive](exp.neoption, exp.neval, ctx);
        let optiondecl = this.assembly.lookupNominalTypeDeclaration(exp.neoption.etype.tkeystr)@<BSQAssembly::OptionTypeDecl>;

        let someop = SMTAssembly::BinKeyNotSomeEqExpression{ 
            TransformNameManager::convertTypeKey(optiondecl.tkey),
            this.transformStdTypeToSMT(optiondecl.someType),
            neqoption,
            neqval
        };

        return nctx, this.wrapOperationResult(exp.etype, someop, obinds);
    }

    recursive method transformBinKeyEqExpression(exp: BSQAssembly::BinKeyEqExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let lexp, rexp, nctx, obinds = this.processBinaryArgs[recursive](exp.lhs, exp.rhs, ctx);
        let eqop = SMTAssembly::BinKeyEqExpression{lexp, rexp};

        return nctx, this.wrapOperationResult(exp.etype, eqop, obinds);
    }

    recursive method transformBinKeyNotEqExpression(exp: BSQAssembly::BinKeyNotEqExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let lexp, rexp, nctx, obinds = this.processBinaryArgs[recursive](exp.lhs, exp.rhs, ctx);
        let eqop = SMTAssembly::BinKeyNotEqExpression{lexp, rexp};

        return nctx, this.wrapOperationResult(exp.etype, eqop, obinds);
    }

    recursive method transformBinaryKeyEqExpression(exp: BSQAssembly::BinaryKeyEqExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        match(exp)@ {
            BSQAssembly::BinKeyEqNoneExpression => { 
                return this.transformBinKeyEqNoneExpression[recursive]($exp, ctx); 
            }
            | BSQAssembly::BinKeyNotEqNoneExpression => { 
                return this.transformBinKeyNotEqNoneExpression[recursive]($exp, ctx); 
            }
            | BSQAssembly::BinKeySomeEqExpression => { 
                return this.transformBinKeySomeEqExpression[recursive]($exp, ctx); 
            }
            | BSQAssembly::BinKeyNotSomeEqExpression => { 
                return this.transformBinKeyNotSomeEqExpression[recursive]($exp, ctx); 
            }
            | BSQAssembly::BinKeyEqExpression => { 
                return this.transformBinKeyEqExpression[recursive]($exp, ctx); 
            }
            | BSQAssembly::BinKeyNotEqExpression => { 
                return this.transformBinKeyNotEqExpression[recursive]($exp, ctx); 
            }
        }
    }

    recursive method transformBinaryNumericCompareExpression(exp: BSQAssembly::BinaryNumericExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let lexp, rexp, nctx, obinds = this.processBinaryArgs[recursive](exp.lhs, exp.rhs, ctx);

        var opexp: SMTAssembly::SafeExpression;
        match(exp)@ {
            BSQAssembly::NumericEqExpression => { 
                opexp = SMTAssembly::NumericEqExpression{lexp, rexp}; 
            }
            | BSQAssembly::NumericNeqExpression => { 
                opexp = SMTAssembly::NumericNeqExpression{lexp, rexp}; 
            }
            | BSQAssembly::NumericLessExpression => { 
                opexp = SMTAssembly::NumericLessExpression{lexp, rexp}; 
            }
            | BSQAssembly::NumericLessEqExpression => { 
                opexp = SMTAssembly::NumericLessEqExpression{lexp, rexp}; 
            }
            | BSQAssembly::NumericGreaterExpression => { 
                opexp = SMTAssembly::NumericGreaterExpression{lexp, rexp}; 
            }
            | BSQAssembly::NumericGreaterEqExpression => { 
                opexp = SMTAssembly::NumericGreaterEqExpression{lexp, rexp}; 
            }
        }

        return nctx, this.wrapOperationResult(exp.etype, opexp, obinds);
    }

    recursive method transformIfSimpleExpression(exp: BSQAssembly::IfSimpleExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let ntexp, cctx, cobinds = this.processUnaryArg[recursive](exp.texp, ctx);
        
        let tctx, nthenexp = this.transformExpressionToSMT[recursive](exp.thenexp, cctx);
        let fctx, nelseexp = this.transformExpressionToSMT[recursive](exp.elseexp, tctx);

        if(nthenexp)@<SafeResult> {
            if(nelseexp)@<SafeResult> {
                let ifop = SMTAssembly::IfThenElseSafeExpression{ntexp, $nthenexp.exp, $nelseexp.exp};
                return fctx, this.wrapOperationResult(exp.etype, ifop, cobinds);
            }
            else {
                let ifop = SMTAssembly::IfThenElseExpression{ntexp, SMTAssembly::WrapIntoResultExpression{this.transformStdTypeToSMT(exp.etype), $nthenexp.exp}, $nelseexp.exp};
                return fctx, this.wrapOperationResultWErr(exp.etype, ifop, cobinds);
            }
        }
        else {
            if(nelseexp)@<SafeResult> {
                let ifop = SMTAssembly::IfThenElseExpression{ntexp, $nthenexp.exp, SMTAssembly::WrapIntoResultExpression{this.transformStdTypeToSMT(exp.etype), $nelseexp.exp}};
                return fctx, this.wrapOperationResultWErr(exp.etype, ifop, cobinds);
            }
            else {
                let ifop = SMTAssembly::IfThenElseExpression{ntexp, $nthenexp.exp, $nelseexp.exp};
                return fctx, this.wrapOperationResultWErr(exp.etype, ifop, cobinds);
            }
        }
    }

    recursive method transformIfTestExpression(exp: BSQAssembly::IfTestExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, cctx, cobinds = this.processUnaryArg[recursive](exp.texp, ctx);
        let ttest = this.transformITestAsTest(exp.texp.etype, exp.itest, onarg);
        
        let tctx, nthenexp = this.transformExpressionToSMT[recursive](exp.thenexp, cctx);
        let fctx, nelseexp = this.transformExpressionToSMT[recursive](exp.elseexp, tctx);

        if(nthenexp)@<SafeResult> {
            if(nelseexp)@<SafeResult> {
                let ifop = SMTAssembly::IfThenElseSafeExpression{ttest, $nthenexp.exp, $nelseexp.exp};
                return fctx, this.wrapOperationResult(exp.etype, ifop, cobinds);
            }
            else {
                let ifop = SMTAssembly::IfThenElseExpression{ttest, SMTAssembly::WrapIntoResultExpression{this.transformStdTypeToSMT(exp.etype), $nthenexp.exp}, $nelseexp.exp};
                return fctx, this.wrapOperationResultWErr(exp.etype, ifop, cobinds);
            }
        }
        else {
            if(nelseexp)@<SafeResult> {
                let ifop = SMTAssembly::IfThenElseExpression{ttest, $nthenexp.exp, SMTAssembly::WrapIntoResultExpression{this.transformStdTypeToSMT(exp.etype), $nelseexp.exp}};
                return fctx, this.wrapOperationResultWErr(exp.etype, ifop, cobinds);
            }
            else {
                let ifop = SMTAssembly::IfThenElseExpression{ttest, $nthenexp.exp, $nelseexp.exp};
                return fctx, this.wrapOperationResultWErr(exp.etype, ifop, cobinds);
            }
        }
    }

    recursive method transformIfBinderExpression(exp: BSQAssembly::IfBinderExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        let onarg, cctx, cobinds = this.processUnaryArg[recursive](exp.texp, ctx);
        let ttest = this.transformITestAsTest(exp.texp.etype, exp.itest, onarg);
        let topt, fopt = this.transformITestAsSafeConvertOptions(exp.texp.etype, exp.itest, onarg);
        
        let tctx, nthenexp = this.transformExpressionToSMT[recursive](exp.thenexp, cctx);
        let fctx, nelseexp = this.transformExpressionToSMT[recursive](exp.elseexp, tctx);

        let bindname = SMTAssembly::Identifier::from(TransformNameManager::safeifyName(exp.binder.srcname.value));
        if(nthenexp)@<SafeResult> {
            if(nelseexp)@<SafeResult> {
                let bindthen = SMTAssembly::LetSafeExpression{bindname, topt, $nthenexp.exp};
                let bindelse = SMTAssembly::LetSafeExpression{bindname, fopt, $nelseexp.exp};

                let ifop = SMTAssembly::IfThenElseSafeExpression{ttest, bindthen, bindelse};
                return fctx, this.wrapOperationResult(exp.etype, ifop, cobinds);
            }
            else {
                let bindthen = SMTAssembly::LetGeneralExpression{bindname, topt, SMTAssembly::WrapIntoResultExpression{this.transformStdTypeToSMT(exp.etype), $nthenexp.exp}};
                let bindelse = SMTAssembly::LetGeneralExpression{bindname, fopt, $nelseexp.exp};

                let ifop = SMTAssembly::IfThenElseExpression{ttest, bindthen, bindelse};
                return fctx, this.wrapOperationResultWErr(exp.etype, ifop, cobinds);
            }
        }
        else {
            if(nelseexp)@<SafeResult> {
                let bindthen = SMTAssembly::LetGeneralExpression{bindname, topt, $nthenexp.exp};
                let bindelse = SMTAssembly::LetGeneralExpression{bindname, fopt, SMTAssembly::WrapIntoResultExpression{this.transformStdTypeToSMT(exp.etype), $nelseexp.exp}};

                let ifop = SMTAssembly::IfThenElseExpression{ttest, bindthen, bindelse};
                return fctx, this.wrapOperationResultWErr(exp.etype, ifop, cobinds);
            }
            else {
                let bindthen = SMTAssembly::LetGeneralExpression{bindname, topt, $nthenexp.exp};
                let bindelse = SMTAssembly::LetGeneralExpression{bindname, fopt, $nelseexp.exp};

                let ifop = SMTAssembly::IfThenElseExpression{ttest, bindthen, bindelse};
                return fctx, this.wrapOperationResultWErr(exp.etype, ifop, cobinds);
            }
        }
    }

    recursive method transformIfExpression(exp: BSQAssembly::IfExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        match(exp)@ {
            BSQAssembly::IfSimpleExpression => { 
                return this.transformIfSimpleExpression[recursive]($exp, ctx); 
            }
            | BSQAssembly::IfTestExpression => { 
                return this.transformIfTestExpression[recursive]($exp, ctx); 
            }
            | BSQAssembly::IfBinderExpression => { 
                return this.transformIfBinderExpression[recursive]($exp, ctx); 
            }
        }
    }

    recursive method transformExpressionToSMT(exp: BSQAssembly::Expression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        match(exp)@ {
            BSQAssembly::LiteralNoneExpression => { 
                return ctx, SafeResult{this.transformStdTypeToSMT(exp.etype), this.transformLiteralNoneExpression($exp)}; 
            }
            | BSQAssembly::LiteralSimpleExpression => { 
                return ctx, SafeResult{this.transformStdTypeToSMT(exp.etype), this.transformLiteralSimpleExpression($exp)}; 
            }
            | BSQAssembly::LiteralCStringExpression => { 
                return ctx, SafeResult{this.transformStdTypeToSMT(exp.etype), this.transformLiteralCStringExpression($exp)};
            }
            | BSQAssembly::LiteralStringExpression => { 
                return ctx, SafeResult{this.transformStdTypeToSMT(exp.etype), this.transformLiteralStringExpression($exp)}; 
            }
            | BSQAssembly::AccessVariableExpression => { 
                return ctx, SafeResult{this.transformStdTypeToSMT(exp.etype), this.transformAccessVariableExpression($exp)}; 
            }
            | BSQAssembly::AccessCapturedVariableExpression => { 
                return ctx, SafeResult{this.transformStdTypeToSMT(exp.etype), this.transformAccessCapturedVariableExpression($exp)}; 
            }
            | BSQAssembly::ConstructorExpression => { 
                return this.transformConstructorExpression[recursive]($exp, ctx);
            }
            | BSQAssembly::ConstructorLambdaExpression => { 
                return this.transformConstructorLambdaExpression[recursive]($exp, ctx);
            }
            | BSQAssembly::LambdaInvokeExpression => { 
                return this.transformLambdaInvokeExpression[recursive]($exp, ctx);
            }
            | BSQAssembly::CallNamespaceFunctionExpression => { 
                return this.transformCallNamespaceFunctionExpression[recursive]($exp, ctx);
            }
            | BSQAssembly::CoerceNarrowTypeExpression => { 
                return this.transformCoerceNarrowTypeExpression[recursive]($exp, ctx);
            }
            | BSQAssembly::CoerceWidenTypeExpression => { 
                return this.transformCoerceWidenTypeExpression[recursive]($exp, ctx);
            }
            | BSQAssembly::SafeConvertExpression => {
                return this.transformSafeConvertExpression[recursive]($exp, ctx);
            }
            | BSQAssembly::PostfixOp => { 
                return this.transformPostfixOp[recursive]($exp, ctx);
            }
            | BSQAssembly::UnaryExpression => { 
                return this.transformUnaryExpression[recursive]($exp, ctx);
            }
            | BSQAssembly::BinaryArithExpression => { 
                return this.transformBinaryArithExpression[recursive]($exp, ctx);
            }
            | BSQAssembly::BinaryKeyEqExpression => { 
                return this.transformBinaryKeyEqExpression[recursive]($exp, ctx);
            }
            | BSQAssembly::BinaryNumericExpression => { 
                return this.transformBinaryNumericCompareExpression[recursive]($exp, ctx);
            }
            | BSQAssembly::IfExpression => { 
                return this.transformIfExpression[recursive]($exp, ctx);
            }
            | _ => { 
                abort; %% NOT IMPLEMENTED
            }
        }
    }

    method transformVariableInitializationStatement(stmt: BSQAssembly::VariableInitializationStatement, tail: SMTAssembly::Operation, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        let rctx, smtexp = this.transformExpressionToSMT(stmt.exp, ctx);
        
        if(smtexp)@<SafeResult> {
            let vname = SMTAssembly::Identifier::from(TransformNameManager::safeifyName(stmt.name.value));
            return rctx, some(SMTAssembly::LetOperation{vname, $smtexp.exp, tail});
        }
        else {
            let tname = TransformNameManager::safeifyName(stmt.name.value);
            let vebind = SMTAssembly::Identifier::from(CString::concat('@tmpe-', tname));
            let vbind = SMTAssembly::Identifier::from(tname);
            let vtype = this.transformStdTypeToSMT(stmt.vtype);

            return rctx, some(SMTAssembly::LetOperationWError{vebind, vbind, vtype, $smtexp.exp, tail});
        }
    }

    method transformVariableAssignmentStatement(stmt: BSQAssembly::VariableAssignmentStatement, tail: SMTAssembly::Operation, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        let rctx, smtexp = this.transformExpressionToSMT(stmt.exp, ctx);
        
        if(smtexp)@<SafeResult> {
            let vname = SMTAssembly::Identifier::from(TransformNameManager::safeifyName(stmt.name.value));
            return rctx, some(SMTAssembly::LetOperation{vname, $smtexp.exp, tail});
        }
        else {
            let tname = TransformNameManager::safeifyName(stmt.name.value);
            let vebind = SMTAssembly::Identifier::from(CString::concat('@tmpe-', tname));
            let vbind = SMTAssembly::Identifier::from(tname);
            let vtype = this.transformStdTypeToSMT(stmt.vtype);

            return rctx, some(SMTAssembly::LetOperationWError{vebind, vbind, vtype, $smtexp.exp, tail});
        }
    }

    method transformAbortStatement(stmt: BSQAssembly::AbortStatement, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        let aop = SMTAssembly::AbortOperation{ctx.errCtr};
        return ctx.addError(stmt.sinfo), some(aop);
    }

    method transformAssertStatement(stmt: BSQAssembly::AssertStatement, tail: SMTAssembly::Operation, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        let rctx, smtexp = this.transformExpressionToSMT(stmt.cond, ctx);
        
        if(smtexp)@<SafeResult> {
            let aop = SMTAssembly::AssertOperation{$smtexp.exp, ctx.errCtr, tail};
            return ctx.addError(stmt.sinfo), some(aop);
        }
        else {
            abort; %%NOT IMPLEMENTED -- I think failure in the assert is mapped to this assert failing
        }
    }

    method transformReturnSingleStatement(stmt: BSQAssembly::ReturnSingleStatement, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        let rctx, smtexp = this.transformExpressionToSMT(stmt.value, ctx);

        if(smtexp)@<ErrorResult> {
            return rctx, some(SMTAssembly::ReturnOperation{$smtexp.exp});
        }
        else {
            if(!ctx.mayErrorReturn) {
                return rctx, some(SMTAssembly::ReturnOperation{$smtexp.exp});
            }
            else {
                return rctx, some(SMTAssembly::ReturnOperation{SMTAssembly::WrapIntoResultExpression{this.transformStdTypeToSMT(stmt.rtype), $smtexp.exp}});
            }
        }
    }

    recursive method transformIfSimpleStatement(stmt: BSQAssembly::IfSimpleStatement, tail: SMTAssembly::Operation, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        let ntexp, cctx, cobinds = this.processUnaryArg[recursive](stmt.texp, ctx);

        let tctx, ontb = this.transformBlockStatement[recursive](stmt.trueBlock, some(tail), cctx);
        let ifop = SMTAssembly::IfThenElseOperation{ntexp, ontb@some, tail};

        if(cobinds)@none {
            return tctx, some(ifop);
        }
        else {
            return tctx, some(SMTAssembly::LetWErrorsOperation{$cobinds, ifop});
        }
    }

    recursive method transformIfTestStatement(stmt: BSQAssembly::IfTestStatement, tail: SMTAssembly::Operation, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        let ntexp, cctx, cobinds = this.processUnaryArg[recursive](stmt.texp, ctx);
        let ttest = this.transformITestAsTest(stmt.texp.etype, stmt.itest, ntexp);
        
        let tctx, ontb = this.transformBlockStatement[recursive](stmt.trueBlock, some(tail), cctx);
        let ifop = SMTAssembly::IfThenElseOperation{ttest, ontb@some, tail};

        if(cobinds)@none {
            return tctx, some(ifop);
        }
        else {
            return tctx, some(SMTAssembly::LetWErrorsOperation{$cobinds, ifop});
        }
    }

    recursive method transformIfBinderStatement(stmt: BSQAssembly::IfBinderStatement, tail: SMTAssembly::Operation, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        let ntexp, cctx, cobinds = this.processUnaryArg[recursive](stmt.texp, ctx);
        let ttest = this.transformITestAsTest(stmt.texp.etype, stmt.itest, ntexp);
        let topt, _ = this.transformITestAsSafeConvertOptions(stmt.texp.etype, stmt.itest, ntexp);

        let tctx, ontb = this.transformBlockStatement[recursive](stmt.trueBlock, some(tail), cctx);
        
        let bindname = SMTAssembly::Identifier::from(TransformNameManager::safeifyName(stmt.binder.srcname.value));
        let bindtb = SMTAssembly::LetOperation{bindname, topt, ontb@some};
        let ifop = SMTAssembly::IfThenElseOperation{ttest, bindtb, tail};

        if(cobinds)@none {
            return tctx, some(ifop);
        }
        else {
            return tctx, some(SMTAssembly::LetWErrorsOperation{$cobinds, ifop});
        }
    }

    recursive method transformIfStatement(stmt: BSQAssembly::IfStatement, tail: SMTAssembly::Operation, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        match(stmt)@ {
            BSQAssembly::IfSimpleStatement => { 
                return this.transformIfSimpleStatement[recursive]($stmt, tail, ctx); 
            }
            | BSQAssembly::IfTestStatement => { 
                return this.transformIfTestStatement[recursive]($stmt, tail, ctx); 
            }
            | BSQAssembly::IfBinderStatement => { 
                return this.transformIfBinderStatement[recursive]($stmt, tail, ctx); 
            }
        }
    }

    recursive method transformIfElseSimpleStatement(stmt: BSQAssembly::IfElseSimpleStatement, tail: Option<SMTAssembly::Operation>, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        let ntexp, cctx, cobinds = this.processUnaryArg[recursive](stmt.texp, ctx);

        let tctx, ontb = this.transformBlockStatement[recursive](stmt.trueBlock, tail, cctx);
        let fctx, onfb = this.transformBlockStatement[recursive](stmt.falseBlock, tail, tctx);
        let ifop = SMTAssembly::IfThenElseOperation{ntexp, ontb@some, onfb@some};

        if(cobinds)@none {
            return fctx, some(ifop);
        }
        else {
            return fctx, some(SMTAssembly::LetWErrorsOperation{$cobinds, ifop});
        }
    }

    recursive method transformIfElseTestStatement(stmt: BSQAssembly::IfElseTestStatement, tail: Option<SMTAssembly::Operation>, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        let ntexp, cctx, cobinds = this.processUnaryArg[recursive](stmt.texp, ctx);
        let ttest = this.transformITestAsTest(stmt.texp.etype, stmt.itest, ntexp);

        let tctx, ontb = this.transformBlockStatement[recursive](stmt.trueBlock, tail, cctx);
        let fctx, onfb = this.transformBlockStatement[recursive](stmt.falseBlock, tail, tctx);
        let ifop = SMTAssembly::IfThenElseOperation{ttest, ontb@some, onfb@some};

        if(cobinds)@none {
            return fctx, some(ifop);
        }
        else {
            return fctx, some(SMTAssembly::LetWErrorsOperation{$cobinds, ifop});
        }
    }

    recursive method transformIfElseBinderStatement(stmt: BSQAssembly::IfElseBinderStatement, tail: Option<SMTAssembly::Operation>, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        let ntexp, cctx, cobinds = this.processUnaryArg[recursive](stmt.texp, ctx);
        let ttest = this.transformITestAsTest(stmt.texp.etype, stmt.itest, ntexp);
        let topt, fopt = this.transformITestAsSafeConvertOptions(stmt.texp.etype, stmt.itest, ntexp);

        let tctx, ontb = this.transformBlockStatement[recursive](stmt.trueBlock, tail, cctx);
        let fctx, onfb = this.transformBlockStatement[recursive](stmt.falseBlock, tail, tctx);

        let bindname = SMTAssembly::Identifier::from(TransformNameManager::safeifyName(stmt.binder.srcname.value));
        let bindtb = SMTAssembly::LetOperation{bindname, topt, ontb@some};
        let bindfb = SMTAssembly::LetOperation{bindname, fopt, onfb@some};
        let ifop = SMTAssembly::IfThenElseOperation{ttest, bindtb, bindfb};

        if(cobinds)@none {
            return fctx, some(ifop);
        }
        else {
            return fctx, some(SMTAssembly::LetWErrorsOperation{$cobinds, ifop});
        }
    }

    recursive method transformIfElseStatement(stmt: BSQAssembly::IfElseStatement, tail: Option<SMTAssembly::Operation>, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        match(stmt)@ {
            BSQAssembly::IfElseSimpleStatement => { 
                return this.transformIfElseSimpleStatement[recursive]($stmt, tail, ctx); 
            }
            | BSQAssembly::IfElseTestStatement => { 
                return this.transformIfElseTestStatement[recursive]($stmt, tail, ctx); 
            }
            | BSQAssembly::IfElseBinderStatement => { 
                return this.transformIfElseBinderStatement[recursive]($stmt, tail, ctx); 
            }
        }
    }

    recursive method transformStatement(stmt: BSQAssembly::Statement, tail: Option<SMTAssembly::Operation>, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        match(stmt)@ {
            BSQAssembly::EmptyStatement => {
                return ctx, tail;
            }
            | BSQAssembly::VariableDeclarationStatement => {
                return ctx, tail;
            }
            | BSQAssembly::VariableMultiDeclarationStatement => {
                return ctx, tail;
            }
            | BSQAssembly::VariableInitializationStatement => {
                return this.transformVariableInitializationStatement($stmt, tail@some, ctx);
            }
            | BSQAssembly::VariableMultiInitializationExplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::VariableMultiInitializationImplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::VariableAssignmentStatement => {
                return this.transformVariableAssignmentStatement($stmt, tail@some, ctx);
            }
            | BSQAssembly::VariableMultiAssignmentExplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::VariableMultiAssignmentImplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::ReturnVoidStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::ReturnSingleStatement => {
                return this.transformReturnSingleStatement($stmt, ctx);
            }
            | BSQAssembly::ReturnMultiStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::IfStatement => {
                return this.transformIfStatement[recursive]($stmt, tail@some, ctx);
            }
            | BSQAssembly::IfElseStatement => {
                return this.transformIfElseStatement[recursive]($stmt, tail, ctx);
            }
            | BSQAssembly::AbortStatement => {
                return this.transformAbortStatement($stmt, ctx);
            }
            | BSQAssembly::AssertStatement => {
                return this.transformAssertStatement($stmt, tail@some, ctx);
            }
            | BSQAssembly::BlockStatement => {
                return this.transformBlockStatement($stmt, tail, ctx);
            }
        }
    }

    recursive method transformBlockStatement(stmt: BSQAssembly::BlockStatement, tail: Option<SMTAssembly::Operation>, ctx: SMTTransformerCtx): SMTTransformerCtx, Option<SMTAssembly::Operation> {
        return stmt.statements.lreduce[recursive]<(|SMTTransformerCtx, Option<SMTAssembly::Operation>|)>((|ctx, tail|), recursive fn(acc, s) => {
            return this.transformStatement[recursive](s, acc.1, acc.0);
        });
    }

    method transformBodyToSMTOperation(impl: BSQAssembly::BodyImplementation, ctx: SMTTransformerCtx, ttype: BSQAssembly::TypeSignature): SMTTransformerCtx, SMTAssembly::Operation {
        match(impl)@ {
            BSQAssembly::ExpressionBodyImplementation => {
                let rctx, smtexp = this.transformExpressionToSMT($impl.exp, ctx);

                if(smtexp)@<ErrorResult> {
                    return rctx, SMTAssembly::ReturnOperation{$smtexp.exp};
                }
                else {
                    if(!ctx.mayErrorReturn) {
                        return rctx, SMTAssembly::ReturnOperation{$smtexp.exp};
                    }
                    else {
                        return rctx, SMTAssembly::ReturnOperation{SMTAssembly::WrapIntoResultExpression{this.transformStdTypeToSMT(ttype), $smtexp.exp}};
                    }
                }
            }
            | BSQAssembly::StandardBodyImplementation => {
                let rctx, smtop = $impl.statements.lreduce[recursive]<(|SMTTransformerCtx, Option<SMTAssembly::Operation>|)>((|ctx, none|), recursive fn(acc, s) => {
                    return this.transformStatement[recursive](s, acc.1, acc.0);
                });
                
                return rctx, smtop@some;
            }
        }
    }

    method transformBodyToSMTBody(impl: BSQAssembly::BodyImplementation, ctx: SMTTransformerCtx, ttype: BSQAssembly::TypeSignature): SMTTransformerCtx, SMTAssembly::Body {
        let rctx, body = this.transformBodyToSMTOperation(impl, ctx, ttype);
        return rctx, SMTAssembly::Body{body, rctx.errors};
    }

    method transformNamespaceFunctionDeclToBuiltinSMT(decl: BSQAssembly::NamespaceFunctionDecl, lambdainvs: Option<List<LambdaGeneratorInfo>>): List<SMTAssembly::BuiltinFunctionDecl> {
        let nskey = TransformNameManager::convertNamespaceKey(decl.declaredInNS);

        let builtin = decl.body@<BSQAssembly::BuiltinBodyImplementation>.builtin;
        let binds = decl.body@<BSQAssembly::BuiltinBodyImplementation>.binds.map<(|CString, SMTAssembly::TypeKey|)>(fn(bb) => (|bb.0, this.transformStdTypeToSMT(bb.1)|));

        if(lambdainvs)@none {
            let ikey = TransformNameManager::convertInvokeKey(decl.ikey, List<Bool>{});
            let params = decl.params.map<SMTAssembly::InvokeParameterDecl>(fn(p) => SMTAssembly::InvokeParameterDecl{SMTAssembly::Identifier::from(p.pname.value), this.transformParamTypeToSMT(p.ptype, false)});
        
            let rtype = this.transformStdTypeToSMT(decl.resultType);
            let artype = if(this.errinvokes.get(decl.ikey)) then SMTAssembly::ErrorResult{ rtype } else SMTAssembly::SafeResult{ rtype };

            return List<SMTAssembly::BuiltinFunctionDecl>{ SMTAssembly::BuiltinFunctionDecl{ ikey, params, artype, none, builtin, binds } };
        }
        else {
            let allprocs = $lambdainvs.map<SMTAssembly::BuiltinFunctionDecl>(fn(lgi) => {
                let ikey = TransformNameManager::convertInvokeKey(decl.ikey, lgi.largerrors.map<Bool>(fn(gg) => gg.1));
                let params = decl.params.map<SMTAssembly::InvokeParameterDecl>(fn(p) => {
                    let mlp = lgi.largerrors.tryFind(pred(gg) => gg.0 === p.pname);
                    let islerr = if(mlp)@some then $mlp.1 else false;

                    return SMTAssembly::InvokeParameterDecl{SMTAssembly::Identifier::from(p.pname.value), this.transformParamTypeToSMT(p.ptype, islerr)};
                });

                let mayerr = \/(this.errinvokes.get(decl.ikey), lgi.largerrors.someOf(pred(gg) => gg.1));
                let rtype = this.transformStdTypeToSMT(decl.resultType);
                let artype = if(mayerr) then SMTAssembly::ErrorResult{ rtype } else SMTAssembly::SafeResult{ rtype };

                let lambdaerr = lgi.largerrors.map<(|SMTAssembly::Identifier, Bool|)>(fn(gg) => (|SMTAssembly::Identifier::from(TransformNameManager::safeifyName(gg.0.value)), gg.1|));
                return SMTAssembly::BuiltinFunctionDecl{ ikey, params, artype, some(lambdaerr), builtin, binds }; 
            });

            return allprocs;
        }
    }

    method transformNamespaceFunctionDeclToSMT(decl: BSQAssembly::NamespaceFunctionDecl, lambdainvs: Option<List<LambdaGeneratorInfo>>): List<SMTAssembly::FunctionDecl>, List<LambdaGeneratorInfo> {
        let nskey = TransformNameManager::convertNamespaceKey(decl.declaredInNS);
        
        if(lambdainvs)@none {
            let ikey = TransformNameManager::convertInvokeKey(decl.ikey, List<Bool>{});
            let params = decl.params.map<SMTAssembly::InvokeParameterDecl>(fn(p) => SMTAssembly::InvokeParameterDecl{SMTAssembly::Identifier::from(p.pname.value), this.transformParamTypeToSMT(p.ptype, false)});
        
            let rtype = this.transformStdTypeToSMT(decl.resultType);
            let artype = if(this.errinvokes.get(decl.ikey)) then SMTAssembly::ErrorResult{ rtype } else SMTAssembly::SafeResult{ rtype };

            let ctx = SMTTransformerCtx{this.errinvokes.get(decl.ikey), Map<BSQAssembly::Identifier, Bool>{}, decl.file, some(decl.ikey), 1n, 1n, List<SMTAssembly::ErrorInfo>{}, List<LambdaGeneratorInfo>{}};
            let rctx, body = this.transformBodyToSMTBody(decl.body, ctx, decl.resultType);
            return List<SMTAssembly::FunctionDecl>{ SMTAssembly::FunctionDecl{ ikey, params, artype, body } }, rctx.lambdagen;
        }
        else {
            let allprocs = $lambdainvs.map<(|SMTAssembly::FunctionDecl, List<LambdaGeneratorInfo>|)>(fn(lgi) => {
                let ikey = TransformNameManager::convertInvokeKey(decl.ikey, lgi.largerrors.map<Bool>(fn(gg) => gg.1));
                let params = decl.params.map<SMTAssembly::InvokeParameterDecl>(fn(p) => {
                    let mlp = lgi.largerrors.tryFind(pred(gg) => gg.0 === p.pname);
                    let islerr = if(mlp)@some then $mlp.1 else false;

                    return SMTAssembly::InvokeParameterDecl{SMTAssembly::Identifier::from(p.pname.value), this.transformParamTypeToSMT(p.ptype, islerr)};
                });

                let mayerr = \/(this.errinvokes.get(decl.ikey), lgi.largerrors.someOf(pred(gg) => gg.1));
                let rtype = this.transformStdTypeToSMT(decl.resultType);
                let artype = if(mayerr) then SMTAssembly::ErrorResult{ rtype } else SMTAssembly::SafeResult{ rtype };

                let lambdaerr = lgi.largerrors.reduce<Map<BSQAssembly::Identifier, Bool>>(Map<BSQAssembly::Identifier, Bool>{}, fn(lemap, gg) => lemap.insert(gg.0, gg.1));
                let ctx = SMTTransformerCtx{mayerr, lambdaerr, decl.file, some(decl.ikey), 1n, 1n, List<SMTAssembly::ErrorInfo>{}, List<LambdaGeneratorInfo>{lgi}};

                let rctx, body = this.transformBodyToSMTBody(decl.body, ctx, decl.resultType);
                return SMTAssembly::FunctionDecl{ ikey, params, artype, body }, rctx.lambdagen; 
            });

            let decls = allprocs.map<SMTAssembly::FunctionDecl>(fn(p) => p.0);
            let lambdagen = List<LambdaGeneratorInfo>::concatAll(allprocs.map<List<LambdaGeneratorInfo>>(fn(p) => p.1));

            return decls, lambdagen;
        }
    }

    method transformMethodDeclStaticToSMT(decl: BSQAssembly::MethodDeclStatic, lambdainvs: Option<List<LambdaGeneratorInfo>>): List<SMTAssembly::FunctionDecl>, List<LambdaGeneratorInfo> {
        let nskey = TransformNameManager::convertNamespaceKey(decl.declaredInNS);
        let thisdecl = SMTAssembly::InvokeParameterDecl{'this'<SMTAssembly::Identifier>, this.transformParamTypeToSMT(decl.ofrcvrtype, false)};
        
        if(lambdainvs)@none {
            let ikey = TransformNameManager::convertInvokeKey(decl.ikey, List<Bool>{});
            let params = decl.params.map<SMTAssembly::InvokeParameterDecl>(fn(p) => SMTAssembly::InvokeParameterDecl{SMTAssembly::Identifier::from(p.pname.value), this.transformParamTypeToSMT(p.ptype, false)});
        
            let rtype = this.transformStdTypeToSMT(decl.resultType);
            let artype = if(this.errinvokes.get(decl.ikey)) then SMTAssembly::ErrorResult{ rtype } else SMTAssembly::SafeResult{ rtype };

            let ctx = SMTTransformerCtx{this.errinvokes.get(decl.ikey), Map<BSQAssembly::Identifier, Bool>{}, decl.file, some(decl.ikey), 1n, 1n, List<SMTAssembly::ErrorInfo>{}, List<LambdaGeneratorInfo>{}};
            let rctx, body = this.transformBodyToSMTBody(decl.body, ctx, decl.resultType);
            return List<SMTAssembly::FunctionDecl>{ SMTAssembly::FunctionDecl{ ikey, List<SMTAssembly::InvokeParameterDecl>{thisdecl}.append(params), artype, body } }, rctx.lambdagen;
        }
        else {
            let allprocs = $lambdainvs.map<(|SMTAssembly::FunctionDecl, List<LambdaGeneratorInfo>|)>(fn(lgi) => {
                let ikey = TransformNameManager::convertInvokeKey(decl.ikey, lgi.largerrors.map<Bool>(fn(gg) => gg.1));
                let params = decl.params.map<SMTAssembly::InvokeParameterDecl>(fn(p) => {
                    let mlp = lgi.largerrors.tryFind(pred(gg) => gg.0 === p.pname);
                    let islerr = if(mlp)@some then $mlp.1 else false;

                    return SMTAssembly::InvokeParameterDecl{SMTAssembly::Identifier::from(p.pname.value), this.transformParamTypeToSMT(p.ptype, islerr)};
                });

                let mayerr = \/(this.errinvokes.get(decl.ikey), lgi.largerrors.someOf(pred(gg) => gg.1));
                let rtype = this.transformStdTypeToSMT(decl.resultType);
                let artype = if(mayerr) then SMTAssembly::ErrorResult{ rtype } else SMTAssembly::SafeResult{ rtype };

                let lambdaerr = lgi.largerrors.reduce<Map<BSQAssembly::Identifier, Bool>>(Map<BSQAssembly::Identifier, Bool>{}, fn(lemap, gg) => lemap.insert(gg.0, gg.1));
                let ctx = SMTTransformerCtx{mayerr, lambdaerr, decl.file, some(decl.ikey), 1n, 1n, List<SMTAssembly::ErrorInfo>{}, List<LambdaGeneratorInfo>{lgi}};

                let rctx, body = this.transformBodyToSMTBody(decl.body, ctx, decl.resultType);
                return SMTAssembly::FunctionDecl{ ikey, List<SMTAssembly::InvokeParameterDecl>{thisdecl}.append(params), artype, body }, rctx.lambdagen; 
            });

            let decls = allprocs.map<SMTAssembly::FunctionDecl>(fn(p) => p.0);
            let lambdagen = List<LambdaGeneratorInfo>::concatAll(allprocs.map<List<LambdaGeneratorInfo>>(fn(p) => p.1));

            return decls, lambdagen;
        }
    }

    method transformImplicitInvariantOrValidateFunctionDeclToSMT(decl: BSQAssembly::ConditionDecl, tdecl: BSQAssembly::AbstractNominalTypeDecl): SMTAssembly::FunctionDecl, List<LambdaGeneratorInfo> {
        let ikey = TransformNameManager::convertInvokeKey(decl.ikey, List<Bool>{});

        let params = tdecl.saturatedBFieldInfo.map<SMTAssembly::InvokeParameterDecl>(fn(f) => {
                let pname = SMTAssembly::Identifier::from(CString::concat('$', TransformNameManager::safeifyName(f.fname.value)));
                return SMTAssembly::InvokeParameterDecl{pname, this.transformStdTypeToSMT(f.ftype)};
            });

        let rtype = 'Bool'<SMTAssembly::TypeKey>;
        let artype = if(this.errinvokes.get(decl.ikey)) then SMTAssembly::ErrorResult{ rtype } else SMTAssembly::SafeResult{ rtype };

        let ctx = SMTTransformerCtx{this.errinvokes.get(decl.ikey), Map<BSQAssembly::Identifier, Bool>{}, decl.file, some(decl.ikey), 1n, 1n, List<SMTAssembly::ErrorInfo>{}, List<LambdaGeneratorInfo>{}};
        let rctx, smtexp = this.transformExpressionToSMT(decl.exp, ctx);

        var body: SMTAssembly::Body;
        if(smtexp)@<ErrorResult> {
            body = SMTAssembly::Body{SMTAssembly::ReturnOperation{$smtexp.exp}, rctx.errors};
        }
        else {
            body = SMTAssembly::Body{SMTAssembly::ReturnOperation{$smtexp.exp}, rctx.errors};
        }

        return SMTAssembly::FunctionDecl{ ikey, params, artype, body }, rctx.lambdagen;
    }

    method processConstExpression(exp: BSQAssembly::Expression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTAssembly::Body {
        let rctx, smtexp = this.transformExpressionToSMT(exp, ctx);
        
        if(smtexp)@<ErrorResult> {
            return rctx, SMTAssembly::Body{SMTAssembly::ReturnOperation{$smtexp.exp}, rctx.errors};
        }
        else {
            return rctx, SMTAssembly::Body{SMTAssembly::ReturnOperation{SMTAssembly::WrapIntoResultExpression{this.transformStdTypeToSMT(exp.etype), $smtexp.exp}}, rctx.errors};
        }
    }

    method transformNamspaceConstDeclToSMT(decl: BSQAssembly::NamespaceConstDecl): SMTAssembly::NamespaceConstDecl, List<LambdaGeneratorInfo> {
        let nskey = TransformNameManager::convertNamespaceKey(decl.declaredInNS);
        let vtype = SMTAssembly::ErrorResult{ this.transformStdTypeToSMT(decl.declaredType) }; %%Not strictly needed but means we don't need to do errors over consts

        let ctx = SMTTransformerCtx{true, Map<BSQAssembly::Identifier, Bool>{}, decl.file, none, 1n, 1n, List<SMTAssembly::ErrorInfo>{}, List<LambdaGeneratorInfo>{}};
        let rctx, body = this.processConstExpression(decl.value, ctx);
        return SMTAssembly::NamespaceConstDecl{ nskey, decl.name.value, vtype, body }, rctx.lambdagen;
    }

    method transformTypeConstDeclToSMT(decl: BSQAssembly::ConstMemberDecl): SMTAssembly::ConstMemberDecl, List<LambdaGeneratorInfo> {
        let tkey = TransformNameManager::convertTypeKey(decl.declaredInType.tkeystr);
        let vtype = SMTAssembly::ErrorResult{ this.transformStdTypeToSMT(decl.declaredType) }; %%Not strictly needed but means we don't need to do errors over consts

        let ctx = SMTTransformerCtx{true, Map<BSQAssembly::Identifier, Bool>{}, decl.file, none, 1n, 1n, List<SMTAssembly::ErrorInfo>{}, List<LambdaGeneratorInfo>{}};
        let rctx, body = this.processConstExpression(decl.value, ctx);
        return SMTAssembly::ConstMemberDecl{ tkey, decl.name.value, vtype, body }, rctx.lambdagen;
    }

    method transformFieldInfoToSMT(finfo: BSQAssembly::SaturatedFieldInfo): SMTAssembly::FieldInfo {
        return SMTAssembly::FieldInfo{finfo.fname.value, this.transformStdTypeToSMT(finfo.ftype)};
    }

    method transformConstructableDeclToSMT(decl: BSQAssembly::ConstructableTypeDecl): SMTAssembly::ConstructableTypeDecl {
        let tkey = TransformNameManager::convertTypeKey(decl.tkey);

        match(decl)@ {
            BSQAssembly::OkTypeDecl => { 
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::FailTypeDecl => { 
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::APIRejectedTypeDecl => { 
                abort;
            }
            | BSQAssembly::APIFailedTypeDecl => { 
                abort; 
            }
            | BSQAssembly::APIErrorTypeDecl => { 
                abort; 
            }
            | BSQAssembly::APISuccessTypeDecl => { 
                abort;
            }
            | BSQAssembly::SomeTypeDecl => { 
                let vtype = this.transformStdTypeToSMT($decl.oftype);
                return SMTAssembly::SomeTypeDecl{ tkey, vtype };
            }
            | BSQAssembly::MapEntryTypeDecl => { 
                let ktype = this.transformStdTypeToSMT($decl.ktype);
                let vtype = this.transformStdTypeToSMT($decl.vtype);
                return SMTAssembly::MapEntryTypeDecl{ tkey, ktype, vtype };
            }
        }
    }

    method transformEntityDeclToSMT(decl: BSQAssembly::EntityTypeDecl): SMTAssembly::EntityTypeDecl {
        let tkey = TransformNameManager::convertTypeKey(decl.tkey);
        let termable = !decl.saturatedProvides.empty();
        let finfo = decl.saturatedBFieldInfo.map<SMTAssembly::FieldInfo>(fn(f) => this.transformFieldInfoToSMT(f));

        return SMTAssembly::EntityTypeDecl{ tkey, termable, finfo };
    }

    method transformPrimitiveConceptDeclToSMT(decl: BSQAssembly::PrimitiveConceptTypeDecl): SMTAssembly::PrimitiveConceptTypeDecl {
        let tkey = TransformNameManager::convertTypeKey(decl.tkey);

        match(decl)@ {
            BSQAssembly::OptionTypeDecl => { 
                let stype = TransformNameManager::convertTypeKey($decl.someType.tkeystr);
                return SMTAssembly::OptionTypeDecl{ tkey, stype };
            }
            | BSQAssembly::ResultTypeDecl => { 
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::APIResultTypeDecl => { 
                abort; %% NOT IMPLEMENTED
            }
        }
    }

    method transformInvokeToSMTBuiltinFunction(ikey: BSQAssembly::InvokeKey, lambdainvs: Option<List<LambdaGeneratorInfo>>): Option<List<SMTAssembly::BuiltinFunctionDecl>> {
        let bsqnsdecl = this.assembly.nsfuncs.tryGet(ikey);
        if(bsqnsdecl)@some {
            if($bsqnsdecl.body?<BSQAssembly::BuiltinBodyImplementation>) {
                return some(this.transformNamespaceFunctionDeclToBuiltinSMT($bsqnsdecl, lambdainvs));
            }
            else {
                return none;
            }
        }

        return none;
    }

    method transformInvokeToSMTFunction(ikey: BSQAssembly::InvokeKey, lambdainvs: Option<List<LambdaGeneratorInfo>>): Option<(|List<SMTAssembly::FunctionDecl>, List<LambdaGeneratorInfo>|)> {
        let bsqnsdecl = this.assembly.nsfuncs.tryGet(ikey);
        if(bsqnsdecl)@some {
            if(\/($bsqnsdecl.body?<BSQAssembly::StandardBodyImplementation>, $bsqnsdecl.body?<BSQAssembly::ExpressionBodyImplementation>)) {
                let ffinfo = this.transformNamespaceFunctionDeclToSMT($bsqnsdecl, lambdainvs);
                return some(ffinfo);
            }
            else {
                return none;
            }
        }

        let bsqsmdecl = this.assembly.staticmethods.tryGet(ikey);
        if(bsqsmdecl)@some {
            let ffinfo = this.transformMethodDeclStaticToSMT($bsqsmdecl, lambdainvs);
            return some(ffinfo);
        }

        let implicitinv = this.assembly.tryGetImplicitInvariantInfo(ikey);
        if(implicitinv)@some {
            let ivs, lgens = this.transformImplicitInvariantOrValidateFunctionDeclToSMT($implicitinv.0, $implicitinv.1);
            return some((|List<SMTAssembly::FunctionDecl>{ivs}, lgens|));
        }

        return none;
    }

    function transformAssemblyToSMT(assembly: BSQAssembly::Assembly, callg: BSQToSMTCallGraph, errinvokes: Map<BSQAssembly::InvokeKey, Bool>): SMTAssembly::Assembly {
        let transformer = SMTTransformer{assembly, callg, errinvokes, MayErrorAnalysis{assembly, callg}};
    
        let tnsconstsinfo = assembly.nsconsts.map<(|SMTAssembly::NamespaceConstDecl, List<LambdaGeneratorInfo>|)>(fn(nsc) => transformer.transformNamspaceConstDeclToSMT(nsc));
        let ttypeconstsinfo = assembly.typeconsts.map<(|SMTAssembly::ConstMemberDecl, List<LambdaGeneratorInfo>|)>(fn(tc) => transformer.transformTypeConstDeclToSMT(tc));
        let lgstate = LambdaGeneratorState{Map<BSQAssembly::InvokeKey, List<LambdaGeneratorInfo>>{}}
            .mergeLambdaGeneratorInfo(List<LambdaGeneratorInfo>::concatAll(tnsconstsinfo.map<List<LambdaGeneratorInfo>>(fn(nsc) => nsc.1)))
            .mergeLambdaGeneratorInfo(List<LambdaGeneratorInfo>::concatAll(ttypeconstsinfo.map<List<LambdaGeneratorInfo>>(fn(tc) => tc.1)));

        let tnsfuncs, lgstatef, tnsinvkeys = callg.topoorder
            .lreduce<(|Map<SMTAssembly::InvokeKey, SMTAssembly::FunctionDecl>, LambdaGeneratorState, List<SMTAssembly::InvokeKey>|)>((|Map<SMTAssembly::InvokeKey, SMTAssembly::FunctionDecl>{}, lgstate, List<SMTAssembly::InvokeKey>{}|), 
                fn(acc, ikey) => {
                    let fdinfo = transformer.transformInvokeToSMTFunction(ikey, acc.1.getLambdaGeneratorInfo(ikey));
                    if(fdinfo)@some {
                        let nfm = $fdinfo.0.reduce<Map<SMTAssembly::InvokeKey, SMTAssembly::FunctionDecl>>(acc.0, fn(mm, f) => mm.insert(f.invokeKey, f));
                        let nlgen = acc.1.mergeLambdaGeneratorInfo($fdinfo.1);
                        let nlsort = acc.2.prepend($fdinfo.0.map<SMTAssembly::InvokeKey>(fn(f) => f.invokeKey));

                        return nfm, nlgen, nlsort;
                    }
                    else {
                        return acc;
                    }
                });

        let tnsfuncsbuiltin = callg.topoorder
            .lreduce<Map<SMTAssembly::InvokeKey, SMTAssembly::BuiltinFunctionDecl>>(Map<SMTAssembly::InvokeKey, SMTAssembly::BuiltinFunctionDecl>{}, 
                fn(acc, ikey) => {
                    let bidl = transformer.transformInvokeToSMTBuiltinFunction(ikey, lgstatef.getLambdaGeneratorInfo(ikey));
                    if(bidl)@some {
                        return $bidl.reduce<Map<SMTAssembly::InvokeKey, SMTAssembly::BuiltinFunctionDecl>>(acc, fn(mm, f) => mm.insert(f.invokeKey, f));
                    }
                    else {
                        return acc;
                    }
                });

        let tentities = assembly.allconcretetypes
            .filter(pred(tkey) => assembly.entities.has(tkey))
            .map<SMTAssembly::EntityTypeDecl>(fn(tkey) => transformer.transformEntityDeclToSMT(assembly.entities.get(tkey)));

        let tconstructables = assembly.allconcretetypes
            .filter(pred(tkey) => assembly.constructables.has(tkey))
            .map<SMTAssembly::ConstructableTypeDecl>(fn(tkey) => transformer.transformConstructableDeclToSMT(assembly.constructables.get(tkey)));

        let tpconcepts = assembly.allabstracttypes
            .filter(pred(tkey) => assembly.pconcepts.has(tkey))
            .map<SMTAssembly::PrimitiveConceptTypeDecl>(fn(tkey) => transformer.transformPrimitiveConceptDeclToSMT(assembly.pconcepts.get(tkey)));

        let tallfuncs = List<SMTAssembly::InvokeKey>::concat(tnsfuncsbuiltin.keyList(), tnsinvkeys);

        return SMTAssembly::Assembly {
            nsconsts = tnsconstsinfo.map<SMTAssembly::NamespaceConstDecl>(fn(nsc) => nsc.0),
            typeconsts = ttypeconstsinfo.map<SMTAssembly::ConstMemberDecl>(fn(tc) => tc.0),

            nspreds = List<SMTAssembly::PredicateFunctionDecl>{},
            nsbuiltins = tnsfuncsbuiltin,
    
            funcs = tnsfuncs,
    
            enums = List<SMTAssembly::EnumTypeDecl>{},
            typedecls = List<SMTAssembly::TypedeclTypeDecl>{},
            constructables = tconstructables,
            collections = List<SMTAssembly::CollectionTypeDecl>{},

            entities = tentities,
            datamembers = List<SMTAssembly::DatatypeMemberEntityTypeDecl>{},

            pconcepts = tpconcepts,
            concepts = List<SMTAssembly::ConceptTypeDecl>{},

            datatypes = List<SMTAssembly::DatatypeTypeDecl>{},

            orderedfuncs = tallfuncs
        };
    }
}
