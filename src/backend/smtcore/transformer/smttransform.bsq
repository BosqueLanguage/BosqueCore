
namespace SMTEmitter;

namespace TransformNameManager {
    const c_dangerous: Map<CString, CString> = Map<CString, CString>{
        'ite' => '@ite'
    };

    function resymbolCStringForSMT(cstr: CString): CString {
        return cstr.replaceAllStringOccurrences('::', '@')
            .replaceAllStringOccurrences(', ', '-')
            .replaceAllStringOccurrences('(|', '@EList<')
            .replaceAllStringOccurrences('|)', '>');
    }

    function safeifyName(name: CString): CString {
        if(!TransformNameManager::c_dangerous.has(name)) {
            return name;
        }
        else {
            return TransformNameManager::c_dangerous.get(name);
        }    
    }

    function convertNamespaceKey(nskey: BSQAssembly::NamespaceKey): SMTAssembly::NamespaceKey {
        return SMTAssembly::NamespaceKey::from(resymbolCStringForSMT(nskey.value));
    }

    function convertTypeKey(nskey: BSQAssembly::TypeKey): SMTAssembly::TypeKey {
        return SMTAssembly::TypeKey::from(resymbolCStringForSMT(nskey.value));
    }

    function convertInvokeKey(ikey: BSQAssembly::InvokeKey): SMTAssembly::InvokeKey {
        return SMTAssembly::InvokeKey::from(resymbolCStringForSMT(ikey.value));
    }
}

datatype SMTExpTransformResult using {
    field oftype: SMTAssembly::TypeKey;
    field exp: SMTAssembly::Expression;
}
of 
DirectResult { }
| PossibleErrorResult { }
;

entity SMTTransformerCtx {
    field tempCtr: Nat;
    field errCtr: Nat;
}

entity SMTTransformer {
    field assembly: BSQAssembly::Assembly;

    function isTermSMTTypeKey(tkey: SMTAssembly::TypeKey): Bool {
        return tkey === '@Term'<SMTAssembly::TypeKey>;
    }

    method transformStdTypeToSMT(tsig: BSQAssembly::TypeSignature): SMTAssembly::TypeKey {
        if(tsig)@!<BSQAssembly::NominalTypeSignature> {
            let smtk = TransformNameManager::convertTypeKey(tsig.tkeystr);
            return smtk;
        }
        else {
            if(this.assembly.isNominalTypeConcrete($tsig.tkeystr)) {
                return SMTAssembly::TypeKey::from($tsig.tkeystr);
            }
            else {
                return SMTAssembly::TypeKey::from('@BTerm');
            }
        }
    }

    method transformCallTypeToSMT(tsig: BSQAssembly::TypeSignature): SMTAssembly::ParamTypeKey {
        if(tsig)@!<BSQAssembly::LambdaTypeSignature> {
            return SMTAssembly::ParamTypeKey::from(this.transformStdTypeToSMT(tsig));
        }
        else {
            abort; %% NOT IMPLEMENTED LAMBDA TYPES
        }
    }

    method emitTermify(smtfrom: SMTAssembly::TypeKey, smtinto: SMTAssembly::TypeKey, exp: SMTAssembly::Expression): SMTAssembly::Expression {
        return SMTAssembly::TermifyValue{exp, smtfrom, smtinto};
    }

    method emitUntermify(smtfrom: SMTAssembly::TypeKey, smtinto: SMTAssembly::TypeKey, exp: SMTAssembly::Expression): SMTAssembly::Expression {
        return SMTAssembly::UntermifyValue{exp, smtfrom, smtinto};
    }

    method emitCoerceAsNeeded(from: BSQAssembly::TypeSignature, into: BSQAssembly::TypeSignature, exp: SMTAssembly::Expression): SMTAssembly::Expression {
        let smtfrom = this.transformStdTypeToSMT(from);
        let smtinto = this.transformStdTypeToSMT(into);

        if(smtfrom === smtinto) {
            return v;
        }
        else {
            if(SMTTransformer::isTermSMTTypeKey(smtinto)) {
                return this.emitTermify(smtfrom, smtinto, v);
            }
            else {
                return this.emitUntermify(smtfrom, smtinto, v);
            }
        }
    } 

    method unpackExpressionErrors(subexps: List<SMTExpTransformResult>, ctx: SMTTransformerCtx): List<SMTAssembly::Expression>, SMTTransformerCtx, Option<List<(|Expression, VarIdentifier|)>> {
        if(subexps.allOf(pred(etr) => etr?<DirectResult>)) {
            return subexps.map<SMTAssembly::Expression>(fn(etr) => etr.exp), ctx, none;
        }
        else {
            let mtag = ctx.tempCtr.toCString();
            let eexps = subexps.mapIdx<(|SMTExpTransformResult, Option<VarIdentifier|)>(fn(etr, idx) => {
                if(etr?<DirectResult>) {
                    return (|etr, none|);
                }
                else {
                    let vname = VarIdentifier::from(CString::concat('@tmp-', mtag, '-', idx.toCString()));
                    return (|etr, some(vname)|);
                }
            });

            let exps = eexps.map<Expression>(fn(etrp) => {
                if($vv = etrp.1)@none {
                    return etrp.0.exp;
                }
                else {
                    return UnwrapValueFromResultExpression{AccessVariableExpression{$vv, etrp.0.oftype}};
                }
            });

            let binds = eexps.filter(pred(etrp) => etrp.1?some).map<(|Expression, VarIdentifier|)>(fn(etrp) => (|etrp.0.exp, etrp.1@some|));

            return exps, ctx[tmpCtr = $tmpCtr + 1], some(binds);
        }
    }

    recursive method processArgsInOrder(args: List<BSQAssembly::Expression>, ctx: SMTTransformerCtx): List<SMTAssembly::Expression>, SMTTransformerCtx, Option<List<(|Expression, VarIdentifier|)>> {
        let subexps = args.transduce<SMTTransformerCtx, SMTExpTransformResult>(ctx, recursive fn(arg) => this.transformExpressionToSMT[recursive](arg, ctx));

        return this.unpackExpressionErrors(subexps, ctx);
    }

    recursive method processUnaryArg(arg: BSQAssembly::Expression, ctx: SMTTransformerCtx): SMTAssembly::Expression, SMTTransformerCtx, Option<List<(|Expression, VarIdentifier|)>> {
        let rexps, nctx, obinds = this.processArgsInOrder[recursive](List<BSQAssembly::Expression>{exp.lhs, exp.rhs}, ctx);
        return rexps.get(0), nctx, obinds;
    }

    recursive method processBinaryArgs(lhs: BSQAssembly::Expression, rhs: BSQAssembly::Expression, ctx: SMTTransformerCtx): SMTAssembly::Expression, SMTAssembly::Expression, SMTTransformerCtx, Option<List<(|Expression, VarIdentifier|)>> {
        let rexps, nctx, obinds = this.processArgsInOrder[recursive](List<BSQAssembly::Expression>{exp.lhs, exp.rhs}, ctx);
        return rexps.get(0), rexps.get(1), nctx, obinds;
    }

    method transformLiteralNoneExpression(exp: BSQAssembly::LiteralNoneExpression): SMTAssembly::Expression {
        return SMTAssembly::LiteralNoneValue{};
    }

    method transformLiteralSimpleExpression(exp: BSQAssembly::LiteralSimpleExpression): SMTAssembly::Expression {
        return SMTAssembly::LiteralSimpleValue{this.transformStdTypeToSMT(exp.etype), exp.value};
    }

    method transformLiteralCStringExpression(exp: BSQAssembly::LiteralCStringExpression): SMTAssembly::Expression {
        return SMTAssembly::LiteralCStringValue{exp.value};
    }

    method transformLiteralStringExpression(exp: BSQAssembly::LiteralStringExpression): SMTAssembly::Expression {
        return SMTAssembly::LiteralStringValue{exp.value};
    }

    method transformAccessVariableExpression(exp: BSQAssembly::AccessVariableExpression): SMTAssembly::Expression {
        return SMTAssembly::AccessVariableValue{exp.vname.value};
    }

    recursive method transformBinAddExpression(exp: BSQAssembly::BinAddExpression, ctx: SMTTransformerCtx): SMTTransformerCtx, ExpressionTransformResult {
        let rexp, lexp, nctx, obinds = this.processBinaryArgs[recursive](exp.lhs, exp.rhs, ctx);

        if(obinds)@none {
            return ctx, DirectResult{this.transformStdTypeToSMT(exp.etype), SMTAssembly::BinAddValue{lexp, rexp}};
        }
        else {
            abort; %% NOT IMPLEMENTED
        }
    }

    recursive method transformExpressionToSMT(exp: BSQAssembly::Expression, ctx: SMTTransformerCtx): SMTTransformerCtx, SMTExpTransformResult {
        match(exp)@ {
            BSQAssembly::LiteralNoneExpression => { 
                return ctx, DirectResult{this.transformStdTypeToSMT(exp.etype), this.transformLiteralNoneExpression($exp)}; 
            }
            | BSQAssembly::LiteralSimpleExpression => { 
                return ctx, DirectResult{this.transformStdTypeToSMT(exp.etype), this.transformLiteralSimpleExpression($exp)}; 
            }
            | BSQAssembly::LiteralCStringExpression => { 
                return ctx, DirectResult{this.transformStdTypeToSMT(exp.etype), this.transformLiteralCStringExpression($exp)};
            }
            | BSQAssembly::LiteralStringExpression => { 
                return ctx, DirectResult{this.transformStdTypeToSMT(exp.etype), this.transformLiteralStringExpression($exp)}; 
            }
            | BSQAssembly::AccessVariableExpression => { 
                return ctx, DirectResult{this.transformStdTypeToSMT(exp.etype), this.transformAccessVariableExpression($exp)}; 
            }
            | BSQAssembly::BinAddExpression => { 
                return this.transformBinAddExpression[recursive]($exp, ctx);
            }
            | _ => { 
                abort; %% NOT IMPLEMENTED
            }
        }
    }

    method transformRealBodyImplementationToSMT(impl: BSQAssembly::BodyImplementation, ttype: BSQAssembly::TypeSignature): SMTAssembly::OperationBlock {
        match(impl)@ {
            BSQAssembly::BuiltinBodyImplementation => {
                abort; %% NOT IMPLEMENTED
            }
            | BSQAssembly::ExpressionBodyImplementation => {
                return this.transformToplevelExpressionToSMT($impl.exp, ttype);
            }
            | BSQAssembly::StandardBodyImplementation => {
                return this.transformStatementListToSMT($impl.statements, ttype);
            }
            | _ => {
                abort; %% NOT IMPLEMENTED
            }
        }
    }

    method transformNamespaceFunctionDeclToSMT(decl: BSQAssembly::NamespaceFunctionDecl, errinvokes: Map<BSQAssembly::InvokeKey, Bool>): SMTAssembly::NamespaceFunctionDecl {
        let nskey = TransformNameManager::convertNamespaceKey(decl.declaredInNS);
        let ikey = TransformNameManager::convertInvokeKey(decl.ikey);

        let params = decl.params.map<SMTAssembly::InvokeParameterDecl>(fn(p) => SMTAssembly::InvokeParameterDecl{p.pname.value, this.transformCallTypeToSMT(p.ptype)});
        let rtype = this.transformStdTypeToSMT(decl.resultType);
        let artype = if(errinvokes.get(decl.ikey)) then SMTAssembly::OptionResult{ rtype } else SMTAssembly::DirectResult{ rtype };

        let body = this.transformRealBodyImplementationToSMT(decl.body, decl.resultType);
        return SMTAssembly::NamespaceFunctionDecl{ nskey, decl.name.value, ikey, params, artype, body };
    }

    method transformNamspaceConstDeclToSMT(decl: BSQAssembly::NamespaceConstDecl): SMTAssembly::NamespaceConstDecl {
        let nskey = TransformNameManager::convertNamespaceKey(decl.declaredInNS);

        let declaredtype = this.transformStdTypeToSMT(decl.declaredType);
        let vtype = SMTAssembly::OptionResult{ declaredtype };

        let body = this.transformToplevelExpressionToSMT(decl.value, decl.declaredType);
        return SMTAssembly::NamespaceConstDecl{ nskey, decl.name.value, vtype, body };
    }

    function transformAssemblyToSMT(assembly: BSQAssembly::Assembly, errinvokes: Map<BSQAssembly::InvokeKey, Bool>): SMTAssembly::Assembly {
        let transformer = SMTTransformer{assembly};

        let tnsfuncs = assembly.allfuncs
            .filter(pred(ikey) => assembly.nsfuncs.has(ikey))
            .reduce<Map<SMTAssembly::InvokeKey, SMTAssembly::NamespaceFunctionDecl>>(Map<SMTAssembly::InvokeKey, SMTAssembly::NamespaceFunctionDecl>{}, 
                fn(acc, ikey) => {
                    let bsqdecl = assembly.nsfuncs.get(ikey);
                    let smtdecl = transformer.transformNamespaceFunctionDeclToSMT(bsqdecl, errinvokes);
                    return acc.insert(smtdecl.invokeKey, smtdecl);
                });

        let tallfuncs = assembly.allfuncs.map<SMTAssembly::InvokeKey>(fn(ikey) => TransformNameManager::convertInvokeKey(ikey));
        %% TODO -- topo sort this

        return SMTAssembly::Assembly {
            nsconsts = assembly.nsconsts.map<SMTAssembly::NamespaceConstDecl>(fn(nsc) => transformer.transformNamspaceConstDeclToSMT(nsc)),
            typeconsts = List<SMTAssembly::ConstMemberDecl>{},

            nspreds = List<SMTAssembly::NamespacePredicateFunctionDecl>{},
            nsbuiltins = List<SMTAssembly::NamespaceBuiltinFunctionDecl>{},
    
            nsfuncs = tnsfuncs,
            typefuncs = Map<SMTAssembly::InvokeKey, SMTAssembly::TypeFunctionDecl>{},
            allfuncs = tallfuncs,
    
            enums = List<SMTAssembly::EnumTypeDecl>{},
            typedecls = List<SMTAssembly::TypedeclTypeDecl>{},
            constructables = List<SMTAssembly::ConstructableTypeDecl>{},
            collections = List<SMTAssembly::CollectionTypeDecl>{},

            entities = List<SMTAssembly::EntityTypeDecl>{},
            datamembers = List<SMTAssembly::DatatypeMemberEntityTypeDecl>{},

            pconcepts = List<SMTAssembly::PrimitiveConceptTypeDecl>{},
            concepts = List<SMTAssembly::ConceptTypeDecl>{},

            datatypes = List<SMTAssembly::DatatypeTypeDecl>{}
        };
    }
}
