namespace BSQAssembly;

entity VarMapping {
    field bnmap: Map<VarIdentifier, VarIdentifier>; %%This is the map from binder names to the new name (or the same name if no shadowing)

    function createEmpty(): VarMapping {
        return VarMapping{
            Map<VarIdentifier, VarIdentifier>{}
        };
    }

    method extendMapping(name: VarIdentifier): VarMapping {
        var nbm: Map<VarIdentifier, VarIdentifier>;

        if(!this.bnmap.has(name)) {
            nbm = this.bnmap.insert(name, name);
        }
        else {
            let nname = this.bnmap.get(name);
            if(nname === name) {
                nbm = this.bnmap.set(name, VarIdentifier::from(name.value.append('_$v$_')));
            }
            else {
                nbm = this.bnmap.set(name, VarIdentifier::from(nname.value.append('$')));
            }
        }

        return VarMapping{ nbm };
    }

    method resolveVariableAsNeeded(name: VarIdentifier): VarIdentifier {
        let nmapped = this.bnmap.tryGet(name);
        if(nmapped)@none {
            return name;
        }
        else {
            return $nmapped;
        }
    }
}

%*
 * Rewrite the IR to make all type conversions and accesses explicit -- ensure all variable names are unique (no shadowing or duplicates)
 *%
entity ExplicitifyTransform {
    field assembly: Assembly;

    method processCoerceTypeAsNeeded(e: Expression, into: TypeSignature): Expression {
        if(this.assembly.areTypesSame(e.etype, into)) {
            return e;
        }
        else {
            if(this.assembly.isSubtypeOf(e.etype, into)) {
                return CoerceWidenTypeExpression{ e.sinfo, into, e, e.etype@<NominalTypeSignature>, into@<NominalTypeSignature> };
            }
            else {
                return CoerceNarrowTypeExpression{ e.sinfo, into, e, e.etype@<NominalTypeSignature>, into@<NominalTypeSignature> };
            }
        }
    }

    method processExplicitBoolConvertAsNeeded(e: Expression): Expression {
        if(this.assembly.isBoolType(e.etype)) {
            return e;
        }
        else {
            abort;
        }
    }

    recursive method processArgs(args: List<Expression>, vmap: VarMapping): List<Expression> {
        return args.map[recursive]<Expression>(recursive fn(arg) => this.processExpression[recursive](arg, vmap));
    }

    recursive method processUnaryArg(arg: Expression, vmap: VarMapping): Expression {
        return this.processExpression[recursive](arg, vmap);
    }

    recursive method processBinaryArgs(lhs: Expression, rhs: Expression, vmap: VarMapping): Expression, Expression {
        return this.processExpression[recursive](lhs, vmap), this.processExpression[recursive](rhs, vmap);
    }

    recursive method processUnaryConstructorArg(arg: Expression, vtype: TypeSignature, vmap: VarMapping): Expression {
        let nexp = this.processExpression[recursive](arg, vmap);
        return this.processCoerceTypeAsNeeded(nexp, vtype);
    }

    method processFieldDefaultValue(tsig: TypeSignature, name: Identifier): Expression {
        var ff: MemberFieldDecl;
        if(this.assembly.entities.has(tsig.tkeystr)) {
            ff = this.assembly.entities.get(tsig.tkeystr).fields.find(pred(f) => f.name === name);
        }
        elif(this.assembly.concepts.has(tsig.tkeystr)) {
            ff = this.assembly.concepts.get(tsig.tkeystr).fields.find(pred(f) => f.name === name);
        }
        elif(this.assembly.datamembers.has(tsig.tkeystr)) {
            ff = this.assembly.datamembers.get(tsig.tkeystr).fields.find(pred(f) => f.name === name);
        }
        else {
            ff = this.assembly.datatypes.get(tsig.tkeystr).fields.find(pred(f) => f.name === name);
        }

        let cv = this.assembly.tryResolveExpAsLiteralExpression(ff.defaultValue@some);
        if(cv)@some {
            return $cv;
        }
        else {
            abort; %% Not implemented -- put in default value expression for the field
        }
    }

    recursive method processStdConstructorArgs(sinfo: SourceInfo, finfos: List<SaturatedFieldInfo>, ainfo: ConstructorArgumentInfo, vmap: VarMapping): ConstructorArgumentInfo {
        let resolvedargs = ainfo.shuffleinfo.mapIdx[recursive]<Expression>(fn(si, i) => {
            let fi = finfos.get(i);

            if($argidx = si.0)@none {
                let resinfo = si.1@some;
                return this.processFieldDefaultValue(resinfo.0, resinfo.1);
            }
            else {
                let eexp = ainfo.srcargs.get($argidx).exp;
                let nexp = this.processExpression[recursive](eexp, vmap);

                return this.processCoerceTypeAsNeeded(nexp, fi.ftype);
            }
        });

        return ainfo[resolvedargs=some(resolvedargs)];
    }

    recursive method processInvokeArgumentInfoStatic(sinfo: SourceInfo, params: List<InvokeParameterDecl>, ainfo: InvokeArgumentInfo, vmap: VarMapping): InvokeArgumentInfo {
        var resolvedargs = ainfo.shuffleinfo.mapIdx[recursive]<Expression>(fn(si, i) => {
            let pp = params.get(i);

            if($argidx = si.0)@none {
                let dexp = this.assembly.tryResolveExpAsLiteralExpression(pp.defaultval@some);
                if(dexp)@some {
                    return $dexp;
                }
                else {
                    abort; %% Put in "default value expression" for the parameter
                }
            }
            else {
                let eexp = ainfo.srcargs.get($argidx).exp;
                let nexp = this.processExpression[recursive](eexp, vmap);

                return this.processCoerceTypeAsNeeded(nexp, pp.ptype);
            }
        });

        if($resttype = ainfo.resttype)@some {
            let resttypedecl = this.assembly.lookupNominalTypeDeclaration($resttype.tkeystr)@<CollectionTypeDecl>;
            let restelemtype = resttypedecl.oftype;

            let restl = ainfo.restinfo.map[recursive]<ArgumentValue>(recursive fn(rri) => {
                let eexp = ainfo.srcargs.get(rri.0).exp;
                let nexp = this.processExpression[recursive](eexp, vmap);

                if(!rri.1) {
                    return PositionalArgumentValue{ this.processCoerceTypeAsNeeded(nexp, restelemtype) };
                }
                else {
                    abort; %% Not implemented -- spread into rest
                }
            });

            if(resttypedecl)@<ListTypeDecl> {
                resolvedargs = resolvedargs.pushBack(ConstructorPrimaryListExpression{ sinfo, $resttype, $resttype@<NominalTypeSignature>, restelemtype, restl });
            }
            else {
                abort; %% Not implemented -- CallNamespaceFunction -- map
            }
        }

        return ainfo[resolvedargs=some(resolvedargs)];
    }

    recursive method processLambdaInvokeArgumentInfoStatic(sinfo: SourceInfo, ptypes: List<TypeSignature>, ainfo: LambdaInvokeArgumentInfo, vmap: VarMapping): LambdaInvokeArgumentInfo {
        var resolvedargs = ainfo.stdargs.mapIdx[recursive]<Expression>(fn(si, i) => {
            let pp = ptypes.get(i);
            let eexp = ainfo.srcargs.get(i).exp;
                
            let nexp = this.processExpression[recursive](eexp, vmap);
            return this.processCoerceTypeAsNeeded(nexp, pp);
        });

        if($resttype = ainfo.resttype)@some {
            let resttypedecl = this.assembly.lookupNominalTypeDeclaration($resttype.tkeystr)@<CollectionTypeDecl>;
            let restelemtype = resttypedecl.oftype;

            let restl = ainfo.restinfo.map[recursive]<ArgumentValue>(recursive fn(rri) => {
                let eexp = ainfo.srcargs.get(rri.0).exp;
                let nexp = this.processExpression[recursive](eexp, vmap);

                if(!rri.1) {
                    return PositionalArgumentValue{ this.processCoerceTypeAsNeeded(nexp, restelemtype) };
                }
                else {
                    abort; %% Not implemented -- spread into rest
                }
            });

            if(resttypedecl?<ListTypeDecl>) {
                resolvedargs = resolvedargs.pushBack(ConstructorPrimaryListExpression{ sinfo, $resttype, $resttype@<NominalTypeSignature>, restelemtype, restl });
            }
            else {
                abort; %% Not implemented -- CallNamespaceFunction -- map
            }
        }

        return ainfo[resolvedargs=some(resolvedargs)];
    }

    recursive method processArgumentListConstructCollection(argl: List<ArgumentValue>, elemtype: TypeSignature, vmap: VarMapping): List<ArgumentValue> {
        let nargs = argl.map[recursive]<ArgumentValue>(recursive fn(arg) => {
            let nexp = this.processExpression[recursive](arg.exp, vmap);
            if(arg?<SpreadArgumentValue>) {
                return arg[exp=nexp];
            }
            else {
                let pexp = this.processCoerceTypeAsNeeded(nexp, elemtype);
                return arg[exp=pexp];
            }
        });

        return nargs;
    }

    recursive method processSimpleArguments(argl: List<Expression>, expected: List<TypeSignature>, vmap: VarMapping): List<Expression>
        requires argl.size() <= expected.size();
    {
        let nargs = argl.mapIdx[recursive]<Expression>(recursive fn(arg, i) => {
            let nexp = this.processExpression[recursive](arg, vmap);
            let pexp = this.processCoerceTypeAsNeeded(nexp, expected.get(i));

            return pexp;
        });

        return nargs;
    }

    method processAccessVariableExpression(e: AccessVariableExpression, vmap: VarMapping): Expression {
        let nname = vmap.resolveVariableAsNeeded(e.vname);
        return AccessVariableExpression{ e.sinfo, e.layouttype, nname, e.layouttype };
    }

    method processAccessCapturedVariableExpression(e: AccessCapturedVariableExpression, vmap: VarMapping): Expression {
        let nname = vmap.resolveVariableAsNeeded(e.vname);
        return AccessCapturedVariableExpression{ e.sinfo, e.layouttype, nname, e.layouttype };
    }

    recursive method processConstructorPrimarySpecialSomeExpression(e: ConstructorPrimarySpecialSomeExpression, vmap: VarMapping): Expression {
        let nval = this.processUnaryConstructorArg[recursive](e.value, e.ofttype, vmap);
        return e[value=nval];
    }

    recursive method processConstructorPrimaryListExpression(e: ConstructorPrimaryListExpression, vmap: VarMapping): Expression {
        let nargs = this.processArgumentListConstructCollection[recursive](e.args, e.elemtype, vmap);
        return e[args=nargs];
    }

    recursive method processConstructorTypeDeclExpression(e: ConstructorTypeDeclExpression, vmap: VarMapping): Expression {
        let nval = this.processUnaryConstructorArg[recursive](e.value, e.valuetype, vmap);
        return e[value=nval];
    }

    recursive method processConstructorTypeDeclStringExpression(e: ConstructorTypeDeclStringExpression, vmap: VarMapping): Expression {
        let nval = this.processUnaryConstructorArg[recursive](e.value, e.valuetype, vmap);
        let nofchk = this.assembly.tryResolveExpAsLiteralExpression(e.ofcheck);

        return e[value=nval, ofcheck=nofchk@some];
    }

    recursive method processConstructorStdExpression(e: ConstructorStdExpression, vmap: VarMapping): Expression {
        let finfos = this.assembly.lookupNominalTypeDeclaration(e.ctype.tkeystr).saturatedBFieldInfo;
        let ninfo = this.processStdConstructorArgs[recursive](e.sinfo, finfos, e.argsinfo, vmap);

        return e[argsinfo=ninfo];
    }

    recursive method processConstructorEListExpression(e: ConstructorEListExpression, vmap: VarMapping): Expression {
        let nargs = this.processSimpleArguments[recursive](e.args, e.etype@<EListTypeSignature>.entries, vmap);
        return e[args=nargs];
    }

    recursive method processConstructorExpression(e: ConstructorExpression, vmap: VarMapping): Expression {
        match(e)@ {
            ConstructorPrimaryListExpression => { return this.processConstructorPrimaryListExpression[recursive]($e, vmap); }
            | ConstructorPrimaryMapExpression => { abort; }
            | ConstructorPrimarySpecialSomeExpression => { return this.processConstructorPrimarySpecialSomeExpression[recursive]($e, vmap); }
            | ConstructorPrimarySpecialOkExpression => { abort; }
            | ConstructorPrimarySpecialFailExpression => { abort; }
            | ConstructorTypeDeclExpression => { return this.processConstructorTypeDeclExpression[recursive]($e, vmap); }
            | ConstructorTypeDeclStringExpression => { return this.processConstructorTypeDeclStringExpression[recursive]($e, vmap); }
            | ConstructorStdExpression => { return this.processConstructorStdExpression[recursive]($e, vmap); }
            | ConstructorEListExpression => { return this.processConstructorEListExpression[recursive]($e, vmap); }
        }
    }

    recursive method processConstructorLambdaExpression(e: ConstructorLambdaExpression, vmap: VarMapping): Expression {
        let nbody = this.processBodyImpl(e.body, vmap);

        return e[body=nbody];
    }

    recursive method processLambdaInvokeExpression(e: LambdaInvokeExpression, vmap: VarMapping): Expression {
        let etypes = e.lambda.params.map<TypeSignature>(fn(param) => param.ptype);
        let ninfo = this.processLambdaInvokeArgumentInfoStatic(e.sinfo, etypes, e.argsinfo, vmap);

        return e[argsinfo=ninfo];
    }

    recursive method processCallNamespaceFunctionExpression(e: CallNamespaceFunctionExpression, vmap: VarMapping): Expression {
        let params = this.assembly.nsfuncs.get(e.ikey).params;
        let nargs = this.processInvokeArgumentInfoStatic[recursive](e.sinfo, params, e.argsinfo, vmap);

        return e[argsinfo=nargs];
    }

    recursive method processCallTypeFunctionExpression(e: CallTypeFunctionExpression, vmap: VarMapping): Expression {
        let params = this.assembly.typefuncs.get(e.ikey).params;
        let nargs = this.processInvokeArgumentInfoStatic[recursive](e.sinfo, params, e.argsinfo, vmap);

        return e[argsinfo=nargs];
    }

    recursive method processLogicActionAndExpression(e: LogicActionAndExpression, vmap: VarMapping): Expression {
        let nargs = this.processArgs(e.args, vmap).map<Expression>(fn(ee) => this.processExplicitBoolConvertAsNeeded(ee));

        let restype = this.assembly.lookupNominalTypeDeclaration(e.etype.tkeystr);
        if(restype)@!<TypedeclTypeDecl> {
            return e[args=nargs];            
        }
        else {
            let nbop = e[etype=$restype.valuetype, args=nargs];
            return ConstructorTypeDeclExpression{ e.sinfo, e.etype, e.etype@<NominalTypeSignature>, nbop, $restype.valuetype };
        }
    }

    recursive method processLogicActionOrExpression(e: LogicActionOrExpression, vmap: VarMapping): Expression {
        let nargs = this.processArgs(e.args, vmap).map<Expression>(fn(ee) => this.processExplicitBoolConvertAsNeeded(ee));

        let restype = this.assembly.lookupNominalTypeDeclaration(e.etype.tkeystr);
        if(restype)@!<TypedeclTypeDecl> {
            return e[args=nargs];            
        }
        else {
            let nbop = e[etype=$restype.valuetype, args=nargs];
            return ConstructorTypeDeclExpression{ e.sinfo, e.etype, e.etype@<NominalTypeSignature>, nbop, $restype.valuetype };
        }
    }

    recursive method processTypeDeclPrimitiveFieldAccessExpression(e: TypeDeclPrimitiveFieldAccessExpression, vmap: VarMapping): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp, vmap);

        return e[exp=nexp];
    }

    recursive method processCoerceNarrowTypeExpression(e: CoerceNarrowTypeExpression, vmap: VarMapping): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp, vmap);

        return e[exp=nexp];
    }

    recursive method processCoerceWidenTypeExpression(e: CoerceWidenTypeExpression, vmap: VarMapping): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp, vmap);

        return e[exp=nexp];
    }
                   
    recursive method processSafeConvertExpression(e: SafeConvertExpression, vmap: VarMapping): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp, vmap);

        return e[exp=nexp];
    }

    recursive method processCreateDirectExpression(e: CreateDirectExpression, vmap: VarMapping): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp, vmap);
        let cexp = this.processCoerceTypeAsNeeded(nexp, e.srctype);

        return e[exp=cexp];
    }

    recursive method processPostfixInvokeStatic(op: PostfixInvokeStatic, vmap: VarMapping): PostfixInvokeStatic {
        let smdecl = this.assembly.staticmethods.get(op.resolvedTrgt);
        let nargs = this.processInvokeArgumentInfoStatic[recursive](op.sinfo, smdecl.params, op.argsinfo, vmap);

        return op[argsinfo=nargs];
    }

    recursive method processPostfixOp(e: PostfixOp, vmap: VarMapping): Expression {
        let ebase = this.processUnaryArg[recursive](e.rootExp, vmap);
        let ops = e.ops.map[recursive]<PostfixOperation>(recursive fn(op) => {
            match(op)@ {
                PostfixAccessFromName => { return $op; }
                | PostfixProjectFromNames => { return $op; }
                | PostfixAccessFromIndex => { return $op; }
                | PostfixIsTest => { return $op; }
                | PostfixAsConvert => { return $op; }
                | PostfixAssignFields => { abort; }
                | PostfixInvokeStatic => { return this.processPostfixInvokeStatic[recursive]($op, vmap); }
                | PostfixInvokeVirtual => { abort; }
                | PostfixLiteralKeyAccess => { abort; }
                | PostfixBoolConstant => { return $op; }
                | PostfixNop => { return $op; }
                | PostfixAbort => { return $op; }
                | PostfixWidenConvert => { return $op; }
                | PostfixAccessSomeValue => { return $op; }
                | PostfixLiteralNoneValue => { return $op; } 
            }
        });

        return PostfixOp{ e.sinfo, e.etype, ebase, ops };
    }

    recursive method processUnaryExpression(e: UnaryExpression, vmap: VarMapping): Expression {
        var nexp = this.processUnaryArg[recursive](e.exp, vmap);

        let ntype = this.assembly.lookupNominalTypeDeclaration(nexp.etype.tkeystr);
        if(ntype)@<TypedeclTypeDecl> {
            nexp = TypeDeclPrimitiveFieldAccessExpression{ nexp.sinfo, $ntype.valuetype, nexp };
        }

        let restype = this.assembly.lookupNominalTypeDeclaration(e.etype.tkeystr);
        if(restype)@!<TypedeclTypeDecl> {
            return e[exp=nexp];
        }
        else {
            let nbop = e[etype=$restype.valuetype, exp=nexp];
            return ConstructorTypeDeclExpression{ e.sinfo, e.etype, e.etype@<NominalTypeSignature>, nbop, $restype.valuetype };
        }
    }

    recursive method processBinaryArithExpression(e: BinaryArithExpression, vmap: VarMapping): Expression {
        var nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs, vmap);

        let lhstype = this.assembly.lookupNominalTypeDeclaration(nlhs.etype.tkeystr);
        if(lhstype)@<TypedeclTypeDecl> {
            nlhs = TypeDeclPrimitiveFieldAccessExpression{ nlhs.sinfo, $lhstype.valuetype, nlhs };
        }

        let rhstype = this.assembly.lookupNominalTypeDeclaration(nrhs.etype.tkeystr);
        if(rhstype)@<TypedeclTypeDecl> {
            nrhs = TypeDeclPrimitiveFieldAccessExpression{ nrhs.sinfo, $rhstype.valuetype, nrhs };
        }

        let restype = this.assembly.lookupNominalTypeDeclaration(e.etype.tkeystr);
        if(restype)@!<TypedeclTypeDecl> {
            return e[lhs=nlhs, rhs=nrhs];            
        }
        else {
            let nbop = e[etype=$restype.valuetype, lhs=nlhs, rhs=nrhs];
            return ConstructorTypeDeclExpression{ e.sinfo, e.etype, e.etype@<NominalTypeSignature>, nbop, $restype.valuetype };
        }
    }

    recursive method procssBinKeyEqNoneExpression(e: BinKeyEqNoneExpression, vmap: VarMapping): Expression {
        let nexp = this.processUnaryArg(e.exp, vmap);
        return e[exp=nexp];
    }

    recursive method procssBinKeyNotEqNoneExpression(e: BinKeyNotEqNoneExpression, vmap: VarMapping): Expression {
        let nexp = this.processUnaryArg(e.exp, vmap);
        return e[exp=nexp];
    }

    recursive method procssBinKeySomeEqExpression(e: BinKeySomeEqExpression, vmap: VarMapping): Expression {
        let noption, nval = this.processBinaryArgs[recursive](e.eqoption, e.eqval, vmap);
        return e[eqoption=noption, eqval=nval];
    }

    recursive method procssBinKeyNotSomeEqExpression(e: BinKeyNotSomeEqExpression, vmap: VarMapping): Expression {
        let noption, nval = this.processBinaryArgs[recursive](e.eqoption, e.eqval, vmap);
        return e[eqoption=noption, eqval=nval];
    }

    recursive method procssBinKeyEqExpression(e: BinKeyEqExpression, vmap: VarMapping): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs, vmap);
        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method procssBinKeyNotEqExpression(e: BinKeyNotEqExpression, vmap: VarMapping): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs, vmap);
        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method processBinaryKeyEqExpression(e: BinaryKeyEqExpression, vmap: VarMapping): Expression {
        match(e)@ {
            BinKeyEqNoneExpression => { return this.procssBinKeyEqNoneExpression[recursive]($e, vmap); }
            | BinKeyNotEqNoneExpression => { return this.procssBinKeyNotEqNoneExpression[recursive]($e, vmap); }
            | BinKeySomeEqExpression => { return this.procssBinKeySomeEqExpression[recursive]($e, vmap); }
            | BinKeyNotSomeEqExpression => { return this.procssBinKeyNotSomeEqExpression[recursive]($e, vmap); }
            | BinKeyEqExpression => { return this.procssBinKeyEqExpression[recursive]($e, vmap); }
            | BinKeyNotEqExpression => { return this.procssBinKeyNotEqExpression[recursive]($e, vmap); }
        }
    }

    recursive method processBinaryNumericExpression(e: BinaryNumericExpression, vmap: VarMapping): Expression {
        var nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs, vmap);

        let lhstype = this.assembly.lookupNominalTypeDeclaration(nlhs.etype.tkeystr);
        if(lhstype)@<TypedeclTypeDecl> {
            nlhs = TypeDeclPrimitiveFieldAccessExpression{ nlhs.sinfo, $lhstype.valuetype, nlhs };
        }

        let rhstype = this.assembly.lookupNominalTypeDeclaration(nrhs.etype.tkeystr);
        if(rhstype)@<TypedeclTypeDecl> {
            nrhs = TypeDeclPrimitiveFieldAccessExpression{ nrhs.sinfo, $rhstype.valuetype, nrhs };
        }

        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method processBinLogicExpression(e: BinLogicExpression, vmap: VarMapping): Expression {
        var nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs, vmap);
        nlhs = this.processExplicitBoolConvertAsNeeded(nlhs);
        nrhs = this.processExplicitBoolConvertAsNeeded(nrhs);

        let restype = this.assembly.lookupNominalTypeDeclaration(e.etype.tkeystr);
        if(restype)@!<TypedeclTypeDecl> {
            return e[lhs=nlhs, rhs=nrhs];            
        }
        else {
            let nbop = e[etype=$restype.valuetype, lhs=nlhs, rhs=nrhs];
            return ConstructorTypeDeclExpression{ e.sinfo, e.etype, e.etype@<NominalTypeSignature>, nbop, $restype.valuetype };
        }
    }

    recursive method processIfSimpleExpression(e: IfSimpleExpression, vmap: VarMapping): Expression {
        let ntexp = this.processExplicitBoolConvertAsNeeded(this.processExpression[recursive](e.texp, vmap));

        let nthen = this.processCoerceTypeAsNeeded(this.processExpression[recursive](e.thenexp, vmap), e.etype);
        let nelse = this.processCoerceTypeAsNeeded(this.processExpression[recursive](e.elseexp, vmap), e.etype);

        return e[texp=ntexp, thenexp=nthen, elseexp=nelse];
    }

    recursive method processIfTestExpression(e: IfTestExpression, vmap: VarMapping): Expression {
        let ntexp = this.processExpression[recursive](e.texp, vmap);

        let nthen = this.processCoerceTypeAsNeeded(this.processExpression[recursive](e.thenexp, vmap), e.etype);
        let nelse = this.processCoerceTypeAsNeeded(this.processExpression[recursive](e.elseexp, vmap), e.etype);

        return e[texp=ntexp, thenexp=nthen, elseexp=nelse];
    }

    recursive method processIfBinderExpression(e: IfBinderExpression, vmap: VarMapping): Expression {
        let ntexp = this.processExpression[recursive](e.texp, vmap);

        let nvmap = vmap.extendMapping(e.binder.srcname);
        let nname = vmap.resolveVariableAsNeeded(e.binder.srcname);
        let nbinder = BinderInfo{nname, e.binder.refineonfollow};

        let nthen = this.processCoerceTypeAsNeeded(this.processExpression[recursive](e.thenexp, nvmap), e.etype);
        let nelse = this.processCoerceTypeAsNeeded(this.processExpression[recursive](e.elseexp, nvmap), e.etype);

        return e[binder=nbinder, texp=ntexp, thenexp=nthen, elseexp=nelse];
    }

    recursive method processIfExpression(e: IfExpression, vmap: VarMapping): Expression {
        match(e)@ {
            IfSimpleExpression => { return this.processIfSimpleExpression[recursive]($e, vmap); }
            | IfTestExpression => { return this.processIfTestExpression[recursive]($e, vmap); }
            | IfBinderExpression => { return this.processIfBinderExpression[recursive]($e, vmap); }
        }
    }

    recursive method processExpression(e: Expression, vmap: VarMapping): Expression {
        match(e)@ {
            LiteralNoneExpression => { return e; }
            | LiteralSimpleExpression => { return e; }
            | LiteralCStringExpression => { return e; }
            | LiteralStringExpression => { return e; }
            | LiteralCRegexExpression => { return e; }
            | LiteralRegexExpression => { return e; }
            | LiteralTypeDeclValueExpression => { return e; }
            | AccessNamespaceConstantExpression => { return e; }
            | AccessStaticFieldExpression => { return e; }
            | AccessEnumExpression => { return e; }
            | AccessVariableExpression => { return this.processAccessVariableExpression($e, vmap); }
            | AccessCapturedVariableExpression => { return this.processAccessCapturedVariableExpression($e, vmap); }
            | ConstructorExpression => { return this.processConstructorExpression[recursive]($e, vmap); }
            | ConstructorLambdaExpression => { return this.processConstructorLambdaExpression[recursive]($e, vmap); }
            | LetExpression => { abort; }
            | LambdaInvokeExpression => { return this.processLambdaInvokeExpression[recursive]($e, vmap); }
            | CallNamespaceFunctionExpression => { return this.processCallNamespaceFunctionExpression[recursive]($e, vmap); }
            | CallTypeFunctionExpression => { return this.processCallTypeFunctionExpression[recursive]($e, vmap); }
            | CallTypeFunctionSpecialExpression => { abort; }
            | CallRefInvokeStaticResolveExpression => { abort; }
            | CallRefInvokeVirtualExpression => { abort; }
            | LogicActionAndExpression => { return this.processLogicActionAndExpression[recursive]($e, vmap); }
            | LogicActionOrExpression => { return this.processLogicActionOrExpression[recursive]($e, vmap); }
            | TypeDeclPrimitiveFieldAccessExpression => { return this.processTypeDeclPrimitiveFieldAccessExpression[recursive]($e, vmap); }
            | CoerceNarrowTypeExpression => { return this.processCoerceNarrowTypeExpression[recursive]($e, vmap); }
            | CoerceWidenTypeExpression => { return this.processCoerceWidenTypeExpression[recursive]($e, vmap); }
            | SafeConvertExpression => { return this.processSafeConvertExpression[recursive]($e, vmap); }
            | CreateDirectExpression => { return this.processCreateDirectExpression[recursive]($e, vmap); }
            | PostfixOp => { return this.processPostfixOp[recursive]($e, vmap); }
            | UnaryExpression => { return this.processUnaryExpression[recursive]($e, vmap); }
            | BinaryArithExpression => { return this.processBinaryArithExpression[recursive]($e, vmap); }
            | BinaryKeyEqExpression => { return this.processBinaryKeyEqExpression[recursive]($e, vmap); }
            | KeyCmpEqualExpression => { abort; }
            | KeyCmpLessExpression => { abort; }
            | BinaryNumericExpression => { return this.processBinaryNumericExpression[recursive]($e, vmap); }
            | BinLogicExpression => { return this.processBinLogicExpression[recursive]($e, vmap); }
            | MapEntryConstructorExpression => { abort; }
            | IfExpression => { return this.processIfExpression[recursive]($e, vmap); }
        }
    }

    recursive method processIfSimpleStatement(s: IfSimpleStatement, vmap: VarMapping): Statement {
        let ntexp = this.processExplicitBoolConvertAsNeeded(this.processExpression[recursive](s.texp, vmap));
        let ntb = this.processBlockStatement[recursive](s.trueBlock, vmap);

        return s[texp=ntexp, trueBlock=ntb];
    }

    recursive method processIfTestStatement(s: IfTestStatement, vmap: VarMapping): Statement {
        let ntexp = this.processExpression[recursive](s.texp, vmap);
        let ntb = this.processBlockStatement[recursive](s.trueBlock, vmap);

        return s[texp=ntexp, trueBlock=ntb];
    }

    recursive method processIfBinderStatement(s: IfBinderStatement, vmap: VarMapping): Statement {
        let ntexp = this.processExpression[recursive](s.texp, vmap);

        let nvmap = vmap.extendMapping(s.binder.srcname);
        let nname = vmap.resolveVariableAsNeeded(s.binder.srcname);
        let nbinder = BinderInfo{nname, s.binder.refineonfollow};

        let ntb = this.processBlockStatement[recursive](s.trueBlock, vmap);

        return s[binder=nbinder, texp=ntexp, trueBlock=ntb];
    }

    recursive method processIfStatement(s: IfStatement, vmap: VarMapping): Statement {
        match(s)@ {
            IfSimpleStatement => { return this.processIfSimpleStatement[recursive]($s, vmap); }
            | IfTestStatement => { return this.processIfTestStatement[recursive]($s, vmap); }
            | IfBinderStatement => { return this.processIfBinderStatement[recursive]($s, vmap); }
        }
    }

    recursive method processIfElseSimpleStatement(s: IfElseSimpleStatement, vmap: VarMapping): Statement {
        let ntexp = this.processExplicitBoolConvertAsNeeded(this.processExpression[recursive](s.texp, vmap));

        let ntb = this.processBlockStatement[recursive](s.trueBlock, vmap);
        let nfb = this.processBlockStatement[recursive](s.falseBlock, vmap);

        return s[texp=ntexp, trueBlock=ntb, falseBlock=nfb];
    }

    recursive method processIfElseTestStatement(s: IfElseTestStatement, vmap: VarMapping): Statement {
        let ntexp = this.processExpression[recursive](s.texp, vmap);

        let ntb = this.processBlockStatement[recursive](s.trueBlock, vmap);
        let nfb = this.processBlockStatement[recursive](s.falseBlock, vmap);

        return s[texp=ntexp, trueBlock=ntb, falseBlock=nfb];
    }

    recursive method processIfElseBinderStatement(s: IfElseBinderStatement, vmap: VarMapping): Statement {
        let ntexp = this.processExpression[recursive](s.texp, vmap);

        let nvmap = vmap.extendMapping(s.binder.srcname);
        let nname = vmap.resolveVariableAsNeeded(s.binder.srcname);
        let nbinder = BinderInfo{nname, s.binder.refineonfollow};

        let ntb = this.processBlockStatement[recursive](s.trueBlock, vmap);
        let nfb = this.processBlockStatement[recursive](s.falseBlock, vmap);

        return s[binder=nbinder, texp=ntexp, trueBlock=ntb, falseBlock=nfb];
    }

    recursive method processIfElseStatement(s: IfElseStatement, vmap: VarMapping): Statement {
        match(s)@ {
            IfElseSimpleStatement => { return this.processIfElseSimpleStatement[recursive]($s, vmap); }
            | IfElseTestStatement => { return this.processIfElseTestStatement[recursive]($s, vmap); }
            | IfElseBinderStatement => { return this.processIfElseBinderStatement[recursive]($s, vmap); }
        }
    }

    recursive method processIfElifElseStatement(s: IfElifElseStatement, vmap: VarMapping): Statement {
        let nifcond = this.processExplicitBoolConvertAsNeeded(this.processExpression[recursive](s.ifcond, vmap));

        let nifflow = this.processBlockStatement[recursive](s.ifflow, vmap);
        let ncondflow = s.condflow.map<(|Expression, BlockStatement|)>(fn(eb) => (|this.processExpression[recursive](eb.0, vmap), this.processBlockStatement[recursive](eb.1, vmap)|));
        let nelseflow = this.processBlockStatement[recursive](s.elseflow, vmap);

        return s[ifcond=nifcond, ifflow=nifflow, condflow=ncondflow, elseflow=nelseflow];
    }

    recursive method processMatchStatement(s: MatchStatement, vmap: VarMapping): Statement {
        let nsv = this.processExpression[recursive](s.sval, vmap);
        let nflow = s.matchflow.map[recursive]<(|TypeSignature, BlockStatement|)>(fn(mb) => {
            return (|mb.0, this.processBlockStatement[recursive](mb.1, vmap)|);
        });

        return s[sval=nsv, matchflow=nflow];
    }

    recursive method processSwitchStatement(s: SwitchStatement, vmap: VarMapping): Statement {
        let nsv = this.processExpression[recursive](s.sval, vmap);
        let nflow = s.switchflow.map[recursive]<(|Option<Expression>, BlockStatement|)>(fn(mb) => {
            return (|if(mb.0)none then none else some(this.processExpression[recursive](mb.0@some, vmap)), 
                this.processBlockStatement[recursive](mb.1, vmap)|);
        });

        return s[sval=nsv, switchflow=nflow];
    }

    recursive method processStatement(s: Statement, vmap: VarMapping): Statement {
        match(s)@ {
            EmptyStatement => {
                return s;
            }
            | VariableDeclarationStatement => {
                return s;
            }
            | VariableMultiDeclarationStatement => {
                return s;
            }
            | VariableInitializationStatement => {
                let nr = this.processExpression($s.exp, vmap);
                let nc = this.processCoerceTypeAsNeeded(nr, $s.vtype);
                
                return $s[exp=nc];
            }
            | VariableMultiInitializationExplicitStatement => {
                let nexps = this.processArgs($s.exps, vmap).mapIdx<Expression>(fn(ee, ii) => this.processCoerceTypeAsNeeded(ee, $s.decls.get(ii).1));
                return $s[exps=nexps];
            }
            | VariableMultiInitializationImplicitStatement => {
                return $s[exp=this.processExpression($s.exp, vmap)];
            }
            | VariableAssignmentStatement => {
                let nr = this.processExpression($s.exp, vmap);
                let nc = this.processCoerceTypeAsNeeded(nr, $s.vtype);

                return VariableAssignmentStatement{ $s.sinfo, $s.name, $s.vtype, nc };
            }
            | VariableMultiAssignmentExplicitStatement => {
                let nexps = this.processArgs($s.exps, vmap).mapIdx<Expression>(fn(ee, ii) => this.processCoerceTypeAsNeeded(ee, $s.vinfos.get(ii).1));
                return $s[exps=nexps];
            }
            | VariableMultiAssignmentImplicitStatement => {
                return $s[exp=this.processExpression($s.exp, vmap)];
            }
            | VariableRetypeStatement => { abort; }
            | ReturnVoidStatement => {
                return s;
            }
            | ReturnSingleStatement => {
                let nr = this.processExpression($s.value, vmap);
                let nc = this.processCoerceTypeAsNeeded(nr, $s.rtype);
                return $s[value = nc];
            }
            | ReturnMultiStatement => {
                let nexps = this.processArgs($s.exps, vmap).mapIdx<Expression>(fn(ee, ii) => this.processCoerceTypeAsNeeded(ee, $s.rtypes.get(ii)));
                return $s[exps=nexps];
            }
            | IfStatement => {
                return this.processIfStatement[recursive]($s, vmap);
            }
            | IfElseStatement => {
                return this.processIfElseStatement[recursive]($s, vmap);
            }
            | IfElifElseStatement => {
                return this.processIfElifElseStatement[recursive]($s, vmap);
            }
            | SwitchStatement => { 
                return this.processSwitchStatement[recursive]($s, vmap); 
            }
            | MatchStatement => {
                return this.processMatchStatement[recursive]($s, vmap);
            }
            | AbortStatement => {
                return s;
            }
            | AssertStatement => {
                let nr = this.processExpression($s.cond, vmap);
                let nc = this.processExplicitBoolConvertAsNeeded(nr);
                return $s[cond = nc];
            }
            | ValidateStatement => { 
                abort;
            }
            | DebugStatement => { 
                abort; 
            }
            | UpdateDirectStatement => { 
                abort; 
            }
            | UpdateIndirectStatement => { 
                abort; 
            }
            | BlockStatement => {
                return this.processBlockStatement[recursive]($s, vmap);
            }
            | BinderBlockStatement => {
                return this.processBinderBlockStatement[recursive]($s, vmap);
            }
        }
    }

    recursive method processBlockStatement(s: BlockStatement, vmap: VarMapping): BlockStatement {
        let nstmts = s.statements.map[recursive]<Statement>(recursive fn(stmt) => this.processStatement[recursive](stmt, vmap));

        return s[statements=nstmts];
    }

    recursive method processBinderBlockStatement(s: BinderBlockStatement, vmap: VarMapping): BinderBlockStatement {
        let nbexp = this.processExpression[recursive](s.bexp, vmap);
        let nstmts = s.statements.map[recursive]<Statement>(recursive fn(stmt) => this.processStatement[recursive](stmt, vmap));

        return s[bexp=nbexp, statements=nstmts];
    }

    method processInvokeParameter(param: InvokeParameterDecl): InvokeParameterDecl {
        if(param.defaultval)@none {
            return param;
        }
        else {
            let dv = this.processExpression(param.defaultval@some, VarMapping::createEmpty());
            let dvc = this.processCoerceTypeAsNeeded(dv, param.ptype);
            
            return param[defaultval=some(dvc)];
        }
    }

    method processInvariant(iiv: InvariantDecl): InvariantDecl {
        let ee = this.processExpression(iiv.exp, VarMapping::createEmpty());
        return iiv[exp=ee];
    }

    method processValidate(vv: ValidateDecl): ValidateDecl {
        let ee = this.processExpression(vv.exp, VarMapping::createEmpty());
        return vv[exp=ee];
    }

    method processPrecondition(precond: PreConditionDecl): PreConditionDecl {
        let ee = this.processExpression(precond.exp, VarMapping::createEmpty());
        return precond[exp=ee];
    }

    method processPostcondition(postcond: PostConditionDecl): PostConditionDecl {
        let ee = this.processExpression(postcond.exp, VarMapping::createEmpty());
        return postcond[exp=ee];
    }

    recursive method processBodyStatementList(stmts: List<Statement>, vmap: VarMapping): List<Statement> {
        return stmts.map<Statement>(fn(stmt) => this.processStatement[recursive](stmt, vmap));
    }

    method processBodyImpl(body: BodyImplementation, vmap: VarMapping): BodyImplementation {
        match(body)@ {
            ExpressionBodyImplementation => { return ExpressionBodyImplementation{ this.processExpression($body.exp, vmap) }; }
            | StandardBodyImplementation => { return StandardBodyImplementation{ this.processBodyStatementList($body.statements, vmap) }; }
            | _ => { return body; }
        }
    }

    method processNamespaceConstDecl(nsconst: NamespaceConstDecl): NamespaceConstDecl {
        let evalue = this.processExpression(nsconst.value, VarMapping::createEmpty());
        return nsconst[value=evalue];
    }

    method processConstMemberDecl(typeconst: ConstMemberDecl): ConstMemberDecl {
        let evalue = this.processExpression(typeconst.value, VarMapping::createEmpty());
        let nevalue = this.processCoerceTypeAsNeeded(evalue, typeconst.declaredType);
        return typeconst[value=nevalue];
    }

    method processMemberFieldDecl(fd: MemberFieldDecl): MemberFieldDecl {
        if($dv=fd.defaultValue)@none {
            return fd;
        }
        else {
            let dvalue = this.processExpression($dv, VarMapping::createEmpty());
            return fd[defaultValue=some(dvalue)];
        }
    }

    method processNamespaceFunctionDecl(nsfunc: NamespaceFunctionDecl): NamespaceFunctionDecl {
        return NamespaceFunctionDecl{
            file = nsfunc.file,
            sinfo = nsfunc.sinfo,
            fullns = nsfunc.fullns,
            declaredInNS = nsfunc.declaredInNS,

            attributes = nsfunc.attributes,
            name = nsfunc.name,

            ikey = nsfunc.ikey,
            irecursive = nsfunc.irecursive,
            params = nsfunc.params.map<InvokeParameterDecl>(fn(param) => this.processInvokeParameter(param)),
            resultType = nsfunc.resultType,

            body = this.processBodyImpl(nsfunc.body, VarMapping::createEmpty()),

            preconditions = nsfunc.preconditions.map<PreConditionDecl>(fn(precond) => this.processPrecondition(precond)),
            postconditions = nsfunc.postconditions.map<PostConditionDecl>(fn(postcond) => this.processPostcondition(postcond)),
            fkind = nsfunc.fkind
        };
    }

    method processTypeFunctionDecl(typefunc: TypeFunctionDecl): TypeFunctionDecl {
        return TypeFunctionDecl{
            file = typefunc.file,
            sinfo = typefunc.sinfo,
            fullns = typefunc.fullns,
            declaredInNS = typefunc.declaredInNS,

            attributes = typefunc.attributes,
            name = typefunc.name,

            ikey = typefunc.ikey,
            irecursive = typefunc.irecursive,
            params = typefunc.params.map<InvokeParameterDecl>(fn(param) => this.processInvokeParameter(param)),
            resultType = typefunc.resultType,

            body = this.processBodyImpl(typefunc.body, VarMapping::createEmpty()),

            preconditions = typefunc.preconditions.map<PreConditionDecl>(fn(precond) => this.processPrecondition(precond)),
            postconditions = typefunc.postconditions.map<PostConditionDecl>(fn(postcond) => this.processPostcondition(postcond))
        };
    }

    method processMethodDeclAbstract(absmethod: MethodDeclAbstract): MethodDeclAbstract {
        abort;
    }

    method processMethodDeclVirtual(virtmethod: MethodDeclVirtual): MethodDeclVirtual {
        abort;
    }

    method processMethodDeclOverride(overmethod: MethodDeclOverride): MethodDeclOverride {
        abort;
    }

    method processMethodDeclStatic(staticmethod: MethodDeclStatic): MethodDeclStatic {
        return MethodDeclStatic{
            file = staticmethod.file,
            sinfo = staticmethod.sinfo,
            fullns = staticmethod.fullns,
            declaredInNS = staticmethod.declaredInNS,

            attributes = staticmethod.attributes,
            name = staticmethod.name,

            ikey = staticmethod.ikey,
            irecursive = staticmethod.irecursive,
            params = staticmethod.params.map<InvokeParameterDecl>(fn(param) => this.processInvokeParameter(param)),
            resultType = staticmethod.resultType,

            body = this.processBodyImpl(staticmethod.body, VarMapping::createEmpty()),

            preconditions = staticmethod.preconditions.map<PreConditionDecl>(fn(precond) => this.processPrecondition(precond)),
            postconditions = staticmethod.postconditions.map<PostConditionDecl>(fn(postcond) => this.processPostcondition(postcond)),

            isThisRef = staticmethod.isThisRef,
            ofrcvrtype = staticmethod.ofrcvrtype
        };
    }

    method processTypedeclTypeDecl(typedecl: TypedeclTypeDecl): TypedeclTypeDecl {
        return TypedeclTypeDecl{
            file=typedecl.file,
            sinfo=typedecl.sinfo,
            fullns=typedecl.fullns,
            declaredInNS=typedecl.declaredInNS,

            tkey=typedecl.tkey,
            name=typedecl.name,

            invariants=typedecl.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=typedecl.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=typedecl.absmethods,
            virtmethods=typedecl.virtmethods,
            overmethods=typedecl.overmethods,
            staticmethods=typedecl.staticmethods,

            saturatedProvides=typedecl.saturatedProvides,
            saturatedBFieldInfo=typedecl.saturatedBFieldInfo,

            allInvariants=typedecl.allInvariants,
            allValidates=typedecl.allValidates,

            valuetype=typedecl.valuetype,
        };
    }

    method processTypedeclStringOfTypeDecl(typedecl: TypedeclStringOfTypeDecl): TypedeclStringOfTypeDecl {
        return TypedeclStringOfTypeDecl{
            file=typedecl.file,
            sinfo=typedecl.sinfo,
            fullns=typedecl.fullns,
            declaredInNS=typedecl.declaredInNS,

            tkey=typedecl.tkey,
            name=typedecl.name,

            invariants=typedecl.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=typedecl.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=typedecl.absmethods,
            virtmethods=typedecl.virtmethods,
            overmethods=typedecl.overmethods,
            staticmethods=typedecl.staticmethods,

            saturatedProvides=typedecl.saturatedProvides,
            saturatedBFieldInfo=typedecl.saturatedBFieldInfo,

            allInvariants=typedecl.allInvariants,
            allValidates=typedecl.allValidates,

            valuetype=typedecl.valuetype,
            ofcheck=typedecl.ofcheck
        };
    }

    method processEntityTypeDecl(etype: EntityTypeDecl): EntityTypeDecl {
        return EntityTypeDecl{
            file=etype.file,
            sinfo=etype.sinfo,
            fullns=etype.fullns,
            declaredInNS=etype.declaredInNS,
            
            tkey=etype.tkey,
            name=etype.name,

            invariants=etype.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=etype.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=etype.absmethods,
            virtmethods=etype.virtmethods,
            overmethods=etype.overmethods,
            staticmethods=etype.staticmethods,

            saturatedProvides=etype.saturatedProvides,
            saturatedBFieldInfo=etype.saturatedBFieldInfo,

            allInvariants=etype.allInvariants,
            allValidates=etype.allValidates,

            fields=etype.fields.map<MemberFieldDecl>(fn(fd) => this.processMemberFieldDecl(fd))
        };
    }

    method processDatatypeMemberEntityTypeDecl(dmtype: DatatypeMemberEntityTypeDecl): DatatypeMemberEntityTypeDecl {
        return DatatypeMemberEntityTypeDecl{
            file=dmtype.file,
            sinfo=dmtype.sinfo,
            fullns = dmtype.fullns,
            declaredInNS=dmtype.declaredInNS,
            
            tkey=dmtype.tkey,
            name=dmtype.name,

            invariants=dmtype.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=dmtype.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=dmtype.absmethods,
            virtmethods=dmtype.virtmethods,
            overmethods=dmtype.overmethods,
            staticmethods=dmtype.staticmethods,

            saturatedProvides=dmtype.saturatedProvides,
            saturatedBFieldInfo=dmtype.saturatedBFieldInfo,

            allInvariants=dmtype.allInvariants,
            allValidates=dmtype.allValidates,

            fields=dmtype.fields.map<MemberFieldDecl>(fn(fd) => this.processMemberFieldDecl(fd)),
            parentTypeDecl=dmtype.parentTypeDecl
        };
    }

    method processOptionTypeDecl(oconcept: OptionTypeDecl): OptionTypeDecl {
        return OptionTypeDecl{
            file=oconcept.file,
            sinfo=oconcept.sinfo,
            fullns = oconcept.fullns,
            declaredInNS=oconcept.declaredInNS,

            tkey=oconcept.tkey,
            name=oconcept.name,

            invariants=oconcept.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=oconcept.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=oconcept.absmethods,
            virtmethods=oconcept.virtmethods,
            overmethods=oconcept.overmethods,
            staticmethods=oconcept.staticmethods,

            saturatedProvides=oconcept.saturatedProvides,
            saturatedBFieldInfo=oconcept.saturatedBFieldInfo,

            allInvariants=oconcept.allInvariants,
            allValidates=oconcept.allValidates,

            subtypes=oconcept.subtypes,

            oftype=oconcept.oftype,
            someType=oconcept.someType
        };
    }

    method processPrimitiveConceptTypeDecl(pconcept: PrimitiveConceptTypeDecl): PrimitiveConceptTypeDecl {
        match(pconcept)@ {
            OptionTypeDecl => { return this.processOptionTypeDecl($pconcept); }
            | ResultTypeDecl => { abort; }
            | APIResultTypeDecl => { abort; }
        }
    }

    method processConceptTypeDecl(cconcept: ConceptTypeDecl): ConceptTypeDecl {
        return ConceptTypeDecl{
            file=cconcept.file,
            sinfo=cconcept.sinfo,
            fullns = cconcept.fullns,
            declaredInNS=cconcept.declaredInNS,

            tkey=cconcept.tkey,
            name=cconcept.name,

            invariants=cconcept.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=cconcept.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=cconcept.absmethods,
            virtmethods=cconcept.virtmethods,
            overmethods=cconcept.overmethods,
            staticmethods=cconcept.staticmethods,

            saturatedProvides=cconcept.saturatedProvides,
            saturatedBFieldInfo=cconcept.saturatedBFieldInfo,

            allInvariants=cconcept.allInvariants,
            allValidates=cconcept.allValidates,

            subtypes=cconcept.subtypes,
            fields=cconcept.fields.map<MemberFieldDecl>(fn(fd) => this.processMemberFieldDecl(fd))
        };
    }

    method processDatatypeTypeDecl(ddatatype: DatatypeTypeDecl): DatatypeTypeDecl {
        return DatatypeTypeDecl {
            file=ddatatype.file,
            sinfo=ddatatype.sinfo,
            fullns = ddatatype.fullns,
            declaredInNS=ddatatype.declaredInNS,
            
            tkey=ddatatype.tkey,
            name=ddatatype.name,

            invariants=ddatatype.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=ddatatype.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=ddatatype.absmethods,
            virtmethods=ddatatype.virtmethods,
            overmethods=ddatatype.overmethods,
            staticmethods=ddatatype.staticmethods,

            saturatedProvides=ddatatype.saturatedProvides,
            saturatedBFieldInfo=ddatatype.saturatedBFieldInfo,

            allInvariants=ddatatype.allInvariants,
            allValidates=ddatatype.allValidates,

            subtypes=ddatatype.subtypes,

            fields=ddatatype.fields.map<MemberFieldDecl>(fn(fd) => this.processMemberFieldDecl(fd)),
            associatedMemberEntityDecls=ddatatype.associatedMemberEntityDecls
        };
    }

    function process(assembly: Assembly): Assembly {
        let explicitifier = ExplicitifyTransform{ assembly };

        return Assembly{
            nsconsts = assembly.nsconsts.map<NamespaceConstDecl>(fn(nsconst) => explicitifier.processNamespaceConstDecl(nsconst)),
            typeconsts = assembly.typeconsts.map<ConstMemberDecl>(fn(typeconst) => explicitifier.processConstMemberDecl(typeconst)),

            nsfuncs = assembly.nsfuncs.map<NamespaceFunctionDecl>(fn(ikey, nsfunc) => explicitifier.processNamespaceFunctionDecl(nsfunc)),
            typefuncs = assembly.typefuncs.map<TypeFunctionDecl>(fn(ikey, typefunc) => explicitifier.processTypeFunctionDecl(typefunc)),

            absmethods = assembly.absmethods.map<MethodDeclAbstract>(fn(ikey, absmethod) => explicitifier.processMethodDeclAbstract(absmethod)),
            virtmethods = assembly.virtmethods.map<MethodDeclVirtual>(fn(ikey, virtmethod) => explicitifier.processMethodDeclVirtual(virtmethod)),
            overmethods = assembly.overmethods.map<MethodDeclOverride>(fn(ikey, overmethod) => explicitifier.processMethodDeclOverride(overmethod)),
            staticmethods = assembly.staticmethods.map<MethodDeclStatic>(fn(ikey, staticmethod) => explicitifier.processMethodDeclStatic(staticmethod)),

            enums = assembly.enums,
            typedecls = assembly.typedecls.map<TypedeclTypeDecl>(fn(ikey, typedecl) => explicitifier.processTypedeclTypeDecl(typedecl)),
            stringoftypedecls = assembly.stringoftypedecls.map<TypedeclStringOfTypeDecl>(fn(ikey, typedecl) => explicitifier.processTypedeclStringOfTypeDecl(typedecl)),

            primtives = assembly.primtives,
            constructables = assembly.constructables,
            collections = assembly.collections,

            entities = assembly.entities.map<EntityTypeDecl>(fn(ikey, etype) => explicitifier.processEntityTypeDecl(etype)),
            datamembers = assembly.datamembers.map<DatatypeMemberEntityTypeDecl>(fn(ikey, dmtype) => explicitifier.processDatatypeMemberEntityTypeDecl(dmtype)),

            pconcepts = assembly.pconcepts.map<PrimitiveConceptTypeDecl>(fn(ikey, pconcept) => explicitifier.processPrimitiveConceptTypeDecl(pconcept)),
            concepts = assembly.concepts.map<ConceptTypeDecl>(fn(ikey, cconcept) => explicitifier.processConceptTypeDecl(cconcept)),

            datatypes = assembly.datatypes.map<DatatypeTypeDecl>(fn(ikey, ddatatype) => explicitifier.processDatatypeTypeDecl(ddatatype)),

            allfuncs = assembly.allfuncs,
            allmethods = assembly.allmethods,
            allvmethods = assembly.allvmethods,

            allconcretetypes = assembly.allconcretetypes,
            allabstracttypes = assembly.allabstracttypes,
            typetopo = assembly.typetopo
        };
    }
}
