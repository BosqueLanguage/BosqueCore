namespace BSQAssembly;

entity VarMapping {
   field seenmap: Map<VarIdentifier, VarIdentifier>; %%This is the map from the original name to the next var name to use
   field remap: List<Map<VarIdentifier, VarIdentifier>>; %%This is the map from the original name to the new name if required

   function createEmpty(): VarMapping {
      return VarMapping{
         Map<VarIdentifier, VarIdentifier>{},
         List<Map<VarIdentifier, VarIdentifier>>{}
      };
   }

   method pushScope(): VarMapping {
      return VarMapping{
         this.seenmap,
         this.remap.pushBack(Map<VarIdentifier, VarIdentifier>{})
      };
   }

   method mergeSeenMapInto(seenmap: Map<VarIdentifier, VarIdentifier>): VarMapping {
      return VarMapping{
         seenmap,
         this.remap
      };
   }

   method extendMapping(name: VarIdentifier): VarMapping {
      var nseen: Map<VarIdentifier, VarIdentifier>;
      var nrmap: List<Map<VarIdentifier, VarIdentifier>>;

      if(!this.seenmap.has(name)) {
         nseen = this.seenmap.insert(name, VarIdentifier::from(name.value.append('_$frsh')));
         nrmap = this.remap;
      }
      else {
         let nname = this.seenmap.get(name);
         nseen = this.seenmap.set(name, VarIdentifier::from(nname.value.append('$')));
         nrmap = this.remap.setBack(this.remap.back().insert(name, nname));
      }

      return VarMapping{
         nseen,
         nrmap
      };
   }

   method resolveVariableAsNeeded(name: VarIdentifier): VarIdentifier {
      let mmp = this.remap.findLast(pred(m) => m.has(name));
      if(mmp)@none {
         return name;
      }
      else {
         return $mmp.get(name);
      }
   }

   method remapDeclarationAsNeeded(name: VarIdentifier): VarMapping, VarIdentifier {
      let nmapping = this.extendMapping(name);
      let nname = nmapping.resolveVariableAsNeeded(name);
      
      return nmapping, nname;
   }
}

%*
 * Rewrite the IR to make all type conversions and accesses explicit -- ensure all variable names are unique (no shadowing or duplicates)
 *%
entity ExplicitifyTransform {

   function processExpression(e: Expression, vmap: VarMapping): Expression, VarMapping {
      abort;
   }

   function processStatement(s: Statement, vmap: VarMapping): Statement, VarMapping {
      match(s)@ {
         ReturnVoidStatement => {
            return s, vmap;
         }
         | ReturnSingleStatement => {
            let nr, nm = this.processExpression($s.value, vmap);
            abort; %% TODO -- here is where we put an explicit cast if needed
            return $s[value = nr], nm;
         }
         | ReturnMultiStatement => {
            abort; %% NOT IMPLEMENTED
         }
         | _ => { 
            abort;
         }
      }
   }

   function processInvokeParameter(param: InvokeParameterDecl): InvokeParameterDecl {
      abort;
   }

   function processPrecondition(precond: PreConditionDecl): PreConditionDecl {
      abort;
   }

   function processPostcondition(postcond: PostConditionDecl): PostConditionDecl {
      abort;
   }

   function processBodyStatementList(stmts: List<Statement>, vmap: VarMapping): List<Statement>, VarMapping {
        reuturn stmts.transduce<VarMapping, Statement>(vmap, fn(vmap, stmt) => ExplicitifyTransform::processStatement(stmt, vmap));
    }

   function processBodyImpl(body: BodyImplementation): BodyImplementation {
      match(body)@ {
         ExpressionBodyImplementation => { return ExpressionBodyImplementation{ ExplicitifyTransform::processExpression($body.exp, VarMapping::createEmpty()).0 }; }
         | StandardBodyImplementation => { return StandardBodyImplementation{ ExplicitifyTransform::processBodyStatementList($body.statements, VarMapping::createEmpty()).0 }; }
         | _ => { return body; }
      }
   }

   function processNamespaceConstDecl(nsconst: NamespaceConstDecl): NamespaceConstDecl {
      abort;
   }

   function processConstMemberDecl(typeconst: ConstMemberDecl): ConstMemberDecl {
      abort;
   }

   function processNamespaceFunctionDecl(nsfunc: NamespaceFunctionDecl): NamespaceFunctionDecl {
      return NamespaceFunctionDecl{
         file = nsfunc.file,
         sinfo = nsfunc.sinfo,
         declaredInNS = nsfunc.declaredInNS,

         attributes = nsfunc.attributes,
         name = nsfunc.name,

         ikey = nsfunc.ikey,
         irecursive = nsfunc.irecursive,
         params = nsfunc.params.map<InvokeParameterDecl>(fn(param) => ExplicitifyTransform::processInvokeParameter(param)),
         resultType = nsfunc.resultType,

         body = ExplicitifyTransform::processBodyImpl(nsfunc.body),

         preconditions = nsfunc.preconditions.map<PreConditionDecl>(fn(precond) => ExplicitifyTransform::processPrecondition(precond)),
         postconditions = nsfunc.postconditions.map<PostConditionDecl>(fn(postcond) => ExplicitifyTransform::processPostcondition(postcond)),
         fkind = nsfunc.fkind
      };
   }

   function processTypeFunctionDecl(typefunc: TypeFunctionDecl): TypeFunctionDecl {
      abort;
   }

   function processMethodDeclAbstract(absmethod: MethodDeclAbstract): MethodDeclAbstract {
      abort;
   }

   function processMethodDeclVirtual(virtmethod: MethodDeclVirtual): MethodDeclVirtual {
      abort;
   }

   function processMethodDeclOverride(overmethod: MethodDeclOverride): MethodDeclOverride {
      abort;
   }

   function processMethodDeclStatic(staticmethod: MethodDeclStatic): MethodDeclStatic {
      abort;
   }

   function processEnumTypeDecl(enumdecl: EnumTypeDecl): EnumTypeDecl {
      abort;
   }

   function processTypedeclTypeDecl(typedecl: TypedeclTypeDecl): TypedeclTypeDecl {
      abort;
   }

   function processPrimitiveEntityTypeDecl(primtype: PrimitiveEntityTypeDecl): PrimitiveEntityTypeDecl {
      abort;
   }

   function processConstructableTypeDecl(ctype: ConstructableTypeDecl): ConstructableTypeDecl {
      abort;
   }

   function processCollectionTypeDecl(ctype: CollectionTypeDecl): CollectionTypeDecl {
      abort;
   }

   function processEntityTypeDecl(etype: EntityTypeDecl): EntityTypeDecl {
      abort;
   }

   function processDatatypeMemberEntityTypeDecl(dmtype: DatatypeMemberEntityTypeDecl): DatatypeMemberEntityTypeDecl {
      abort;
   }

   function processPrimitiveConceptTypeDecl(pconcept: PrimitiveConceptTypeDecl): PrimitiveConceptTypeDecl {
      abort;
   }

   function processConceptTypeDecl(cconcept: ConceptTypeDecl): ConceptTypeDecl {
      abort;
   }

   function processDatatypeTypeDecl(ddatatype: DatatypeTypeDecl): DatatypeTypeDecl {
      abort;
   }

   function process(assembly: Assembly): Assembly {
      return Assembly{
         nsconsts = assembly.nsconsts.map<NamespaceConstDecl>(fn(nsconst) => ExplicitifyTransform::processNamespaceConstDecl(nsconst)),
         typeconsts = assembly.typeconsts.map<ConstMemberDecl>(fn(typeconst) => ExplicitifyTransform::processConstMemberDecl(typeconst)),

         nsfuncs = assembly.nsfuncs.map<NamespaceFunctionDecl>(fn(ikey, nsfunc) => ExplicitifyTransform::processNamespaceFunctionDecl(nsfunc)),
         typefuncs = assembly.typefuncs.map<TypeFunctionDecl>(fn(ikey, typefunc) => ExplicitifyTransform::processTypeFunctionDecl(typefunc)),

         absmethods = assembly.absmethods.map<MethodDeclAbstract>(fn(ikey, absmethod) => ExplicitifyTransform::processMethodDeclAbstract(absmethod)),
         virtmethods = assembly.virtmethods.map<MethodDeclVirtual>(fn(ikey, virtmethod) => ExplicitifyTransform::processMethodDeclVirtual(virtmethod)),
         overmethods = assembly.overmethods.map<MethodDeclOverride>(fn(ikey, overmethod) => ExplicitifyTransform::processMethodDeclOverride(overmethod)),
         staticmethods = assembly.staticmethods.map<MethodDeclStatic>(fn(ikey, staticmethod) => ExplicitifyTransform::processMethodDeclStatic(staticmethod)),

         enums = assembly.enums.map<EnumTypeDecl>(fn(ikey, enumdecl) => ExplicitifyTransform::processEnumTypeDecl(enumdecl)),
         typedecls = assembly.typedecls.map<TypedeclTypeDecl>(fn(ikey, typedecl) => ExplicitifyTransform::processTypedeclTypeDecl(typedecl)),

         primtives = assembly.primtives.map<PrimitiveEntityTypeDecl>(fn(ikey, primtype) => ExplicitifyTransform::processPrimitiveEntityTypeDecl(primtype)),
         constructables = assembly.constructables.map<ConstructableTypeDecl>(fn(ikey, ctype) => ExplicitifyTransform::processConstructableTypeDecl(ctype)),
         collections = assembly.collections.map<CollectionTypeDecl>(fn(ikey, ctype) => ExplicitifyTransform::processCollectionTypeDecl(ctype)),

         entities = assembly.entities.map<EntityTypeDecl>(fn(ikey, etype) => ExplicitifyTransform::processEntityTypeDecl(etype)),
         datamembers = assembly.datamembers.map<DatatypeMemberEntityTypeDecl>(fn(ikey, dmtype) => ExplicitifyTransform::processDatatypeMemberEntityTypeDecl(dmtype)),

         pconcepts = assembly.pconcepts.map<PrimitiveConceptTypeDecl>(fn(ikey, pconcept) => ExplicitifyTransform::processPrimitiveConceptTypeDecl(pconcept)),
         concepts = assembly.concepts.map<ConceptTypeDecl>(fn(ikey, cconcept) => ExplicitifyTransform::processConceptTypeDecl(cconcept)),

         datatypes = assembly.datatypes.map<DatatypeTypeDecl>(fn(ikey, ddatatype) => ExplicitifyTransform::processDatatypeTypeDecl(ddatatype)),

         allfuncs = assembly.allfuncs,
         allmethods = assembly.allmethods,
         allvmethods = assembly.allvmethods,

         allconcretetypes = assembly.allconcretetypes,
         allabstracttypes = assembly.allabstracttypes
      };
   }
}
