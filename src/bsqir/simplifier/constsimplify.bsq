namespace BSQAssembly;

%*
 * Rewrite the IR to do constant folding, constant propagation, flow/test simplification, and dead code elimination
 *%
entity ConstantSimplification {
    field assembly: Assembly;

    const trueExp: Expression = LiteralSimpleExpression{ SourceInfo{0n, 0n, 0n, 0n}, NominalTypeSignature{SourceInfo{0n, 0n, 0n, 0n}, 'Bool'<TypeKey>}, 'true' };
    const falseExp: Expression = LiteralSimpleExpression{ SourceInfo{0n, 0n, 0n, 0n}, NominalTypeSignature{SourceInfo{0n, 0n, 0n, 0n}, 'Bool'<TypeKey>}, 'false' };

    function isTerminalStatement(stmt: Statement): Bool {
        return stmt?<ReturnVoidStatement> || stmt?<ReturnSingleStatement> || stmt?<ReturnMultiStatement> || stmt?<AbortStatement>;
    }

    method processITestTypeAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestType): PostfixOperation {
        if(itest.isnot) {
            if(this.assembly.isSubtypeOf(srctype, itest.ttype)) {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
            elif(this.assembly.areDisjoint(itest.ttype, srctype)) {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
            else {
                return PostfixIsTest { sinfo, srctype, itest };
            }
        }
        else {
            if(this.assembly.isSubtypeOf(srctype, itest.ttype)) {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
            elif(this.assembly.areDisjoint(itest.ttype, srctype)) {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
            else {
                return PostfixIsTest { sinfo, srctype, itest };
            }
        }
    }

    method processITestNoneAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestNone): PostfixOperation {
        if(srctype.tkeystr === 'None'<TypeKey>) {
            if(itest.isnot) {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
            else {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
        }
        elif(srctype.tkeystr === 'Some'<TypeKey>) {
            if(itest.isnot) {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
            else {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
        }
        else {
            return PostfixIsTest { sinfo, srctype, itest };
        }
    }

    method processITestSomeAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestSome): PostfixOperation {
        if(srctype.tkeystr === 'None'<TypeKey>) {
            if(itest.isnot) {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
            else {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
        }
        elif(srctype.tkeystr === 'Some'<TypeKey>) {
            if(itest.isnot) {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
            else {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
        }
        else {
            return PostfixIsTest { sinfo, srctype, itest };
        }
    }

    method processITestOkAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestOk): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestFailAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestFail): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITest): PostfixOperation {
        match(itest)@ {
            | ITestType => { return this.processITestTypeAsTest(sinfo, srctype, $itest); }
            | ITestNone => { return this.processITestNoneAsTest(sinfo, srctype, $itest); }
            | ITestSome => { return this.processITestSomeAsTest(sinfo, srctype, $itest); }
            | ITestOk => { return this.processITestOkAsTest(sinfo, srctype, $itest); }
            | ITestFail => { return this.processITestFailAsTest(sinfo, srctype, $itest); }
        }
    }

    method processITestTypeAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestType): PostfixOperation {
        if(itest.isnot) {
            if(this.assembly.areTypesSame(srctype, itest.ttype)) {
                return PostfixAbort{ sinfo, srctype, none };
            }
            elif(this.assembly.isSubtypeOf(srctype, itest.ttype)) {
                return PostfixAbort{ sinfo, srctype, none };
            }
            elif(this.assembly.areDisjoint(itest.ttype, srctype)) {
                return PostfixWidenConvert{ sinfo, srctype, itest.ttype };
            }
            else {
                return PostfixAsConvert{ sinfo, srctype, itest };
            }
        }
        else {
            if(this.assembly.areTypesSame(srctype, itest.ttype)) {
                return PostfixNop{ sinfo, srctype };
            }
            elif(this.assembly.isSubtypeOf(srctype, itest.ttype)) {
                return PostfixWidenConvert{ sinfo, srctype, itest.ttype };
            }
            elif(this.assembly.areDisjoint(itest.ttype, srctype)) {
                return PostfixAbort{ sinfo, srctype, none };
            }
            else {
                return PostfixAsConvert{ sinfo, srctype, itest };
            }
        }
    }

    method processITestNoneAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestNone): PostfixOperation {
        if(srctype.tkeystr === 'None'<TypeKey>) {
            if(itest.isnot) {
                return PostfixAbort{ sinfo, srctype, none };
            }
            else {
                return PostfixNop{ sinfo, srctype };
            }
        }
        elif(srctype.tkeystr === 'Some'<TypeKey>) {
            if(itest.isnot) {
                return PostfixAccessSomeValue{ sinfo, srctype };
            }
            else {
                return PostfixAbort{ sinfo, srctype, none };
            }
        }
        else {
            return PostfixAsConvert { sinfo, srctype, itest };
        }
    }

    method processITestSomeAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestSome): PostfixOperation {
        if(srctype.tkeystr === 'None'<TypeKey>) {
            if(itest.isnot) {
                return PostfixNop{ sinfo, srctype};
            }
            else {
                return PostfixAbort{ sinfo, srctype, none };
            }
        }
        elif(srctype.tkeystr === 'Some'<TypeKey>) {
            if(itest.isnot) {
                return PostfixAbort{ sinfo, srctype, none };
            }
            else {
                return PostfixAccessSomeValue{ sinfo, srctype };
            }
        }
        else {
            return PostfixAsConvert { sinfo, srctype, itest };
        }
    }

    method processITestOkAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestOk): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestFailAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestFail): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITest): PostfixOperation {
        match(itest)@ {
            | ITestType => { return this.processITestTypeAsConvert(sinfo, srctype, $itest); }
            | ITestNone => { return this.processITestNoneAsConvert(sinfo, srctype, $itest); }
            | ITestSome => { return this.processITestSomeAsConvert(sinfo, srctype, $itest); }
            | ITestOk => { return this.processITestOkAsConvert(sinfo, srctype, $itest); }
            | ITestFail => { return this.processITestFailAsConvert(sinfo, srctype, $itest); }
        }
    }

    recursive method processArgs(args: List<Expression>): List<Expression> {
        return args.map[recursive]<Expression>(recursive fn(arg) => this.processExpression[recursive](arg));
    }

    recursive method processUnaryArg(arg: Expression): Expression {
        return this.processExpression[recursive](arg);
    }

    recursive method processBinaryArgs(lhs: Expression, rhs: Expression): Expression, Expression {
        return this.processExpression[recursive](lhs), this.processExpression[recursive](rhs);
    }

    recursive method processStdConstructorArgs(ainfo: ConstructorArgumentInfo): ConstructorArgumentInfo {
        let nresolved = ainfo.resolvedargs@some.map[recursive]<Expression>(recursive fn(arg) => this.processExpression[recursive](arg));
        return ainfo[resolvedargs=some(nresolved)];
    }

    recursive method processInvokeArgumentInfoStatic(arginfo: InvokeArgumentInfo): InvokeArgumentInfo {
        let nresolved = arginfo.resolvedargs@some.map[recursive]<Expression>(recursive fn(arg) => this.processExpression[recursive](arg));
        return arginfo[resolvedargs=some(nresolved)];
    }

    recursive method processLambdaInvokeArgumentInfo(arginfo: LambdaInvokeArgumentInfo): LambdaInvokeArgumentInfo {
        let nresolved = arginfo.resolvedargs@some.map[recursive]<Expression>(recursive fn(arg) => this.processExpression[recursive](arg));
        return arginfo[resolvedargs=some(nresolved)];
    }

    recursive method processArgumentListSimple(argl: List<ArgumentValue>): List<ArgumentValue> {
        let nargs = argl.map[recursive]<ArgumentValue>(recursive fn(arg) => {
            let nexp = this.processExpression[recursive](arg.exp);
            return arg[exp=nexp];
        });

        return nargs;
    }

    method processAccessNamespaceConstantExpression(e: AccessNamespaceConstantExpression): Expression {
        let sexp = this.assembly.tryResolveExpAsLiteralExpression(e);
        if(sexp)@none {
            return e;
        }
        else {
            return $sexp;
        }
    }

    method processAccessStaticFieldExpression(e: AccessStaticFieldExpression): Expression {
        let sexp = this.assembly.tryResolveExpAsLiteralExpression(e);
        if(sexp)@none {
            return e;
        }
        else {
            return $sexp;
        }
    }

    recursive method processConstructorPrimarySpecialSomeExpression(e: ConstructorPrimarySpecialSomeExpression): Expression {
        let nval = this.processUnaryArg[recursive](e.value);
        return e[value=nval];
    }

    recursive method processConstructorPrimaryListExpression(e: ConstructorPrimaryListExpression): Expression {
        let nargs = this.processArgumentListSimple[recursive](e.args);
        return e[args=nargs];
    }

    recursive method processConstructorPrimaryMapExpression(e: ConstructorPrimaryMapExpression): Expression {
        let nargs = this.processArgumentListSimple[recursive](e.args);
        return e[args=nargs];
    }

    recursive method processConstructorPrimarySpecialMapEntryExpression(e: ConstructorPrimarySpecialMapEntryExpression): Expression {
        let nval = this.processUnaryArg[recursive](e.value);
        return e[value=nval];
    }

    recursive method processConstructorTypeDeclExpression(e: ConstructorTypeDeclExpression): Expression {
        let nval = this.processUnaryArg[recursive](e.value);
        return e[value=nval];
    }

    recursive method processConstructorTypeDeclStringExpression(e: ConstructorTypeDeclStringExpression): Expression {
        let nval = this.processUnaryArg[recursive](e.value);
        return e[value=nval];
    }

    recursive method processConstructorStdExpression(e: ConstructorStdExpression): Expression {
        let ninfo = this.processStdConstructorArgs[recursive](e.argsinfo);
        return e[argsinfo=ninfo];
    }

    recursive method processConstructorEListExpression(e: ConstructorEListExpression): Expression {
        let nargs = this.processArgs[recursive](e.args);

        return e[args=nargs];
    }

    recursive method processConstructorExpression(e: ConstructorExpression): Expression {
        match(e)@ {
            | ConstructorPrimaryListExpression => { return this.processConstructorPrimaryListExpression[recursive]($e); }
            | ConstructorPrimaryMapExpression => { return this.processConstructorPrimaryMapExpression[recursive]($e); }
            | ConstructorPrimarySpecialMapEntryExpression => { return this.processConstructorPrimarySpecialMapEntryExpression[recursive]($e); }
            | ConstructorPrimarySpecialSomeExpression => { return this.processConstructorPrimarySpecialSomeExpression[recursive]($e); }
            | ConstructorPrimarySpecialOkExpression => { abort; }
            | ConstructorPrimarySpecialFailExpression => { abort; }
            | ConstructorTypeDeclExpression => { return this.processConstructorTypeDeclExpression[recursive]($e); }
            | ConstructorTypeDeclStringExpression => { return this.processConstructorTypeDeclStringExpression[recursive]($e); }
            | ConstructorStdExpression => { return this.processConstructorStdExpression[recursive]($e); }
            | ConstructorEListExpression => { return this.processConstructorEListExpression[recursive]($e); }
        }
    }

    recursive method processConstructorLambdaExpression(e: ConstructorLambdaExpression): Expression {
        let nbody = this.processBodyImpl[recursive](e.body);

        return e[body=nbody];
    }

    recursive method processLambdaInvokeExpression(e: LambdaInvokeExpression): Expression {
        let ninfo = this.processLambdaInvokeArgumentInfo[recursive](e.argsinfo);
        return e[argsinfo=ninfo];
    }

    recursive method processCallNamespaceFunctionExpression(e: CallNamespaceFunctionExpression): Expression {
        let ninfo = this.processInvokeArgumentInfoStatic[recursive](e.argsinfo);
        return e[argsinfo=ninfo];
    }

    recursive method processCallTypeFunctionExpression(e: CallTypeFunctionExpression): Expression {
        let ninfo = this.processInvokeArgumentInfoStatic[recursive](e.argsinfo);
        return e[argsinfo=ninfo];
    }

    recursive method processCallTypeFunctionSpecialExpression(e: CallTypeFunctionSpecialExpression): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp);
        return e[exp=nexp];
    }

    recursive method processTypeDeclPrimitiveFieldAccessExpression(e: TypeDeclPrimitiveFieldAccessExpression): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp);
        return e[exp=nexp];
    }

    recursive method processCoerceNarrowTypeExpression(e: CoerceNarrowTypeExpression): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp);
        return e[exp=nexp];
    }

    recursive method processCoerceWidenTypeExpression(e: CoerceWidenTypeExpression): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp);
        return e[exp=nexp];
    }

    recursive method processSafeConvertExpression(e: SafeConvertExpression): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp);
        return e[exp=nexp];
    }

    recursive method processCreateDirectExpression(e: CreateDirectExpression): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp);
        return e[exp=nexp];
    }

    recursive method processPostfixAssignFields(op: PostfixAssignFields): PostfixAssignFields {
        let nupdates = op.updates.map<(|NominalTypeSignature, Identifier, NominalTypeSignature, Expression|)>(
            fn(upd) => {
                let nupdate = this.processUnaryArg[recursive](upd.3);
                return upd.0, upd.1, upd.2, nupdate;
            }
        );

        return op[updates=nupdates];
    }

    recursive method processPostfixInvokeStatic(op: PostfixInvokeStatic): PostfixInvokeStatic {
        let ninfo = this.processInvokeArgumentInfoStatic[recursive](op.argsinfo);
        return op[argsinfo=ninfo];
    }

    recursive method processPostfixOp(e: PostfixOp): Expression {
        let ebase = this.processUnaryArg[recursive](e.rootExp);
        let ops = e.ops.map[recursive]<PostfixOperation>(recursive fn(op) => {
            match(op)@ {
                | PostfixAccessFromName => { return $op; }
                | PostfixProjectFromNames => { return $op; }
                | PostfixAccessFromIndex => { return $op; }
                | PostfixIsTest => { return this.processITestAsTest($op.sinfo, $op.baseType, $op.ttest); }
                | PostfixAsConvert => { return this.processITestAsConvert($op.sinfo, $op.baseType, $op.ttest); }
                | PostfixAssignFields => { return this.processPostfixAssignFields($op); }
                | PostfixInvokeStatic => { return this.processPostfixInvokeStatic($op); }
                | PostfixInvokeVirtual => { abort; }
                | PostfixLiteralKeyAccess => { abort; }
                | PostfixBoolConstant => { return $op; }
                | PostfixNop => { return $op; }
                | PostfixAbort => { return $op; }
                | PostfixWidenConvert => { return $op; }
                | PostfixAccessSomeValue => { return $op; }
                | PostfixLiteralNoneValue => { return $op; } 
            }
        });

        var sops = ops.filter(pred(op) => op?!<PostfixNop>);
        let hasabort = sops.someOf(pred(op) => op?<PostfixAbort>);
        if(hasabort) {
            abort; %%TODO: we should trim the list if we have a PostfixAbort -- also set the type of the abort to be the final e.type
        }

        return PostfixOp{ e.sinfo, e.etype, ebase, sops };
    }

    function negateLiteralBoolean(v: CString, sinfo: SourceInfo, btype: TypeSignature): Expression {
        var val: CString;

        if(v === 'true') {
            val = 'false';
        }
        else {
            val = 'true';
        }

        return LiteralSimpleExpression{ sinfo, btype, val };
    }

    function negateLiteralNumber(v: CString, sinfo: SourceInfo, ntype: TypeSignature): Expression {
        var val: CString;

        if(v === '0') {
            val = '0';
        }
        else {
            if(v.startsWithString('-')) {
                val = v.removePrefixString('-');
            }
            else {
                val = v.prepend('-');
            }
        }

        return LiteralSimpleExpression{ sinfo, ntype, val };
    }

    function processPrefixNotOpExpression(e: PrefixNotOpExpression, ee: Expression): Expression {
        match(ee)@ {
            | LiteralSimpleExpression => {
                return ConstantSimplification::negateLiteralBoolean($ee.value, e.sinfo, e.opertype);
            }
            | PrefixNotOpExpression => {
                return $ee.exp;
            }
            | _ => {
                return e[exp=ee];
            }
        }
    }

    function processPrefixNegateOpExpression(e: PrefixNegateOpExpression, ee: Expression): Expression {
        match(ee)@ {
            | LiteralSimpleExpression => {
                return ConstantSimplification::negateLiteralNumber($ee.value, e.sinfo, e.opertype);
            }
            | PrefixNegateOpExpression => {
                return $ee.exp;
            }
            | _ => {
                return e[exp=ee];
            }
        }
    }

    function processPrefixPlusOpExpression(e: PrefixPlusOpExpression, ee: Expression): Expression {
        return ee;
    }

    recursive method processUnaryExpression(e: UnaryExpression): Expression {
        let ee = this.processUnaryArg(e.exp);

        match(e)@ {
            | PrefixNotOpExpression => { return ConstantSimplification::processPrefixNotOpExpression($e, ee); }
            | PrefixNegateOpExpression => { return ConstantSimplification::processPrefixNegateOpExpression($e, ee); }
            | PrefixPlusOpExpression => { return ConstantSimplification::processPrefixPlusOpExpression($e, ee); }
        }
    }

    recursive method processBinaryArithExpression(e: BinaryArithExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);

        %%TODO: here is where we would like to do some constant folding and algebraic simplification

        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method processBinKeyEqNoneExpression(e: BinKeyEqNoneExpression): Expression {
        let ee = this.processUnaryArg(e.exp);
        let etype = this.assembly.lookupNominalTypeDeclaration(ee.etype.tkeystr);

        if(etype.tkey === 'None'<TypeKey>) {
            return ConstantSimplification::trueExp;
        }
        else {
            if(etype)<SomeTypeDecl> {
                return ConstantSimplification::falseExp;
            }
            else {
                return e[exp=ee];
            }
        }
    }

    recursive method processBinKeyNotEqNoneExpression(e: BinKeyNotEqNoneExpression): Expression {
        let ee = this.processUnaryArg(e.exp);
        let etype = this.assembly.lookupNominalTypeDeclaration(ee.etype.tkeystr);

        if(etype.tkey === 'None'<TypeKey>) {
            return ConstantSimplification::falseExp;
        }
        else {
            if(etype)<SomeTypeDecl> {
                return ConstantSimplification::trueExp;
            }
            else {
                return e[exp=ee];
            }
        }
    }

    recursive method processBinKeySomeEqExpression(e: BinKeySomeEqExpression): Expression {
        let noption, nval = this.processBinaryArgs(e.eqoption, e.eqval);
        let etype = this.assembly.lookupNominalTypeDeclaration(noption.etype.tkeystr);

        if(etype.tkey === 'None'<TypeKey>) {
            return ConstantSimplification::falseExp;
        }
        else {
            if(etype)<SomeTypeDecl> {
                abort; %%Not implemented -- explicitly unwrap and compare here
            }
            else {
                return e[eqoption=noption, eqval=nval];
            }
        }
    }

    recursive method processBinKeyNotSomeEqExpression(e: BinKeyNotSomeEqExpression): Expression {
        let noption, nval = this.processBinaryArgs(e.eqoption, e.eqval);
        let etype = this.assembly.lookupNominalTypeDeclaration(noption.etype.tkeystr);

        if(etype.tkey === 'None'<TypeKey>) {
            return ConstantSimplification::trueExp;
        }
        else {
            if(etype)<SomeTypeDecl> {
                abort; %%Not implemented -- explicitly unwrap and compare here
            }
            else {
                return e[eqoption=noption, eqval=nval];
            }
        }
    }

    recursive method processBinKeyEqExpression(e: BinKeyEqExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);

        %%TODO: here is where we would like to do some basic constant checks

        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method processBinKeyNotEqExpression(e: BinKeyNotEqExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);

        %%TODO: here is where we would like to do some basic const checks

        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method processBinaryKeyEqExpression(e: BinaryKeyEqExpression): Expression {
        match(e)@ {
            | BinKeyEqNoneExpression => { return this.processBinKeyEqNoneExpression[recursive]($e); }
            | BinKeyNotEqNoneExpression => { return this.processBinKeyNotEqNoneExpression[recursive]($e); }
            | BinKeySomeEqExpression => { return this.processBinKeySomeEqExpression[recursive]($e); }
            | BinKeyNotSomeEqExpression => { return this.processBinKeyNotSomeEqExpression[recursive]($e); }
            | BinKeyEqExpression => { return this.processBinKeyEqExpression[recursive]($e); }
            | BinKeyNotEqExpression => { return this.processBinKeyNotEqExpression[recursive]($e); }
        }
    }

    recursive method processKeyCmpEqualExpression(e: KeyCmpEqualExpression): Expression {
        let nlhs = this.processExpression[recursive](e.lhs);
        let nrhs = this.processExpression[recursive](e.rhs);

        if(nlhs?!<LiteralSimpleExpression> || nrhs?!<LiteralSimpleExpression>) {
            return e[lhs=nlhs, rhs=nrhs];
        }
        else {
            if(nlhs@<LiteralSimpleExpression>.value === nrhs@<LiteralSimpleExpression>.value) {
                return ConstantSimplification::trueExp;
            }
            else {
                return ConstantSimplification::falseExp;
            }
        }
    }

    recursive method processKeyCmpLessExpression(e: KeyCmpLessExpression): Expression {
        let nlhs = this.processExpression[recursive](e.lhs);
        let nrhs = this.processExpression[recursive](e.rhs);

        if(nlhs?!<LiteralSimpleExpression> || nrhs?!<LiteralSimpleExpression>) {
            return e[lhs=nlhs, rhs=nrhs];
        }
        else {
            %%
            %% Eventually we might want to perform numeric checks here
            %%
            if(nlhs@<LiteralSimpleExpression>.value === nrhs@<LiteralSimpleExpression>.value) {
                return ConstantSimplification::falseExp;
            }
            else {
                 return e[lhs=nlhs, rhs=nrhs];
            }
        }
    }

    recursive method processBinaryNumericExpression(e: BinaryNumericExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);

        %%TODO: here is where we would like to do some algebraic simplification

        return e[lhs=nlhs, rhs=nrhs];
    }

    method simplifyBinAnd(e: BinLogicExpression, nlhs: Expression, nrhs: Expression): Expression {
        if(nlhs)@!<LiteralSimpleExpression> {
            return e[lhs=nlhs, rhs=nrhs];
        }
        else {
            if($nlhs.value === 'false') {
                return ConstantSimplification::falseExp;
            }
            else {
                return nrhs;
            }
        }
    }

    method simplifyBinOr(e: BinLogicExpression, nlhs: Expression, nrhs: Expression): Expression {
        if(nrhs)@!<LiteralSimpleExpression> {
            return e[lhs=nlhs, rhs=nrhs];
        }
        else {
            if($nrhs.value === 'true') {
                return ConstantSimplification::trueExp;
            }
            else {
                return nrhs;
            }
        }
    }

    method simplifyBinImplies(e: BinLogicExpression, nlhs: Expression, nrhs: Expression): Expression {
        if(nlhs)@!<LiteralSimpleExpression> {
            return e[lhs=nlhs, rhs=nrhs];
        }
        else {
            if($nlhs.value === 'false') {
                return ConstantSimplification::trueExp;
            }
            else {
                return nrhs;
            }
        }
    }

    method simplifyBinIFF(e: BinLogicExpression, nlhs: Expression, nrhs: Expression): Expression {
        if(nlhs?!<LiteralSimpleExpression> || nrhs?!<LiteralSimpleExpression>) {
            return e[lhs=nlhs, rhs=nrhs];
        }
        else {
            if(nlhs@<LiteralSimpleExpression>.value === nrhs@<LiteralSimpleExpression>.value) {
                return ConstantSimplification::trueExp;
            }
            else {
                return ConstantSimplification::falseExp;
            }
        }
    }

    recursive method processBinLogicExpression(e: BinLogicExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);
        
        match(e)@ {
            | BinLogicAndExpression => { return this.simplifyBinAnd($e, nlhs, nrhs); }
            | BinLogicOrExpression => { return this.simplifyBinOr($e, nrhs, nlhs); } 
            | BinLogicImpliesExpression => { return this.simplifyBinImplies($e, nlhs, nrhs); }
            | BinLogicIFFExpression => { return this.simplifyBinIFF($e, nlhs, nrhs); }
        }
    }

    recursive method processIfSimpleExpression(e: IfSimpleExpression): Expression {
        let ntexp = this.processExpression[recursive](e.texp);
        let nthen = this.processExpression[recursive](e.thenexp);
        let nelse = this.processExpression[recursive](e.elseexp);

        if(ntexp)@!<LiteralSimpleExpression> {
            return e[texp=ntexp, thenexp=nthen, elseexp=nelse];
        }
        else {
            if($ntexp.value === 'true') {
                return nthen;
            }
            else {
                return nelse;
            }
        }
    }

    recursive method processIfTestExpression(e: IfTestExpression): Expression {
        let ntexp = this.processExpression[recursive](e.texp);
        let nthen = this.processExpression[recursive](e.thenexp);
        let nelse = this.processExpression[recursive](e.elseexp);

        let op = this.processITestAsTest(ntexp.sinfo, ntexp.etype, e.itest);
        if(op)@!<PostfixBoolConstant> {
            return e[texp=ntexp, thenexp=nthen, elseexp=nelse];
        }
        else {
            if($op.value) {
                return nthen;
            }
            else {
                return nelse;
            }
        }
    }

    recursive method processIfBinderExpression(e: IfBinderExpression): Expression {
        let ntexp = this.processExpression[recursive](e.texp);
        let nthen = this.processExpression[recursive](e.thenexp);
        let nelse = this.processExpression[recursive](e.elseexp);

        let op = this.processITestAsTest(ntexp.sinfo, ntexp.etype, e.itest);
        if(op)@!<PostfixBoolConstant> {
            return e[texp=ntexp, thenexp=nthen, elseexp=nelse];
        }
        else {
            %%TODO: we need to turn this into a Let (but that isn't all implemented yet)
            abort; 

%*
            if($op.value) {
                return nthen;
            }
            else {
                return nelse;
            }
*%
        }
    }

    recursive method processIfExpression(e: IfExpression): Expression {
        match(e)@ {
            | IfSimpleExpression => { return this.processIfSimpleExpression[recursive]($e); }
            | IfTestExpression => { return this.processIfTestExpression[recursive]($e); }
            | IfBinderExpression => { return this.processIfBinderExpression[recursive]($e); }
        }
    }

    recursive method processMapEntryConstructorExpression(e: MapEntryConstructorExpression): Expression {
        let nkexp = this.processExpression[recursive](e.kexp);
        let nvexp = this.processExpression[recursive](e.vexp);

        return e[kexp=nkexp, vexp=nvexp];
    }

    recursive method processExpression(e: Expression): Expression {
        match(e)@ {
            | LiteralNoneExpression => { return e; }
            | LiteralSimpleExpression => { return e; }
            | LiteralCStringExpression => { return e; }
            | LiteralStringExpression => { return e; }
            | LiteralCCharExpression => { return e; }
            | LiteralUnicodeCharExpression => { return e; }
            | LiteralCRegexExpression => { return e; }
            | LiteralRegexExpression => { return e; }
            | LiteralTypeDeclValueExpression => { return e; }
            | AccessNamespaceConstantExpression => { return this.processAccessNamespaceConstantExpression($e); }
            | AccessStaticFieldExpression => { return this.processAccessStaticFieldExpression($e); }
            | AccessEnumExpression => { return e; }
            | AccessVariableExpression => { return e; }
            | AccessCapturedVariableExpression => { return e; }
            | ConstructorExpression => { return this.processConstructorExpression[recursive]($e); }
            | ConstructorLambdaExpression => { return this.processConstructorLambdaExpression[recursive]($e); }
            | LetExpression => { abort; }
            | LambdaInvokeExpression => { return this.processLambdaInvokeExpression[recursive]($e); }
            | CallNamespaceFunctionExpression => { return this.processCallNamespaceFunctionExpression[recursive]($e); }
            | CallTypeFunctionExpression => { return this.processCallTypeFunctionExpression[recursive]($e); }
            | CallTypeFunctionSpecialExpression => { return this.processCallTypeFunctionSpecialExpression[recursive]($e); }
            | CallRefInvokeStaticResolveExpression => { abort; }
            | CallRefInvokeVirtualExpression => { abort; }
            | TypeDeclPrimitiveFieldAccessExpression => { return this.processTypeDeclPrimitiveFieldAccessExpression[recursive]($e); }
            | CoerceNarrowTypeExpression => { return this.processCoerceNarrowTypeExpression[recursive]($e); }
            | CoerceWidenTypeExpression => { return this.processCoerceWidenTypeExpression[recursive]($e); }
            | SafeConvertExpression => { return this.processSafeConvertExpression[recursive]($e); }
            | CreateDirectExpression => { return this.processCreateDirectExpression[recursive]($e); }
            | PostfixOp => { return this.processPostfixOp[recursive]($e); }
            | UnaryExpression => { return this.processUnaryExpression[recursive]($e); }
            | BinaryArithExpression => { return this.processBinaryArithExpression[recursive]($e); }
            | BinaryKeyEqExpression => { return this.processBinaryKeyEqExpression[recursive]($e); }
            | KeyCmpEqualExpression => { return this.processKeyCmpEqualExpression[recursive]($e); }
            | KeyCmpLessExpression => { return this.processKeyCmpLessExpression[recursive]($e); }
            | BinaryNumericExpression => { return this.processBinaryNumericExpression[recursive]($e); }
            | BinLogicExpression => { return this.processBinLogicExpression[recursive]($e); }
            | MapEntryConstructorExpression => { return this.processMapEntryConstructorExpression[recursive]($e); }
            | IfExpression => { return this.processIfExpression[recursive]($e); }
        }
    }

    method processAssertStatement(s: AssertStatement): Statement {
        let ncond = this.processExpression(s.cond);
        
        if(ncond)@!<LiteralSimpleExpression> {
            return s[cond = $ncond];
        }
        else {
            if($ncond.value === 'true') {
                return EmptyStatement{ s.sinfo };
            }
            else{
                return AbortStatement{ s.sinfo };
            }
        }
    }

    recursive method processIfSimpleStatement(s: IfSimpleStatement): Statement {
        let ntexp = this.processExpression[recursive](s.texp);
        let ntb = this.processBlockStatement[recursive](s.trueBlock);

        if(ntexp)@!<LiteralSimpleExpression> {
            return s[texp=ntexp, trueBlock=ntb];
        }
        else {
            if($ntexp.value === 'true') {
                return ntb;
            }
            else {
                return EmptyStatement{ s.sinfo };
            }
        }
    }

    recursive method processIfTestStatement(s: IfTestStatement): Statement {
        let ntexp = this.processExpression[recursive](s.texp);
        let ntb = this.processBlockStatement[recursive](s.trueBlock);

        let op = this.processITestAsTest(ntexp.sinfo, ntexp.etype, s.itest);
        if(op)@!<PostfixBoolConstant> {
            return s[texp=ntexp, trueBlock=ntb];
        }
        else {
            if($op.value) {
                return ntb;
            }
            else {
                return EmptyStatement{ s.sinfo };
            }
        }
    }

    recursive method processIfBinderStatement(s: IfBinderStatement): Statement {
        let ntexp = this.processExpression[recursive](s.texp);
        let ntb = this.processBlockStatement[recursive](s.trueBlock);

        let op = this.processITestAsTest(ntexp.sinfo, ntexp.etype, s.itest);
        if(op)@!<PostfixBoolConstant> {
            return s[texp=ntexp, trueBlock=ntb];
        }
        else {
            if($op.value) {
                return BinderBlockStatement{ s.sinfo, s.binder, ntexp, s.itest, List<Statement>{ntb}, true };
            }
            else {
                return EmptyStatement{ s.sinfo };
            }
        }
    }

    recursive method processIfStatement(s: IfStatement): Statement {
        match(s)@ {
            | IfSimpleStatement => { return this.processIfSimpleStatement[recursive]($s); }
            | IfTestStatement => { return this.processIfTestStatement[recursive]($s); }
            | IfBinderStatement => { return this.processIfBinderStatement[recursive]($s); }
        }
    }

    recursive method processIfElseSimpleStatement(s: IfElseSimpleStatement): Statement {
        let ntexp = this.processExpression[recursive](s.texp);
        let ntb = this.processBlockStatement[recursive](s.trueBlock);
        let nfb = this.processBlockStatement[recursive](s.falseBlock);

        if(ntexp)@!<LiteralSimpleExpression> {
            return s[texp=ntexp, trueBlock=ntb, falseBlock=nfb];
        }
        else {
            if($ntexp.value === 'true') {
                return ntb;
            }
            else {
                return nfb;
            }
        }
    }

    recursive method processIfElseTestStatement(s: IfElseTestStatement): Statement {
        let ntexp = this.processExpression[recursive](s.texp);
        let ntb = this.processBlockStatement[recursive](s.trueBlock);
        let nfb = this.processBlockStatement[recursive](s.falseBlock);

        let op = this.processITestAsTest(ntexp.sinfo, ntexp.etype, s.itest);
        if(op)@!<PostfixBoolConstant> {
            return s[texp=ntexp, trueBlock=ntb, falseBlock=nfb];
        }
        else {
            if($op.value) {
                return ntb;
            }
            else {
                return nfb;
            }
        }
    }

    recursive method processIfElseBinderStatement(s: IfElseBinderStatement): Statement {
        let ntexp = this.processExpression[recursive](s.texp);
        let ntb = this.processBlockStatement[recursive](s.trueBlock);
        let nfb = this.processBlockStatement[recursive](s.falseBlock);

        let op = this.processITestAsTest(ntexp.sinfo, ntexp.etype, s.itest);
        if(op)@!<PostfixBoolConstant> {
            return s[texp=ntexp, trueBlock=ntb, falseBlock=nfb];
        }
        else {
            if($op.value) {
                return BinderBlockStatement{ s.sinfo, s.binder, ntexp, s.itest, List<Statement>{ntb}, true };
            }
            else {
                return BinderBlockStatement{ s.sinfo, s.binder, ntexp, s.itest, List<Statement>{nfb}, true };
            }
        }
    }

    recursive method processIfElseStatement(s: IfElseStatement): Statement {
        match(s)@ {
            | IfElseSimpleStatement => { return this.processIfElseSimpleStatement[recursive]($s); }
            | IfElseTestStatement => { return this.processIfElseTestStatement[recursive]($s); }
            | IfElseBinderStatement => { return this.processIfElseBinderStatement[recursive]($s); }
        }
    }

    recursive method processIfElifElseStatement(s: IfElifElseStatement): Statement {
        let nifcond = this.processExpression[recursive](s.ifcond);
        let nifflow = this.processBlockStatement[recursive](s.ifflow);
        let ncondflow = s.condflow
            .map<(|Expression, BlockStatement|)>(fn(eb) 
                => (|this.processExpression[recursive](eb.0), this.processBlockStatement(eb.1)|));
        let nelseflow = this.processBlockStatement(s.elseflow);

        if(nifcond?<LiteralSimpleExpression> && nifcond@<LiteralSimpleExpression>.value === 'true') {
            return nifflow;
        }
        else {
            return ncondflow.lreduce<Statement>(nelseflow, fn(acc, eb) => {
                let cur = eb.0;
                if(cur)@!<LiteralSimpleExpression> {
                    return s[ifcond=nifcond, ifflow=nifflow, condflow=ncondflow, elseflow=nelseflow];
                }
                else {
                    if($cur.value === 'true') {
                        return eb.1;
                    }
                    else {
                        return acc;
                    }
                }
            });
        }
    }

    recursive method processMatchStatement(s: MatchStatement): Statement {
        let nsv = this.processExpression[recursive](s.sval);

        let nflow = s.matchflow.reduce[recursive]<(|Bool, List<(|TypeSignature, BlockStatement|)>|)>((|true, List<(|TypeSignature, BlockStatement|)>{}|), recursive fn(acc, mb) => {
            if(!acc.0) {
                return acc;
            }
            else {
                if(this.assembly.isSubtypeOf(nsv.etype, mb.0)) {
                    return (|false, acc.1.pushBack((|mb.0, this.processBlockStatement[recursive](mb.1)|))|);
                }
                elif(this.assembly.areDisjoint(nsv.etype, mb.0)) {
                    return (|true, acc.1|);
                }
                else {
                    return (|true, acc.1.pushBack((|mb.0, this.processBlockStatement[recursive](mb.1)|))|);
                }
            }
        });

        if(nflow.1.empty()) {
            return AbortStatement{ s.sinfo };
        }
        else {
            if(nflow.0) {
                return s[sval=nsv, matchflow=nflow.1];
            }
            else {
                if(nflow.1.isSingle()) {
                    let mb = nflow.1.single();
                    if($binfo = s.bindInfo)@none {
                        return mb.1;
                    }
                    else {
                        let ttest = ITestType{ false, mb.0 };
                        return BinderBlockStatement{ s.sinfo, $binfo, nsv, ttest, List<Statement>{mb.1}, true };
                    }
                }
                else {
                    return s[sval=nsv, matchflow=nflow.1, mustExhaustive=true];
                }
            }
        }
    }

    recursive method processSwitchStatement(s: SwitchStatement): Statement {
        let nsv = this.processExpression[recursive](s.sval);

        let nflow = s.switchflow.map<(|Option<Expression>, BlockStatement|)>(fn(mb) => {
            let ne = if(mb.0)none then none else some(this.processExpression[recursive](mb.0@some));
            let nb = this.processBlockStatement[recursive](mb.1);
            return (|ne, nb|);
        });
            
        return s[sval=nsv, switchflow=nflow];
    }

    recursive method processStatement(s: Statement): Statement {
        match(s)@ {
            | EmptyStatement => { 
                return s; 
            }
            | VariableDeclarationStatement => {
                return s;
            }
            | VariableMultiDeclarationStatement => {
                return s;
            }
            | VariableInitializationStatement => {
                return $s[exp = this.processExpression($exp)];
            }
            | VariableMultiInitializationExplicitStatement => {
                return $s[exps = this.processArgs($exps)];
            }
            | VariableMultiInitializationImplicitStatement => {
                return $s[exp = this.processExpression($exp)];
            }
            | VariableAssignmentStatement => {
                return $s[exp = this.processExpression($exp)];
            }
            | VariableMultiAssignmentExplicitStatement => {
                return $s[exps = this.processArgs($exps)];
            }
            | VariableMultiAssignmentImplicitStatement => {
                return $s[exp = this.processExpression($exp)];
            }
            | VariableRetypeStatement => { 
                abort; 
            }
            | ReturnVoidStatement => {
                return s;
            }
            | ReturnSingleStatement => {
                return $s[value = this.processExpression($value)];
            }
            | ReturnMultiStatement => {
                return $s[exps = this.processArgs($exps)];
            }
            | IfStatement => {
                return this.processIfStatement[recursive]($s);
            }
            | IfElseStatement => {
                return this.processIfElseStatement[recursive]($s);
            }
            | IfElifElseStatement => {
                return this.processIfElifElseStatement[recursive]($s);
            }
            | SwitchStatement => { 
                return this.processSwitchStatement[recursive]($s);
            }
            | MatchStatement => {
                return this.processMatchStatement[recursive]($s);
            }
            | AbortStatement => {
                return s;
            }
            | AssertStatement => {
                return this.processAssertStatement($s);
            }
            | BlockStatement => {
                return this.processBlockStatement[recursive]($s);
            }
            | BinderBlockStatement => {
                return this.processBinderBlockStatement[recursive]($s);
            }
        }
    }

    recursive method processBlockStatement(s: BlockStatement): BlockStatement {
        let nstmts = s.statements.map[recursive]<Statement>(recursive fn(stmt) => this.processStatement[recursive](stmt));

        return s[statements=nstmts];
    }

    recursive method processBinderBlockStatement(s: BinderBlockStatement): BinderBlockStatement {
        let nbexp = this.processExpression[recursive](s.bexp);
        let nstmts = s.statements.map[recursive]<Statement>(recursive fn(stmt) => this.processStatement[recursive](stmt));

        return s[bexp=nbexp, statements=nstmts];
    }

    method processInvokeParameter(param: InvokeParameterDecl): InvokeParameterDecl {
        if(param.defaultval)@none {
            return param;
        }
        else {
            let dv = this.processExpression(param.defaultval@some);
            
            return param[defaultval=some(dv)];
        }
    }

    method processInvariant(iiv: InvariantDecl): InvariantDecl {
        let ee = this.processExpression(iiv.exp);
        return iiv[exp=ee];
    }

    method processValidate(vv: ValidateDecl): ValidateDecl {
        let ee = this.processExpression(vv.exp);
        return vv[exp=ee];
    }

    method processPrecondition(precond: PreConditionDecl): PreConditionDecl {
        let ee = this.processExpression(precond.exp);
        return precond[exp=ee];
    }

    method processPostcondition(postcond: PostConditionDecl): PostConditionDecl {
        let ee = this.processExpression(postcond.exp);
        return postcond[exp=ee];
    }

    recursive method processBodyStatementList(stmts: List<Statement>): List<Statement> {
        let _, nstmts = stmts.reduce[recursive]<(|Bool, List<Statement>|)>((|false, List<Statement>{}|), recursive fn(rvi, stmt) => {
            if(rvi.0) {
                return rvi;
            }
            else {
                let pcc = this.processStatement[recursive](stmt);
                let done = ConstantSimplification::isTerminalStatement(pcc);

                return (|done, rvi.1.pushBack(pcc)|);
            }
        });

        return nstmts;
    }

    method processBodyImpl(body: BodyImplementation): BodyImplementation {
        match(body)@ {
            | ExpressionBodyImplementation => { return ExpressionBodyImplementation{ this.processExpression($body.exp) }; }
            | StandardBodyImplementation => { return StandardBodyImplementation{ this.processBodyStatementList($body.statements) }; }
            | _ => { return body; }
        }
    }

    method processNamespaceConstDecl(nsconst: NamespaceConstDecl): NamespaceConstDecl {
        let evalue = this.processExpression(nsconst.value);
        return nsconst[value=evalue];
    }

    method processConstMemberDecl(typeconst: ConstMemberDecl): ConstMemberDecl {
        let evalue = this.processExpression(typeconst.value);
        return typeconst[value=evalue];
    }

    method processMemberFieldDecl(fd: MemberFieldDecl): MemberFieldDecl {
        if($dv=fd.defaultValue)@none {
            return fd;
        }
        else {
            let dvalue = this.processExpression($dv);
            return fd[defaultValue=some(dvalue)];
        }
    }

    method processNamespaceFunctionDecl(nsfunc: NamespaceFunctionDecl): NamespaceFunctionDecl {
        return NamespaceFunctionDecl{
            file = nsfunc.file,
            sinfo = nsfunc.sinfo,
            fullns = nsfunc.fullns,
            declaredInNS = nsfunc.declaredInNS,

            attributes = nsfunc.attributes,
            name = nsfunc.name,

            ikey = nsfunc.ikey,
            irecursive = nsfunc.irecursive,
            params = nsfunc.params.map<InvokeParameterDecl>(fn(param) => this.processInvokeParameter(param)),
            resultType = nsfunc.resultType,

            body = this.processBodyImpl(nsfunc.body),

            preconditions = nsfunc.preconditions.map<PreConditionDecl>(fn(precond) => this.processPrecondition(precond)),
            postconditions = nsfunc.postconditions.map<PostConditionDecl>(fn(postcond) => this.processPostcondition(postcond)),
            fkind = nsfunc.fkind
        };
    }

    method processTypeFunctionDecl(typefunc: TypeFunctionDecl): TypeFunctionDecl {
        return TypeFunctionDecl{
            file = typefunc.file,
            sinfo = typefunc.sinfo,
            fullns = typefunc.fullns,
            declaredInNS = typefunc.declaredInNS,

            attributes = typefunc.attributes,
            name = typefunc.name,

            ikey = typefunc.ikey,
            irecursive = typefunc.irecursive,
            params = typefunc.params.map<InvokeParameterDecl>(fn(param) => this.processInvokeParameter(param)),
            resultType = typefunc.resultType,

            body = this.processBodyImpl(typefunc.body),

            preconditions = typefunc.preconditions.map<PreConditionDecl>(fn(precond) => this.processPrecondition(precond)),
            postconditions = typefunc.postconditions.map<PostConditionDecl>(fn(postcond) => this.processPostcondition(postcond))
        }; 
    }

    method processMethodDeclAbstract(absmethod: MethodDeclAbstract): MethodDeclAbstract {
        abort;
    }

    method processMethodDeclVirtual(virtmethod: MethodDeclVirtual): MethodDeclVirtual {
        abort;
    }

    method processMethodDeclOverride(overmethod: MethodDeclOverride): MethodDeclOverride {
        abort;
    }

    method processMethodDeclStatic(staticmethod: MethodDeclStatic): MethodDeclStatic {
        return MethodDeclStatic{
            file = staticmethod.file,
            sinfo = staticmethod.sinfo,
            fullns = staticmethod.fullns,
            declaredInNS = staticmethod.declaredInNS,

            attributes = staticmethod.attributes,
            name = staticmethod.name,

            ikey = staticmethod.ikey,
            irecursive = staticmethod.irecursive,
            params = staticmethod.params.map<InvokeParameterDecl>(fn(param) => this.processInvokeParameter(param)),
            resultType = staticmethod.resultType,

            body = this.processBodyImpl(staticmethod.body),

            preconditions = staticmethod.preconditions.map<PreConditionDecl>(fn(precond) => this.processPrecondition(precond)),
            postconditions = staticmethod.postconditions.map<PostConditionDecl>(fn(postcond) => this.processPostcondition(postcond)),

            isThisRef = staticmethod.isThisRef,
            ofrcvrtype = staticmethod.ofrcvrtype
        };
    }

    method processTypedeclTypeDecl(typedecl: TypedeclTypeDecl): TypedeclTypeDecl {
        return TypedeclTypeDecl{
            file=typedecl.file,
            sinfo=typedecl.sinfo,
            fullns=typedecl.fullns,
            declaredInNS=typedecl.declaredInNS,

            tkey=typedecl.tkey,
            name=typedecl.name,

            invariants=typedecl.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=typedecl.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=typedecl.absmethods,
            virtmethods=typedecl.virtmethods,
            overmethods=typedecl.overmethods,
            staticmethods=typedecl.staticmethods,

            saturatedProvides=typedecl.saturatedProvides,
            saturatedBFieldInfo=typedecl.saturatedBFieldInfo,

            allInvariants=typedecl.allInvariants,
            allValidates=typedecl.allValidates,

            valuetype=typedecl.valuetype
        };
    }

    method processTypedeclStringOfTypeDecl(typedecl: TypedeclStringOfTypeDecl): TypedeclStringOfTypeDecl {
        return TypedeclStringOfTypeDecl{
            file=typedecl.file,
            sinfo=typedecl.sinfo,
            fullns=typedecl.fullns,
            declaredInNS=typedecl.declaredInNS,

            tkey=typedecl.tkey,
            name=typedecl.name,

            invariants=typedecl.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=typedecl.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=typedecl.absmethods,
            virtmethods=typedecl.virtmethods,
            overmethods=typedecl.overmethods,
            staticmethods=typedecl.staticmethods,

            saturatedProvides=typedecl.saturatedProvides,
            saturatedBFieldInfo=typedecl.saturatedBFieldInfo,

            allInvariants=typedecl.allInvariants,
            allValidates=typedecl.allValidates,

            valuetype=typedecl.valuetype,
            ofcheck=this.assembly.tryResolveExpAsLiteralExpression(typedecl.ofcheck)@some
        };
    }

    method processPrimitiveEntityTypeDecl(primtype: PrimitiveEntityTypeDecl): PrimitiveEntityTypeDecl {
        return primtype;
    }

    method processEntityTypeDecl(etype: EntityTypeDecl): EntityTypeDecl {
        return EntityTypeDecl{
            file=etype.file,
            sinfo=etype.sinfo,
            fullns = etype.fullns,
            declaredInNS=etype.declaredInNS,
            
            tkey=etype.tkey,
            name=etype.name,

            invariants=etype.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=etype.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=etype.absmethods,
            virtmethods=etype.virtmethods,
            overmethods=etype.overmethods,
            staticmethods=etype.staticmethods,

            saturatedProvides=etype.saturatedProvides,
            saturatedBFieldInfo=etype.saturatedBFieldInfo,

            allInvariants=etype.allInvariants,
            allValidates=etype.allValidates,

            fields=etype.fields.map<MemberFieldDecl>(fn(fd) => this.processMemberFieldDecl(fd))
        };
    }

    method processDatatypeMemberEntityTypeDecl(dmtype: DatatypeMemberEntityTypeDecl): DatatypeMemberEntityTypeDecl {
        return DatatypeMemberEntityTypeDecl{
            file=dmtype.file,
            sinfo=dmtype.sinfo,
            fullns = dmtype.fullns,
            declaredInNS=dmtype.declaredInNS,
            
            tkey=dmtype.tkey,
            name=dmtype.name,

            invariants=dmtype.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=dmtype.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=dmtype.absmethods,
            virtmethods=dmtype.virtmethods,
            overmethods=dmtype.overmethods,
            staticmethods=dmtype.staticmethods,

            saturatedProvides=dmtype.saturatedProvides,
            saturatedBFieldInfo=dmtype.saturatedBFieldInfo,

            allInvariants=dmtype.allInvariants,
            allValidates=dmtype.allValidates,

            fields=dmtype.fields.map<MemberFieldDecl>(fn(fd) => this.processMemberFieldDecl(fd)),
            parentTypeDecl=dmtype.parentTypeDecl
        };
    }

    method processOptionTypeDecl(oconcept: OptionTypeDecl): OptionTypeDecl {
        return OptionTypeDecl{
            file=oconcept.file,
            sinfo=oconcept.sinfo,
            fullns = oconcept.fullns,
            declaredInNS=oconcept.declaredInNS,

            tkey=oconcept.tkey,
            name=oconcept.name,

            invariants=oconcept.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=oconcept.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=oconcept.absmethods,
            virtmethods=oconcept.virtmethods,
            overmethods=oconcept.overmethods,
            staticmethods=oconcept.staticmethods,

            saturatedProvides=oconcept.saturatedProvides,
            saturatedBFieldInfo=oconcept.saturatedBFieldInfo,

            allInvariants=oconcept.allInvariants,
            allValidates=oconcept.allValidates,

            subtypes=oconcept.subtypes,
            
            oftype=oconcept.oftype,
            someType=oconcept.someType
        };
    }

    method processPrimitiveConceptTypeDecl(pconcept: PrimitiveConceptTypeDecl): PrimitiveConceptTypeDecl {
        match(pconcept)@ {
            | OptionTypeDecl => { return this.processOptionTypeDecl($pconcept); }
            | ResultTypeDecl => { abort; }
            | APIResultTypeDecl => { abort; }
        }
    }

    method processConceptTypeDecl(cconcept: ConceptTypeDecl): ConceptTypeDecl {
        return ConceptTypeDecl{
            file=cconcept.file,
            sinfo=cconcept.sinfo,
            fullns = cconcept.fullns,
            declaredInNS=cconcept.declaredInNS,

            tkey=cconcept.tkey,
            name=cconcept.name,

            invariants=cconcept.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=cconcept.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=cconcept.absmethods,
            virtmethods=cconcept.virtmethods,
            overmethods=cconcept.overmethods,
            staticmethods=cconcept.staticmethods,

            saturatedProvides=cconcept.saturatedProvides,
            saturatedBFieldInfo=cconcept.saturatedBFieldInfo,

            allInvariants=cconcept.allInvariants,
            allValidates=cconcept.allValidates,

            subtypes=cconcept.subtypes,
            fields=cconcept.fields.map<MemberFieldDecl>(fn(fd) => this.processMemberFieldDecl(fd))
        };
    }

    method processDatatypeTypeDecl(ddatatype: DatatypeTypeDecl): DatatypeTypeDecl {
        return DatatypeTypeDecl {
            file=ddatatype.file,
            sinfo=ddatatype.sinfo,
            fullns = ddatatype.fullns,
            declaredInNS=ddatatype.declaredInNS,
            
            tkey=ddatatype.tkey,
            name=ddatatype.name,

            invariants=ddatatype.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=ddatatype.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=ddatatype.absmethods,
            virtmethods=ddatatype.virtmethods,
            overmethods=ddatatype.overmethods,
            staticmethods=ddatatype.staticmethods,

            saturatedProvides=ddatatype.saturatedProvides,
            saturatedBFieldInfo=ddatatype.saturatedBFieldInfo,

            allInvariants=ddatatype.allInvariants,
            allValidates=ddatatype.allValidates,

            subtypes=ddatatype.subtypes,

            fields=ddatatype.fields.map<MemberFieldDecl>(fn(fd) => this.processMemberFieldDecl(fd)),
            associatedMemberEntityDecls=ddatatype.associatedMemberEntityDecls
        };
    }

    function process(assembly: Assembly): Assembly {
        let simplifier = ConstantSimplification{ assembly };

        return Assembly{
            nsconsts = assembly.nsconsts.map<NamespaceConstDecl>(fn(nsconst) => simplifier.processNamespaceConstDecl(nsconst)),
            typeconsts = assembly.typeconsts.map<ConstMemberDecl>(fn(typeconst) => simplifier.processConstMemberDecl(typeconst)),

            nsfuncs = assembly.nsfuncs.map<NamespaceFunctionDecl>(fn(ikey, nsfunc) => simplifier.processNamespaceFunctionDecl(nsfunc)),
            typefuncs = assembly.typefuncs.map<TypeFunctionDecl>(fn(ikey, typefunc) => simplifier.processTypeFunctionDecl(typefunc)),

            absmethods = assembly.absmethods.map<MethodDeclAbstract>(fn(ikey, absmethod) => simplifier.processMethodDeclAbstract(absmethod)),
            virtmethods = assembly.virtmethods.map<MethodDeclVirtual>(fn(ikey, virtmethod) => simplifier.processMethodDeclVirtual(virtmethod)),
            overmethods = assembly.overmethods.map<MethodDeclOverride>(fn(ikey, overmethod) => simplifier.processMethodDeclOverride(overmethod)),
            staticmethods = assembly.staticmethods.map<MethodDeclStatic>(fn(ikey, staticmethod) => simplifier.processMethodDeclStatic(staticmethod)),

            enums = assembly.enums,
            typedecls = assembly.typedecls.map<TypedeclTypeDecl>(fn(ikey, typedecl) => simplifier.processTypedeclTypeDecl(typedecl)),
            stringoftypedecls = assembly.stringoftypedecls.map<TypedeclStringOfTypeDecl>(fn(ikey, typedecl) => simplifier.processTypedeclStringOfTypeDecl(typedecl)),

            primtives = assembly.primtives,
            constructables = assembly.constructables,
            collections = assembly.collections,

            entities = assembly.entities.map<EntityTypeDecl>(fn(ikey, etype) => simplifier.processEntityTypeDecl(etype)),
            datamembers = assembly.datamembers.map<DatatypeMemberEntityTypeDecl>(fn(ikey, dmtype) => simplifier.processDatatypeMemberEntityTypeDecl(dmtype)),

            pconcepts = assembly.pconcepts.map<PrimitiveConceptTypeDecl>(fn(ikey, pconcept) => simplifier.processPrimitiveConceptTypeDecl(pconcept)),
            concepts = assembly.concepts.map<ConceptTypeDecl>(fn(ikey, cconcept) => simplifier.processConceptTypeDecl(cconcept)),

            datatypes = assembly.datatypes.map<DatatypeTypeDecl>(fn(ikey, ddatatype) => simplifier.processDatatypeTypeDecl(ddatatype)),

            allfuncs = assembly.allfuncs,
            allmethods = assembly.allmethods,
            allvmethods = assembly.allvmethods,

            allconcretetypes = assembly.allconcretetypes,
            allabstracttypes = assembly.allabstracttypes,
            typetopo = assembly.typetopo
        };
    }
}
