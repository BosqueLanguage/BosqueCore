namespace BSQAssembly;

%*
 * Rewrite the IR to do constant folding, constant propagation, flow/test simplification, and dead code elimination
 *%
entity ConstantSimplification {
    field assembly: Assembly;

    const trueExp: Expression = LiteralSimpleExpression{ SourceInfo{0n, 0n, 0n, 0n}, NominalTypeSignature{SourceInfo{0n, 0n, 0n, 0n}, 'Bool'<TypeKey>}, 'true' };
    const falseExp: Expression = LiteralSimpleExpression{ SourceInfo{0n, 0n, 0n, 0n}, NominalTypeSignature{SourceInfo{0n, 0n, 0n, 0n}, 'Bool'<TypeKey>}, 'false' };

    function isTerminalStatement(stmt: Statement): Bool {
        return \/(stmt?<ReturnVoidStatement>, stmt?<ReturnSingleStatement>, stmt?<ReturnMultiStatement>, stmt?<AbortStatement>);
    }

    recursive method tryResolveExpAsLiteralExpression(exp: Expression): Option<Expression> {
        match(exp)@ {
            AccessNamespaceConstantExpression => {
                let cc = this.assembly.nsconsts.find(pred(nsconst) => /\(nsconst.name === $exp.name, nsconst.declaredInNS === $exp.ns));
                return this.tryResolveExpAsLiteralExpression[recursive](cc.value);
            }
            | AccessStaticFieldExpression => {
                let cc = this.assembly.typeconsts.find(pred(tconst) => /\(tconst.name === $exp.name, tconst.declaredInType.tkeystr === $exp.stype.tkeystr));
                return this.tryResolveExpAsLiteralExpression[recursive](cc.value);
            }
            | AccessEnumExpression => {
                return some(exp);
            }
            | LiteralNoneExpression => {
                return some(exp);
            }
            | LiteralSimpleExpression => {
                return some(exp);
            }
            | LiteralCStringExpression => {
                return some(exp);
            }
            | LiteralStringExpression => {
                return some(exp);
            }
            | LiteralTypeDeclValueExpression => {
                let tdecl = this.assembly.lookupNominalTypeDeclaration($exp.constype.tkeystr);
                
                if(!tdecl.allInvariants.empty()) {
                    return none;
                }
                else {
                    return some(exp);
                }
            }
            | _ => {
                return none;
            }
        }
    }

    method processITestTypeAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestType): PostfixOperation {
        if(itest.isnot) {
            if(this.assembly.isSubtypeOf(srctype, itest.ttype)) {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
            elif(this.assembly.areDisjoint(itest.ttype, srctype)) {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
            else {
                return PostfixIsTest { sinfo, srctype, itest };
            }
        }
        else {
            if(this.assembly.isSubtypeOf(srctype, itest.ttype)) {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
            elif(this.assembly.areDisjoint(itest.ttype, srctype)) {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
            else {
                return PostfixIsTest { sinfo, srctype, itest };
            }
        }
    }

    method processITestNoneAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestNone): PostfixOperation {
        if(srctype.tkeystr === 'None'<TypeKey>) {
            if(itest.isnot) {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
            else {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
        }
        elif(srctype.tkeystr === 'Some'<TypeKey>) {
            if(itest.isnot) {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
            else {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
        }
        else {
            return PostfixIsTest { sinfo, srctype, itest };
        }
    }

    method processITestSomeAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestSome): PostfixOperation {
        if(srctype.tkeystr === 'None'<TypeKey>) {
            if(itest.isnot) {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
            else {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
        }
        elif(srctype.tkeystr === 'Some'<TypeKey>) {
            if(itest.isnot) {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
            else {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
        }
        else {
            return PostfixIsTest { sinfo, srctype, itest };
        }
    }

    method processITestOkAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestOk): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestFailAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestFail): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITest): PostfixOperation {
        match(itest)@ {
            ITestType => { return this.processITestTypeAsTest(sinfo, srctype, $itest); }
            | ITestNone => { return this.processITestNoneAsTest(sinfo, srctype, $itest); }
            | ITestSome => { return this.processITestSomeAsTest(sinfo, srctype, $itest); }
            | ITestOk => { return this.processITestOkAsTest(sinfo, srctype, $itest); }
            | ITestFail => { return this.processITestFailAsTest(sinfo, srctype, $itest); }
        }
    }

    method processITestTypeAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestType): PostfixOperation {
        if(itest.isnot) {
            if(this.assembly.isSubtypeOf(srctype, itest.ttype)) {
                return PostfixAbort{ sinfo, srctype, none };
            }
            elif(this.assembly.areDisjoint(itest.ttype, srctype)) {
                return PostfixNop{ sinfo, srctype };
            }
            else {
                return PostfixAsConvert { sinfo, srctype, itest };
            }
        }
        else {
            if(this.assembly.isSubtypeOf(srctype, itest.ttype)) {
                return PostfixNop{ sinfo, srctype };
            }
            elif(this.assembly.areDisjoint(itest.ttype, srctype)) {
                return PostfixAbort{ sinfo, srctype, none };
            }
            else {
                return PostfixAsConvert { sinfo, srctype, itest };
            }
        }
    }

    method processITestNoneAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestNone): PostfixOperation {
        if(srctype.tkeystr === 'None'<TypeKey>) {
            if(itest.isnot) {
                return PostfixAbort{ sinfo, srctype, none };
            }
            else {
                return PostfixNop{ sinfo, srctype };
            }
        }
        elif(srctype.tkeystr === 'Some'<TypeKey>) {
            if(itest.isnot) {
                return PostfixAccessSomeValue{ sinfo, srctype };
            }
            else {
                return PostfixAbort{ sinfo, srctype, none };
            }
        }
        else {
            return PostfixAsConvert { sinfo, srctype, itest };
        }
    }

    method processITestSomeAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestSome): PostfixOperation {
        if(srctype.tkeystr === 'None'<TypeKey>) {
            if(itest.isnot) {
                return PostfixNop{ sinfo, srctype};
            }
            else {
                return PostfixAbort{ sinfo, srctype, none };
            }
        }
        elif(srctype.tkeystr === 'Some'<TypeKey>) {
            if(itest.isnot) {
                return PostfixAbort{ sinfo, srctype, none };
            }
            else {
                return PostfixAccessSomeValue{ sinfo, srctype };
            }
        }
        else {
            return PostfixAsConvert { sinfo, srctype, itest };
        }
    }

    method processITestOkAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestOk): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestFailAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestFail): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITest): PostfixOperation {
        match(itest)@ {
            ITestType => { return this.processITestTypeAsConvert(sinfo, srctype, $itest); }
            | ITestNone => { return this.processITestNoneAsConvert(sinfo, srctype, $itest); }
            | ITestSome => { return this.processITestSomeAsConvert(sinfo, srctype, $itest); }
            | ITestOk => { return this.processITestOkAsConvert(sinfo, srctype, $itest); }
            | ITestFail => { return this.processITestFailAsConvert(sinfo, srctype, $itest); }
        }
    }

    recursive method processArgs(args: List<Expression>): List<Expression> {
        return args.map[recursive]<Expression>(recursive fn(arg) => this.processExpression[recursive](arg));
    }

    recursive method processUnaryArg(arg: Expression): Expression {
        return this.processExpression[recursive](arg);
    }

    recursive method processBinaryArgs(lhs: Expression, rhs: Expression): Expression, Expression {
        return this.processExpression[recursive](lhs), this.processExpression[recursive](rhs);
    }

    recursive method processArgumentList(argl: ArgumentList): ArgumentList {
        let nargs = argl.args.map[recursive]<ArgumentValue>(recursive fn(arg) => {
            let nexp = this.processExpression[recursive](arg.exp);
            return arg[exp=nexp];
        });

        return ArgumentList{ nargs };
    }

    method processAccessNamespaceConstantExpression(e: AccessNamespaceConstantExpression): Expression {
        let sexp = this.tryResolveExpAsLiteralExpression(e);
        if(sexp)@none {
            return e;
        }
        else {
            return $sexp;
        }
    }

    method processAccessStaticFieldExpression(e: AccessStaticFieldExpression): Expression {
        let sexp = this.tryResolveExpAsLiteralExpression(e);
        if(sexp)@none {
            return e;
        }
        else {
            return $sexp;
        }
    }

    recursive method processConstructorExpression(e: ConstructorExpression): Expression {
        let nargs = this.processArgumentList[recursive](e.args);
        return e[args=nargs];
    }

    recursive method processConstructorLambdaExpression(e: ConstructorLambdaExpression): Expression {
        let nbody = this.processBodyImpl[recursive](e.body);

        return e[body=nbody];
    }

    recursive method processLambdaInvokeExpression(e: LambdaInvokeExpression): Expression {
        let nargs = this.processArgumentList[recursive](e.argsinfo.args);
        return e[argsinfo=$argsinfo[args=nargs]];
    }

    recursive method processCallNamespaceFunctionExpression(e: CallNamespaceFunctionExpression): Expression {
        let nargs = this.processArgumentList[recursive](e.argsinfo.args);
        return e[argsinfo=$argsinfo[args=nargs]];
    }

    recursive method processCallTypeFunctionExpression(e: CallTypeFunctionExpression): Expression {
        let nargs = this.processArgumentList[recursive](e.argsinfo.args);
        return e[argsinfo=$argsinfo[args=nargs]];
    }

    recursive method processLogicActionAndExpression(e: LogicActionAndExpression): Expression {
        let nargs = this.processArgs(e.args);

        let cfalse = nargs.someOf(pred(arg) => arg?<LiteralSimpleExpression> && arg@<LiteralSimpleExpression>.value === 'false');
        if(cfalse) {
            return ConstantSimplification::falseExp;
        }
        else {
            let sargs = nargs.filter(pred(arg) => arg?!<LiteralSimpleExpression>);
            
            if(sargs.empty()) {
                return ConstantSimplification::falseExp;
            }
            else {
                if(sargs.isSingle()) {
                    return sargs.single();
                }
                else {
                    return e[args=sargs];
                }
            }
        }
    }

    recursive method processLogicActionOrExpression(e: LogicActionOrExpression): Expression {
        let nargs = this.processArgs(e.args);

        let ctrue = nargs.someOf(pred(arg) => arg?<LiteralSimpleExpression> && arg@<LiteralSimpleExpression>.value === 'true');
        if(ctrue) {
            return ConstantSimplification::trueExp;
        }
        else {
            let sargs = nargs.filter(pred(arg) => arg?!<LiteralSimpleExpression>);

            if(sargs.empty()) {
                return ConstantSimplification::falseExp;
            }
            else {
                if(sargs.isSingle()) {
                    return sargs.single();
                }
                else {
                    return e[args=sargs];
                }
            }
        }
    }

    recursive method processCoerceNarrowTypeExpression(e: CoerceNarrowTypeExpression): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp);
        return e[exp=nexp];
    }

    recursive method processCoerceWidenTypeExpression(e: CoerceWidenTypeExpression): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp);
        return e[exp=nexp];
    }

    recursive method processSafeConvertExpression(e: SafeConvertExpression): Expression {
        let nexp = this.processUnaryArg[recursive](e.exp);
        return e[exp=nexp];
    }

    recursive method processPostfixInvokeStatic(op: PostfixInvokeStatic): PostfixInvokeStatic {
        let nargs = this.processArgumentList[recursive](op.argsinfo.args);
        return op[argsinfo=$argsinfo[args=nargs]];
    }

    recursive method processPostfixOp(e: PostfixOp): Expression {
        let ebase = this.processUnaryArg[recursive](e.rootExp);
        let ops = e.ops.map[recursive]<PostfixOperation>(recursive fn(op) => {
            match(op)@ {
                PostfixAccessFromName => { return $op; }
                | PostfixProjectFromNames => { return $op; }
                | PostfixAccessFromIndex => { return $op; }
                | PostfixIsTest => { return this.processITestAsTest($op.sinfo, $op.baseType, $op.ttest); }
                | PostfixAsConvert => { return this.processITestAsConvert($op.sinfo, $op.baseType, $op.ttest); }
                | PostfixAssignFields => { abort; }
                | PostfixInvokeStatic => { return this.processPostfixInvokeStatic($op); }
                | PostfixInvokeVirtual => { abort; }
                | PostfixLiteralKeyAccess => { abort; }
                | PostfixBoolConstant => { return $op; }
                | PostfixNop => { return $op; }
                | PostfixAbort => { return $op; }
                | PostfixWidenConvert => { return $op; }
                | PostfixAccessSomeValue => { return $op; }
                | PostfixLiteralNoneValue => { return $op; } 
            }
        });

        var sops = ops.filter(pred(op) => op?!<PostfixNop>);
        let hasabort = sops.someOf(pred(op) => op?<PostfixAbort>);
        if(hasabort) {
            abort; %%TODO: we should trim the list if we have a PostfixAbort -- also set the type of the abort to be the final e.type
        }

        return PostfixOp{ e.sinfo, e.etype, ebase, sops };
    }

    function negateLiteralBoolean(v: CString, sinfo: SourceInfo, btype: TypeSignature): Expression {
        var val: CString;

        if(v === 'true') {
            val = 'false';
        }
        else {
            val = 'true';
        }

        return LiteralSimpleExpression{ sinfo, btype, val };
    }

    function negateLiteralNumber(v: CString, sinfo: SourceInfo, ntype: TypeSignature): Expression {
        var val: CString;

        if(v === '0') {
            val = '0';
        }
        else {
            if(v.startsWithString('-')) {
                val = v.removePrefixString('-');
            }
            else {
                val = v.prepend('-');
            }
        }

        return LiteralSimpleExpression{ sinfo, ntype, val };
    }

    function processPrefixNotOpExpression(e: PrefixNotOpExpression, ee: Expression): Expression {
        match(ee)@ {
            LiteralSimpleExpression => {
                return ConstantSimplification::negateLiteralBoolean($ee.value, e.sinfo, e.opertype);
            }
            | PrefixNotOpExpression => {
                return $ee.exp;
            }
            | _ => {
                return e[exp=ee];
            }
        }
    }

    function processPrefixNegateOpExpression(e: PrefixNegateOpExpression, ee: Expression): Expression {
        match(ee)@ {
            LiteralSimpleExpression => {
                return ConstantSimplification::negateLiteralNumber($ee.value, e.sinfo, e.opertype);
            }
            | PrefixNegateOpExpression => {
                return $ee.exp;
            }
            | _ => {
                return e[exp=ee];
            }
        }
    }

    function processPrefixPlusOpExpression(e: PrefixPlusOpExpression, ee: Expression): Expression {
        return ee;
    }

    recursive method processUnaryExpression(e: UnaryExpression): Expression {
        let ee = this.processUnaryArg(e.exp);

        match(e)@ {
            PrefixNotOpExpression => { return ConstantSimplification::processPrefixNotOpExpression($e, ee); }
            | PrefixNegateOpExpression => { return ConstantSimplification::processPrefixNegateOpExpression($e, ee); }
            | PrefixPlusOpExpression => { return ConstantSimplification::processPrefixPlusOpExpression($e, ee); }
        }
    }

    recursive method processBinaryArithExpression(e: BinaryArithExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);

        %%TODO: here is where we would like to do some constant folding and algebraic simplification

        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method processBinKeyEqNoneExpression(e: BinKeyEqNoneExpression): Expression {
        let ee = this.processUnaryArg(e.exp);
        let etype = this.assembly.lookupNominalTypeDeclaration(ee.etype.tkeystr);

        if(etype.tkey === 'None'<TypeKey>) {
            return ConstantSimplification::trueExp;
        }
        else {
            if(etype)<SomeTypeDecl> {
                return ConstantSimplification::falseExp;
            }
            else {
                return e[exp=ee];
            }
        }
    }

    recursive method processBinKeyNotEqNoneExpression(e: BinKeyNotEqNoneExpression): Expression {
        let ee = this.processUnaryArg(e.exp);
        let etype = this.assembly.lookupNominalTypeDeclaration(ee.etype.tkeystr);

        if(etype.tkey === 'None'<TypeKey>) {
            return ConstantSimplification::falseExp;
        }
        else {
            if(etype)<SomeTypeDecl> {
                return ConstantSimplification::trueExp;
            }
            else {
                return e[exp=ee];
            }
        }
    }

    recursive method processBinKeySomeEqExpression(e: BinKeySomeEqExpression): Expression {
        let noption, nval = this.processBinaryArgs(e.eqoption, e.eqval);
        let etype = this.assembly.lookupNominalTypeDeclaration(noption.etype.tkeystr);

        if(etype.tkey === 'None'<TypeKey>) {
            return ConstantSimplification::falseExp;
        }
        else {
            if(etype)<SomeTypeDecl> {
                abort; %%Not implemented -- explicitly unwrap and compare here
            }
            else {
                return e[eqoption=noption, eqval=nval];
            }
        }
    }

    recursive method processBinKeyNotSomeEqExpression(e: BinKeyNotSomeEqExpression): Expression {
        let noption, nval = this.processBinaryArgs(e.neoption, e.neval);
        let etype = this.assembly.lookupNominalTypeDeclaration(noption.etype.tkeystr);

        if(etype.tkey === 'None'<TypeKey>) {
            return ConstantSimplification::trueExp;
        }
        else {
            if(etype)<SomeTypeDecl> {
                abort; %%Not implemented -- explicitly unwrap and compare here
            }
            else {
                return e[neoption=noption, neval=nval];
            }
        }
    }

    recursive method processBinKeyEqExpression(e: BinKeyEqExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);

        %%TODO: here is where we would like to do some basic constant checks

        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method processBinKeyNotEqExpression(e: BinKeyNotEqExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);

        %%TODO: here is where we would like to do some basic const checks

        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method processBinaryKeyEqExpression(e: BinaryKeyEqExpression): Expression {
        match(e)@ {
            BinKeyEqNoneExpression => { return this.processBinKeyEqNoneExpression[recursive]($e); }
            | BinKeyNotEqNoneExpression => { return this.processBinKeyNotEqNoneExpression[recursive]($e); }
            | BinKeySomeEqExpression => { return this.processBinKeySomeEqExpression[recursive]($e); }
            | BinKeyNotSomeEqExpression => { return this.processBinKeyNotSomeEqExpression[recursive]($e); }
            | BinKeyEqExpression => { return this.processBinKeyEqExpression[recursive]($e); }
            | BinKeyNotEqExpression => { return this.processBinKeyNotEqExpression[recursive]($e); }
        }
    }

    recursive method processBinaryNumericExpression(e: BinaryNumericExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);

        %%TODO: here is where we would like to do some algebraic simplification

        return e[lhs=nlhs, rhs=nrhs];
    }

    method simplifyBinAnd(e: BinLogicExpression, nlhs: Expression, nrhs: Expression): Expression {
        if(nlhs)@!<LiteralSimpleExpression> {
            return e[lhs=nlhs, rhs=nrhs];
        }
        else {
            if($nlhs.value === 'false') {
                return ConstantSimplification::falseExp;
            }
            else {
                return nrhs;
            }
        }
    }

    method simplifyBinOr(e: BinLogicExpression, nlhs: Expression, nrhs: Expression): Expression {
        if(nrhs)@!<LiteralSimpleExpression> {
            return e[lhs=nlhs, rhs=nrhs];
        }
        else {
            if($nrhs.value === 'true') {
                return ConstantSimplification::trueExp;
            }
            else {
                return nrhs;
            }
        }
    }

    method simplifyBinImplies(e: BinLogicExpression, nlhs: Expression, nrhs: Expression): Expression {
        if(nlhs)@!<LiteralSimpleExpression> {
            return e[lhs=nlhs, rhs=nrhs];
        }
        else {
            if($nlhs.value === 'false') {
                return ConstantSimplification::trueExp;
            }
            else {
                return nrhs;
            }
        }
    }

    method simplifyBinIFF(e: BinLogicExpression, nlhs: Expression, nrhs: Expression): Expression {
        if(nlhs?!<LiteralSimpleExpression> || nrhs?!<LiteralSimpleExpression>) {
            return e[lhs=nlhs, rhs=nrhs];
        }
        else {
            if(nlhs@<LiteralSimpleExpression>.value === nrhs@<LiteralSimpleExpression>.value) {
                return ConstantSimplification::trueExp;
            }
            else {
                return ConstantSimplification::falseExp;
            }
        }
    }

    recursive method processBinLogicExpression(e: BinLogicExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);
        
        match(e)@ {
            BinLogicAndExpression => { return this.simplifyBinAnd($e, nlhs, nrhs); }
            | BinLogicOrExpression => { return this.simplifyBinOr($e, nrhs, nlhs); } 
            | BinLogicImpliesExpression => { return this.simplifyBinImplies($e, nlhs, nrhs); }
            | BinLogicIFFExpression => { return this.simplifyBinIFF($e, nlhs, nrhs); }
        }
    }

    recursive method processIfSimpleExpression(e: IfSimpleExpression): Expression {
        let ntexp = this.processExpression[recursive](e.texp);
        let nthen = this.processExpression[recursive](e.thenexp);
        let nelse = this.processExpression[recursive](e.elseexp);

        if(ntexp)@!<LiteralSimpleExpression> {
            return e[texp=ntexp, thenexp=nthen, elseexp=nelse];
        }
        else {
            if($ntexp.value === 'true') {
                return nthen;
            }
            else {
                return nelse;
            }
        }
    }

    recursive method processIfTestExpression(e: IfTestExpression): Expression {
        let ntexp = this.processExpression[recursive](e.texp);
        let nthen = this.processExpression[recursive](e.thenexp);
        let nelse = this.processExpression[recursive](e.elseexp);

        let op = this.processITestAsTest(ntexp.sinfo, ntexp.etype, e.itest);
        if(op)@!<PostfixBoolConstant> {
            return e[texp=ntexp, thenexp=nthen, elseexp=nelse];
        }
        else {
            if($op.value) {
                return nthen;
            }
            else {
                return nelse;
            }
        }
    }

    recursive method processIfBinderExpression(e: IfBinderExpression): Expression {
        let ntexp = this.processExpression[recursive](e.texp);
        let nthen = this.processExpression[recursive](e.thenexp);
        let nelse = this.processExpression[recursive](e.elseexp);

        let op = this.processITestAsTest(ntexp.sinfo, ntexp.etype, e.itest);
        if(op)@!<PostfixBoolConstant> {
            return e[texp=ntexp, thenexp=nthen, elseexp=nelse];
        }
        else {
            if($op.value) {
                return nthen;
            }
            else {
                return nelse;
            }
        }
    }

    recursive method processIfExpression(e: IfExpression): Expression {
        match(e)@ {
            IfSimpleExpression => { return this.processIfSimpleExpression[recursive]($e); }
            | IfTestExpression => { return this.processIfTestExpression[recursive]($e); }
            | IfBinderExpression => { return this.processIfBinderExpression[recursive]($e); }
        }
    }

    recursive method processExpression(e: Expression): Expression {
        match(e)@ {
            LiteralNoneExpression => { return e; }
            | LiteralSimpleExpression => { return e; }
            | LiteralCStringExpression => { return e; }
            | LiteralStringExpression => { return e; }  
            | LiteralCRegexExpression => { return e; }
            | LiteralRegexExpression => { return e; }
            | LiteralTypeDeclValueExpression => { abort; }
            | AccessNamespaceConstantExpression => { return this.processAccessNamespaceConstantExpression($e); }
            | AccessStaticFieldExpression => { return this.processAccessStaticFieldExpression($e); }
            | AccessEnumExpression => { return e; }
            | AccessVariableExpression => { return e; }
            | AccessCapturedVariableExpression => { return e; }
            | ConstructorExpression => { return this.processConstructorExpression[recursive]($e); }
            | ConstructorLambdaExpression => { return this.processConstructorLambdaExpression[recursive]($e); }
            | LetExpression => { abort; }
            | LambdaInvokeExpression => { return this.processLambdaInvokeExpression[recursive]($e); }
            | CallNamespaceFunctionExpression => { return this.processCallNamespaceFunctionExpression[recursive]($e); }
            | CallTypeFunctionExpression => { return this.processCallTypeFunctionExpression[recursive]($e); }
            | CallTypeFunctionSpecialExpression => { abort; }
            | CallRefInvokeStaticResolveExpression => { abort; }
            | CallRefInvokeVirtualExpression => { abort; }
            | LogicActionAndExpression => { return this.processLogicActionAndExpression[recursive]($e); }
            | LogicActionOrExpression => { return this.processLogicActionOrExpression[recursive]($e); }
            | TypeDeclPrimitiveFieldAccessExpression => { abort; }
            | CoerceNarrowTypeExpression => { return this.processCoerceNarrowTypeExpression[recursive]($e); }
            | CoerceWidenTypeExpression => { return this.processCoerceWidenTypeExpression[recursive]($e); }
            | SafeConvertExpression => { return this.processSafeConvertExpression[recursive]($e); }
            | CreateDirectExpression => { abort; }
            | PostfixOp => { return this.processPostfixOp[recursive]($e); }
            | UnaryExpression => { return this.processUnaryExpression[recursive]($e); }
            | BinaryArithExpression => { return this.processBinaryArithExpression[recursive]($e); }
            | BinaryKeyEqExpression => { return this.processBinaryKeyEqExpression[recursive]($e); }
            | KeyCmpEqualExpression => { abort; }
            | KeyCmpLessExpression => { abort; }
            | BinaryNumericExpression => { return this.processBinaryNumericExpression[recursive]($e); }
            | BinLogicExpression => { return this.processBinLogicExpression[recursive]($e); }
            | MapEntryConstructorExpression => { abort; }
            | IfExpression => { return this.processIfExpression[recursive]($e); }
        }
    }

    method processAssertStatement(s: AssertStatement): Statement {
        let ncond = this.processExpression(s.cond);
        
        if(ncond)@!<LiteralSimpleExpression> {
            return s[cond = $ncond];
        }
        else {
            if($ncond.value === 'true') {
                return EmptyStatement{ s.sinfo };
            }
            else{
                return AbortStatement{ s.sinfo };
            }
        }
    }

    recursive method processIfSimpleStatement(s: IfSimpleStatement): Statement {
        let ntexp = this.processExpression[recursive](s.texp);
        let ntb = this.processBlockStatement[recursive](s.trueBlock);

        if(ntexp)@!<LiteralSimpleExpression> {
            return s[texp=ntexp, trueBlock=ntb];
        }
        else {
            if($ntexp.value === 'true') {
                return ntb;
            }
            else {
                return EmptyStatement{ s.sinfo };
            }
        }
    }

    recursive method processIfTestStatement(s: IfTestStatement): Statement {
        let ntexp = this.processExpression[recursive](s.texp);
        let ntb = this.processBlockStatement[recursive](s.trueBlock);

        let op = this.processITestAsTest(ntexp.sinfo, ntexp.etype, s.itest);
        if(op)@!<PostfixBoolConstant> {
            return s[texp=ntexp, trueBlock=ntb];
        }
        else {
            if($op.value) {
                return ntb;
            }
            else {
                return EmptyStatement{ s.sinfo };
            }
        }
    }

    recursive method processIfBinderStatement(s: IfBinderStatement): Statement {
        let ntexp = this.processExpression[recursive](s.texp);
        let ntb = this.processBlockStatement[recursive](s.trueBlock);

        let op = this.processITestAsTest(ntexp.sinfo, ntexp.etype, s.itest);
        if(op)@!<PostfixBoolConstant> {
            return s[texp=ntexp, trueBlock=ntb];
        }
        else {
            if($op.value) {
                return ntb;
            }
            else {
                return EmptyStatement{ s.sinfo };
            }
        }
    }

    recursive method processIfStatement(s: IfStatement): Statement {
        match(s)@ {
            IfSimpleStatement => { return this.processIfSimpleStatement[recursive]($s); }
            | IfTestStatement => { return this.processIfTestStatement[recursive]($s); }
            | IfBinderStatement => { return this.processIfBinderStatement[recursive]($s); }
        }
    }

    recursive method processIfElseSimpleStatement(s: IfElseSimpleStatement): Statement {
        let ntexp = this.processExpression[recursive](s.texp);
        let ntb = this.processBlockStatement[recursive](s.trueBlock);
        let nfb = this.processBlockStatement[recursive](s.falseBlock);

        if(ntexp)@!<LiteralSimpleExpression> {
            return s[texp=ntexp, trueBlock=ntb, falseBlock=nfb];
        }
        else {
            if($ntexp.value === 'true') {
                return ntb;
            }
            else {
                return nfb;
            }
        }
    }

    recursive method processIfElseTestStatement(s: IfElseTestStatement): Statement {
        let ntexp = this.processExpression[recursive](s.texp);
        let ntb = this.processBlockStatement[recursive](s.trueBlock);
        let nfb = this.processBlockStatement[recursive](s.falseBlock);

        let op = this.processITestAsTest(ntexp.sinfo, ntexp.etype, s.itest);
        if(op)@!<PostfixBoolConstant> {
            return s[texp=ntexp, trueBlock=ntb, falseBlock=nfb];
        }
        else {
            if($op.value) {
                return ntb;
            }
            else {
                return nfb;
            }
        }
    }

    recursive method processIfElseBinderStatement(s: IfElseBinderStatement): Statement {
        let ntexp = this.processExpression[recursive](s.texp);
        let ntb = this.processBlockStatement[recursive](s.trueBlock);
        let nfb = this.processBlockStatement[recursive](s.falseBlock);

        let op = this.processITestAsTest(ntexp.sinfo, ntexp.etype, s.itest);
        if(op)@!<PostfixBoolConstant> {
            return s[texp=ntexp, trueBlock=ntb, falseBlock=nfb];
        }
        else {
            if($op.value) {
                return ntb;
            }
            else {
                return nfb;
            }
        }
    }

    recursive method processIfElseStatement(s: IfElseStatement): Statement {
        match(s)@ {
            IfElseSimpleStatement => { return this.processIfElseSimpleStatement[recursive]($s); }
            | IfElseTestStatement => { return this.processIfElseTestStatement[recursive]($s); }
            | IfElseBinderStatement => { return this.processIfElseBinderStatement[recursive]($s); }
        }
    }

    recursive method processIfElifElseStatement(s: IfElifElseStatement): Statement {
        let nifcond = this.processExpression[recursive](s.ifcond);
        let nifflow = this.processBlockStatement[recursive](s.ifflow);
        let ncondflow = s.condflow
            .map<(|Expression, BlockStatement|)>(fn(eb) 
                => (|this.processExpression[recursive](eb.0), this.processBlockStatement(eb.1)|));
        let nelseflow = this.processBlockStatement(s.elseflow);

        if(nifcond?<LiteralSimpleExpression> && nifcond@<LiteralSimpleExpression>.value === 'true') {
            return nifflow;
        }
        else {
            return ncondflow.lreduce<Statement>(nelseflow, fn(acc, eb) => {
                let cur = eb.0;
                if(cur)@!<LiteralSimpleExpression> {
                    return s[ifcond=nifcond, ifflow=nifflow, condflow=ncondflow, elseflow=nelseflow];
                }
                else {
                    if($cur.value === 'true') {
                        return eb.1;
                    }
                    else {
                        return acc;
                    }
                }
            });
        }
    }

    recursive method processStatement(s: Statement): Statement {
        match(s)@ {
            VariableDeclarationStatement => {
                return s;
            }
            | VariableMultiDeclarationStatement => {
                return s;
            }
            | VariableInitializationStatement => {
                return $s[exp = this.processExpression($exp)];
            }
            | VariableMultiInitializationExplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | VariableMultiInitializationImplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | VariableAssignmentStatement => {
                return $s[exp = this.processExpression($exp)];
            }
            | VariableMultiAssignmentExplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | VariableMultiAssignmentImplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | ReturnVoidStatement => {
                return s;
            }
            | ReturnSingleStatement => {
                return $s[value = this.processExpression($value)];
            }
            | ReturnMultiStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | IfStatement => {
                return this.processIfStatement[recursive]($s);
            }
            | IfElseStatement => {
                return this.processIfElseStatement[recursive]($s);
            }
            | IfElifElseStatement => {
                return this.processIfElifElseStatement[recursive]($s);
            }
            | AbortStatement => {
                return s;
            }
            | AssertStatement => {
                return this.processAssertStatement($s);
            }
        }
    }

    recursive method processBlockStatement(s: BlockStatement): BlockStatement {
        let nstmts = s.statements.map[recursive]<Statement>(recursive fn(stmt) => this.processStatement[recursive](stmt));

        return s[statements=nstmts];
    }

    method processInvokeParameter(param: InvokeParameterDecl): InvokeParameterDecl {
        if(param.defaultval)@none {
            return param;
        }
        else {
            let dv = this.processExpression(param.defaultval@some);
            
            return param[defaultval=some(dv)];
        }
    }

    method processInvariant(iiv: InvariantDecl): InvariantDecl {
        let ee = this.processExpression(iiv.exp);
        return iiv[exp=ee];
    }

    method processValidate(vv: ValidateDecl): ValidateDecl {
        let ee = this.processExpression(vv.exp);
        return vv[exp=ee];
    }

    method processPrecondition(precond: PreConditionDecl): PreConditionDecl {
        let ee = this.processExpression(precond.exp);
        return precond[exp=ee];
    }

    method processPostcondition(postcond: PostConditionDecl): PostConditionDecl {
        let ee = this.processExpression(postcond.exp);
        return postcond[exp=ee];
    }

    recursive method processBodyStatementList(stmts: List<Statement>): List<Statement> {
        let _, nstmts = stmts.reduce[recursive]<(|Bool, List<Statement>|)>((|false, List<Statement>{}|), recursive fn(rvi, stmt) => {
            if(rvi.0) {
                return rvi;
            }
            else {
                let pcc = this.processStatement[recursive](stmt);
                let done = ConstantSimplification::isTerminalStatement(pcc);

                return (|done, rvi.1.pushBack(pcc)|);
            }
        });

        return nstmts;
    }

    method processBodyImpl(body: BodyImplementation): BodyImplementation {
        match(body)@ {
            ExpressionBodyImplementation => { return ExpressionBodyImplementation{ this.processExpression($body.exp) }; }
            | StandardBodyImplementation => { return StandardBodyImplementation{ this.processBodyStatementList($body.statements) }; }
            | _ => { return body; }
        }
    }

    method processNamespaceConstDecl(nsconst: NamespaceConstDecl): NamespaceConstDecl {
        let evalue = this.processExpression(nsconst.value);
        return nsconst[value=evalue];
    }

    method processConstMemberDecl(typeconst: ConstMemberDecl): ConstMemberDecl {
        let evalue = this.processExpression(typeconst.value);
        return typeconst[value=evalue];
    }

    method processMemberFieldDecl(fd: MemberFieldDecl): MemberFieldDecl {
        if($dv=fd.defaultValue)@none {
            return fd;
        }
        else {
            let dvalue = this.processExpression($dv);
            return fd[defaultValue=some(dvalue)];
        }
    }

    method processNamespaceFunctionDecl(nsfunc: NamespaceFunctionDecl): NamespaceFunctionDecl {
        return NamespaceFunctionDecl{
            file = nsfunc.file,
            sinfo = nsfunc.sinfo,
            fullns = nsfunc.fullns,
            declaredInNS = nsfunc.declaredInNS,

            attributes = nsfunc.attributes,
            name = nsfunc.name,

            ikey = nsfunc.ikey,
            irecursive = nsfunc.irecursive,
            params = nsfunc.params.map<InvokeParameterDecl>(fn(param) => this.processInvokeParameter(param)),
            resultType = nsfunc.resultType,

            body = this.processBodyImpl(nsfunc.body),

            preconditions = nsfunc.preconditions.map<PreConditionDecl>(fn(precond) => this.processPrecondition(precond)),
            postconditions = nsfunc.postconditions.map<PostConditionDecl>(fn(postcond) => this.processPostcondition(postcond)),
            fkind = nsfunc.fkind
        };
    }

    method processTypeFunctionDecl(typefunc: TypeFunctionDecl): TypeFunctionDecl {
        return TypeFunctionDecl{
            file = typefunc.file,
            sinfo = typefunc.sinfo,
            fullns = typefunc.fullns,
            declaredInNS = typefunc.declaredInNS,

            attributes = typefunc.attributes,
            name = typefunc.name,

            ikey = typefunc.ikey,
            irecursive = typefunc.irecursive,
            params = typefunc.params.map<InvokeParameterDecl>(fn(param) => this.processInvokeParameter(param)),
            resultType = typefunc.resultType,

            body = this.processBodyImpl(typefunc.body),

            preconditions = typefunc.preconditions.map<PreConditionDecl>(fn(precond) => this.processPrecondition(precond)),
            postconditions = typefunc.postconditions.map<PostConditionDecl>(fn(postcond) => this.processPostcondition(postcond)),
            completens = typefunc.completens,
            completeikey = typefunc.completeikey
        }; 
    }

    method processMethodDeclAbstract(absmethod: MethodDeclAbstract): MethodDeclAbstract {
        abort;
    }

    method processMethodDeclVirtual(virtmethod: MethodDeclVirtual): MethodDeclVirtual {
        abort;
    }

    method processMethodDeclOverride(overmethod: MethodDeclOverride): MethodDeclOverride {
        abort;
    }

    method processMethodDeclStatic(staticmethod: MethodDeclStatic): MethodDeclStatic {
        return MethodDeclStatic{
            file = staticmethod.file,
            sinfo = staticmethod.sinfo,
            fullns = staticmethod.fullns,
            declaredInNS = staticmethod.declaredInNS,

            attributes = staticmethod.attributes,
            name = staticmethod.name,

            ikey = staticmethod.ikey,
            irecursive = staticmethod.irecursive,
            params = staticmethod.params.map<InvokeParameterDecl>(fn(param) => this.processInvokeParameter(param)),
            resultType = staticmethod.resultType,

            body = this.processBodyImpl(staticmethod.body),

            preconditions = staticmethod.preconditions.map<PreConditionDecl>(fn(precond) => this.processPrecondition(precond)),
            postconditions = staticmethod.postconditions.map<PostConditionDecl>(fn(postcond) => this.processPostcondition(postcond)),

            isThisRef = staticmethod.isThisRef,
            ofrcvrtype = staticmethod.ofrcvrtype
        };
    }

    method processEnumTypeDecl(enumdecl: EnumTypeDecl): EnumTypeDecl {
        abort;
    }

    method processTypedeclTypeDecl(typedecl: TypedeclTypeDecl): TypedeclTypeDecl {
        abort;
    }

    method processPrimitiveEntityTypeDecl(primtype: PrimitiveEntityTypeDecl): PrimitiveEntityTypeDecl {
        return primtype;
    }

    method processConstructableTypeDecl(ctype: ConstructableTypeDecl): ConstructableTypeDecl {
        abort;
    }

    method processCollectionTypeDecl(ctype: CollectionTypeDecl): CollectionTypeDecl {
        abort;
    }

    method processEntityTypeDecl(etype: EntityTypeDecl): EntityTypeDecl {
        return EntityTypeDecl{
            file=etype.file,
            sinfo=etype.sinfo,
            fullns = etype.fullns,
            declaredInNS=etype.declaredInNS,
            
            tkey=etype.tkey,
            name=etype.name,

            invariants=etype.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=etype.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=etype.absmethods,
            virtmethods=etype.virtmethods,
            overmethods=etype.overmethods,
            staticmethods=etype.staticmethods,

            saturatedProvides=etype.saturatedProvides,
            saturatedBFieldInfo=etype.saturatedBFieldInfo,

            allInvariants=etype.allInvariants,
            allValidates=etype.allValidates,

            fields=etype.fields.map<MemberFieldDecl>(fn(fd) => this.processMemberFieldDecl(fd))
        };
    }

    method processDatatypeMemberEntityTypeDecl(dmtype: DatatypeMemberEntityTypeDecl): DatatypeMemberEntityTypeDecl {
        return DatatypeMemberEntityTypeDecl{
            file=dmtype.file,
            sinfo=dmtype.sinfo,
            fullns = dmtype.fullns,
            declaredInNS=dmtype.declaredInNS,
            
            tkey=dmtype.tkey,
            name=dmtype.name,

            invariants=dmtype.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=dmtype.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=dmtype.absmethods,
            virtmethods=dmtype.virtmethods,
            overmethods=dmtype.overmethods,
            staticmethods=dmtype.staticmethods,

            saturatedProvides=dmtype.saturatedProvides,
            saturatedBFieldInfo=dmtype.saturatedBFieldInfo,

            allInvariants=dmtype.allInvariants,
            allValidates=dmtype.allValidates,

            fields=dmtype.fields.map<MemberFieldDecl>(fn(fd) => this.processMemberFieldDecl(fd)),
            parentTypeDecl=dmtype.parentTypeDecl
        };
    }

    method processPrimitiveConceptTypeDecl(pconcept: PrimitiveConceptTypeDecl): PrimitiveConceptTypeDecl {
        abort;
    }

    method processConceptTypeDecl(cconcept: ConceptTypeDecl): ConceptTypeDecl {
        abort;
    }

    method processDatatypeTypeDecl(ddatatype: DatatypeTypeDecl): DatatypeTypeDecl {
        return DatatypeTypeDecl {
            file=ddatatype.file,
            sinfo=ddatatype.sinfo,
            fullns = ddatatype.fullns,
            declaredInNS=ddatatype.declaredInNS,
            
            tkey=ddatatype.tkey,
            name=ddatatype.name,

            invariants=ddatatype.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=ddatatype.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=ddatatype.absmethods,
            virtmethods=ddatatype.virtmethods,
            overmethods=ddatatype.overmethods,
            staticmethods=ddatatype.staticmethods,

            saturatedProvides=ddatatype.saturatedProvides,
            saturatedBFieldInfo=ddatatype.saturatedBFieldInfo,

            allInvariants=ddatatype.allInvariants,
            allValidates=ddatatype.allValidates,

            subtypes=ddatatype.subtypes,

            fields=ddatatype.fields.map<MemberFieldDecl>(fn(fd) => this.processMemberFieldDecl(fd)),
            associatedMemberEntityDecls=ddatatype.associatedMemberEntityDecls
        };
    }

    function process(assembly: Assembly): Assembly {
        let simplifier = ConstantSimplification{ assembly };

        return Assembly{
            nsconsts = assembly.nsconsts.map<NamespaceConstDecl>(fn(nsconst) => simplifier.processNamespaceConstDecl(nsconst)),
            typeconsts = assembly.typeconsts.map<ConstMemberDecl>(fn(typeconst) => simplifier.processConstMemberDecl(typeconst)),

            nsfuncs = assembly.nsfuncs.map<NamespaceFunctionDecl>(fn(ikey, nsfunc) => simplifier.processNamespaceFunctionDecl(nsfunc)),
            typefuncs = assembly.typefuncs.map<TypeFunctionDecl>(fn(ikey, typefunc) => simplifier.processTypeFunctionDecl(typefunc)),

            absmethods = assembly.absmethods.map<MethodDeclAbstract>(fn(ikey, absmethod) => simplifier.processMethodDeclAbstract(absmethod)),
            virtmethods = assembly.virtmethods.map<MethodDeclVirtual>(fn(ikey, virtmethod) => simplifier.processMethodDeclVirtual(virtmethod)),
            overmethods = assembly.overmethods.map<MethodDeclOverride>(fn(ikey, overmethod) => simplifier.processMethodDeclOverride(overmethod)),
            staticmethods = assembly.staticmethods.map<MethodDeclStatic>(fn(ikey, staticmethod) => simplifier.processMethodDeclStatic(staticmethod)),

            enums = assembly.enums,
            typedecls = assembly.typedecls.map<TypedeclTypeDecl>(fn(ikey, typedecl) => simplifier.processTypedeclTypeDecl(typedecl)),

            primtives = assembly.primtives,
            constructables = assembly.constructables,
            collections = assembly.collections,

            entities = assembly.entities.map<EntityTypeDecl>(fn(ikey, etype) => simplifier.processEntityTypeDecl(etype)),
            datamembers = assembly.datamembers.map<DatatypeMemberEntityTypeDecl>(fn(ikey, dmtype) => simplifier.processDatatypeMemberEntityTypeDecl(dmtype)),

            pconcepts = assembly.pconcepts,
            concepts = assembly.concepts.map<ConceptTypeDecl>(fn(ikey, cconcept) => simplifier.processConceptTypeDecl(cconcept)),

            datatypes = assembly.datatypes.map<DatatypeTypeDecl>(fn(ikey, ddatatype) => simplifier.processDatatypeTypeDecl(ddatatype)),

            allfuncs = assembly.allfuncs,
            allmethods = assembly.allmethods,
            allvmethods = assembly.allvmethods,

            allconcretetypes = assembly.allconcretetypes,
            allabstracttypes = assembly.allabstracttypes,
            typetopo = assembly.typetopo
        };
    }
}
