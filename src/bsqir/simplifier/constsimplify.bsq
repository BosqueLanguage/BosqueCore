namespace BSQAssembly;

%*
 * Rewrite the IR to do constant folding, constant propagation, flow/test simplification, and dead code elimination
 *%
entity ConstantSimplification {
    field assembly: Assembly;

    const trueExp: Expression = LiteralSimpleExpression{ SourceInfo{0n, 0n, 0n, 0n}, NominalTypeSignature{SourceInfo{0n, 0n, 0n, 0n}, 'Bool'<TypeKey>}, 'true' };
    const falseExp: Expression = LiteralSimpleExpression{ SourceInfo{0n, 0n, 0n, 0n}, NominalTypeSignature{SourceInfo{0n, 0n, 0n, 0n}, 'Bool'<TypeKey>}, 'false' };

    function isTerminalStatement(stmt: Statement): Bool {
        return \/(stmt?<ReturnVoidStatement>, stmt?<ReturnSingleStatement>, stmt?<ReturnMultiStatement>, stmt?<AbortStatement>);
    }

    recursive method tryResolveExpAsLiteralExpression(exp: Expression): Option<Expression> {
        match(exp)@ {
            AccessNamespaceConstantExpression => {
                let cc = this.assembly.nsconsts.find(pred(nsconst) => /\(nsconst.name === $exp.name, nsconst.declaredInNS === $exp.ns));
                return this.tryResolveExpAsLiteralExpression[recursive](cc.value);
            }
            | AccessStaticFieldExpression => {
                let cc = this.assembly.typeconsts.find(pred(tconst) => /\(tconst.name === $exp.name, tconst.declaredInType.tkeystr === $exp.stype.tkeystr));
                return this.tryResolveExpAsLiteralExpression[recursive](cc.value);
            }
            | AccessEnumExpression => {
                return some(exp);
            }
            | LiteralNoneExpression => {
                return some(exp);
            }
            | LiteralSimpleExpression => {
                return some(exp);
            }
            | LiteralCStringExpression => {
                return some(exp);
            }
            | LiteralStringExpression => {
                return some(exp);
            }
            | LiteralTypeDeclValueExpression => {
                if($exp.invchecks) {
                    return none;
                }
                else {
                    return some(exp);
                }
            }
            | _ => {
                return none;
            }
        }
    }

    method processITestTypeAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestType): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestNoneAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestNone): PostfixOperation {
        if(srctype.tkeystr === 'None'<TypeKey>) {
            if(itest.isnot) {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
            else {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
        }
        elif(srctype.tkeystr === 'Some'<TypeKey>) {
            if(itest.isnot) {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
            else {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
        }
        else {
            return PostfixIsTest { sinfo, srctype, itest };
        }
    }

    method processITestSomeAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestSome): PostfixOperation {
        if(srctype.tkeystr === 'None'<TypeKey>) {
            if(itest.isnot) {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
            else {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
        }
        elif(srctype.tkeystr === 'Some'<TypeKey>) {
            if(itest.isnot) {
                return PostfixBoolConstant{ sinfo, srctype, false };
            }
            else {
                return PostfixBoolConstant{ sinfo, srctype, true };
            }
        }
        else {
            return PostfixIsTest { sinfo, srctype, itest };
        }
    }

    method processITestOkAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestOk): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestFailAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestFail): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestAsTest(sinfo: SourceInfo, srctype: TypeSignature, itest: ITest): PostfixOperation {
        match(itest)@ {
            ITestType => { return this.processITestTypeAsTest(sinfo, srctype, $itest); }
            | ITestNone => { return this.processITestNoneAsTest(sinfo, srctype, $itest); }
            | ITestSome => { return this.processITestSomeAsTest(sinfo, srctype, $itest); }
            | ITestOk => { return this.processITestOkAsTest(sinfo, srctype, $itest); }
            | ITestFail => { return this.processITestFailAsTest(sinfo, srctype, $itest); }
        }
    }

    method processITestTypeAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestType): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestNoneAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestNone): PostfixOperation {
        if(srctype.tkeystr === 'None'<TypeKey>) {
            if(itest.isnot) {
                return PostfixAbort{ sinfo, srctype, none };
            }
            else {
                return PostfixNop{ sinfo, srctype };
            }
        }
        elif(srctype.tkeystr === 'Some'<TypeKey>) {
            if(itest.isnot) {
                return PostfixAccessSomeValue{ sinfo, srctype };
            }
            else {
                return PostfixAbort{ sinfo, srctype, none };
            }
        }
        else {
            return PostfixAsConvert { sinfo, srctype, itest };
        }
    }

    method processITestSomeAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestSome): PostfixOperation {
        if(srctype.tkeystr === 'None'<TypeKey>) {
            if(itest.isnot) {
                return PostfixNop{ sinfo, srctype};
            }
            else {
                return PostfixAbort{ sinfo, srctype, none };
            }
        }
        elif(srctype.tkeystr === 'Some'<TypeKey>) {
            if(itest.isnot) {
                return PostfixAbort{ sinfo, srctype, none };
            }
            else {
                return PostfixAccessSomeValue{ sinfo, srctype };
            }
        }
        else {
            return PostfixAsConvert { sinfo, srctype, itest };
        }
    }

    method processITestOkAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestOk): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestFailAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITestFail): PostfixOperation {
        abort; %% Not implemented
    }

    method processITestAsConvert(sinfo: SourceInfo, srctype: TypeSignature, itest: ITest): PostfixOperation {
        match(itest)@ {
            ITestType => { return this.processITestTypeAsConvert(sinfo, srctype, $itest); }
            | ITestNone => { return this.processITestNoneAsConvert(sinfo, srctype, $itest); }
            | ITestSome => { return this.processITestSomeAsConvert(sinfo, srctype, $itest); }
            | ITestOk => { return this.processITestOkAsConvert(sinfo, srctype, $itest); }
            | ITestFail => { return this.processITestFailAsConvert(sinfo, srctype, $itest); }
        }
    }

    recursive method processArgs(args: List<Expression>): List<Expression> {
        return args.map[recursive]<Expression>(recursive fn(arg) => this.processExpression[recursive](arg));
    }

    recursive method processUnaryArg(arg: Expression): Expression {
        return this.processExpression[recursive](arg);
    }

    recursive method processBinaryArgs(lhs: Expression, rhs: Expression): Expression, Expression {
        return this.processExpression[recursive](lhs), this.processExpression[recursive](rhs);
    }

    recursive method processArgumentList(argl: ArgumentList): ArgumentList {
        let nargs = argl.args.map[recursive]<ArgumentValue>(recursive fn(arg) => {
            let nexp = this.processExpression[recursive](arg.exp);
            return arg[exp=nexp];
        });

        return ArgumentList{ nargs };
    }

    method processAccessNamespaceConstantExpression(e: AccessNamespaceConstantExpression): Expression {
        let sexp = this.tryResolveExpAsLiteralExpression(e);
        if(sexp)@none {
            return e;
        }
        else {
            return $sexp;
        }
    }

    method processAccessStaticFieldExpression(e: AccessStaticFieldExpression): Expression {
        let sexp = this.tryResolveExpAsLiteralExpression(e);
        if(sexp)@none {
            return e;
        }
        else {
            return $sexp;
        }
    }

    recursive method processConstructorExpression(e: ConstructorExpression): Expression {
        let nargs = this.processArgumentList[recursive](e.args);
        return e[args=nargs];
    }

    recursive method processCoerceNarrowTypeExpression(e: CoerceNarrowTypeExpression): Expression {
        let nexp = this.processUnaryArg(e.exp);
        return e[exp=nexp];
    }

    recursive method processCoerceWidenTypeExpression(e: CoerceWidenTypeExpression): Expression {
        let nexp = this.processUnaryArg(e.exp);
        return e[exp=nexp];
    }

    recursive method processSafeConvertExpression(e: SafeConvertExpression): Expression {
        let nexp = this.processUnaryArg(e.exp);
        return e[exp=nexp];
    }

    recursive method processPostfixOp(e: PostfixOp): Expression {
        let ebase = this.processUnaryArg[recursive](e.rootExp);
        let ops = e.ops.map[recursive]<PostfixOperation>(recursive fn(op) => {
            match(op)@ {
                PostfixAccessFromName => { return $op; }
                | PostfixProjectFromNames => { abort; }
                | PostfixAccessFromIndex => { abort; }
                | PostfixIsTest => { return this.processITestAsTest($op.sinfo, $op.baseType, $op.ttest); }
                | PostfixAsConvert => { return this.processITestAsConvert($op.sinfo, $op.baseType, $op.ttest); }
                | PostfixAssignFields => { abort; }
                | PostfixInvokeStatic => { abort; }
                | PostfixInvokeVirtual => { abort; }
                | PostfixLiteralKeyAccess => { abort; }
                | PostfixBoolConstant => { return $op; }
                | PostfixNop => { return $op; }
                | PostfixAbort => { return $op; }
                | PostfixWidenConvert => { return $op; }
                | PostfixAccessSomeValue => { return $op; }
                | PostfixLiteralNoneValue => { return $op; } 
            }
        });

        var sops = ops.filter(pred(op) => op?!<PostfixNop>);
        let hasabort = sops.someOf(pred(op) => op?<PostfixAbort>);
        if(hasabort) {
            abort; %%TODO: we should trim the list if we have a PostfixAbort -- also set the type of the abort to be the final e.type
        }

        return PostfixOp{ e.sinfo, e.etype, ebase, sops };
    }

    function negateLiteralBoolean(v: CString, sinfo: SourceInfo, btype: TypeSignature): Expression {
        var val: CString;

        if(v === 'true') {
            val = 'false';
        }
        else {
            val = 'true';
        }

        return LiteralSimpleExpression{ sinfo, btype, val };
    }

    function negateLiteralNumber(v: CString, sinfo: SourceInfo, ntype: TypeSignature): Expression {
        var val: CString;

        if(v === '0') {
            val = '0';
        }
        else {
            if(v.startsWithString('-')) {
                val = v.removePrefixString('-');
            }
            else {
                val = v.prepend('-');
            }
        }

        return LiteralSimpleExpression{ sinfo, ntype, val };
    }

    function processPrefixNotOpExpression(e: PrefixNotOpExpression, ee: Expression): Expression {
        match(ee)@ {
            LiteralSimpleExpression => {
                return ConstantSimplification::negateLiteralBoolean($ee.value, e.sinfo, e.opertype);
            }
            | PrefixNotOpExpression => {
                return $ee.exp;
            }
            | _ => {
                return e[exp=ee];
            }
        }
    }

    function processPrefixNegateOpExpression(e: PrefixNegateOpExpression, ee: Expression): Expression {
        match(ee)@ {
            LiteralSimpleExpression => {
                return ConstantSimplification::negateLiteralNumber($ee.value, e.sinfo, e.opertype);
            }
            | PrefixNegateOpExpression => {
                return $ee.exp;
            }
            | _ => {
                return e[exp=ee];
            }
        }
    }

    function processPrefixPlusOpExpression(e: PrefixPlusOpExpression, ee: Expression): Expression {
        return ee;
    }

    recursive method processUnaryExpression(e: UnaryExpression): Expression {
        let ee = this.processUnaryArg(e.exp);

        match(e)@ {
            PrefixNotOpExpression => { return ConstantSimplification::processPrefixNotOpExpression($e, ee); }
            | PrefixNegateOpExpression => { return ConstantSimplification::processPrefixNegateOpExpression($e, ee); }
            | PrefixPlusOpExpression => { return ConstantSimplification::processPrefixPlusOpExpression($e, ee); }
        }
    }

    recursive method processBinaryArithExpression(e: BinaryArithExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);

        %%TODO: here is where we would like to do some constant folding and algebraic simplification

        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method processBinKeyEqNoneExpression(e: BinKeyEqNoneExpression): Expression {
        let ee = this.processUnaryArg(e.exp);
        let etype = this.assembly.lookupNominalTypeDeclaration(ee.etype.tkeystr);

        if(etype.tkey === 'None'<TypeKey>) {
            return ConstantSimplification::trueExp;
        }
        else {
            if(etype)<SomeTypeDecl> {
                return ConstantSimplification::falseExp;
            }
            else {
                return e[exp=ee];
            }
        }
    }

    recursive method processBinKeyNotEqNoneExpression(e: BinKeyNotEqNoneExpression): Expression {
        let ee = this.processUnaryArg(e.exp);
        let etype = this.assembly.lookupNominalTypeDeclaration(ee.etype.tkeystr);

        if(etype.tkey === 'None'<TypeKey>) {
            return ConstantSimplification::falseExp;
        }
        else {
            if(etype)<SomeTypeDecl> {
                return ConstantSimplification::trueExp;
            }
            else {
                return e[exp=ee];
            }
        }
    }

    recursive method processBinKeySomeEqExpression(e: BinKeySomeEqExpression): Expression {
        let noption, nval = this.processBinaryArgs(e.eqoption, e.eqval);
        let etype = this.assembly.lookupNominalTypeDeclaration(noption.etype.tkeystr);

        if(etype.tkey === 'None'<TypeKey>) {
            return ConstantSimplification::falseExp;
        }
        else {
            if(etype)<SomeTypeDecl> {
                abort; %%Not implemented -- explicitly unwrap and compare here
            }
            else {
                return e[eqoption=noption, eqval=nval];
            }
        }
    }

    recursive method processBinKeyNotSomeEqExpression(e: BinKeyNotSomeEqExpression): Expression {
        let noption, nval = this.processBinaryArgs(e.neoption, e.neval);
        let etype = this.assembly.lookupNominalTypeDeclaration(noption.etype.tkeystr);

        if(etype.tkey === 'None'<TypeKey>) {
            return ConstantSimplification::trueExp;
        }
        else {
            if(etype)<SomeTypeDecl> {
                abort; %%Not implemented -- explicitly unwrap and compare here
            }
            else {
                return e[neoption=noption, neval=nval];
            }
        }
    }

    recursive method processBinKeyEqExpression(e: BinKeyEqExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);

        %%TODO: here is where we would like to do some basic constant checks

        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method processBinKeyNotEqExpression(e: BinKeyNotEqExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);

        %%TODO: here is where we would like to do some basic const checks

        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method processBinaryKeyEqExpression(e: BinaryKeyEqExpression): Expression {
        match(e)@ {
            BinKeyEqNoneExpression => { return this.processBinKeyEqNoneExpression[recursive]($e); }
            | BinKeyNotEqNoneExpression => { return this.processBinKeyNotEqNoneExpression[recursive]($e); }
            | BinKeySomeEqExpression => { return this.processBinKeySomeEqExpression[recursive]($e); }
            | BinKeyNotSomeEqExpression => { return this.processBinKeyNotSomeEqExpression[recursive]($e); }
            | BinKeyEqExpression => { return this.processBinKeyEqExpression[recursive]($e); }
            | BinKeyNotEqExpression => { return this.processBinKeyNotEqExpression[recursive]($e); }
        }
    }

    recursive method processBinaryNumericExpression(e: BinaryNumericExpression): Expression {
        let nlhs, nrhs = this.processBinaryArgs[recursive](e.lhs, e.rhs);

        %%TODO: here is where we would like to do some algebraic simplification

        return e[lhs=nlhs, rhs=nrhs];
    }

    recursive method processIfExpression(e: IfExpression): Expression {
        let ncond = this.processExpression[recursive](e.iftest.exp);
        let ntrue = this.processExpression[recursive](e.trueValue);
        let nfalse = this.processExpression[recursive](e.falseValue);

        if($itest = e.iftest.itest)@none {
            if(ncond)@!<LiteralSimpleExpression> {
                return e[iftest=ncond, trueValue=ntrue, falseValue=nfalse];
            }
            else {
                if($ncond.value === 'true') {
                    return ntrue;
                }
                else {
                    return nfalse;
                }
            }
        }
        else {
            const op = this.processITestAsTest(ncond.sinfo, ncond.etype, $itest);
            if(op)@!<PostfixBoolConstant> {
                return e[iftest=IfTest{ncond, e.iftest.itestopt}, trueValue=ntrue, falseValue=nfalse];
            }
            else {
                if($op.value) {
                    return ntrue;
                }
                else {
                    return nfalse;
                }
            }
        }
    }

    recursive method processExpression(e: Expression): Expression {
        match(e)@ {
            LiteralNoneExpression => { return e; }
            | LiteralSimpleExpression => { return e; }
            | LiteralCStringExpression => { return e; }
            | LiteralStringExpression => { return e; }  
            | LiteralCRegexExpression => { return e; }
            | LiteralRegexExpression => { return e; }
            | LiteralTypeDeclValueExpression => { abort; }
            | AccessNamespaceConstantExpression => { return this.processAccessNamespaceConstantExpression($e); }
            | AccessStaticFieldExpression => { return this.processAccessStaticFieldExpression($e); }
            | AccessEnumExpression => { return e; }
            | AccessVariableExpression => { return e; }
            | AccessCapturedVariableExpressionSpecial => { abort; }
            | ConstructorExpression => { return this.processConstructorExpression($e); }
            | ConstructorLambdaExpression => { abort; }
            | LetExpression => { abort; }
            | LambdaInvokeExpression => { abort; }
            | CallNamespaceFunctionExpression => { abort; }
            | CallTypeFunctionExpression => { abort; }
            | CallTypeFunctionSpecialExpression => { abort; }
            | CallRefInvokeStaticResolveExpression => { abort; }
            | CallRefInvokeVirtualExpression => { abort; }
            | LogicActionAndExpression => { abort; }
            | LogicActionOrExpression => { abort; }
            | TypeDeclPrimitiveFieldAccessExpression => { abort; }
            | CoerceNarrowTypeExpression => { return this.processCoerceNarrowTypeExpression[recursive]($e); }
            | CoerceWidenTypeExpression => { return this.processCoerceWidenTypeExpression[recursive]($e); }
            | SafeConvertExpression => { return this.processSafeConvertExpression[recursive]($e); }
            | CreateDirectExpression => { abort; }
            | PostfixOp => { return this.processPostfixOp[recursive]($e); }
            | UnaryExpression => { return this.processUnaryExpression[recursive]($e); }
            | BinaryArithExpression => { return this.processBinaryArithExpression[recursive]($e); }
            | BinaryKeyEqExpression => { return this.processBinaryKeyEqExpression[recursive]($e); }
            | KeyCmpEqualExpression => { abort; }
            | KeyCmpLessExpression => { abort; }
            | BinaryNumericExpression => { return this.processBinaryNumericExpression[recursive]($e); }
            | BinLogicExpression => { abort; }
            | MapEntryConstructorExpression => { abort; }
            | IfExpression => { return this.processIfExpression[recursive]($e); }
        }
    }

    method processAssertStatement(s: AssertStatement): Statement {
        let ncond = this.processExpression(s.cond);
        
        if(ncond)@!<LiteralSimpleExpression> {
            return s[cond = $ncond];
        }
        else {
            if($ncond.value === 'true') {
                return EmptyStatement{ s.sinfo };
            }
            else{
                return AbortStatement{ s.sinfo };
            }
        }
    }

    recursive method processStatement(s: Statement): Statement {
        match(s)@ {
            VariableDeclarationStatement => {
                return s;
            }
            | VariableMultiDeclarationStatement => {
                return s;
            }
            | VariableInitializationStatement => {
                return $s[exp = this.processExpression($exp)];
            }
            | VariableMultiInitializationExplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | VariableMultiInitializationImplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | VariableAssignmentStatement => {
                return $s[exp = this.processExpression($exp)];
            }
            | VariableMultiAssignmentExplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | VariableMultiAssignmentImplicitStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | ReturnVoidStatement => {
                return s;
            }
            | ReturnSingleStatement => {
                return $s[value = this.processExpression($value)];
            }
            | ReturnMultiStatement => {
                abort; %% NOT IMPLEMENTED
            }
            | AbortStatement => {
                return s;
            }
            | AssertStatement => {
                return this.processAssertStatement($s);
            }
        }
    }

    method processInvokeParameter(param: InvokeParameterDecl): InvokeParameterDecl {
        if(param.defaultval)@none {
            return param;
        }
        else {
            abort;
        }
    }

    method processInvariant(iiv: InvariantDecl): InvariantDecl {
        let ee = this.processExpression(iiv.exp);
        return iiv[exp=ee];
    }

    method processValidate(vv: ValidateDecl): ValidateDecl {
        let ee = this.processExpression(vv.exp);
        return vv[exp=ee];
    }

    method processPrecondition(precond: PreConditionDecl): PreConditionDecl {
        let ee = this.processExpression(precond.exp);
        return precond[exp=ee];
    }

    method processPostcondition(postcond: PostConditionDecl): PostConditionDecl {
        let ee = this.processExpression(postcond.exp);
        return postcond[exp=ee];
    }

    recursive method processBodyStatementList(stmts: List<Statement>): List<Statement> {
        let _, nstmts = stmts.reduce[recursive]<(|Bool, List<Statement>|)>((|false, List<Statement>{}|), recursive fn(rvi, stmt) => {
            if(rvi.0) {
                return rvi;
            }
            else {
                let pcc = this.processStatement[recursive](stmt);
                let done = ConstantSimplification::isTerminalStatement(pcc);

                return (|done, rvi.1.pushBack(pcc)|);
            }
        });

        return nstmts;
    }

    method processBodyImpl(body: BodyImplementation): BodyImplementation {
        match(body)@ {
            ExpressionBodyImplementation => { return ExpressionBodyImplementation{ this.processExpression($body.exp) }; }
            | StandardBodyImplementation => { return StandardBodyImplementation{ this.processBodyStatementList($body.statements) }; }
            | _ => { return body; }
        }
    }

    method processNamespaceConstDecl(nsconst: NamespaceConstDecl): NamespaceConstDecl {
        let evalue = this.processExpression(nsconst.value);
        return nsconst[value=evalue];
    }

    method processConstMemberDecl(typeconst: ConstMemberDecl): ConstMemberDecl {
        let evalue = this.processExpression(typeconst.value);
        return typeconst[value=evalue];
    }

    method processMemberFieldDecl(fd: MemberFieldDecl): MemberFieldDecl {
        if($dv=fd.defaultValue)@none {
            return fd;
        }
        else {
            let dvalue = this.processExpression($dv);
            return fd[defaultValue=some(dvalue)];
        }
    }

    method processNamespaceFunctionDecl(nsfunc: NamespaceFunctionDecl): NamespaceFunctionDecl {
        return NamespaceFunctionDecl{
            file = nsfunc.file,
            sinfo = nsfunc.sinfo,
            declaredInNS = nsfunc.declaredInNS,

            attributes = nsfunc.attributes,
            name = nsfunc.name,

            ikey = nsfunc.ikey,
            irecursive = nsfunc.irecursive,
            params = nsfunc.params.map<InvokeParameterDecl>(fn(param) => this.processInvokeParameter(param)),
            resultType = nsfunc.resultType,

            body = this.processBodyImpl(nsfunc.body),

            preconditions = nsfunc.preconditions.map<PreConditionDecl>(fn(precond) => this.processPrecondition(precond)),
            postconditions = nsfunc.postconditions.map<PostConditionDecl>(fn(postcond) => this.processPostcondition(postcond)),
            fkind = nsfunc.fkind
        };
    }

    method processTypeFunctionDecl(typefunc: TypeFunctionDecl): TypeFunctionDecl {
        abort;
    }

    method processMethodDeclAbstract(absmethod: MethodDeclAbstract): MethodDeclAbstract {
        abort;
    }

    method processMethodDeclVirtual(virtmethod: MethodDeclVirtual): MethodDeclVirtual {
        abort;
    }

    method processMethodDeclOverride(overmethod: MethodDeclOverride): MethodDeclOverride {
        abort;
    }

    method processMethodDeclStatic(staticmethod: MethodDeclStatic): MethodDeclStatic {
        abort;
    }

    method processEnumTypeDecl(enumdecl: EnumTypeDecl): EnumTypeDecl {
        abort;
    }

    method processTypedeclTypeDecl(typedecl: TypedeclTypeDecl): TypedeclTypeDecl {
        abort;
    }

    method processPrimitiveEntityTypeDecl(primtype: PrimitiveEntityTypeDecl): PrimitiveEntityTypeDecl {
        return primtype;
    }

    method processConstructableTypeDecl(ctype: ConstructableTypeDecl): ConstructableTypeDecl {
        abort;
    }

    method processCollectionTypeDecl(ctype: CollectionTypeDecl): CollectionTypeDecl {
        abort;
    }

    method processEntityTypeDecl(etype: EntityTypeDecl): EntityTypeDecl {
        return EntityTypeDecl{
            file=etype.file,
            sinfo=etype.sinfo,
            declaredInNS=etype.declaredInNS,
            
            tkey=etype.tkey,

            invariants=etype.invariants.map<InvariantDecl>(fn(iiv) => this.processInvariant(iiv)),
            validates=etype.validates.map<ValidateDecl>(fn(vv) => this.processValidate(vv)),

            absmethods=etype.absmethods,
            virtmethods=etype.virtmethods,
            overmethods=etype.overmethods,
            staticmethods=etype.staticmethods,

            saturatedProvides=etype.saturatedProvides,
            saturatedBFieldInfo=etype.saturatedBFieldInfo,

            allInvariants=etype.allInvariants,
            allValidates=etype.allValidates,

            fields=etype.fields.map<MemberFieldDecl>(fn(fd) => this.processMemberFieldDecl(fd))
        };
    }

    method processDatatypeMemberEntityTypeDecl(dmtype: DatatypeMemberEntityTypeDecl): DatatypeMemberEntityTypeDecl {
        abort;
    }

    method processPrimitiveConceptTypeDecl(pconcept: PrimitiveConceptTypeDecl): PrimitiveConceptTypeDecl {
        abort;
    }

    method processConceptTypeDecl(cconcept: ConceptTypeDecl): ConceptTypeDecl {
        abort;
    }

    method processDatatypeTypeDecl(ddatatype: DatatypeTypeDecl): DatatypeTypeDecl {
        abort;
    }

    function process(assembly: Assembly): Assembly {
        let simplifier = ConstantSimplification{ assembly };

        return Assembly{
            nsconsts = assembly.nsconsts.map<NamespaceConstDecl>(fn(nsconst) => simplifier.processNamespaceConstDecl(nsconst)),
            typeconsts = assembly.typeconsts.map<ConstMemberDecl>(fn(typeconst) => simplifier.processConstMemberDecl(typeconst)),

            nsfuncs = assembly.nsfuncs.map<NamespaceFunctionDecl>(fn(ikey, nsfunc) => simplifier.processNamespaceFunctionDecl(nsfunc)),
            typefuncs = assembly.typefuncs.map<TypeFunctionDecl>(fn(ikey, typefunc) => simplifier.processTypeFunctionDecl(typefunc)),

            absmethods = assembly.absmethods.map<MethodDeclAbstract>(fn(ikey, absmethod) => simplifier.processMethodDeclAbstract(absmethod)),
            virtmethods = assembly.virtmethods.map<MethodDeclVirtual>(fn(ikey, virtmethod) => simplifier.processMethodDeclVirtual(virtmethod)),
            overmethods = assembly.overmethods.map<MethodDeclOverride>(fn(ikey, overmethod) => simplifier.processMethodDeclOverride(overmethod)),
            staticmethods = assembly.staticmethods.map<MethodDeclStatic>(fn(ikey, staticmethod) => simplifier.processMethodDeclStatic(staticmethod)),

            enums = assembly.enums,
            typedecls = assembly.typedecls.map<TypedeclTypeDecl>(fn(ikey, typedecl) => simplifier.processTypedeclTypeDecl(typedecl)),

            primtives = assembly.primtives,
            constructables = assembly.constructables,
            collections = assembly.collections,

            entities = assembly.entities.map<EntityTypeDecl>(fn(ikey, etype) => simplifier.processEntityTypeDecl(etype)),
            datamembers = assembly.datamembers.map<DatatypeMemberEntityTypeDecl>(fn(ikey, dmtype) => simplifier.processDatatypeMemberEntityTypeDecl(dmtype)),

            pconcepts = assembly.pconcepts,
            concepts = assembly.concepts.map<ConceptTypeDecl>(fn(ikey, cconcept) => simplifier.processConceptTypeDecl(cconcept)),

            datatypes = assembly.datatypes.map<DatatypeTypeDecl>(fn(ikey, ddatatype) => simplifier.processDatatypeTypeDecl(ddatatype)),

            allfuncs = assembly.allfuncs,
            allmethods = assembly.allmethods,
            allvmethods = assembly.allvmethods,

            allconcretetypes = assembly.allconcretetypes,
            allabstracttypes = assembly.allabstracttypes
        };
    }
}
