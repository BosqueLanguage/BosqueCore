declare namespace BSQAssembly;

concept AbstractDecl {
    field file: String;
    field sinfo: SourceInfo;
}

concept ConditionDecl provides AbstractDecl {
    field diagnosticTag: Option<CString>;
}

entity PreConditionDecl provides ConditionDecl {
    field issoft: Bool;
    field exp: Expression;
}

entity PostConditionDecl provides ConditionDecl {
    field issoft: Bool;
    field exp: Expression;
}

entity InvariantDecl provides ConditionDecl {
    field exp: Expression;
}

entity ValidateDecl provides ConditionDecl {
    field exp: Expression;
}

entity DeclarationAttibute {
    field name: Identifier;
    field tags: List<(|TypeSignature, CString|)>; %%tags are enum names
    field text: Option<CString>;
}

concept AbstractCoreDecl provides AbstractDecl {
    field attributes: List<DeclarationAttibute>;
    field name: Identifier;
}

entity InvokeParameterDecl {
    field pname: Identifier;
    field ptype: TypeSignature;
    field defaultval: Option<Expression>;
    field isRefParam: Bool;
    field isRestParam: Bool;
}

concept AbstractInvokeDecl provides AbstractCoreDecl {
    field ikey: InvokeKey;
    field irecursive: RecursiveAnnotation;

    field params: List<InvokeParameterDecl>;
    field resultType: TypeSignature;

    field body: BodyImplementation;
}

concept ExplicitInvokeDecl provides AbstractInvokeDecl {
    field preconditions: List<PreConditionDecl>;
    field postconditions: List<PostConditionDecl>;
}

concept FunctionInvokeDecl provides ExplicitInvokeDecl {
}

enum FunctionDeclKindTag {
    Function,
    Predicate,
    ErrTest,
    ChkTest,
    Example
}

entity NamespaceFunctionDecl provides FunctionInvokeDecl {
    field fkind: FunctionDeclKindTag;
}

entity TypeFunctionDecl provides FunctionInvokeDecl {
}

entity MethodDecl provides ExplicitInvokeDecl {
    field isThisRef: Bool;
}

entity TaskMethodDecl provides ExplicitInvokeDecl {
    field isSelfRef: Bool;
}

entity TaskActionDecl provides ExplicitInvokeDecl {
}

entity ConstMemberDecl provides AbstractCoreDecl {
    field declaredInType: NominalTypeSignature;

    field declaredType: TypeSignature;
    field value: Expression;
}

entity MemberFieldDecl provides AbstractCoreDecl {
    field declaredInType: NominalTypeSignature;

    field declaredType: TypeSignature;
    field defaultValue: Option<Expression>;
    field isSpecialAccess: Bool;
}

enum AdditionalTypeDeclTag {
    Std,
    Status,
    Event
}

entity SaturatedFieldInfo {
    field containingtype: NominalTypeSignature;
    field fname: Identifier;
    field ftype: TypeSignature;
    field hasdefault: Bool;
}

entity SaturatedInvariantInfo {
    field declaredInType: NominalTypeSignature;
    field file: String;
    field sinfo: SourceInfo;
    field tag: Option<CString>;
}

concept AbstractNominalTypeDecl provides AbstractDecl {
    field attributes: List<DeclarationAttibute>;
    field tkey: TypeKey;

    field invariants: List<InvariantDecl>;
    field validates: List<ValidateDecl>;

    field consts: List<ConstMemberDecl>;
    field functions: List<TypeFunctionDecl>;
    field methods: List<MethodDecl>;

    field saturatedProvides: List<NominalTypeSignature>;
    field saturatedBFieldInfo: List<SaturatedFieldInfo>;

    field allInvariants: List<SaturatedInvariantInfo>;
    field allValidates: List<SaturatedInvariantInfo>;
}

concept AbstractEntityTypeDecl provides AbstractNominalTypeDecl {
}

entity EnumTypeDecl provides AbstractEntityTypeDecl {
    field members: List<CString>;
}

entity TypedeclTypeDecl provides AbstractEntityTypeDecl {
    field valuetype: NominalTypeSignature;
}

entity TypedeclStringOfTypeDecl provides AbstractEntityTypeDecl {
    field valuetype: NominalTypeSignature;
    field ofexp: Expression;
}

concept InternalEntityTypeDecl provides AbstractEntityTypeDecl {
}

entity PrimitiveEntityTypeDecl provides InternalEntityTypeDecl {
}

datatype ConstructableTypeDecl provides InternalEntityTypeDecl 
of
OkTypeDecl { field ttype: TypeSignature; field etype: TypeSignature; }
| FailTypeDecl { field ttype: TypeSignature; field etype: TypeSignature; }
| APIRejectedTypeDecl { }
| APIFailedTypeDecl { }
| APIErrorTypeDecl { }
| APISuccessTypeDecl { }
| SomeTypeDecl { field oftype: TypeSignature; }
| MapEntryTypeDecl { field ktype: NominalTypeSignature; field vtype: TypeSignature; }
;

datatype CollectionTypeDecl provides InternalEntityTypeDecl 
of
ListTypeDecl { field oftype: TypeSignature; }
| StackTypeDecl { }
| QueueTypeDecl { }
| SetTypeDecl { }
| MapTypeDecl { field ktype: NominalTypeSignature; field vtype: TypeSignature; }
;

entity EventListTypeDecl provides InternalEntityTypeDecl {
    field ttype: TypeSignature;
}

entity EntityTypeDecl provides AbstractEntityTypeDecl {
    field fields: List<MemberFieldDecl>;
}

concept AbstractConceptTypeDecl provides AbstractNominalTypeDecl {
    field subtypes: List<NominalTypeSignature>;
}

datatype PrimitiveConceptTypeDecl provides AbstractConceptTypeDecl 
of
OptionTypeDecl { 
    field oftype: TypeSignature; 

    field someType: SomeTypeDecl;
}
| ResultTypeDecl {
    field ttype: TypeSignature; 
    field etype: TypeSignature;

    field okType: OkTypeDecl;
    field failType: FailTypeDecl;
}
| APIResultTypeDecl {
    field ttype: TypeSignature;

    field errorType: APIErrorTypeDecl;
    field failedType: APIFailedTypeDecl;
    field rejectedType: APIRejectedTypeDecl;
    field successType: APISuccessTypeDecl;
}
;

entity ConceptTypeDecl provides AbstractConceptTypeDecl {
    field fields: List<MemberFieldDecl>;
}

entity DatatypeMemberEntityTypeDecl provides AbstractEntityTypeDecl {
    field fields: List<MemberFieldDecl>;
    field parentTypeDecl: NominalTypeSignature;
}

entity DatatypeTypeDecl provides AbstractConceptTypeDecl {
    field fields: List<MemberFieldDecl>;
    field associatedMemberEntityDecls: List<NominalTypeSignature>;
}

%%
%% TODO: missing task related stuff
%%

entity NamespaceConstDecl provides AbstractCoreDecl {
    field declaredInNS: NamespaceKey;

    field declaredType: TypeSignature;
    field value: Expression;
}

entity Assembly {
    field nsconsts: List<NamespaceConstDecl>;
    field typeconsts: List<ConstMemberDecl>;
    
    field nsfuncs: Map<InvokeKey, NamespaceFunctionDecl>;
    field typefuncs: Map<InvokeKey, TypeFunctionDecl>;
    
    field enums: Map<TypeKey, EnumTypeDecl>;
    field typedecls: Map<TypeKey, TypedeclTypeDecl>;

    field primtives: Map<TypeKey, PrimitiveEntityTypeDecl>;
    field constructables: Map<TypeKey, ConstructableTypeDecl>;
    field collections: Map<TypeKey, CollectionTypeDecl>;

    field entities: Map<TypeKey, EntityTypeDecl>;
    field datamembers: Map<TypeKey, DatatypeMemberEntityTypeDecl>;

    field pconcepts: Map<TypeKey, PrimitiveConceptTypeDecl>;
    field concepts: Map<TypeKey, ConceptTypeDecl>;

    field datatypes: Map<TypeKey, DatatypeTypeDecl>;

    field allfuncs: List<InvokeKey>;
    field allconcretetypes: List<TypeKey>;
    field allabstracttypes: List<TypeKey>;

    method lookupNominalTypeDeclaration(tkey: TypeKey): AbstractNominalTypeDecl {
        if(this.enums.has(tkey)) {
            return this.enums.get(tkey);
        }
        elif(this.typedecls.has(tkey)) {
            return this.typedecls.get(tkey);
        }
        elif(this.primtives.has(tkey)) {
            return this.primtives.get(tkey);
        }
        elif(this.constructables.has(tkey)) {
            return this.constructables.get(tkey);
        }
        elif(this.collections.has(tkey)) {
            return this.collections.get(tkey);
        }
        elif(this.entities.has(tkey)) {
            return this.entities.get(tkey);
        }
        elif(this.datamembers.has(tkey)) {
            return this.datamembers.get(tkey);
        }
        elif(this.pconcepts.has(tkey)) {
            return this.pconcepts.get(tkey);
        }
        elif(this.concepts.has(tkey)) {
            return this.concepts.get(tkey);
        }
        elif(this.datatypes.has(tkey)) {
            return this.datatypes.get(tkey);
        }
        else {
            %% Unknown type key
            abort;
        }
    }

    method isNominalTypeConcrete(tkey: TypeKey): Bool {
        return this.lookupNominalTypeDeclaration(tkey)?<AbstractEntityTypeDecl>;
    }

    method isNominalTypeConcept(tkey: TypeKey): Bool {
        return this.lookupNominalTypeDeclaration(tkey)?<AbstractConceptTypeDecl>;
    }
}
