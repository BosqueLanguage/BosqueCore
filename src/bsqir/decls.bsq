declare namespace IR;

const min_safe_int: Int = -4611686018427387903i;
const max_safe_int: Int = 4611686018427387903i;

%%negation and conversion are always safe
const max_safe_nat: Nat = 4611686018427387903n;

const namespaceComponentRE: CRegex = /[A-Z][_a-zA-Z0-9]+/c;
const namespaceKeyRE: CRegex = /(${IR::namespaceComponentRE}'::')*${IR::namespaceComponentRE}/c; %%Core is implicit here
type NamespaceComponentKey = CString of IR::namespaceComponentRE;
type NamespaceKey = CString of IR::namespaceKeyRE; %%Core is implicit here

const basicNominalTypeKeyRE: CRegex = /(${IR::namespaceKeyRE}'::')?[A-Z][_a-zA-Z0-9]+('<'.+'>')?/c; %%Core is implicit here
const specialScopedTypeKeyRE: CRegex = /('Result'|'APIResult')'<'.+'>''::'('Ok'|'Fail'|'Rejected'|'Failed'|'Error'|'Success')/c; %%Core is implicit here
const nominalTypeKeyRE: CRegex = /(${IR::basicNominalTypeKeyRE}|${IR::specialScopedTypeKeyRE})/c; %%a bit rough but helps prevent mistakes
const elistTypeKeyRE: CRegex = /'(|'.*'|)'/c;

const lambdaTypeKeyRE: CRegex = /('fn'|'pred') '('.*')' '->' ${IR::templateTypeKeyRE}|${IR::nominalTypeKeyRE}|${IR::elistTypeKeyRE}/c;
const typeKeyRE: CRegex = /${IR::nominalTypeKeyRE}|${IR::elistTypeKeyRE}|${IR::lambdaTypeKeyRE}/c; 
type TypeKey = CString of IR::typeKeyRE;

const invokeKeyRE: CRegex = /(${IR::namespaceKeyRE}|${IR::nominalTypeKeyRE})'::'[_a-z][_a-zA-Z0-9&]+/c;
type InvokeKey = CString of IR::invokeKeyRE;

const identifierRE: CRegex = /[_a-z][_a-zA-Z0-9&]+/c; %%we allow & inside these identifiers so we can make special names
const videntifierRE: CRegex = /'$'?[_a-z][_a-zA-Z0-9]+/c;
type Identifier = CString of IR::identifierRE;
type VarIdentifier = CString of IR::videntifierRE;

entity SourceInfo {
    field line: Nat;
    field column: Nat;
    field pos: Nat;
    field span: Nat;
}

enum RecursiveAnnotation {
    RecursiveTag,
    RecursiveNoTag,
    RecursiveCondTag
}
