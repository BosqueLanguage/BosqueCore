namespace SMTEmit;

import TreeIR;

function unescapeString(str: String): String {
    return str;
}

function extractLiteralStringValue(str: String, unescape: Bool): String {
    return if (unescape) then unescapeString(str.removeFront("%;").removeEnd("%;")) else str;
}

function extractLiteralASCIIStringValue(str: String, unescape: Bool): String {
    let ll = str.removeFront("ascii{").removeEnd("}");
    return if (unescape) then unescapeString(ll.removeFront("%;").removeEnd("%;")) else ll;
}

entity BodyEmitter {
    field assembly: TreeIR::Assembly;
    field nemitter: NameEmitter;
    field temitter: TypeInfoEmitter;

    field file: String;

    field trgtError: Int;
    field invokeResultErrMap: Map<TreeIR::InvokeKey, TreeIR::ErrorKind>;

    field bodyResultType: TreeIR::TypeKey;
    field bodyResultErrKind: TreeIR::ErrorKind;

    method isTrgtError(errid: Int): Bool {
        return this.trgtError === errid;
    }

    function buildErrorIsTest(evar: String, etype: TreeIR::TypeKey, errkind: TreeIR::ErrorKind): String {
        let etname = smtifyTypeKey(etype);

        if(isOtherErrorKind(errkind)) {
            return String::concat(List<String>{"((_ is) @ResultO-mk-err-", etname, " ", evar, ")"});
        }
        else {
            return String::concat(List<String>{"((_ is) @ResultT-mk-err-", etname, " ", evar, ")"});
        }
    }

    function buildErrorExtract(evar: String, etype: TreeIR::TypeKey, errkind: TreeIR::ErrorKind): String {
        let etname = smtifyTypeKey(etype);

        if(isOtherErrorKind(errkind)) {
            return String::concat(List<String>{"(@ResultO-", etname, "-error ", evar, ")"});
        }
        else {
            return String::concat(List<String>{"(@ResultT-", etname, "-error ", evar, ")"});
        }
    }

    function buildOkIsTest(evar: String, etype: TreeIR::TypeKey, errkind: TreeIR::ErrorKind): String {
        let etname = smtifyTypeKey(etype);

        if(isOtherErrorKind(errkind)) {
            return String::concat(List<String>{"((_ is) @ResultO-mk-ok-", etname, " ", evar, ")"});
        }
        else {
            return String::concat(List<String>{"((_ is) @ResultT-mk-ok-", etname, " ", evar, ")"});
        }
    }

    function buildValueExtract(okvar: String, etype: TreeIR::TypeKey, errkind: TreeIR::ErrorKind): String {
        let etname = smtifyTypeKey(etype);

        if(isOtherErrorKind(errkind)) {
            return String::concat(List<String>{"(@ResultO-", etname, "-val ", okvar, ")"});
        }
        else {
            return String::concat(List<String>{"(@ResultT-", etname, "-val ", okvar, ")"});
        }
    }

    function buildMakeError(evar: String, oftype: TreeIR::TypeKey, errkind: TreeIR::ErrorKind): String {
        let oftname = smtifyTypeKey(oftype);

        if(isOtherErrorKind(errkind)) {
            return String::concat(List<String>{"(@ResultO-mk-err-", oftname, " ", evar, ")"});
        }
        else {
            return String::concat(List<String>{"(@ResultT-mk-err-", oftname, " ", evar, ")"});
        }
    }

    function buildMakeOk(okvar: String, oftype: TreeIR::TypeKey, errkind: TreeIR::ErrorKind): String {
        let oftname = smtifyTypeKey(oftype);
        
        if(isOtherErrorKind(errkind)) {
            return String::concat(List<String>{"(@ResultO-mk-ok-", oftname, " ", okvar, ")"});
        }
        else {
            return String::concat(List<String>{"(@ResultT-mk-ok-", oftname, " ", okvar, ")"});
        }
    }

    method generateReturnWithError(errval: String): String {
        return BodyEmitter::buildMakeError(errval, this.bodyResultType, this.bodyResultErrKind);
    }

    method generateReturnWithValue(okval: String): String {
        return BodyEmitter::buildMakeOk(okval, this.bodyResultType, this.bodyResultErrKind);
    }

    method rewrapError(exp: String, exptype: TreeIR::TypeKey, experr: TreeIR::ErrorKind): String {
        if(/\(exptype === this.bodyResultType, TreeIR::isTargetErrorKind(experr) === TreeIR::isTargetErrorKind(this.bodyResultErrKind))) {
            return exp;
        }
        else {
            return BodyEmitter::buildMakeError(BodyEmitter::buildErrorExtract(exp, exptype, experr), this.bodyResultType, this.bodyResultErrKind);
        }
    }

    recursive method processArgs(args: List<TreeIR::Expression>): List<String> {
        return args.map<String>[recursive](recursive fn(arg: TreeIR::Expression): String => this.emitExpression[recursive](arg));
    }

    function buildUnaryOp(op: String, arg: String): String {
        return String::concat(List<String>{"(", op, " ", arg, ")"});
    }

    function buildBinaryOp(op: String, lhsarg: String, rhsarg: String): String {
        return String::concat(List<String>{"(", op, " ", lhsarg, " ", rhsarg, ")"});
    }

    function buildGeneralOp(op: String, args: List<String>): String {
        if(args.empty()) {
            return op;
        }
        else {
            return String::concat(List<String>{"(", op, " ", String::join(" ", args), ")"});
        }
    }

    function buildITEOp(cond: String, tres: String, fres: String, indent: String): String{
        return String::concat(List<String>{
            indent, "(ite ", cond, "\n",
            tres, "\n",
            fres, "\n",
            indent, ")"
        });
    }

    function buildErrorBailOp(errtest: String, errres: String, flowval: String, indent: String): String {
        return String::concat(List<String>{
            indent, "(ite ", errtest, " ", errres, "\n",
            flowval, "\n",
            indent, ")"
        });
    }

    function buildLetOp(vname: String, vval: String, flowvar: String, indent: String): String {
        return String::concat(List<String>{
            indent, "(let ((", vname, " ", vval, "))\n",
            flowvar, "\n",
            indent, ")"
        });
    }

    method emitLiteralNoneExpression(exp: TreeIR::LiteralNoneExpression): String {
        return "@none";
    }

    method emitLiteralNothingExpression(exp: TreeIR::LiteralNothingExpression): String {
        return "@nothing";
    }
    
    method emitLiteralBoolExpression(exp: TreeIR::LiteralBoolExpression): String {
        return if(exp.value) then "true" else "false";
    }

    method emitLiteralIntegralExpression(exp: TreeIR::LiteralIntegralExpression): String {
        return exp.value.removeEnd("n");
    }

    method emitLiteralRationalExpression(exp: TreeIR::LiteralRationalExpression): String {
        return String::concat(List<String>{"@Rational_uninterp(", exp.value, ")"});
    }

    method emitLiteralFloatPointExpression(exp: TreeIR::LiteralFloatPointExpression): String {
        let fstr: String = if(exp.etype === "Float"_TreeIR::TypeKey) then exp.value.removeEnd("f") else exp.value.removeEnd("d");

        if(fstr === "0.0") {
            return if(exp.etype === "Float"_TreeIR::TypeKey) then "@Float_0" else "@Decimal_0";
        }
        else {
            return if(exp.etype === "Float"_TreeIR::TypeKey) then String::concat(List<String>{"@Float_uninterp(", exp.value, ")"}) else String::concat(List<String>{"@Decimal_uninterp(", exp.value, ")"});
        }
    }

    method emitLiteralRegexExpression(exp: TreeIR::LiteralRegexExpression): String {
        return "[NOT IMPLEMENTED Regex]";
    }

    method emitLiteralStringExpression(exp: TreeIR::LiteralStringExpression): String {
        return extractLiteralStringValue(exp.value, false);
    }

    method emitLiteralASCIIStringExpression(exp: TreeIR::LiteralASCIIStringExpression): String {
        return extractLiteralASCIIStringValue(exp.value, false);
    }
    
    method emitLiteralTypedStringExpression(exp: TreeIR::LiteralTypedStringExpression): String {
        return extractLiteralStringValue(exp.value, false);
    }

    method emitLiteralASCIITypedStringExpression(exp: TreeIR::LiteralASCIITypedStringExpression): String {
        return extractLiteralASCIIStringValue(exp.value, false);
    }
    
    method emitLiteralTemplateStringExpression(exp: TreeIR::LiteralTemplateStringExpression): String {
        return extractLiteralStringValue(exp.value, false);
    }

    method emitLiteralASCIITemplateStringExpression(exp: TreeIR::LiteralASCIITemplateStringExpression): String {
        return extractLiteralASCIIStringValue(exp.value, false);
    }
    
    method emitLiteralTypedPrimitiveDirectExpression(exp: TreeIR::LiteralTypedPrimitiveDirectExpression): String {
        return "[NOT IMPLEMENTED TypedPrimitiveDirect]";
    }

    recursive method emitLiteralTypedPrimitiveConstructorExpression(exp: TreeIR::LiteralTypedPrimitiveConstructorExpression): [String, TreeIR::ErrorKind] {
        return ["[NOT IMPLEMENTED TypedPrimitiveConstructor]", TreeIR::ErrorKind::safe];
    }

    method emitAccessEnvValueExpression(exp: TreeIR::AccessEnvValueExpression): String {
        return "[NOT IMPLEMENTED EnvValue]";
    }

    method emitAccessNamespaceConstantExpression(exp: TreeIR::AccessNamespaceConstantExpression): String {
        return String::concat(List<String>{smtifyNamespace(exp.ns), SMTEncodingSymbol::coloncolon, smtifyIdentifier(exp.cname)});
    }

    method emitAccessConstMemberFieldExpression(exp: TreeIR::AccessConstMemberFieldExpression): String {
        return String::concat(List<String>{smtifyTypeKey(exp.tkey), SMTEncodingSymbol::coloncolon, smtifyIdentifier(exp.cname)});
    }

    method emitAccessVariableExpression(exp: TreeIR::AccessVariableExpression): [String, ArgExpErrorKind] {
        return smtifyIdentifier(exp.name);
    }
/*
    method emitAccessCapturedVariableExpression(exp: TIRAccessCapturedVariableExpression): String {
        return `$CodePack.${exp.name}`;
    }

    method emitAccessScratchSingleValueExpression(exp: TIRAccessScratchSingleValueExpression): String {
        this.m_hasScratch = true;
        return `$$scratch[${exp.sidx}]`;
    }

    method emitAccessScratchIndexExpression(exp: TIRAccessScratchIndexExpression): String {
        this.m_hasScratch = true;
        return `$$scratch[${exp.sidx}][${exp.index}]`
    }

    method emitLoadIndexExpression(exp: TIRLoadIndexExpression): String {
        return `${this.emitExpression(exp.exp)}[${exp.index}]`;
    }

    method emitLoadPropertyExpression(exp: TIRLoadPropertyExpression): String {
        return `${this.emitExpression(exp.exp)}.${exp.property}`;
    }
    */

    recursive method emitLoadFieldExpression(exp: TreeIR::LoadFieldExpression): String {
        let bexp = this.emitExpression[recursive](exp.exp);
        let lfop = this.nemitter.getFieldAccessorName(exp.tkey, exp.fieldkey);

        return String::concat(List<String>{"(", lfop, " ", bexp, ")"});
    }

    /*
    method emitLoadFieldVirtualExpression(exp: TIRLoadFieldVirtualExpression): String {
        const fname = (this.m_assembly.fieldMap.get(exp.fieldkey) as TIRMemberFieldDecl).name;
        const bexp = (this.typeEncodedAsUnion(exp.exp.etype) ? `${this.emitExpression(exp.exp)}.value` : this.emitExpression(exp.exp));

        return `${bexp}.${fname}`;
    }
    */

    recursive method emitConstructorPrimaryDirectExpression(exp: TreeIR::ConstructorPrimaryDirectExpression): String {
        let ctname = this.nemitter.getConstructorName(exp.oftype);

        if(exp.args.empty()) {
            return ctname;
        }
        else {
            let args = exp.args.map<String>(fn(arg) => this.emitExpression[recursive](arg));
            return String::concat(List<String>{"(", ctname, " ", String::join(" ", args), ")"});
        }
    }

    /*
    method emitConstructorPrimaryCheckExpression(exp: TIRConstructorPrimaryCheckExpression): String {
        const tname = this.resolveTypeMemberAccess(exp.oftype);
        const args = exp.args.map((arg) => this.emitExpression(arg, true));
        
        return `${tname}.$constructorWithChecks(${args.join(", ")})`;
    }

    method emitConstructorTupleExpression(exp: TIRConstructorTupleExpression): String {
        return `[${exp.args.map((arg) => this.emitExpression(arg, true)).join(", ")}]`;
    }

    method emitConstructorRecordExpression(exp: TIRConstructorRecordExpression): String {
        const tt = this.m_assembly.getTypeAs<TIRRecordType>(exp.oftype);
        const entries = exp.args.map((arg, ii) => `${tt.entries[ii].pname}: ${this.emitExpression(arg, true)}`);
        return `{${entries.join(", ")}}`;
    }

    method emitConstructorListExpression(exp: TIRConstructorListExpression): String {
        return `$CoreLibs.$ListOps.create(${exp.args.map((arg) => this.emitExpression(arg, true)).join(", ")})`;
    }

    method emitConstructorMapExpression(exp: TIRConstructorMapExpression): String {
        return `$CoreLibs.$MapOps.create("${exp.etype}", ${exp.args.map((arg) => this.emitExpression(arg, true)).join(", ")})`;
    }

    method emitCodePackInvokeExpression(exp: TIRCodePackInvokeExpression): String {
        return `($Runtime.lambdas.get("${exp.cpack.invk}"))(${[...exp.args.map((arg) => this.emitExpression(arg, true))].join(", ")})`;
    }

    method emitResultOkConstructorExpression(exp: TIRResultOkConstructorExpression, toplevel: boolean): String {
        return this.emitExpression(exp.arg, toplevel);
    }

    method emitResultErrConstructorExpression(exp: TIRResultErrConstructorExpression, toplevel: boolean): String {
        return this.emitExpression(exp.arg, toplevel);
    }

    method emitSomethingConstructorExpression(exp: TIRSomethingConstructorExpression, toplevel: boolean): String {
        return this.emitExpression(exp.arg, toplevel);
    }

    method emitTypedeclDirectExpression(exp: TIRTypedeclDirectExpression, toplevel: boolean): String {
        return this.emitExpression(exp.arg, toplevel);
    }

    method emitTypedeclConstructorExpression(exp: TIRSomethingConstructorExpression): String {
        return `${this.resolveTypeMemberAccess(exp.oftype)}.$constructorWithChecks(${this.emitExpression(exp.arg, true)})`;
    }
*/
    recursive method emitCallNamespaceFunctionExpression(exp: TreeIR::CallNamespaceFunctionExpression): [String, TreeIR::ErrorKind] {
        let invks = this.assembly.namespaceMap.get(exp.ns).functions.get(exp.fname);
        let invk = invks.find(pred(ii) => ii.ikey === exp.fkey);

        let opexp = BodyEmitter::buildGeneralOp(smtifyInvokeKey(invk.ikey), this.processArgs[recursive](exp.args));
        let callerr = this.invokeResultErrMap.get(invk.ikey);
        return [opexp, callerr];
    }
/*
    method emitCallNamespaceOperatorExpression(exp: TIRCallNamespaceOperatorExpression): String {
       return NOT_IMPLEMENTED_EXPRESSION(exp.tag);
    }
    
    method emitCallStaticFunctionExpression(exp: TIRCallStaticFunctionExpression): String {
        const ttype = this.m_assembly.typeMap.get(exp.tkey) as TIROOType;
        const invk = ttype.staticFunctions.find((sf) => sf.ikey === exp.fkey);
        assert(invk !== undefined, "emitCallStaticFunctionExpression");

        const accessterm = this.resolveTypeMemberAccess(ttype.tkey);
        if((invk as TIRStaticFunctionDecl).invoke.tbinds.size === 0 && (invk as TIRStaticFunctionDecl).invoke.pcodes.size === 0) {
            return `${accessterm}.${(invk as TIRStaticFunctionDecl).name}(${exp.args.map((arg) => this.emitExpression(arg)).join(", ")})`;
        }
        else {
            return `${accessterm}.$Functions["${(invk as TIRStaticFunctionDecl).ikey}"](${exp.args.map((arg) => this.emitExpression(arg)).join(", ")})`;
        }
    }
*/
    recursive method emitLogicActionAndExpression(exp: TreeIR::LogicActionAndExpression): String {
        return BodyEmitter::buildGeneralOp("and", this.processArgs[recursive](exp.args));
    }

    recursive method emitLogicActionOrExpression(exp: TreeIR::LogicActionOrExpression): String {
        return BodyEmitter::buildGeneralOp("or", this.processArgs[recursive](exp.args));
    }

    recursive method emitPrefixNotOpExpression(exp: TreeIR::PrefixNotExpression): String {
        return BodyEmitter::buildUnaryOp("not", this.emitExpression[recursive](exp.exp));
    }

    recursive method emitPrefixNegateOpExpression(exp: TreeIR::PrefixNegateExpression): String {
        var nexp: String;
        if(exp.optype === "Rational"_TreeIR::TypeKey) {
            nexp = "@Rational_negate";
        }
        elif(exp.optype === "Float"_TreeIR::TypeKey) {
            nexp = "@Float_negate";
        }
        elif(exp.optype === "Decimal"_TreeIR::TypeKey) {
            nexp = "@Decmial_negate";
        }
        else {
            nexp = "neg";
        }

        return BodyEmitter::buildUnaryOp(nexp, this.emitExpression[recursive](exp.exp));
    }

    recursive method emitBinAddExpression(exp: TreeIR::BinAddExpression): String {
        var nexp: String;
        if(exp.optype === "Rational"_TreeIR::TypeKey) {
            nexp = "@Rational_add";
        }
        elif(exp.optype === "Float"_TreeIR::TypeKey) {
            nexp = "@Float_add";
        }
        elif(exp.optype === "Decimal"_TreeIR::TypeKey) {
            nexp = "@Decmial_add";
        }
        else {
            nexp = "+";
        }

        return BodyEmitter::buildBinaryOp(nexp, this.emitExpression[recursive](exp.lhs), this.emitExpression[recursive](exp.rhs));
    }

    recursive method emitBinSubExpression(exp: TreeIR::BinSubExpression): [String, TreeIR::ErrorKind] {
        var nexp: String;
        var opterr: TreeIR::ErrorKind = TreeIR::ErrorKind::safe;
        if(exp.optype === "Rational"_TreeIR::TypeKey) {
            nexp = "@Rational_sub";
        }
        elif(exp.optype === "Float"_TreeIR::TypeKey) {
            nexp = "@Float_sub";
        }
        elif(exp.optype === "Decimal"_TreeIR::TypeKey) {
            nexp = "@Decmial_sub";
        }
        else {
            if(exp.optype === "Nat"_TreeIR::TypeKey) {
                if(this.isTrgtError(exp.errid)) {
                    nexp = "@Nat_checked_trgt_sub";
                    opterr = TreeIR::ErrorKind::target;
                }
                else {
                    nexp = "@Nat_checked_sub";
                    opterr = TreeIR::ErrorKind::other;
                }
            }
            elif(exp.optype === "BigNat"_TreeIR::TypeKey) {
                if(this.isTrgtError(exp.errid)) {
                    nexp = "@BigNat_checked_trgt_sub";
                    opterr = TreeIR::ErrorKind::target;
                }
                else {
                    nexp = "@BigNat_checked_sub";
                    opterr = TreeIR::ErrorKind::other;
                }
            }
            else {
                nexp = "-";
            }
        }

        return [BodyEmitter::buildBinaryOp(nexp, this.emitExpression[recursive](exp.lhs), this.emitExpression[recursive](exp.rhs)), opterr];
    }

    recursive method emitBinMultExpression(exp: TreeIR::BinMultExpression): String {
        var nexp: String;

        if(exp.optype === "Rational"_TreeIR::TypeKey) {
            nexp = "@Rational_mult";
        }
        elif(exp.optype === "Float"_TreeIR::TypeKey) {
            nexp = "@Float_mult";
        }
        elif(exp.optype === "Decimal"_TreeIR::TypeKey) {
            nexp = "@Decmial_mult";
        }
        else {
            if<TreeIR::LiteralIntegralExpression>(exp.lhs) {
                nexp = "*";
            }
            else {
                if(exp.optype === "Nat"_TreeIR::TypeKey) {
                    nexp = "@Nat_mult";
                }
                elif(exp.optype === "Int"_TreeIR::TypeKey) {
                    nexp = "@Int_mult";
                }
                elif(exp.optype === "BigNat"_TreeIR::TypeKey) {
                    nexp = "@BigNat_mult";
                }
                else {
                    nexp = "@BigInt_mult";
                }       
            }
        }

        return BodyEmitter::buildBinaryOp(nexp, this.emitExpression[recursive](exp.lhs), this.emitExpression[recursive](exp.rhs));
    }

    recursive method emitBinDivExpression(exp: TreeIR::BinDivExpression): [String, TreeIR::ErrorKind] {
        var nexp: String;
        var opterr: TreeIR::ErrorKind = TreeIR::ErrorKind::safe;

        if(exp.optype === "Rational"_TreeIR::TypeKey) {
            nexp = "@Rational_div";
        }
        elif(exp.optype === "Float"_TreeIR::TypeKey) {
            nexp = "@Float_div";
        }
        elif(exp.optype === "Decimal"_TreeIR::TypeKey) {
            nexp = "@Decmial_div";
        }
        else {
            if<TreeIR::LiteralIntegralExpression>(exp.rhs) {
                nexp = "/";
            }
            elif(exp.optype === "Nat"_TreeIR::TypeKey) {
                if(this.isTrgtError(exp.errid)) {
                    nexp = "@Nat_checked_trgt_div";
                    opterr = TreeIR::ErrorKind::target;
                }
                else {
                    nexp = "@Nat_checked_div";
                    opterr = TreeIR::ErrorKind::other;
                }
            }
            elif(exp.optype === "BigNat"_TreeIR::TypeKey) {
                if(this.isTrgtError(exp.errid)) {
                    nexp = "@BigNat_checked_trgt_div";
                    opterr = TreeIR::ErrorKind::target;
                }
                else {
                    nexp = "@BigNat_checked_div";
                    opterr = TreeIR::ErrorKind::other;
                }
            }
            elif(exp.optype === "Int"_TreeIR::TypeKey) {
                if(this.isTrgtError(exp.errid)) {
                    nexp = "@Int_checked_trgt_div";
                    opterr = TreeIR::ErrorKind::target;
                }
                else {
                    nexp = "@Int_checked_div";
                    opterr = TreeIR::ErrorKind::other;
                }
            }
            else {
                if(this.isTrgtError(exp.errid)) {
                    nexp = "@BigInt_checked_trgt_div";
                    opterr = TreeIR::ErrorKind::target;
                }
                else {
                    nexp = "@BigInt_checked_div";
                    opterr = TreeIR::ErrorKind::other;
                }
            }
        }

        return [BodyEmitter::buildBinaryOp(nexp, this.emitExpression[recursive](exp.lhs), this.emitExpression[recursive](exp.rhs)), opterr];
    }
/*
    method emitBinKeyEqBothUniqueExpression(exp: TIRBinKeyEqBothUniqueExpression): String {
        return `($CoreLibs.$KeyEqualOps.get("${exp.optype}"))(${this.emitExpression(exp.lhs, true)}, ${this.emitExpression(exp.rhs, true)})`;
    }

    method emitBinKeyEqOneUniqueExpression(exp: TIRBinKeyEqOneUniqueExpression): String {
        return `$CoreLibs.$KeyEqualMixed(${this.emitExpression(exp.uarg, true)}, ${this.emitExpression(exp.garg, true)}, "${exp.oftype}")`;
    }
    
    method emitBinKeyEqGeneralExpression(exp: TIRBinKeyEqGeneralExpression): String {
        return `$CoreLibs.$KeyEqualGeneral(${this.emitExpression(exp.lhs, true)}, ${this.emitExpression(exp.rhs, true)})`;
    }

    method emitBinKeyNeqBothUniqueExpression(exp: TIRBinKeyNeqBothUniqueExpression, toplevel: boolean): String {
        const rr = `!($CoreLibs.$KeyEqualOps.get("${exp.optype}"))(${this.emitExpression(exp.lhs, true)}, ${this.emitExpression(exp.rhs, true)})`;
        return toplevel ? rr : "(" + rr + ")";
    }

    method emitBinKeyNeqOneUniqueExpression(exp: TIRBinKeyNeqOneUniqueExpression, toplevel: boolean): String {
        const rr = `!$CoreLibs.$KeyEqualMixed(${this.emitExpression(exp.uarg, true)}, ${this.emitExpression(exp.garg, true)}, "${exp.oftype}")`;
        return toplevel ? rr : "(" + rr + ")";
    }
    
    method emitBinKeyNeqGeneralExpression(exp: TIRBinKeyNeqGeneralExpression, toplevel: boolean): String {
        const rr = `!$CoreLibs.$KeyEqualGeneral(${this.emitExpression(exp.lhs, true)}, ${this.emitExpression(exp.rhs, true)})`;
        return toplevel ? rr : "(" + rr + ")";
    }

    method emitBinKeyUniqueLessExpression(exp: TIRBinKeyUniqueLessExpression): String {
        return `($CoreLibs.$KeyLessOps.get("${exp.optype}"))(${this.emitExpression(exp.lhs, true)}, ${this.emitExpression(exp.rhs, true)})`;
    }

    method emitBinKeyGeneralLessExpression(exp: TIRBinKeyGeneralLessExpression): String {
        return `$CoreLibs.$KeyLessGeneral(${this.emitExpression(exp.lhs, true)}, ${this.emitExpression(exp.rhs, true)})`;
    }
*/
    recursive method emitNumericEqExpression(exp: TreeIR::NumericEqExpression): String {
        return BodyEmitter::buildBinaryOp("=", this.emitExpression[recursive](exp.lhs), this.emitExpression[recursive](exp.rhs));
    }

    recursive method emitNumericNeqExpression(exp: TreeIR::NumericNeqExpression): String {
        return BodyEmitter::buildUnaryOp("not", BodyEmitter::buildBinaryOp("=", this.emitExpression[recursive](exp.lhs), this.emitExpression[recursive](exp.rhs)));
    }

    recursive method emitNumericLessExpression(exp: TreeIR::NumericLessExpression): String {
        var nexp: String;

        if(exp.optype === "Rational"_TreeIR::TypeKey) {
            nexp = "@Rational_lt";
        }
        elif(exp.optype === "Float"_TreeIR::TypeKey) {
            nexp = "@Float_lt";
        }
        elif(exp.optype === "Decimal"_TreeIR::TypeKey) {
            nexp = "@Decmial_lt";
        }
        else {
            nexp = "<";
        }

        return BodyEmitter::buildBinaryOp(nexp, this.emitExpression[recursive](exp.lhs), this.emitExpression[recursive](exp.rhs));
    }

    recursive method emitNumericLessEqExpression(exp: TreeIR::NumericLessEqExpression): String {
        var nexp: String;

        if(exp.optype === "Rational"_TreeIR::TypeKey) {
            nexp = "@Rational_lteq";
        }
        elif(exp.optype === "Float"_TreeIR::TypeKey) {
            nexp = "@Float_lteq";
        }
        elif(exp.optype === "Decimal"_TreeIR::TypeKey) {
            nexp = "@Decmial_lteq";
        }
        else {
            nexp = "<=";
        }

        return BodyEmitter::buildBinaryOp(nexp, this.emitExpression[recursive](exp.lhs), this.emitExpression[recursive](exp.rhs));
    }

    recursive method emitNumericGreaterExpression(exp: TreeIR::NumericGreaterExpression): String {
        var nexp: String;

        if(exp.optype === "Rational"_TreeIR::TypeKey) {
            nexp = "@Rational_lt";
        }
        elif(exp.optype === "Float"_TreeIR::TypeKey) {
            nexp = "@Float_lt";
        }
        elif(exp.optype === "Decimal"_TreeIR::TypeKey) {
            nexp = "@Decmial_lt";
        }
        else {
            nexp = "<";
        }

        //just swap the lhs and rhs
        return BodyEmitter::buildBinaryOp(nexp, this.emitExpression[recursive](exp.rhs), this.emitExpression[recursive](exp.lhs));
    }

    recursive method emitNumericGreaterEqExpression(exp: TreeIR::NumericGreaterEqExpression): String {
        var nexp: String;

        if(exp.optype === "Rational"_TreeIR::TypeKey) {
            nexp = "@Rational_lteq";
        }
        elif(exp.optype === "Float"_TreeIR::TypeKey) {
            nexp = "@Float_lteq";
        }
        elif(exp.optype === "Decimal"_TreeIR::TypeKey) {
            nexp = "@Decmial_lteq";
        }
        else {
            nexp = "<=";
        }

        //just swap the lhs and rhs
        return BodyEmitter::buildBinaryOp(nexp, this.emitExpression[recursive](exp.rhs), this.emitExpression[recursive](exp.lhs));
    }

    recursive method emitBinLogicAndExpression(exp: TreeIR::BinLogicAndExpression): String {
        return BodyEmitter::buildBinaryOp("and", this.emitExpression[recursive](exp.rhs), this.emitExpression[recursive](exp.lhs));
    }

    recursive method emitBinLogicOrExpression(exp: TreeIR::BinLogicOrExpression): String {
        return BodyEmitter::buildBinaryOp("or", this.emitExpression[recursive](exp.rhs), this.emitExpression[recursive](exp.lhs));
    }

    recursive method emitBinLogicImpliesExpression(exp: TreeIR::BinLogicImpliesExpression): String {
        return BodyEmitter::buildBinaryOp("=>", this.emitExpression[recursive](exp.rhs), this.emitExpression[recursive](exp.lhs));
    }
/*
    method emitMapEntryConstructorExpression(exp: TIRMapEntryConstructorExpression): String {
        return `[${this.emitExpression(exp.kexp, true)}, ${this.emitExpression(exp.vexp, true)}]`;
    }

    method emitIfExpression(exp: TIRIfExpression, toplevel: boolean): String {
        let rstr = "";
        if(exp.ifentry.binderinfo === undefined) {
            rstr = `${this.emitExpression(exp.ifentry.test)} ? ${this.emitExpression(exp.ifentry.value)} : `;
        }
        else {
            this.m_hasScratch = true;
            const tstr = `($Runtime.setScratchValue($$scratch, ${exp.ifentry.binderinfo[1]}, ${this.emitExpression(exp.ifentry.binderinfo[0])}) || ${this.emitExpression(exp.ifentry.test)})`;
            const texp = `((${exp.ifentry.binderinfo[3]}) => ${this.emitExpression(exp.ifentry.value)})(${this.emitExpression(exp.ifentry.binderinfo[2])})`;
            rstr = `${tstr} ? ${texp} : `;
        } 

        for(let i = 0; i < exp.elifentries.length; ++i){
            const eii = exp.elifentries[i];

            if(eii.binderinfo === undefined) {
                rstr += `${this.emitExpression(eii.test)} ? ${this.emitExpression(eii.value)} : `
            }
            else {
                this.m_hasScratch = true;
                const tstr = `($Runtime.setScratchValue($$scratch, ${eii.binderinfo[1]}, ${this.emitExpression(eii.binderinfo[0])}) || ${this.emitExpression(eii.test)})`;
                const texp = `((${eii.binderinfo[3]}) => ${this.emitExpression(eii.value)})(${this.emitExpression(eii.binderinfo[2])})`;
                rstr += `${tstr} ? ${texp} : `;
            }
        }

        if(exp.elseentry.binderinfo === undefined) {
            rstr += this.emitExpression(exp.elseentry.value);
        }
        else {
            this.m_hasScratch = true;
            const tstr = `$Runtime.setScratchValue($$scratch, ${exp.elseentry.binderinfo[1]}, ${this.emitExpression(exp.elseentry.binderinfo[0])})`;
            const texp = `((${exp.elseentry.binderinfo[3]}) => ${this.emitExpression(exp.elseentry.value)})(${this.emitExpression(exp.elseentry.binderinfo[2])})`;
            rstr += `(${tstr} || ${texp})`;
        }

        return toplevel ? rstr : "(" + rstr + ")";
    }

    method emitSwitchExpression(exp: TIRSwitchExpression, toplevel: boolean): String {
        this.m_hasScratch = true;
        let sstr = `$Runtime.setScratchValue($$scratch, ${exp.scratchidx}, ${this.emitExpression(exp.exp, true)}) || `;

        if(exp.clauses[0].binderinfo === undefined) {
            sstr += `${this.emitExpression(exp.clauses[0].match, false)} ? ${this.emitExpression(exp.clauses[0].value, false)} : `;
        }
        else {
            sstr += `${this.emitExpression(exp.clauses[0].match, false)} ? ((${exp.clauses[0].binderinfo[1]}) => ${this.emitExpression(exp.clauses[0].value, true)})(${this.emitExpression(exp.clauses[0].binderinfo[0], true)}) : `;
        }

        for(let i = 1; i < exp.clauses.length; ++i) {
            if(exp.clauses[i].binderinfo === undefined) {
                sstr += `${this.emitExpression(exp.clauses[i].match, false)} ? ${this.emitExpression(exp.clauses[i].value, false)} : `;
            }
            else {
                const binfo = exp.clauses[i].binderinfo as [TIRExpression, string];
                sstr += `${this.emitExpression(exp.clauses[i].match, false)} ? ((${binfo[1]}) => ${this.emitExpression(exp.clauses[i].value, true)})(${this.emitExpression(binfo[0], true)}) : `;
            }
        }

        if(exp.edefault !== undefined) {
            if(exp.edefault.binderinfo === undefined) {
                sstr += `${this.emitExpression(exp.edefault.value, false)}\n`;
            }
            else {
                sstr += `((${exp.edefault.binderinfo[1]}) => ${this.emitExpression(exp.edefault.value, true)})(${this.emitExpression(exp.edefault.binderinfo[0], true)})`;
            }
        }
        else {
            //we just ignore exp.isexhaustive -- maybe want to be more optimized in the future
            sstr += `$Runtime.raiseRuntimeError("Non-exhaustive switch statement" + " -- ${this.m_file} @ line ${exp.sinfo.line}")`;
        }

        return toplevel ? sstr : ("(" + sstr + ")");
    }
    
    method emitMatchExpression(exp: TIRMatchExpression, toplevel: boolean): String {
        this.m_hasScratch = true;
        let sstr = `$Runtime.setScratchValue($$scratch, ${exp.scratchidx}, ${this.emitExpression(exp.exp, true)}) || `;

        if(exp.clauses[0].binderinfo === undefined) {
            sstr += `${this.emitExpression(exp.clauses[0].match, false)} ? ${this.emitExpression(exp.clauses[0].value, false)} : `;
        }
        else {
            sstr += `${this.emitExpression(exp.clauses[0].match, false)} ? ((${exp.clauses[0].binderinfo[1]}) => ${this.emitExpression(exp.clauses[0].value, true)})(${this.emitExpression(exp.clauses[0].binderinfo[0], true)}) : `;
        }

        for(let i = 1; i < exp.clauses.length; ++i) {
            if(exp.clauses[i].binderinfo === undefined) {
                sstr += `${this.emitExpression(exp.clauses[i].match, false)} ? ${this.emitExpression(exp.clauses[i].value, false)} : `;
            }
            else {
                const binfo = exp.clauses[i].binderinfo as [TIRExpression, string];
                sstr += `${this.emitExpression(exp.clauses[i].match, false)} ? ((${binfo[1]}) => ${this.emitExpression(exp.clauses[i].value, true)})(${this.emitExpression(binfo[0], true)}) : `;
            }
        }

        if(exp.edefault !== undefined) {
            if(exp.edefault.binderinfo === undefined) {
                sstr += `${this.emitExpression(exp.edefault.value, false)}\n`;
            }
            else {
                sstr += `((${exp.edefault.binderinfo[1]}) => ${this.emitExpression(exp.edefault.value, true)})(${this.emitExpression(exp.edefault.binderinfo[0], true)})`;
            }
        }
        else {
            //we just ignore exp.isexhaustive -- maybe want to be more optimized in the future
            sstr += `$Runtime.raiseRuntimeError("Non-exhaustive match statement" + " -- ${this.m_file} @ line ${exp.sinfo.line}")`;
        }

        return toplevel ? sstr : ("(" + sstr + ")");
    }

    method emitTaskSelfFieldExpression(exp: TIRTaskSelfFieldExpression): String {
        return `self.${exp.fname}`;
    }

    method emitTaskSelfControlExpression(exp: TIRTaskSelfControlExpression): String {
        return "self.$CNTL";
    }

    method emitTaskGetIDExpression(exp: TIRTaskGetIDExpression): String {
        return "self.$ID";
    }
*/
    recursive method emitCoerceSafeExpression(exp: TreeIR::CoerceSafeExpression): String {
        let srcunion = this.typeEncodedAsUnion(exp.exp.etype);
        let trgtunion = this.typeEncodedAsUnion(exp.totype);

        if(srcunion === trgtunion) {
            return this.emitExpression[recursive](exp.exp);
        }
        elif(trgtunion) {
            //TODO
            return "[TODO -- emitCoerceSafeExpression to union]";
        }
        else {
            //TODO
            return "[TODO -- emitCoerceSafeExpression to concrete]";
        }
    }

    recursive method emitInjectExpression(exp: TreeIR::InjectExpression): String {
       return this.emitExpression[recursive](exp.exp);
    }

    recursive method emitExtractExpression(exp: TreeIR::ExtractExpression): String {
       return this.emitExpression[recursive](exp.exp);
    }
/*    
    method emitCreateCodePackExpression(exp: TIRCreateCodePackExpression): String {
        const capturepcdirect = exp.capturepackdirect.map((pcc) => `${pcc}: ${pcc}`);
        const capturepcindirect = exp.capturepackindirect.map((pcc) => `${pcc}: $CodePack.${pcc}`);
        const capturevvdirect = exp.capturedirect.map((pcc) => `${pcc}: ${pcc === "this" ? "$_this" : pcc}`);
        const capturevvindirect = exp.captureindirect.map((pcc) => `${pcc}: $CodePack.${pcc}`);

        return `{${[...capturevvdirect, ...capturevvindirect, ...capturepcdirect, ...capturepcindirect].join(", ")}}`;
    }

    method emitIsNoneSpecialExpression(exp: TIRIsNoneSpecialExpression, toplevel: boolean): String {
       assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

       const bval = `${this.emitExpression(exp.exp)}.tkey === "None"`;
       return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsSomeSpecialExpression(exp: TIRIsSomeSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `${this.emitExpression(exp.exp)}.tkey !== "None"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsNothingSpecialExpression(exp: TIRIsNothingSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `${this.emitExpression(exp.exp)}.tkey === "Nothing"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsSomethingSpecialExpression(exp: TIRIsSomethingSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `${this.emitExpression(exp.exp)}.tkey !== "Nothing"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsOkSpecialExpression(exp: TIRIsOkSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `${this.emitExpression(exp.exp)}.tkey === "${exp.oktype}"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsErrSpecialExpression(exp: TIRIsErrSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `${this.emitExpression(exp.exp)}.tkey === "${exp.errtype}"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsEqualToLiteralExpression(exp: TIRIsEqualToLiteralExpression, toplevel: boolean): String {
        if(this.typeEncodedAsUnion(exp.exp.etype)) {
            const rr = `$CoreLibs.$KeyEqualMixed(${this.emitExpression(exp.literal.exp, true)}, ${this.emitExpression(exp.exp, true)}, "${exp.literal.exp.etype}")`;
            return toplevel ? rr : "(" + rr + ")";
        }
        else {
            const rr = `($CoreLibs.$KeyEqualOps.get("${exp.literal.exp.etype}"))(${this.emitExpression(exp.literal.exp, true)}, ${this.emitExpression(exp.exp, true)})`;
            return toplevel ? rr : "(" + rr + ")";
        }
    }

    method emitIsNotEqualToLiteralExpression(exp: TIRIsNotEqualToLiteralExpression, toplevel: boolean): String {
        if(this.typeEncodedAsUnion(exp.exp.etype)) {
            const rr = `!$CoreLibs.$KeyEqualMixed(${this.emitExpression(exp.literal.exp, true)}, ${this.emitExpression(exp.exp, true)}, "${exp.literal.exp.etype}")`;
            return toplevel ? rr : "(" + rr + ")";
        }
        else {
            const rr = `!($CoreLibs.$KeyEqualOps.get("${exp.literal.exp.etype}"))(${this.emitExpression(exp.literal.exp, true)}, ${this.emitExpression(exp.exp, true)})`;
            return toplevel ? rr : "(" + rr + ")";
        }
    }

    method emitIsTypeExpression(exp: TIRIsTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(!this.typeEncodedAsUnion(exp.ttype), "this should be a subtype then");

        const bval = `${this.emitExpression(exp.exp)}.tkey === "${exp.ttype}"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsNotTypeExpression(exp: TIRIsNotTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(!this.typeEncodedAsUnion(exp.ttype), "this should be a subtype then");

        const bval = `${this.emitExpression(exp.exp)}.tkey !== "${exp.ttype}"`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsSubTypeExpression(exp: TIRIsSubTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(this.typeEncodedAsUnion(exp.ttype), "this should be a oftype then");

        const bval = `$Runtime.isSubtype(${this.emitExpression(exp.exp, true)}.tkey, "${exp.ttype}")`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitIsNotSubTypeExpression(exp: TIRIsNotSubTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(this.typeEncodedAsUnion(exp.ttype), "this should be a oftype then");

        const bval = `!$Runtime.isSubtype(${this.emitExpression(exp.exp, true)}.tkey, "${exp.ttype}")`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsNoneSpecialExpression(exp: TIRAsNoneSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `(${this.emitExpression(exp.exp)}.tkey === "None") ? undefined : $Runtime.raiseRuntimeError("cannot convert value to None")`;
        return toplevel ? bval : "(" + bval + ")";
    }
    
    method emitAsSomeSpecialExpression(exp: TIRAsSomeSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        let bval = "[NOT SET]";
        if(this.typeEncodedAsUnion(exp.etype)) {
            bval = `((__expval__) => (__expval__.tkey !== "None") ? __expval__ : $Runtime.raiseRuntimeError("cannot convert value to Some"))(${this.emitExpression(exp.exp)})`;
        }
        else {
            bval = `((__expval__) => (__expval__.tkey !== "None") ? __expval__.value : $Runtime.raiseRuntimeError("cannot convert value to Some"))(${this.emitExpression(exp.exp)})`;
        }

        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsNothingSpecialExpression(exp: TIRAsNothingSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `(${this.emitExpression(exp.exp)}.tkey === "Nothing") ? null : $Runtime.raiseRuntimeError("cannot convert value to Nothing")`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsSomethingSpecialExpression(exp: TIRAsSomethingSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `((__expval__) => (__expval__.tkey !== "Nothing") ? __expval__.value : $Runtime.raiseRuntimeError("cannot convert value to Something"))(${this.emitExpression(exp.exp)})`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsOkSpecialExpression(exp: TIRAsOkSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `((__expval__) => (${this.emitExpression(exp.exp)}.tkey === "${exp.etype}") ? __expval__.value : $Runtime.raiseRuntimeError("cannot convert value to ok"))(${this.emitExpression(exp.exp)})`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsErrSpecialExpression(exp: TIRAsErrSpecialExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");

        const bval = `((__expval__) => (${this.emitExpression(exp.exp)}.tkey === "${exp.etype}") ? __expval__.value : $Runtime.raiseRuntimeError("cannot convert value to err"))(${this.emitExpression(exp.exp)})`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsEqualToLiteralExpression(exp: TIRAsEqualToLiteralExpression, toplevel: boolean): String {
        if(this.typeEncodedAsUnion(exp.exp.etype)) {
            const rr = `$CoreLibs.$KeyEqualMixed(${this.emitExpression(exp.literal.exp, true)}, __expval__, "${exp.literal.exp.etype}")`;
            const bval = `((__expval__) => ${rr} ? ${this.emitExpression(exp.literal.exp, true)} : $Runtime.raiseRuntimeError("cannot convert value to literal"))(${this.emitExpression(exp.exp)})`;
            return toplevel ? bval : "(" + bval + ")";
        }
        else {
            const rr = `($CoreLibs.$KeyEqualOps.get("${exp.literal.exp.etype}"))(${this.emitExpression(exp.literal.exp, true)}, __expval__)`;
            const bval = `((__expval__) => ${rr} ? ${this.emitExpression(exp.literal.exp, true)} : $Runtime.raiseRuntimeError("cannot convert value to literal"))(${this.emitExpression(exp.exp)})`;
            return toplevel ? bval : "(" + bval + ")";
        }
    }

    method emitAsNotEqualToLiteralExpression(exp: TIRAsNotEqualToLiteralExpression, toplevel: boolean): String {
        if(this.typeEncodedAsUnion(exp.exp.etype)) {
            const rr = `!$CoreLibs.$KeyEqualMixed(${this.emitExpression(exp.literal.exp, true)}, __expval__, "${exp.literal.exp.etype}")`;
            const bval = `((__expval__) => ${rr} ? __expval__${!this.typeEncodedAsUnion(exp.etype) ? ".value" : ""} : $Runtime.raiseRuntimeError("cannot convert value to literal"))(${this.emitExpression(exp.exp)})`;
            return toplevel ? bval : "(" + bval + ")";
        }
        else {
            const rr = `!($CoreLibs.$KeyEqualOps.get("${exp.literal.exp.etype}"))(${this.emitExpression(exp.literal.exp, true)}, __expval__)`;
            const bval = `((__expval__) => ${rr} ? ${this.emitExpression(exp.literal.exp, true)} : $Runtime.raiseRuntimeError("cannot convert value to literal"))(${this.emitExpression(exp.exp)})`;
            return toplevel ? bval : "(" + bval + ")";
        }
    }

    method emitAsTypeExpression(exp: TIRAsTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(!this.typeEncodedAsUnion(exp.ttype), "this should be a subtype then");

        const bval = `((__expval__) => (__expval__.tkey === "${exp.ttype}") ? __expval__.value : $Runtime.raiseRuntimeError("cannot convert value to ${exp.etype}"))(${this.emitExpression(exp.exp, true)})`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsNotTypeExpression(exp: TIRAsNotTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(!this.typeEncodedAsUnion(exp.ttype), "this should be a subtype then");

        const bval = `((__expval__) => (__expval__.tkey === "${exp.ttype}") ? __expval__${!this.typeEncodedAsUnion(exp.etype) ? ".value" : ""} : $Runtime.raiseRuntimeError("cannot convert value to ${exp.etype}"))(${this.emitExpression(exp.exp, true)})`;
        return toplevel ? bval : "(" + bval + ")";
    }
    
    method emitAsSubTypeExpression(exp: TIRAsSubTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(this.typeEncodedAsUnion(exp.ttype), "this should be a oftype then");

        const bval = `((__expval__) => $Runtime.isSubtype(__expval__.tkey, "${exp.ttype}") ? __expval__ : $Runtime.raiseRuntimeError("cannot convert value to ${exp.ttype}"))(${this.emitExpression(exp.exp, true)})`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitAsNotSubTypeExpression(exp: TIRAsNotSubTypeExpression, toplevel: boolean): String {
        assert(this.typeEncodedAsUnion(exp.exp.etype), "Why are we doing this test then?");
        assert(this.typeEncodedAsUnion(exp.ttype), "this should be a oftype then");

        const bval = `((__expval__) => $Runtime.isSubtype(__expval__.tkey, "${exp.ttype}") ? __expval__${!this.typeEncodedAsUnion(exp.etype) ? ".value" : ""} : $Runtime.raiseRuntimeError("cannot convert value to ${exp.ttype}"))(${this.emitExpression(exp.exp, true)})`;
        return toplevel ? bval : "(" + bval + ")";
    }

    method emitCallMemberFunctionExpression(exp: TIRCallMemberFunctionExpression, toplevel: boolean): String {
        const aargs = [this.emitExpression(exp.thisarg, true), ...exp.args.map((arg) => this.emitExpression(arg, true))];

        const ttype = this.m_assembly.typeMap.get(exp.tkey) as TIROOType;
        const invk = ttype.memberMethods.find((mm) => mm.ikey === exp.fkey);
        assert(invk !== undefined, "emitCallMemberFunctionExpression");

        const fexp = `${this.resolveTypeMemberAccess(exp.tkey)}`;
        let meexp = "[NOT SET]";
        if((invk as TIRMemberMethodDecl).invoke.tbinds.size === 0 && (invk as TIRMemberMethodDecl).invoke.pcodes.size === 0) {
            meexp = `.${exp.fname}`;
        }
        else {
            meexp = `.$Methods["${exp.fkey}"]`;
        }
        
        const eexp = `${fexp}${meexp}(${aargs.join(", ")})`;

        return toplevel ? eexp : "(" + eexp + ")";
    }

    method emitCallMemberFunctionDynamicExpression(exp: TIRCallMemberFunctionDynamicExpression, toplevel: boolean): String {
        const thisarg = this.emitExpression(exp.thisarg, true);
        const thisunion = this.typeEncodedAsUnion(exp.thisarg.etype);

        const aargs = exp.args.map((arg) => this.emitExpression(arg, true));

        let vtable = "[NOT SET]";
        if (thisunion) {
            vtable = `$Runtime.invmap.get($Runtime.vtablemap.get(__expval__.tkey).get("${exp.fname}")).op`
        }
        else {
            vtable = `$Runtime.invmap.get($Runtime.vtablemap.get("${exp.thisarg.etype}").get("${exp.fname}")).op`;
        }

        let thisargas = "[NOT SET]";
        if(thisunion) {
            thisargas = `($Runtime.invmap.get($Runtime.vtablemap.get(__expval__.tkey).get("${exp.fname}")).isatom ? __expval__.value : __expval__)`;
        }
        else {
            thisargas = `($Runtime.invmap.get($Runtime.vtablemap.get(__expval__.tkey).get("${exp.fname}")).isatom ? __expval__ : $Runtime.UnionValue.create("${exp.thisarg.etype}", ${thisarg}))`;
        }

        const eexp = `((__expval__) => ${vtable}(${[thisargas, ...aargs].join(", ")}))(${thisarg})`;

        return toplevel ? eexp : "(" + eexp + ")";
    }
    
    method emitCallMemberFunctionSelfRefExpression(exp: TIRCallMemberFunctionSelfRefExpression, toplevel: boolean): String {
        const aargs = [this.emitExpression(exp.thisarg, true), ...exp.args.map((arg) => this.emitExpression(arg, true))];

        const ttype = this.m_assembly.typeMap.get(exp.tkey) as TIROOType;
        const invk = ttype.memberMethods.find((mm) => mm.ikey === exp.fkey);
        assert(invk !== undefined, "emitCallMemberFunctionExpression");

        const fexp = `${this.resolveTypeMemberAccess(exp.tkey)}`;
        let meexp = "[NOT SET]";
        if((invk as TIRMemberMethodDecl).invoke.tbinds.size === 0 && (invk as TIRMemberMethodDecl).invoke.pcodes.size === 0) {
            meexp = `.${exp.fname}`;
        }
        else {
            meexp = `.$Methods["${exp.fkey}"]`;
        }

        this.m_hasScratch = true;
        return `$Runtime.setScratchValue($$scratch, ${exp.scidx}, ${fexp}${meexp}(${aargs.join(", ")}));`;
    }

    method emitCallMemberFunctionTaskExpression(exp: TIRCallMemberFunctionTaskExpression, toplevel: boolean): String {
        const aargs = ["self", ...exp.args.map((arg) => this.emitExpression(arg, true))];

        const ttype = this.m_assembly.typeMap.get(exp.tsktype) as TIRTaskType;
        const invk = ttype.memberMethods.find((mm) => mm.ikey === exp.fkey);
        assert(invk !== undefined, "emitCallMemberFunctionExpression");

        const fexp = `${this.resolveTypeMemberAccess(exp.tsktype)}`;
        let meexp = "[NOT SET]";
        if((invk as TIRMemberMethodDecl).invoke.tbinds.size === 0 && (invk as TIRMemberMethodDecl).invoke.pcodes.size === 0) {
            meexp = `.${exp.fname}`;
        }
        else {
            meexp = `.$Methods["${exp.fkey}"]`;
        }

        const eexp = `${fexp}${meexp}(${aargs.join(", ")})`;

        return toplevel ? eexp : "(" + eexp + ")";
    }

    method emitCallMemberFunctionTaskSelfRefExpression(exp: TIRCallMemberFunctionTaskSelfRefExpression, toplevel: boolean): String {
        const aargs = ["self", ...exp.args.map((arg) => this.emitExpression(arg, true))];

        const ttype = this.m_assembly.typeMap.get(exp.tsktype) as TIRTaskType;
        const invk = ttype.memberMethods.find((mm) => mm.ikey === exp.fkey);
        assert(invk !== undefined, "emitCallMemberFunctionExpression");

        const fexp = `${this.resolveTypeMemberAccess(exp.tsktype)}`;
        let meexp = "[NOT SET]";
        if((invk as TIRMemberMethodDecl).invoke.tbinds.size === 0 && (invk as TIRMemberMethodDecl).invoke.pcodes.size === 0) {
            meexp = `.${exp.fname}`;
        }
        else {
            meexp = `.$Methods["${exp.fkey}"]`;
        }

        this.m_hasScratch = true;
        return `$Runtime.setScratchValue($$scratch, ${exp.scidx}, ${fexp}${meexp}(${aargs.join(", ")}));`;
    }

    method emitCallMemberActionExpression(exp: TIRCallMemberActionExpression, toplevel: boolean): String {
        const aargs = ["self", ...exp.args.map((arg) => this.emitExpression(arg, true))];
        const fexp = `${this.resolveTypeMemberAccess(exp.tsktype)}.${exp.fname}`;

        this.m_hasScratch = true;
        return `$Runtime.setScratchValue($$scratch, ${exp.scidx}, ${fexp}(${aargs.join(", ")}));`;
    }
*/
    recursive method emitExpression(exp: TreeIR::Expression): String {
        return match (exp) {
            TreeIR::LiteralNoneExpression => this.emitLiteralNoneExpression($)
            | TreeIR::LiteralNothingExpression => this.emitLiteralNothingExpression($)
            | TreeIR::LiteralBoolExpression => this.emitLiteralBoolExpression($)
            | TreeIR::LiteralIntegralExpression => this.emitLiteralIntegralExpression($)
            | TreeIR::LiteralRationalExpression => this.emitLiteralRationalExpression($)
            | TreeIR::LiteralFloatPointExpression => this.emitLiteralFloatPointExpression($)
            | TreeIR::LiteralRegexExpression => this.emitLiteralRegexExpression($)
            | TreeIR::LiteralStringExpression => this.emitLiteralStringExpression($)
            | TreeIR::LiteralASCIIStringExpression => this.emitLiteralASCIIStringExpression($)
            | TreeIR::LiteralTypedStringExpression => this.emitLiteralTypedStringExpression($)
            | TreeIR::LiteralASCIITypedStringExpression => this.emitLiteralASCIITypedStringExpression($)
            | TreeIR::LiteralTemplateStringExpression => this.emitLiteralTemplateStringExpression($)
            | TreeIR::LiteralASCIITemplateStringExpression => this.emitLiteralASCIITemplateStringExpression($)
            | TreeIR::LiteralTypedPrimitiveDirectExpression => this.emitLiteralTypedPrimitiveDirectExpression($)
            | TreeIR::LiteralTypedPrimitiveConstructorExpression => this.emitLiteralTypedPrimitiveConstructorExpression[recursive]($).0
/*
            case TIRExpressionTag.AccessEnvValueExpression: {
                return this.emitAccessEnvValueExpression(exp as TIRAccessEnvValueExpression);
            }
            case TIRExpressionTag.AccessNamespaceConstantExpression: {
                return this.emitAccessNamespaceConstantExpression(exp as TIRAccessNamespaceConstantExpression);
            }
            case TIRExpressionTag.AccessConstMemberFieldExpression: {
                return this.emitAccessConstMemberFieldExpression(exp as TIRAccessConstMemberFieldExpression);
            }
            case TIRExpressionTag.AccessVariableExpression: {
                return this.emitAccessVariableExpression(exp as TIRAccessVariableExpression);
            }
            case TIRExpressionTag.AccessCapturedVariableExpression: {
                return this.emitAccessCapturedVariableExpression(exp as TIRAccessCapturedVariableExpression);
            }
            case TIRExpressionTag.AccessScratchSingleValueExpression: {
                return this.emitAccessScratchSingleValueExpression(exp as TIRAccessScratchSingleValueExpression);
            }
            case TIRExpressionTag.AccessScratchIndexExpression: {
                return this.emitAccessScratchIndexExpression(exp as TIRAccessScratchIndexExpression);
            }
            case TIRExpressionTag.LoadIndexExpression: {
                return this.emitLoadIndexExpression(exp as TIRLoadIndexExpression);
            }
            case TIRExpressionTag.LoadPropertyExpression: {
                return this.emitLoadPropertyExpression(exp as TIRLoadPropertyExpression);
            }
            */
            | TreeIR::LoadFieldExpression => this.emitLoadFieldExpression[recursive]($)
            /*
            case TIRExpressionTag.LoadFieldVirtualExpression: {
                return this.emitLoadFieldVirtualExpression(exp as TIRLoadFieldVirtualExpression);
            }
            */
            | TreeIR::ConstructorPrimaryDirectExpression => this.emitConstructorPrimaryDirectExpression[recursive]($)
            /*
            case TIRExpressionTag.ConstructorPrimaryCheckExpression: {
                return this.emitConstructorPrimaryCheckExpression(exp as TIRConstructorPrimaryCheckExpression);
            }
            case TIRExpressionTag.ConstructorTupleExpression: {
                return this.emitConstructorTupleExpression(exp as TIRConstructorTupleExpression);
            }
            case TIRExpressionTag.ConstructorRecordExpression: {
                return this.emitConstructorRecordExpression(exp as TIRConstructorRecordExpression);
            }
            case TIRExpressionTag.ConstructorListExpression : {
                return this.emitConstructorListExpression(exp as TIRConstructorListExpression);
            }
            case TIRExpressionTag.ConstructorMapExpression: {
                return this.emitConstructorMapExpression(exp as TIRConstructorMapExpression);
            }
            case TIRExpressionTag.CodePackInvokeExpression: {
                return this.emitCodePackInvokeExpression(exp as TIRCodePackInvokeExpression);
            }
            case TIRExpressionTag.ResultOkConstructorExpression: {
                return this.emitResultOkConstructorExpression(exp as TIRResultOkConstructorExpression, toplevel || false);
            }
            case TIRExpressionTag.ResultErrConstructorExpression: {
                return this.emitResultErrConstructorExpression(exp as TIRResultErrConstructorExpression, toplevel || false);
            }
            case TIRExpressionTag.SomethingConstructorExpression: {
                return this.emitSomethingConstructorExpression(exp as TIRSomethingConstructorExpression, toplevel || false);
            }
            case TIRExpressionTag.TypedeclDirectExpression: {
                return this.emitTypedeclDirectExpression(exp as TIRTypedeclDirectExpression, toplevel || false);
            }
            case TIRExpressionTag.TypedeclConstructorExpression: {
                return this.emitTypedeclConstructorExpression(exp as TIRTypedeclConstructorExpression);
            }
*/
            | TreeIR::CallNamespaceFunctionExpression => this.emitCallNamespaceFunctionExpression[recursive]($).0
/*
            case TIRExpressionTag.CallNamespaceOperatorExpression: {
                return this.emitCallNamespaceOperatorExpression(exp as TIRCallNamespaceOperatorExpression);
            }
            | TreeIR::CallStaticFunctionExpression => this.emitCallStaticFunctionExpression[recursive]($).0
*/
            | TreeIR::LogicActionAndExpression => this.emitLogicActionAndExpression[recursive]($)
            | TreeIR::LogicActionOrExpression => this.emitLogicActionOrExpression[recursive]($)
            | TreeIR::PrefixNotExpression => this.emitPrefixNotOpExpression[recursive]($)
            | TreeIR::PrefixNegateExpression => this.emitPrefixNegateOpExpression[recursive]($)
            | TreeIR::BinAddExpression => this.emitBinAddExpression[recursive]($)
            | TreeIR::BinSubExpression => this.emitBinSubExpression[recursive]($).0
            | TreeIR::BinMultExpression => this.emitBinMultExpression[recursive]($)
            | TreeIR::BinDivExpression => this.emitBinDivExpression[recursive]($).0
/*
            case TIRExpressionTag.BinKeyEqBothUniqueExpression: {
                return this.emitBinKeyEqBothUniqueExpression(exp as TIRBinKeyEqBothUniqueExpression);
            }
            case TIRExpressionTag.BinKeyEqOneUniqueExpression: {
                return this.emitBinKeyEqOneUniqueExpression(exp as TIRBinKeyEqOneUniqueExpression);
            }
            case TIRExpressionTag.BinKeyEqGeneralExpression: {
                return this.emitBinKeyEqGeneralExpression(exp as TIRBinKeyEqGeneralExpression);
            }
            case TIRExpressionTag.BinKeyNeqBothUniqueExpression: {
                return this.emitBinKeyNeqBothUniqueExpression(exp as TIRBinKeyNeqBothUniqueExpression, toplevel || false);
            }
            case TIRExpressionTag.BinKeyNeqOneUniqueExpression: {
                return this.emitBinKeyNeqOneUniqueExpression(exp as TIRBinKeyNeqOneUniqueExpression, toplevel || false);
            }
            case TIRExpressionTag.BinKeyNeqGeneralExpression: {
                return this.emitBinKeyNeqGeneralExpression(exp as TIRBinKeyNeqGeneralExpression, toplevel || false);
            }
            case TIRExpressionTag.BinKeyUniqueLessExpression: {
                return this.emitBinKeyUniqueLessExpression(exp as TIRBinKeyUniqueLessExpression);
            }
            case TIRExpressionTag.BinKeyGeneralLessExpression: {
                return this.emitBinKeyGeneralLessExpression(exp as TIRBinKeyGeneralLessExpression);
            }
*/
            | TreeIR::NumericEqExpression => this.emitNumericEqExpression[recursive]($)
            | TreeIR::NumericNeqExpression => this.emitNumericNeqExpression[recursive]($)
            | TreeIR::NumericLessExpression => this.emitNumericLessExpression[recursive]($)
            | TreeIR::NumericLessEqExpression => this.emitNumericLessEqExpression[recursive]($)
            | TreeIR::NumericGreaterExpression => this.emitNumericGreaterExpression[recursive]($)
            | TreeIR::NumericGreaterEqExpression => this.emitNumericGreaterEqExpression[recursive]($)
            | TreeIR::BinLogicAndExpression => this.emitBinLogicAndExpression[recursive]($)
            | TreeIR::BinLogicOrExpression => this.emitBinLogicOrExpression[recursive]($)
            | TreeIR::BinLogicImpliesExpression => this.emitBinLogicImpliesExpression[recursive]($)
/*
            case TIRExpressionTag.MapEntryConstructorExpression: {
                return this.emitMapEntryConstructorExpression(exp as TIRMapEntryConstructorExpression);
            }
            case TIRExpressionTag.IfExpression: {
                return this.emitIfExpression(exp as TIRIfExpression, toplevel || false);
            }
            case TIRExpressionTag.SwitchExpression: {
                return this.emitSwitchExpression(exp as TIRSwitchExpression, toplevel || false);
            }
            case TIRExpressionTag.MatchExpression: {
                return this.emitMatchExpression(exp as TIRMatchExpression, toplevel || false);
            }
            case TIRExpressionTag.TaskSelfFieldExpression: {
                return this.emitTaskSelfFieldExpression(exp as TIRTaskSelfFieldExpression);
            }
            case TIRExpressionTag.TaskSelfControlExpression: {
                return this.emitTaskSelfControlExpression(exp as TIRTaskSelfControlExpression);
            }
            case TIRExpressionTag.TaskGetIDExpression: {
                return this.emitTaskGetIDExpression(exp as TIRTaskGetIDExpression);
            }
            case TIRExpressionTag.CoerceSafeExpression: {
                return this.emitCoerceSafeExpression(exp as TIRCoerceSafeExpression, toplevel || false);
            }
            case TIRExpressionTag.InjectExpression: {
                return this.emitInjectExpression(exp as TIRInjectExpression, toplevel || false);
            }
            case TIRExpressionTag.ExtractExpression: {
                return this.emitExtractExpression(exp as TIRExtractExpression, toplevel || false);
            }
            case TIRExpressionTag.CreateCodePackExpression: {
                return this.emitCreateCodePackExpression(exp as TIRCreateCodePackExpression);
            }
            case TIRExpressionTag.IsNoneSpecialExpression: {
                return this.emitIsNoneSpecialExpression(exp as TIRIsNoneSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.IsSomeSpecialExpression: {
                return this.emitIsSomeSpecialExpression(exp as TIRIsSomeSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.IsNothingSpecialExpression: {
                return this.emitIsNothingSpecialExpression(exp as TIRIsNothingSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.IsSomethingSpecialExpression: {
                return this.emitIsSomethingSpecialExpression(exp as TIRIsSomethingSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.IsOkSpecialExpression: {
                return this.emitIsOkSpecialExpression(exp as TIRIsOkSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.IsErrSpecialExpression: {
                return this.emitIsErrSpecialExpression(exp as TIRIsErrSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.IsEqualToLiteralExpression: {
                return this.emitIsEqualToLiteralExpression(exp as TIRIsEqualToLiteralExpression, toplevel || false);
            }
            case TIRExpressionTag.IsNotEqualToLiteralExpression: {
                return this.emitIsNotEqualToLiteralExpression(exp as TIRIsNotEqualToLiteralExpression, toplevel || false);
            }
            case TIRExpressionTag.IsTypeExpression: {
                return this.emitIsTypeExpression(exp as TIRIsTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.IsNotTypeExpression: {
                return this.emitIsNotTypeExpression(exp as TIRIsNotTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.IsSubTypeExpression: {
                return this.emitIsSubTypeExpression(exp as TIRIsSubTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.IsNotSubTypeExpression: {
                return this.emitIsNotSubTypeExpression(exp as TIRIsNotSubTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNoneSpecialExpression: {
                return this.emitAsNoneSpecialExpression(exp as TIRAsNoneSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsSomeSpecialExpression: {
                return this.emitAsSomeSpecialExpression(exp as TIRAsSomeSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNothingSpecialExpression: {
                return this.emitAsNothingSpecialExpression(exp as TIRAsNothingSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsSomethingSpecialExpression: {
                return this.emitAsSomethingSpecialExpression(exp as TIRAsSomethingSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsOkSpecialExpression: {
                return this.emitAsOkSpecialExpression(exp as TIRAsOkSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsErrSpecialExpression: {
                return this.emitAsErrSpecialExpression(exp as TIRAsErrSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsEqualToLiteralExpression: {
                return this.emitAsEqualToLiteralExpression(exp as TIRAsEqualToLiteralExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNotEqualToLiteralExpression: {
                return this.emitAsNotEqualToLiteralExpression(exp as TIRAsNotEqualToLiteralExpression, toplevel || false);
            }
            case TIRExpressionTag.AsTypeExpression: {
                return this.emitAsTypeExpression(exp as TIRAsTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNotTypeExpression: {
                return this.emitAsNotTypeExpression(exp as TIRAsNotTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.AsSubTypeExpression: {
                return this.emitAsSubTypeExpression(exp as TIRAsSubTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNotSubTypeExpression: {
                return this.emitAsNotSubTypeExpression(exp as TIRAsNotSubTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionExpression: {
                return this.emitCallMemberFunctionExpression(exp as TIRCallMemberFunctionExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionDynamicExpression: {
                return this.emitCallMemberFunctionDynamicExpression(exp as TIRCallMemberFunctionDynamicExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionSelfRefExpression: {
                return this.emitCallMemberFunctionSelfRefExpression(exp as TIRCallMemberFunctionSelfRefExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionTaskExpression: {
                return this.emitCallMemberFunctionTaskExpression(exp as TIRCallMemberFunctionTaskExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionTaskSelfRefExpression: {
                return this.emitCallMemberFunctionTaskSelfRefExpression(exp as TIRCallMemberFunctionTaskSelfRefExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberActionExpression: {
                return this.emitCallMemberActionExpression(exp as TIRCallMemberActionExpression, toplevel || false);
            }
            default: {
                assert(false, `Unknown expression kind ${exp.tag}`);
                return `[UNKNOWN TAG ${exp.tag}]`
            }
*/
        };
    }


    method emitExpressionWErr(exp: TreeIR::Expression): [String, TreeIR::ErrorKind] {
        return match (exp) {
            TreeIR::LiteralTypedPrimitiveConstructorExpression => this.emitLiteralTypedPrimitiveConstructorExpression[recursive]($)
/*
            case TIRExpressionTag.AccessEnvValueExpression: {
                return this.emitAccessEnvValueExpression(exp as TIRAccessEnvValueExpression);
            }
            case TIRExpressionTag.ConstructorPrimaryCheckExpression: {
                return this.emitConstructorPrimaryCheckExpression(exp as TIRConstructorPrimaryCheckExpression);
            }
            case TIRExpressionTag.ConstructorMapExpression: {
                return this.emitConstructorMapExpression(exp as TIRConstructorMapExpression);
            }
            case TIRExpressionTag.CodePackInvokeExpression: {
                return this.emitCodePackInvokeExpression(exp as TIRCodePackInvokeExpression);
            }
            case TIRExpressionTag.TypedeclConstructorExpression: {
                return this.emitTypedeclConstructorExpression(exp as TIRTypedeclConstructorExpression);
            }
*/
            | TreeIR::CallNamespaceFunctionExpression => this.emitCallNamespaceFunctionExpression[recursive]($)
/*
            case TIRExpressionTag.CallNamespaceOperatorExpression: {
                return this.emitCallNamespaceOperatorExpression(exp as TIRCallNamespaceOperatorExpression);
            }
            | TreeIR::CallStaticFunctionExpression => this.emitCallStaticFunctionExpression[recursive]($)
*/
            | TreeIR::BinSubExpression => this.emitBinSubExpression[recursive]($)
            | TreeIR::BinDivExpression => this.emitBinDivExpression[recursive]($)
/*
            case TIRExpressionTag.AsSomeSpecialExpression: {
                return this.emitAsSomeSpecialExpression(exp as TIRAsSomeSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNothingSpecialExpression: {
                return this.emitAsNothingSpecialExpression(exp as TIRAsNothingSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsSomethingSpecialExpression: {
                return this.emitAsSomethingSpecialExpression(exp as TIRAsSomethingSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsOkSpecialExpression: {
                return this.emitAsOkSpecialExpression(exp as TIRAsOkSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsErrSpecialExpression: {
                return this.emitAsErrSpecialExpression(exp as TIRAsErrSpecialExpression, toplevel || false);
            }
            case TIRExpressionTag.AsEqualToLiteralExpression: {
                return this.emitAsEqualToLiteralExpression(exp as TIRAsEqualToLiteralExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNotEqualToLiteralExpression: {
                return this.emitAsNotEqualToLiteralExpression(exp as TIRAsNotEqualToLiteralExpression, toplevel || false);
            }
            case TIRExpressionTag.AsTypeExpression: {
                return this.emitAsTypeExpression(exp as TIRAsTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNotTypeExpression: {
                return this.emitAsNotTypeExpression(exp as TIRAsNotTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.AsSubTypeExpression: {
                return this.emitAsSubTypeExpression(exp as TIRAsSubTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.AsNotSubTypeExpression: {
                return this.emitAsNotSubTypeExpression(exp as TIRAsNotSubTypeExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionExpression: {
                return this.emitCallMemberFunctionExpression(exp as TIRCallMemberFunctionExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionDynamicExpression: {
                return this.emitCallMemberFunctionDynamicExpression(exp as TIRCallMemberFunctionDynamicExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionSelfRefExpression: {
                return this.emitCallMemberFunctionSelfRefExpression(exp as TIRCallMemberFunctionSelfRefExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionTaskExpression: {
                return this.emitCallMemberFunctionTaskExpression(exp as TIRCallMemberFunctionTaskExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberFunctionTaskSelfRefExpression: {
                return this.emitCallMemberFunctionTaskSelfRefExpression(exp as TIRCallMemberFunctionTaskSelfRefExpression, toplevel || false);
            }
            case TIRExpressionTag.CallMemberActionExpression: {
                return this.emitCallMemberActionExpression(exp as TIRCallMemberActionExpression, toplevel || false);
            }
*/
            | _ => [this.emitExpression(exp), TreeIR::ErrorKind::safe]
        };
    }

    recursive method emitNopStatement(stmt: TreeIR::NopStatement, follow: List<TreeIR::Statement>, indent: String): String {
        return this.emitStatementList[recursive](follow, indent);
    }

    recursive method emitAbortStatement(stmt: TreeIR::AbortStatement, follow: List<TreeIR::Statement>, indent: String): String {
        if(this.isTrgtError(stmt.errid)) {
            return BodyEmitter::buildMakeError("@error-target", this.bodyResultType, TreeIR::ErrorKind::target).prepend(indent);
        }
        else {
            return BodyEmitter::buildMakeError("@error-other", this.bodyResultType, TreeIR::ErrorKind::other).prepend(indent);
        }
    }

    recursive method emitAssertCheckStatement(stmt: TreeIR::AssertCheckStatement, follow: List<TreeIR::Statement>, indent: String): String {
        let fstr = this.emitStatementList(follow, indent.append("    "));
        let chkstr = this.emitExpression(stmt.cond);

        var errstr: String;
        if(this.isTrgtError(stmt.errid)) {
            errstr = BodyEmitter::buildMakeError("@error-target", this.bodyResultType, TreeIR::ErrorKind::target);
        }
        else {
            errstr = BodyEmitter::buildMakeError("@error-other", this.bodyResultType, TreeIR::ErrorKind::other);
        }

        return BodyEmitter::buildErrorBailOp(chkstr, errstr, fstr, indent);
    }

    recursive method emitDebugStatement(stmt: TreeIR::DebugStatement, follow: List<TreeIR::Statement>, indent: String): String {
        //These are nop'd in the SMT model
        return this.emitStatementList[recursive](follow, indent);
    }

    recursive method emitVarDeclareAndAssignStatement(stmt: TreeIR::VarDeclareAndAssignStatement, follow: List<TreeIR::Statement>, indent: String): String {
        let eeval = this.emitExpressionWErr(stmt.vexp);

        if(eeval.1 === TreeIR::ErrorKind::safe) {
             let fstr = this.emitStatementList(follow, indent);
             return BodyEmitter::buildLetOp(smtifyIdentifier(stmt.vname), eeval.0, fstr, indent);
        }
        else {
            let fstr = this.emitStatementList(follow, indent.append("    "));
            let tvstr = String::concat(List<String>{"@", smtifyIdentifier(stmt.vname), "@"});

            let errchk = BodyEmitter::buildErrorIsTest(tvstr, stmt.vexp.etype, eeval.1);
            let errstr = BodyEmitter::buildMakeError(this.rewrapError(tvstr, stmt.vexp.etype, eeval.1), this.bodyResultType, this.bodyResultErrKind);

            let normalflow = BodyEmitter::buildLetOp(smtifyIdentifier(stmt.vname), BodyEmitter::buildValueExtract(tvstr, stmt.vexp.etype, eeval.1), fstr, indent.append("    "));
            let errctrl = BodyEmitter::buildErrorBailOp(errchk, errstr, normalflow, indent);

            return BodyEmitter::buildLetOp(tvstr, eeval.0, errctrl, indent);
        }
    }
/*
    method emitStoreToScratch(stmt: TIRStoreToScratch): String {
        this.m_hasScratch = true;
        return `$Runtime.setScratchValue($$scratch, ${stmt.scidx}, ${this.emitExpression(stmt.exp, true)});`;
    }

    method emitVarRefAssignFromScratch(stmt: TIRVarRefAssignFromScratch): String {
        if(stmt.vname !== "this") {
            return `${stmt.vname} = $$scratch[${stmt.scidx}][0];`;
        }
        else {
            return `$_this = $$scratch[${stmt.scidx}][0];`;
        }
    }

    method emitTaskRefAssignFromScratch(stmt: TIRTaskRefAssignFromScratch): String {
        return `self = $$scratch[${stmt.scidx}];`;
    }

    method emitCallStatementWRef(stmt: TIRCallStatementWRef): String {
        return this.emitExpression(stmt.vexp, true);
    }

    method emitCallStatementWTaskRef(stmt: TIRCallStatementWTaskRef): String {
        return this.emitExpression(stmt.vexp, true);
    }

    method emitCallStatementWAction(stmt: TIRCallStatementWAction): String {
        return this.emitExpression(stmt.vexp, true);
    }

    method emitVariableRetypeStatement(stmt: TIRVariableRetypeStatement): String {
       return `${stmt.vname} = ${this.emitExpression(stmt.asconv, true)};`
    }

    method emitVariableSCRetypeStatement(stmt: TIRVariableSCRetypeStatement): String {
        const binder = stmt.binderinfo !== undefined ? ` ${stmt.binderinfo[1]} = ${this.emitExpression(stmt.binderinfo[0], true)};` : ""
        return `if(${this.emitExpression(stmt.test, true)}) { ${stmt.vname} = ${this.emitExpression(stmt.asconv, true)}; } else {${binder} return ${this.emitExpression(stmt.resexp, true)}; }`
    }

    method emitScratchSCStatement(stmt: TIRScratchSCStatement): String {
        assert(false, "NOT IMPLEMENTED -- TIRScratchSCStatement");
        return "NOT IMPLEMENTED -- TIRScratchSCStatement";
    }
*/
    recursive method emitReturnStatement(stmt: TreeIR::ReturnStatement, follow: List<TreeIR::Statement>, indent: String): String {
        let rv =  this.emitExpression(stmt.value);
        return rv.prepend(indent);
    }
/*
    method emitReturnStatementWRef(stmt: TIRReturnStatementWRef): String {
        return `return [$_this, ${this.emitExpression(stmt.value, true)}];`;
    }

    method emitReturnStatementWTaskRef(stmt: TIRReturnStatementWTaskRef): String {
        return `return [self, ${this.emitExpression(stmt.value, true)}];`;
    }

    method emitReturnStatementWAction(stmt: TIRReturnStatementWAction): String {
        return `return [self, ${this.emitExpression(stmt.value, true)}];`;
    }   

    method emitIfStatement(stmt: TIRIfStatement, indent: String): String {
        let sstr = "";
        if(stmt.ifentry.binderinfo === undefined) {
            const poststr = stmt.ifentry.recasttypes.length !== 0 ? stmt.ifentry.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
            sstr = `if(${this.emitExpression(stmt.ifentry.test, true)}) ${this.emitScopedBlock(stmt.ifentry.value, indent, undefined, poststr)}\n`;
        }
        else {
            this.m_hasScratch = true;
            const tstr = `($Runtime.setScratchValue($$scratch, ${stmt.ifentry.binderinfo[1]}, ${this.emitExpression(stmt.ifentry.binderinfo[0])}) || ${this.emitExpression(stmt.ifentry.test)})`;
            const prestr = `var ${stmt.ifentry.binderinfo[3]} = ${this.emitExpression(stmt.ifentry.binderinfo[2], true)};`
            const poststr = stmt.ifentry.recasttypes.length !== 0 ? stmt.ifentry.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
            sstr = `if(${tstr}) ${this.emitScopedBlock(stmt.ifentry.value, indent, prestr, poststr)}\n`;
        } 

        for (let i = 0; i < stmt.elifentries.length; ++i) {
            const eei = stmt.elifentries[i];
            const poststr = stmt.ifentry.recasttypes.length !== 0 ? eei.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;

            if (eei.binderinfo === undefined) {
                sstr += indent + `else if(${this.emitExpression(eei.test, true)}) ${this.emitScopedBlock(eei.value, indent, undefined, poststr)}\n`;
            }
            else {
                this.m_hasScratch = true;
                const tstr = `($Runtime.setScratchValue($$scratch, ${eei.binderinfo[1]}, ${this.emitExpression(eei.binderinfo[0], true)}) || ${this.emitExpression(eei.test)})`;
                const prestr = `var ${eei.binderinfo[3]} = ${this.emitExpression(eei.binderinfo[2], true)};`
                sstr += `if(${tstr}) ${this.emitScopedBlock(eei.value, indent, prestr, poststr)}\n`;
            }
        }

        if(stmt.elseentry.binderinfo === undefined) {
            const poststr = stmt.ifentry.recasttypes.length !== 0 ? stmt.elseentry.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
            sstr += indent + `else ${this.emitScopedBlock(stmt.elseentry.value, indent, undefined, poststr)}\n`;
        }
        else {
            this.m_hasScratch = true;
            const poststr = stmt.ifentry.recasttypes.length !== 0 ? stmt.elseentry.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
            const prestr = `$Runtime.setScratchValue($$scratch, ${stmt.elseentry.binderinfo[1]}, ${this.emitExpression(stmt.elseentry.binderinfo[0], true)}); var ${stmt.elseentry.binderinfo[3]} = ${this.emitExpression(stmt.elseentry.binderinfo[2], true)};`
            sstr += indent + `else ${this.emitScopedBlock(stmt.elseentry.value, indent, prestr, poststr)}\n`;
        }

        return sstr;
    }

    method emitSwitchStatement(stmt: TIRSwitchStatement, indent: String): String {
        assert(false, "NOT IMPLEMENTED -- TIRSwitchStatement");
        return "NOT IMPLEMENTED -- TIRSwitchStatement";
    }

    method emitMatchStatement(stmt: TIRMatchStatement, indent: String): String {
        this.m_hasScratch = true;
        let sstr = `$Runtime.setScratchValue($$scratch, ${stmt.scratchidx}, ${this.emitExpression(stmt.exp, true)});\n\n`;

        if(stmt.clauses[0].binderinfo === undefined) {
            const poststr = stmt.clauses[0].recasttypes.length !== 0 ? stmt.clauses[0].recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
            sstr += indent + `if(${this.emitExpression(stmt.clauses[0].match, true)}) ${this.emitScopedBlock(stmt.clauses[0].value, indent, undefined, poststr)}\n`;
        }
        else {
            const prestr = `var ${stmt.clauses[0].binderinfo[1]} = ${this.emitExpression(stmt.clauses[0].binderinfo[0], true)};`
            const poststr = stmt.clauses[0].recasttypes.length !== 0 ? stmt.clauses[0].recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
            sstr += indent + `if(${this.emitExpression(stmt.clauses[0].match, true)}) ${this.emitScopedBlock(stmt.clauses[0].value, indent, prestr, poststr)}\n`;
        }

        for(let i = 1; i < stmt.clauses.length; ++i) {
            if(stmt.clauses[i].binderinfo === undefined) {
                const poststr = stmt.clauses[i].recasttypes.length !== 0 ? stmt.clauses[i].recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
                sstr += indent + `else if(${this.emitExpression(stmt.clauses[i].match, true)}) ${this.emitScopedBlock(stmt.clauses[i].value, indent, undefined, poststr)}\n`;
            }
            else {
                const binfo = stmt.clauses[i].binderinfo as [TIRExpression, string];

                const prestr = `var ${binfo[1]} = ${this.emitExpression(binfo[0], true)};`
                const poststr = stmt.clauses[i].recasttypes.length !== 0 ? stmt.clauses[i].recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
                sstr += indent + `else if(${this.emitExpression(stmt.clauses[i].match, true)}) ${this.emitScopedBlock(stmt.clauses[i].value, indent, prestr, poststr)}\n`;
            }
        }

        if(stmt.edefault !== undefined) {
            if(stmt.edefault.binderinfo === undefined) {
                const poststr = stmt.edefault.recasttypes.length !== 0 ? stmt.edefault.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
                sstr += indent + `else ${this.emitScopedBlock(stmt.edefault.value, indent, undefined, poststr)}\n`;
            }
            else {
                const prestr = `var ${stmt.edefault.binderinfo[1]} = ${this.emitExpression(stmt.edefault.binderinfo[0], true)};`
                const poststr = stmt.edefault.recasttypes.length !== 0 ? stmt.edefault.recasttypes.map((rct) => `${rct.vname} = ${this.emitExpression(rct.cast, true)};`).join(" ") : undefined;
                sstr += indent + `else ${this.emitScopedBlock(stmt.edefault.value, indent, prestr, poststr)}\n`;
            }
        }
        else {
            sstr += indent + "else {\n"
            if(stmt.isexhaustive) {
                sstr += indent + "    ;\n";
            }
            else {
                sstr += indent + "    " + `$Runtime.raiseRuntimeError("Non-exhaustive match statement" + " -- ${this.m_file} @ line ${stmt.sinfo.line}")` + ";\n"
            }
            sstr += indent + "}\n";
        }

        return sstr;
    }

    method emitEnvironmentFreshStatement(stmt: TIREnvironmentFreshStatement): String {
        const binds = stmt.assigns.map((asgn) => `["${asgn.keyname}", {tkey: "${asgn.valexp[0]}", value: ${this.emitExpression(asgn.valexp[1], true)}}]`);
        return `self.$environment = new $Runtime.BSQEnvironment(undefined, ${binds.join(", ")});`
    }

    method emitEnvironmentSetStatement(stmt: TIREnvironmentSetStatement): String {
        const binds = stmt.assigns.map((asgn) => {
            if(asgn.valexp === undefined) {
                return `$Runtime.BSQEnvironment.clear(self.$environment, "${asgn.keyname}");`
            }
            else {
                return `$Runtime.BSQEnvironment.set(self.$environment, "${asgn.keyname}", ${this.emitExpression(asgn.valexp[1], true)}, "${asgn.valexp[0]}");`
            }
        });

        return binds.join(" ");
    }

    method emitEnvironmentSetStatementBracket(stmt: TIREnvironmentSetStatementBracket, indent: String): String {
        let sstr = "";
        let tmpe = `$_tmpenv_${this.m_varCtr++}`;
        if(stmt.isFresh) {
            sstr = `const ${tmpe} = self.$environment; self.$environment = new $Runtime.BSQEnvironment(undefined);`;
        }
        else {
            sstr = `self.$environment = $Runtime.BSQEnvironment.push(self.$environment);`;
        }

        const binds = stmt.assigns.map((asgn) => {
            if(asgn.valexp === undefined) {
                return `$Runtime.BSQEnvironment.clear(self.$environment, "${asgn.keyname}");`
            }
            else {
                return `$Runtime.BSQEnvironment.set(self.$environment, "${asgn.keyname}", ${this.emitExpression(asgn.valexp[1], true)}, "${asgn.valexp[0]}");`
            }
        });
        sstr += (binds.length !== 0) ? ("\n" + indent + binds.join(" ")) : ""

        if(stmt.block instanceof TIRScopedBlockStatement) {
            sstr += this.emitScopedBlock(stmt.block, indent);
        }
        else {
            sstr += this.emitUnscopedBlock(stmt.block, indent);
        }

        if(stmt.isFresh) {
            sstr += `self.$environment = ${tmpe}\n`;
        }
        else {
            sstr += `self.$environment = $Runtime.BSQEnvironment.pop(self.$environment);\n`;
        }

        return sstr;
    }

    method emitTaskRunStatement(stmt: TIRTaskRunStatement): String {
        const taskaccess = this.resolveTypeMemberAccess(stmt.task);
        const vdcl = stmt.isdefine ? (stmt.isconst ? `let ${stmt.vtrgt.name}` : `var ${stmt.vtrgt.name}`) : stmt.vtrgt.name;

        const execargs = `{${stmt.taskargs.map((earg) => earg.argn + ": " + this.emitExpression(earg.argv, true)).join(", ")}}`;
        const consarg = this.emitExpression(stmt.consarg.rarg, true);
        const callargs = stmt.args.map((arg) => this.emitExpression(arg, true));

        return `${vdcl} = await ${taskaccess}.$mainfunc(${execargs}, ${consarg}, ${callargs});`;
    }

    method emitTaskMultiStatement(stmt: TIRTaskMultiStatement): String {
        return NOT_IMPLEMENTED_STATEMENT(stmt.tag);
    }

    method emitTaskDashStatement(stmt: TIRTaskDashStatement): String {
        return NOT_IMPLEMENTED_STATEMENT(stmt.tag);
    }

    method emitTaskAllStatement(stmt: TIRTaskAllStatement): String {
        return NOT_IMPLEMENTED_STATEMENT(stmt.tag);
    }

    method emitTaskRaceStatement(stmt: TIRTaskRaceStatement): String {
        return NOT_IMPLEMENTED_STATEMENT(stmt.tag);
    }

    method emitTaskSetSelfFieldStatement(stmt: TIRTaskSetSelfFieldStatement): String {
        return `self.${stmt.fname} = ${this.emitExpression(stmt.value, true)};`;
    }

    method emitLoggerEmitStatement(stmt: TIRLoggerEmitStatement): String {
        const fmt = `${stmt.fmt.ns}.${stmt.fmt}`; 
        const args = stmt.args.map((arg) => this.emitExpression(arg)).join(", ")

        return `if($Runtime.checkloglevel(${stmt.level})) { try { $Runtime.log("${fmt}", ${stmt.level}, ${fmt}, ${args}); } catch(ex) { $Runtime.log("LoggerError", "error", "[[logging failure -- ${this.m_file}@${stmt.sinfo.line}]]"); } }`;
    }

    method emitLoggerEmitConditionalStatement(stmt: TIRLoggerEmitConditionalStatement): String {
        const fmt = `${stmt.fmt.ns}.${stmt.fmt}`; 
        const args = stmt.args.map((arg) => this.emitExpression(arg)).join(", ")
        
        const test = this.emitExpression(stmt.cond);
        return `if($Runtime.checkloglevel(${stmt.level} && ${test})) { try { $Runtime.log("${fmt}", ${stmt.level}, ${fmt}, ${args}); } catch(ex) { $Runtime.log("LoggerError", "error", "[[logging failure -- ${this.m_file}@${stmt.sinfo.line}]]"); } }`
    }

    method emitLoggerSetPrefixStatement(stmt: TIRLoggerSetPrefixStatement, indent: String): String {
        const fmt = `${stmt.fmt.ns}.${stmt.fmt}`; 
        const args = stmt.args.map((arg) => this.emitExpression(arg)).join(", ")
        
        const bblock = (stmt.block instanceof TIRScopedBlockStatement) ? this.emitScopedBlock(stmt.block, indent) : this.emitUnscopedBlock(stmt.block, indent);

        //TODO: unscoped block needs some work here!
        return `$Runtime.pushlogprefix(${fmt}, ${args}); try ${bblock}\n${indent}catch(ex) { $Runtime.log("LoggerError", "error", "[[logging failure -- ${this.m_file}@${stmt.sinfo.line}]]"); } \n${indent}$Runtime.poplogprefix();`
    }
*/
    recursive method emitScopedBlock(blck: TreeIR::ScopedBlockStatement, indent: String): String 
        requires !blck.ops.empty();
    {
        return this.emitStatementList[recursive](blck.ops, indent);
    }

    recursive method emitUnscopedBlock(blck: TreeIR::UnscopedBlockStatement, indent: String): String 
        requires !blck.ops.empty();
    {
        return this.emitStatementList[recursive](blck.ops, indent);
    }

    recursive method emitStatement(stmt: TreeIR::Statement, follows: List<TreeIR::Statement>, indent: String): String {
        return match (stmt) {
            TreeIR::NopStatement => this.emitNopStatement[recursive]($, follows, indent)
            | TreeIR::AbortStatement => this.emitAbortStatement[recursive]($, follows, indent)
            | TreeIR::AssertCheckStatement => this.emitAssertCheckStatement[recursive]($, follows, indent)
            | TreeIR::DebugStatement => this.emitDebugStatement[recursive]($, follows, indent)
            | TreeIR::VarDeclareAndAssignStatement => this.emitVarDeclareAndAssignStatement[recursive]($, follows, indent)
            /*
            case TIRStatementTag.StoreToScratch: {
                return this.emitStoreToScratch(stmt as TIRStoreToScratch);
            }
            case TIRStatementTag.VarRefAssignFromScratch: {
                return this.emitVarRefAssignFromScratch(stmt as TIRVarRefAssignFromScratch);
            }
            case TIRStatementTag.TaskRefAssignFromScratch: {
                return this.emitTaskRefAssignFromScratch(stmt as TIRTaskRefAssignFromScratch);
            }
            case TIRStatementTag.CallWRefStatement: {
                return this.emitCallStatementWRef(stmt as TIRCallStatementWRef);
            }
            case TIRStatementTag.CallStatementWTaskRef: {
                return this.emitCallStatementWTaskRef(stmt as TIRCallStatementWTaskRef);
            }
            case TIRStatementTag.CallStatementWTaskAction: {
                return this.emitCallStatementWAction(stmt as TIRCallStatementWAction);
            }
            case TIRStatementTag.VariableRetypeStatement: {
                return this.emitVariableRetypeStatement(stmt as TIRVariableRetypeStatement);
            }
            case TIRStatementTag.VariableSCRetypeStatement: {
                return this.emitVariableSCRetypeStatement(stmt as TIRVariableSCRetypeStatement);
            }
            case TIRStatementTag.ScratchSCStatement: {
                return this.emitScratchSCStatement(stmt as TIRScratchSCStatement);
            }
*/
            | TreeIR::ReturnStatement => this.emitReturnStatement[recursive]($, follows, indent)
/*
            case TIRStatementTag.ReturnStatementWRef: {
                return this.emitReturnStatementWRef(stmt as TIRReturnStatementWRef);
            }
            case TIRStatementTag.ReturnStatementWTaskRef: {
                return this.emitReturnStatementWTaskRef(stmt as TIRReturnStatementWTaskRef);
            }
            case TIRStatementTag.ReturnStatementWAction: {
                return this.emitReturnStatementWAction(stmt as TIRReturnStatementWAction);
            }
            case TIRStatementTag.IfStatement: {
                return this.emitIfStatement(stmt as TIRIfStatement, indent);
            }
            case TIRStatementTag.SwitchStatement: {
                return this.emitSwitchStatement(stmt as TIRSwitchStatement, indent);
            }
            case TIRStatementTag.MatchStatement: {
                return this.emitMatchStatement(stmt as TIRMatchStatement, indent);
            }
            case TIRStatementTag.EnvironmentFreshStatement: {
                return this.emitEnvironmentFreshStatement(stmt as TIREnvironmentFreshStatement);
            }
            case TIRStatementTag.EnvironmentSetStatement: {
                return this.emitEnvironmentSetStatement(stmt as TIREnvironmentSetStatement);
            }
            case TIRStatementTag.EnvironmentSetStatementBracket: {
                return this.emitEnvironmentSetStatementBracket(stmt as TIREnvironmentSetStatementBracket, indent);
            }
            case TIRStatementTag.TaskRunStatement: {
                return this.emitTaskRunStatement(stmt as TIRTaskRunStatement);
            }
            case TIRStatementTag.TaskMultiStatement: {
                return this.emitTaskMultiStatement(stmt as TIRTaskMultiStatement);
            }
            case TIRStatementTag.TaskDashStatement: {
                return this.emitTaskDashStatement(stmt as TIRTaskDashStatement);
            }
            case TIRStatementTag.TaskAllStatement: {
                return this.emitTaskAllStatement(stmt as TIRTaskAllStatement);
            }
            case TIRStatementTag.TaskRaceStatement: {
                return this.emitTaskRaceStatement(stmt as TIRTaskRaceStatement);
            }
            case TIRStatementTag.TaskSetSelfFieldStatement: {
                return this.emitTaskSetSelfFieldStatement(stmt as TIRTaskSetSelfFieldStatement);
            }
            case TIRStatementTag.LoggerEmitStatement: {
                return this.emitLoggerEmitStatement(stmt as TIRLoggerEmitStatement);
            }
            case TIRStatementTag.LoggerEmitConditionalStatement: {
                return this.emitLoggerEmitConditionalStatement(stmt as TIRLoggerEmitConditionalStatement);
            }
            case TIRStatementTag.LoggerSetPrefixStatement: {
                return this.emitLoggerSetPrefixStatement(stmt as TIRLoggerSetPrefixStatement, indent);
            }
            default: {
                assert(false, `Unknown statement kind ${stmt.tag}`);
                return `[UNKNOWN TAG ${stmt.tag}]`
            }
*/
        };
    }

    recursive method emitStatementList(stmts: List<TreeIR::Statement>, indent: String): String 
        requires !stmts.empty();
    {
        return this.emitStatement[recursive](stmts.front(), stmts.popFront(), indent);
    }

    method emitBodyStatementList(body: List<TreeIR::Statement>): String {
        return this.emitStatementList(body, "    ");
    }
}
